import type { StructuredContent, ImagePlan, HeadingPlan } from '../contentGenerator.js';
import { globalCleanupManager, memoryMonitor, cleanupAllMemoryManagers } from '../utils/memoryManager.js';
// ✅ [2026-01-25 모듈화] 안전 실행 유틸리티
import { safeExecute, safeExecuteAsync, safeGetElement, safeAddEventListener } from './utils/safeExecute.js';
// ✅ [2026-01-25 모듈화] 진행상황 모달
import { ProgressModal } from './components/ProgressModal.js';
// ✅ [2026-01-25 모듈화] 소제목 이미지 설정
import { HeadingImageMode, getHeadingImageMode, setHeadingImageMode, openHeadingImageModal, initHeadingImageButton } from './components/HeadingImageSettings.js';
// ✅ [2026-01-25 모듈화] 프롬프트 편집 모달
import './components/PromptEditModal.js';
// ✅ [2026-01-25 모듈화] 초기화 가드 및 UI 락 시스템
import { InitializationGuard, clearImageGenerationLocks, runUiActionLocked } from './utils/stabilityUtils.js';
// ✅ [2026-01-25 모듈화] HTML 유틸리티
import { escapeHtml, removeMarkdownBold } from './utils/htmlUtils.js';
// ✅ [2026-01-25 모듈화] 이미지 비용 유틸리티
import { isCostRiskImageProvider, getCostRiskProviderLabel, getTodayKey } from './utils/imageCostUtils.js';
// ✅ [2026-01-25 모듈화] 쇼핑커넥트 유틸리티
import { isShoppingConnectModeActive } from './utils/shoppingConnectUtils.js';
// ✅ [2026-01-25 모듈화] 스토리지 유틸리티
import { safeLocalStorageSetItem } from './utils/storageUtils.js';
// ✅ [2026-01-25 모듈화] Gemini 모델 동기화
import { initGeminiModelSync } from './utils/geminiModelSync.js';
// ✅ [2026-01-25 모듈화] 에러 유틸리티
import { translateGeminiError } from './utils/errorUtils.js';
// ✅ [2026-01-25 모듈화] 카테고리 모달 유틸리티
import { initCategorySelectionListener } from './utils/categoryModalUtils.js';
// ✅ [2026-01-25 모듈화] 앱 이벤트 핸들러
import { initAllAppEventHandlers } from './utils/appEventsHandler.js';
// ✅ [2026-01-25 모듈화] 전체 자동 발행 유틸리티
import { isFullAutoStopRequested, requestStopFullAutoPublish, normalizeReviewHeadingSeed, applyReviewHeadingPrefix } from './utils/fullAutoUtils.js';
// ✅ [2026-01-25 모듈화] 소제목 키 및 파일 URL 유틸리티
import { toFileUrlMaybe, normalizeHeadingKeyForVideoCache } from './utils/headingKeyUtils.js';
// ✅ [2026-01-25 모듈화] Veo 진행 오버레이
import { showVeoProgressOverlay, setVeoProgressOverlay, hideVeoProgressOverlay, handleVeoLogForOverlay } from './components/VeoProgressOverlay.js';
// ✅ [2026-01-25 모듈화] 영상 제공자 유틸리티
import {
  VideoProvider, getCurrentVideoProvider, setCurrentVideoProvider,
  isVeoQuotaExceededMessage, buildVeoQuotaUserMessage,
  isImageStylePromptForVeo, extractEnglishishProductName
} from './utils/videoProviderUtils.js';
// ✅ [2026-01-25 모듈화] 이미지 헬퍼
import { getHeadingTitleByIndex, getStableImageKey, getRequiredImageBasePath } from './utils/imageHelpers.js';
// ✅ [2026-01-25 모듈화] Ken Burns 스타일
import { ensureKenBurnsStyles } from './utils/kenBurnsStyles.js';
// ✅ [2026-01-25 모듈화] 카테고리 정규화 유틸
import { CATEGORY_NORMALIZE_MAP, normalizeCategory } from './utils/categoryNormalizeUtils.js';
// ✅ [2026-01-25 모듈화] 텍스트 포맷 유틸
import { formatContentForPreview, normalizeReadableBodyText, formatParagraph } from './utils/textFormatUtils.js';
// ✅ [2026-01-25 모듈화] Veo 프롬프트 안전화 유틸
import { buildVeoSafePrompt, isVeoAudioBlockedMessage } from './utils/veoSafetyUtils.js';
// ✅ [2026-01-25 모듈화] UI 매니저 클래스
import { LoadingManager, ToastManager, AnimationHelper, loadingManager, toastManager } from './utils/uiManagers.js';
// ✅ [2026-01-25 모듈화] 향상된 API 클라이언트
import { EnhancedApiClient, ApiRequestOptions, ApiResponse, apiClient } from './utils/apiClient.js';
// ✅ [2026-01-25 모듈화] 발행 글 저장소 유틸리티
import {
  GENERATED_POSTS_KEY,
  POSTS_MIGRATION_DONE_KEY,
  getPublishedPostsKey,
  loadPublishedPosts,
  savePublishedPost,
  getPostsStorageKey,
  getCurrentNaverId
} from './utils/postStorageUtils.js';
// ✅ [2026-01-25 모듈화] 오류 처리 시스템
import {
  ErrorType,
  ErrorInfo,
  showError,
  handleApiError,
  errorHandler
} from './utils/errorHandlerUtils.js';
// ✅ [2026-01-25 모듈화] 날짜/스케줄 유틸리티
import {
  convertDatetimeLocalToScheduleFormat,
  getScheduleDateFromInput,
  getRecommendedScheduleTime
} from './utils/dateUtils.js';
// ✅ [2026-01-25 모듈화] 제목 처리 유틸리티
import {
  applyKeywordPrefixToTitle
} from './utils/titleUtils.js';
// ✅ [2026-01-25 모듈화] 프롬프트 오버라이드 유틸리티
import {
  getManualEnglishPromptOverridesStore,
  getManualEnglishPromptOverrideForHeading,
  setManualEnglishPromptOverrideForHeading,
  clearManualEnglishPromptOverrideForHeading
} from './utils/promptOverrideUtils.js';
// ✅ [2026-01-25 모듈화] 소제목 영상 미리보기 유틸리티
import {
  HeadingVideoPreviewCacheEntry,
  headingVideoPreviewCache,
  headingVideoPreviewInFlight,
  getHeadingVideoPreviewFromCache,
  getReviewHeadingSeed,
  ImageManagerLike
} from './utils/headingVideoPreviewUtils.js';
// ✅ [2026-01-25 모듈화] VEO 영상 생성 유틸리티
import {
  getVeoQuotaLockUntil,
  setVeoQuotaLockUntil,
  VeoQuotaCallbacks,
  GenerateVeoCallbacks
} from './utils/veoVideoUtils.js';
// ✅ [2026-01-25] 환경설정 모달
import { initSettingsModal as initSettingsModalFunc } from './utils/settingsModal.js';

// ✅ [리팩토링] 새 UI 모듈 import - 점진적 마이그레이션용
// 새로 작성하는 코드에서는 아래 모듈들(ui* 접두사)을 사용하세요.
// 기존 함수와 충돌 방지를 위해 모든 import에 ui* 별칭 적용
import {
  // 상태 관리
  GlobalStore as UIGlobalStore,
  // 서비스
  ApiBridge as UIApiBridge,
  // 유틸리티
  escapeHtml as uiEscapeHtml,
  debounce as uiDebounce,
  delay as uiDelay,
  formatDate as uiFormatDate,
  // DOM 헬퍼
  getCachedElement as uiGetCachedElement,
  show as uiShow,
  hide as uiHide,
  setText as uiSetText,
  setValue as uiSetValue,
  getValue as uiGetValue,
  addClasses as uiAddClasses,
  removeClasses as uiRemoveClasses,
  setButtonLoading as uiSetButtonLoading,
  // UI 팩토리
  showToast as uiShowToast,
  createSpinner as uiCreateSpinner,
  // 매니저
  EventManager as UIEventManager,
  ErrorHandler as UIErrorHandler,
  withErrorHandling as uiWithErrorHandling,
  // 설정
  AFFILIATE_ENABLED_CATEGORIES as UI_AFFILIATE_CATEGORIES,
  isAffiliateCategoryEnabled as uiIsAffiliateCategoryEnabled,
  DELAYS as UI_DELAYS,
  ERROR_MESSAGES as UI_ERROR_MESSAGES,
  SUCCESS_MESSAGES as UI_SUCCESS_MESSAGES,
} from '../ui/index.js';

// ═══════════════════════════════════════════════════════════════════════════════
// ✅ [2026-01-20] 전역 에러 핸들러 - 예상치 못한 오류 캡처 및 로깅
// ═══════════════════════════════════════════════════════════════════════════════
(function setupGlobalErrorHandlers() {
  // 동기 에러 캡처
  window.onerror = (message, source, lineno, colno, error) => {
    console.error('[GlobalError] 예상치 못한 오류 발생:', {
      message,
      source,
      line: lineno,
      column: colno,
      error: error?.stack || error
    });
    // UI에 표시하지 않고 로그만 남김 (사용자 경험 보호)
    return false; // 기본 에러 핸들링도 허용
  };

  // 비동기 Promise 에러 캡처
  window.onunhandledrejection = (event) => {
    console.error('[GlobalError] 처리되지 않은 Promise 거부:', {
      reason: event.reason?.message || event.reason,
      stack: event.reason?.stack
    });
    // 개발 모드에서만 콘솔에 상세 정보 표시
    if ((window as any).DEBUG_MODE) {
      console.trace('[GlobalError] Promise 거부 위치 추적');
    }
  };

  console.log('[Stability] 전역 에러 핸들러 등록 완료');
})();

// ✅ [2026-01-25 모듈화] safeExecute, safeExecuteAsync, safeGetElement, safeAddEventListener
// → ./utils/safeExecute.js로 이동됨 (상단 import 참조)

// ✅ [2026-01-25 모듈화] InitializationGuard 클래스
// → ./utils/stabilityUtils.js로 이동됨 (상단 import 참조)


// ✅ [Stability] 앱 종료 시 메모리 정리 등록
window.addEventListener('beforeunload', () => {
  cleanupAllMemoryManagers();
});
// ✅ [2026-01-25 모듈화] translateGeminiError
// → ./utils/errorUtils.js로 이동됨 (상단 import 참조)

// ✅ [2026-01-25 모듈화] 카테고리 모달 유틸리티
// → ./utils/categoryModalUtils.js로 이동됨 (상단 import 참조)
// openUnifiedCategoryModal, openCategoryModalInContinuousMode, CATEGORY_SELECTED 리스너
// initCategorySelectionListener()는 DOMContentLoaded에서 호출됨


import type { AppConfig } from '../configManager.js';
import { initClockAndCalendar, externalLinks, loadCalendarMemo, saveCalendarMemo } from './scheduleAndUI.js';

// ✅ [2026-01-25 모듈화] HeadingImageSettings
// → ./components/HeadingImageSettings.js로 이동됨 (상단 import 참조)
document.addEventListener('DOMContentLoaded', () => {
  initCategorySelectionListener(); // ✅ 카테고리 모달 이벤트 리스너
  initHeadingImageButton();
  initSettingsModalFunc(); // ✅ [2026-01-25] 환경설정 모달 초기화

  // ✅ [2026-01-25] 환경설정 저장 버튼 이벤트 리스너 (CSP 우회)
  const saveBtn = document.getElementById('save-settings-btn');
  if (saveBtn) {
    saveBtn.addEventListener('click', () => {
      console.log('[Settings] 💾 저장 버튼 클릭됨 (DOMContentLoaded)');
      if (typeof (window as any).saveSettingsHandler === 'function') {
        (window as any).saveSettingsHandler();
      } else {
        console.error('[Settings] ❌ saveSettingsHandler 함수를 찾을 수 없음');
      }
    });
    console.log('[Settings] ✅ 저장 버튼 이벤트 리스너 등록 완료');
  }

  // ✅ 취소 버튼도 등록
  const cancelBtn = document.querySelector('#settings-modal button[onclick*="closeSettingsModal"]');
  if (cancelBtn) {
    cancelBtn.removeAttribute('onclick');
    cancelBtn.addEventListener('click', () => {
      if (typeof (window as any).closeSettingsModal === 'function') {
        (window as any).closeSettingsModal();
      }
    });
  }
});


// ✅ [Global Safety Net] 전역 에러 핸들러 (구매자 환경 보호)
// 알 수 없는 에러가 발생해도 흰 화면 대신 친절한 메시지를 보여줍니다.
window.addEventListener('unhandledrejection', (event) => {
  const reason = event.reason;
  // 명시적 취소나 무시 가능한 에러는 스킵
  if (reason?.message?.includes('cancelled') || reason === 'cancelled') return;

  const msg = reason instanceof Error ? translateGeminiError(reason) : String(reason);
  console.error('⚠️ [Global Catch] Unhandled Rejection:', reason);

  // UI 토스트가 준비되었으면 표시, 아니면 콘솔만
  if ((window as any).showToast) {
    (window as any).showToast(`⚠️ 예기치 않은 오류: ${msg}`, 'error', 5000);
  }
});

// ✅ [2026-01-25 모듈화] safeLocalStorageSetItem
// → ./utils/storageUtils.js로 이동됨 (상단 import 참조)

// ✅ [2026-01-25 모듈화] 앱 이벤트 핸들러
// → ./utils/appEventsHandler.js로 이동됨 (상단 import 참조)
// navigateToBannerTab, 공지사항 모달, 종료 카운트다운, 전역 에러 핸들러
initAllAppEventHandlers();

declare global {
  function updateReserveImagesThumbnails(): void;
  function showHeadingSelectionModalV2(image: any, currentIndex: number): Promise<void>;
  function regenerateWithNewAI(index: number, heading: string): Promise<void>;
  function showSavedImagesForReplace(targetIndex: number): Promise<void>;
  function initApiGuideModal(): void;
  function initUserGuideModal(): void;
  function initDashboard(): void;
  function initTabSwitching(): void;
  function initUnifiedImageEventHandlers(): void;
  function displayGeneratedImages(images: any[]): void;
  function updatePromptItemsWithImages(images: any[]): void;
  function autoAnalyzeHeadings(structuredContent: any): Promise<void>;
  function generateImagePromptByIndex(heading: string, index: number, blogTitle?: string): string;
  function generateImagen4ImageLocal(prompt: string, isRegenerate?: boolean): Promise<string>;
  function searchNaverImage(prompt: string, isRegenerate?: boolean): Promise<string>;
  function generateNanoBananaProImage(prompt: string, headingOrRegenerate?: string | boolean, isRegenerate?: boolean): Promise<string>;
  function generateEnglishPromptForHeadingSync(heading: string): string;
  function initMultiAccountManager(): Promise<void>;
  // ✅ [2026-01-25] 환경설정 저장/닫기 전역 함수
  function saveSettingsHandler(): void;
  function closeSettingsModal(): void;
}

// ✅ [2026-01-25 모듈화] initGeminiModelSync
// → ./utils/geminiModelSync.js로 이동됨 (상단 import 참조)

// ✅ [2026-01-25 모듈화] showHeadingPromptEditModal
// → ./components/PromptEditModal.js로 이동됨 (상단 import 참조)

// ✅ [2026-01-25 모듈화] getHeadingTitleByIndex
// → ./utils/imageHelpers.js로 이동됨 (상단 import 참조)

function hydrateImageManagerFromImages(structuredContent: any, images: any[]): void {
  try {
    ImageManager.imageMap.clear();
    ImageManager.unsetHeadings.clear();
  } catch {
    // ignore
  }

  try {
    if (structuredContent?.headings) {
      ImageManager.setHeadings(structuredContent.headings);
    }
  } catch {
    // ignore
  }

  // ✅ 소제목 목록 추출 (heading 없는 이미지 매핑용)
  const headingTitles: string[] = [];
  if (structuredContent?.headings && Array.isArray(structuredContent.headings)) {
    structuredContent.headings.forEach((h: any) => {
      const title = typeof h === 'string' ? h : (h?.title || '');
      if (title.trim()) headingTitles.push(title.trim());
    });
  }

  const byHeading = new Map<string, any[]>();
  (Array.isArray(images) ? images : []).forEach((img: any, idx: number) => {
    let heading = String(img?.heading || '').trim();

    // ✅ heading이 없으면 인덱스 기반으로 소제목 매핑 (썸네일 등)
    if (!heading && idx < headingTitles.length) {
      heading = headingTitles[idx];
      console.log(`[hydrateImageManager] 이미지 ${idx}에 소제목 자동 매핑: "${heading}"`);
    }

    if (!heading) return;
    const list = byHeading.get(heading) || [];
    list.push({
      ...img,
      heading,
      timestamp: typeof img?.timestamp === 'number' ? img.timestamp : Date.now(),
    });
    byHeading.set(heading, list);
  });

  byHeading.forEach((list, heading) => {
    try {
      ImageManager.imageMap.set(heading, list);
      ImageManager.unsetHeadings.delete(heading);
    } catch {
      // ignore
    }
  });

  try {
    syncGlobalImagesFromImageManager();
  } catch {
    // ignore
  }
}

// ✅ [2026-01-25 모듈화] getRequiredImageBasePath, getStableImageKey
// → ./utils/imageHelpers.js로 이동됨 (상단 import 참조)

// ✅ [2026-01-25 모듈화] escapeHtml, removeMarkdownBold

// → ./utils/htmlUtils.js로 이동됨 (상단 import 참조)

// ✅ [2026-01-25 모듈화] ProgressModal 클래스
// → ./components/ProgressModal.js로 이동됨 (상단 import 참조)

function saveGeneratedPostFromData(
  structuredContent: any,
  images: any[] = [],
  overrides?: { category?: string; toneStyle?: string; ctaText?: string; ctaLink?: string }
): string | null {
  try {
    console.log('[SavePost] 생성된 글 저장 시작...');

    if (!structuredContent) {
      console.error('[SavePost] ❌ 저장 실패: structuredContent가 없습니다.');
      return null;
    }

    const posts = loadGeneratedPosts();
    const postId = `post_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const now = new Date().toISOString();

    const categoryFromContent = String((structuredContent as any)?.articleType || (structuredContent as any)?.category || '').trim();
    const resolvedCategory = String(overrides?.category || categoryFromContent || '').trim();

    const normalizedImages = (images || []).map((img: any) => ({
      heading: img.heading || '',
      provider: img.provider || img.source || img.engine || 'unknown',
      filePath: img.filePath || '',
      previewDataUrl: img.previewDataUrl || img.url || img.filePath || '',
      url: img.url || img.link || img.previewDataUrl || img.filePath || '',
      thumbnail: img.thumbnail || '',
      savedToLocal: img.savedToLocal || false,
    }));

    const post: GeneratedPost = {
      id: postId,
      title: structuredContent?.selectedTitle || '',
      content: structuredContent?.bodyPlain || structuredContent?.content || '',
      hashtags: structuredContent?.hashtags || [],
      headings: structuredContent?.headings || [],
      structuredContent: structuredContent,
      createdAt: now,
      updatedAt: now,
      images: normalizedImages.length > 0 ? normalizedImages : undefined,
      imageCount: normalizedImages.length || undefined,
      isFavorite: false,
      category: resolvedCategory || undefined,
      publishedUrl: undefined,
      publishedAt: undefined,
      isPublished: false,
      toneStyle: String(overrides?.toneStyle || structuredContent?.toneStyle || 'professional'),
      ctaText: String(overrides?.ctaText || ''),
      ctaLink: String(overrides?.ctaLink || ''),
    };

    posts.unshift(post);
    if (posts.length > 100) posts.pop();

    // ✅ [2026-01-23 FIX] 계정별 저장소에 저장 (다중계정 호환)
    const currentNaverId = getCurrentNaverId();
    const storageKey = getPostsStorageKey(currentNaverId);
    const saveSuccess = safeLocalStorageSetItem(storageKey, JSON.stringify(posts));

    if (!saveSuccess) {
      console.error('[SavePost] ❌ localStorage 저장 실패!');
      return null;
    }

    // ✅ [Bug Fix] 저장 검증
    try {
      const verifyPosts = loadGeneratedPosts();
      const saved = verifyPosts.find((p: any) => p.id === postId);
      if (!saved) {
        console.error('[SavePost] ❌ 저장 검증 실패: 저장된 글을 찾을 수 없습니다.');
        return null;
      }
      console.log(`[SavePost] ✅ 저장 검증 성공 (ID: ${postId}, 제목: ${post.title?.substring(0, 20)}...)`);
    } catch (verifyErr) {
      console.error('[SavePost] ⚠️ 저장 검증 중 오류:', verifyErr);
    }

    // ✅ UI 갱신
    try {
      refreshGeneratedPostsList();
      console.log('[SavePost] ✅ 생성된 글 목록 UI 갱신 완료');
    } catch (refreshErr) {
      console.error('[SavePost] ⚠️ UI 갱신 실패:', refreshErr);
    }

    console.log(`[SavePost] ✅ 저장 완료 (ID: ${postId})`);
    return postId;
  } catch (error) {
    console.error('[SavePost] ❌ 생성된 글 저장 실패(다계정):', error);
    return null;
  }
}

// ✅ [2026-01-25 모듈화] isFullAutoStopRequested, requestStopFullAutoPublish,
// normalizeReviewHeadingSeed, applyReviewHeadingPrefix
// → ./utils/fullAutoUtils.js로 이동됨 (상단 import 참조)

// ✅ [2026-01-25 모듈화] UI 액션 락 시스템
// → ./utils/stabilityUtils.js로 이동됨 (상단 import 참조)
// toastManager 호환을 위한 래퍼 (기존 코드와의 호환성 유지)
async function runUiActionLockedCompat<T>(key: string, message: string, fn: () => Promise<T>): Promise<T | null> {
  return runUiActionLocked(key, message, fn, toastManager);
}


// ✅ [2026-01-25 모듈화] isCostRiskImageProvider, getCostRiskProviderLabel, getTodayKey
// → ./utils/imageCostUtils.js로 이동됨 (상단 import 참조)

async function ensureExternalApiCostConsent(provider: string): Promise<boolean> {
  if (!window.api || typeof window.api.getConfig !== 'function' || typeof window.api.saveConfig !== 'function') {
    return true;
  }

  const config: any = (await window.api.getConfig()) || {};

  // ✅ 나노 바나나 프로 / Fal.ai (FLUX) 전용 플랜 선택 로직
  if (provider === 'nano-banana-pro' || provider === 'falai') {
    // 플랜이 이미 설정되어 있으면 통과
    if (config.geminiPlanType) {
      return true;
    }

    // ✅ 보안 강화: 라이선스 타입 확인 (IPC로 main process에 요청)
    let isFreeLicense = false;
    try {
      const result = await window.api.getLicense();
      isFreeLicense = result?.license?.licenseType === 'free';
    } catch {
      // 라이선스 확인 실패 시 안전하게 free로 간주
      isFreeLicense = true;
    }

    // 무료 라이선스면 팝업 없이 바로 'free'로 설정
    if (isFreeLicense) {
      await window.api.saveConfig({
        ...config,
        geminiPlanType: 'free',
        geminiImageDailyCount: 0,
        geminiImageLastReset: new Date().toISOString().split('T')[0]
      });
      console.log('[Security] 무료 라이선스 감지 → geminiPlanType을 자동으로 "free"로 설정');
      return true;
    }

    // 모달 생성 및 사용자 응답 대기 (유료 라이선스 사용자만 여기 도달)
    return new Promise<boolean>((resolve) => {
      // 오버레이
      const overlay = document.createElement('div');
      overlay.style.cssText = 'position:fixed; inset:0; z-index: 999999; background: rgba(0,0,0,0.65); display:flex; align-items:center; justify-content:center; padding: 1rem; backdrop-filter: blur(4px);';

      const modal = document.createElement('div');
      modal.style.cssText = 'width: min(500px, 90vw); background: var(--bg-primary); border: 1px solid var(--border-light); border-radius: 16px; box-shadow: 0 25px 50px rgba(0,0,0,0.25); overflow:hidden; animation: modal-pop 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);';

      modal.innerHTML = `
        <div style="background: linear-gradient(135deg, #FFC107 0%, #FF9800 100%); padding: 1.5rem; text-align: center;">
          <div style="font-size: 3rem; margin-bottom: 0.5rem;">🍌</div>
          <h2 style="margin: 0; color: #fff; font-size: 1.5rem; font-weight: 800; text-shadow: 0 2px 4px rgba(0,0,0,0.2);">나노 바나나 프로<br>사용자 플랜 확인</h2>
        </div>
        <div style="padding: 1.5rem;">
          <p style="margin: 0 0 1.5rem; color: var(--text-strong); font-size: 1.05rem; line-height: 1.6; text-align: center;">
            <b style="color: #FF9800;">Gemini API</b>를 사용하여 고품질 이미지를 생성합니다.<br>
            사용 중인 API 키의 <b>요금제(플랜)</b>를 선택해주세요.
          </p>
          
          <div style="background: var(--bg-secondary); border-radius: 12px; padding: 1rem; margin-bottom: 1.5rem; font-size: 0.9rem; color: var(--text-muted);">
            <ul style="margin: 0; padding-left: 1.2rem; display: flex; flex-direction: column; gap: 0.5rem;">
              <li><b>무료 사용자:</b> 하루 사용량이 제한됩니다. (약 45장)</li>
              <li><b>유료 사용자:</b> 제한 없이 계속 사용할 수 있습니다.</li>
            </ul>
          </div>

          <div style="display: flex; gap: 0.75rem; flex-direction: column;">
            <button id="btn-paid-plan" style="padding: 1rem; border: 2px solid #ddd; border-radius: 12px; background: white; color: #333; cursor: pointer; font-weight: 700; font-size: 1rem; transition: all 0.2s; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
              <span>💳</span> 저는 <b>유료 플랜</b> 사용자입니다
            </button>
            <button id="btn-free-plan" style="padding: 1rem; border: none; border-radius: 12px; background: #FF9800; color: white; cursor: pointer; font-weight: 700; font-size: 1rem; transition: all 0.2s; box-shadow: 0 4px 6px rgba(255, 152, 0, 0.25);">
              <span>🆓</span> 저는 <b>무료 사용자</b>입니다
            </button>
          </div>
          <div style="margin-top: 1rem; text-align: center;">
           <button id="btn-cancel" style="background: none; border: none; color: var(--text-muted); text-decoration: underline; cursor: pointer; font-size: 0.9rem;">취소하고 다른 생성기 사용하기</button>
          </div>
        </div>
      `;

      overlay.appendChild(modal);
      document.body.appendChild(overlay);

      // 스타일 애니메이션 추가
      const style = document.createElement('style');
      style.innerHTML = `
        @keyframes modal-pop { from { transform: scale(0.9); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        #btn-paid-plan:hover { border-color: #4CAF50; color: #4CAF50; background: #f0fdf4; transform: translateY(-2px); }
        #btn-free-plan:hover { background: #f57c00; transform: translateY(-2px); box-shadow: 0 6px 12px rgba(255, 152, 0, 0.3); }
      `;
      document.head.appendChild(style);

      // 핸들러
      const saveAndClose = async (type: 'free' | 'paid') => {
        try {
          await window.api.saveConfig({
            ...config,
            geminiPlanType: type,
            // 날짜/카운트 초기화
            geminiImageDailyCount: 0,
            geminiImageLastReset: new Date().toISOString().split('T')[0]
          });
          toastManager.success(`플랜이 [${type === 'free' ? '무료' : '유료'}]로 설정되었습니다.`);
          resolve(true); // 성공
        } catch (e) {
          console.error(e);
          resolve(false);
        } finally {
          overlay.remove();
          style.remove();
        }
      };

      document.getElementById('btn-paid-plan')?.addEventListener('click', () => saveAndClose('paid'));
      document.getElementById('btn-free-plan')?.addEventListener('click', () => saveAndClose('free'));
      document.getElementById('btn-cancel')?.addEventListener('click', () => {
        overlay.remove();
        style.remove();
        resolve(false); // 취소
      });
    });
  }

  // 기존 로직 (다른 제공자용, 사실 나노 바나나 프로 외엔 거의 안 씀)
  if (config.externalApiCostConsent === true) return true;

  const label = getCostRiskProviderLabel(provider);
  const ok = window.confirm(
    `⚠️ 비용/할당량 경고 (${label})\n\n` +
    `너무 과도하게 사용하면 비용 폭탄을 맞을 수 있으니, 할당량/결제 설정을 반드시 확인하시고 사용하시길 바랍니다.\n\n` +
    `동의하십니까?\n` +
    `- 예: 계속 진행\n` +
    `- 아니오: 취소\n`
  );
  if (!ok) return false;

  await window.api.saveConfig({
    ...config,
    externalApiCostConsent: true,
    externalApiCostConsentAt: new Date().toISOString(),
  });
  return true;
}

async function reserveExternalApiImageQuota(provider: string, requestCount: number): Promise<{ ok: true; rollback: () => Promise<void> } | { ok: false; message: string }> {
  if (!window.api || typeof window.api.getConfig !== 'function' || typeof window.api.saveConfig !== 'function') {
    return { ok: true, rollback: async () => undefined };
  }

  void provider;
  void requestCount;
  return { ok: true, rollback: async () => undefined };
}


// ✅ [2026-01-25 모듈화] isShoppingConnectModeActive
// → ./utils/shoppingConnectUtils.js로 이동됨 (상단 import 참조)

async function generateImagesWithCostSafety(options: any): Promise<any> {
  const provider = String(options?.provider || '').trim();

  // ✅ [2026-01-24 FIX] headingImageMode 자동 주입 - 다중계정 발행에서도 홀수/짝수 필터링 적용
  if (!options.headingImageMode) {
    const savedMode = localStorage.getItem('headingImageMode') as 'all' | 'thumbnail-only' | 'odd-only' | 'even-only' | 'none' | null;
    if (savedMode) {
      options.headingImageMode = savedMode;
      console.log(`[Renderer] 🖼️ headingImageMode 자동 주입: "${savedMode}"`);
    }
  }

  // ✅ [핵심 수정] 호출자가 isShoppingConnect를 명시적으로 전달했으면 그 값 사용
  // 전달되지 않았으면 UI 상태(체크박스) 확인
  const isShoppingConnect = options.isShoppingConnect === true || isShoppingConnectModeActive();
  options.isShoppingConnect = isShoppingConnect; // 메인 프로세스에도 전달

  console.log(`[Renderer] 🛒 isShoppingConnect 결정: ${isShoppingConnect} (전달값: ${options.isShoppingConnect}, UI: ${isShoppingConnectModeActive()})`);

  if (isShoppingConnect) {
    // ✅ [FIX] 빈 배열도 체크: collectedImages가 없거나 빈 배열이면 currentStructuredContent.images 사용
    const hasCollectedImages = options.collectedImages && Array.isArray(options.collectedImages) && options.collectedImages.length > 0;
    const hasStructuredImages = currentStructuredContent?.images && Array.isArray(currentStructuredContent.images) && currentStructuredContent.images.length > 0;

    if (!hasCollectedImages && hasStructuredImages) {
      options.collectedImages = (currentStructuredContent as any).images;
      console.log(`[Renderer] 🛒 쇼핑커넥트: ${(currentStructuredContent as any).images.length}개 수집 이미지 자동 주입`);
    } else if (hasCollectedImages) {
      console.log(`[Renderer] 🛒 쇼핑커넥트: ${options.collectedImages.length}개 수집 이미지 전달됨`);
    } else {
      console.log(`[Renderer] ⚠️ 쇼핑커넥트: 수집된 이미지 없음`);
    }
  } else {
    // ✅ [수정] 일반 모드에서도 collectedImages가 있으면 참조 이미지로 사용 (제품 이미지 기반 생성 지원)
    // 더 이상 delete하지 않음 - 수집된 이미지가 있으면 참조로 활용
    if (options.collectedImages && options.collectedImages.length > 0) {
      console.log(`[Renderer] 🔍 일반 모드: 수집 이미지 ${(options.collectedImages as any[]).length}개를 참조 이미지로 사용합니다.`);
    }
  }

  if (!isCostRiskImageProvider(provider)) {
    return window.api.generateImages(options);
  }

  const locked = await runUiActionLocked(
    `cost-risk-image:${provider}`,
    '이미지 생성이 이미 진행 중입니다. 잠시만 기다려주세요.',
    async () => {
      const consentOk = await ensureExternalApiCostConsent(provider);
      if (!consentOk) {
        throw new Error('사용자가 과금/쿼터 안내에 동의하지 않았습니다.');
      }

      const items = Array.isArray(options?.items) ? options.items : [];
      const reserve = await reserveExternalApiImageQuota(provider, items.length || 1);
      if (!reserve.ok) {
        throw new Error(reserve.message);
      }

      try {
        return await window.api.generateImages(options);
      } catch (e) {
        await reserve.rollback();
        throw e;
      }
    }
  );

  if (locked === null) {
    throw new Error('이미지 생성이 이미 진행 중입니다.');
  }
  return locked;
}

function syncGlobalImagesFromImageManager(): void {
  try {
    ImageManager.syncGeneratedImagesArray();
  } catch {
    // ignore
  }

  const managerAllImages = ImageManager.getAllImages();
  const existingAllImages = (window as any).imageManagementGeneratedImages;

  const getKey = (img: any): string => {
    const raw = img?.url || img?.filePath || img?.previewDataUrl || '';
    return toFileUrlMaybe(String(raw || '').trim());
  };

  let allImages = managerAllImages;
  try {
    if (Array.isArray(existingAllImages) && existingAllImages.length > 0) {
      const existingList = Array.isArray(existingAllImages) ? existingAllImages : [];
      const merged: any[] = [];
      const seen = new Set<string>();

      existingList.forEach((img: any) => {
        const k = getKey(img);
        if (!k) return;
        merged.push(img);
        seen.add(k);
      });

      managerAllImages.forEach((img: any) => {
        const k = getKey(img);
        if (!k) return;
        if (seen.has(k)) return;
        merged.push(img);
        seen.add(k);
      });

      allImages = merged;
    }
  } catch {
    // ignore
  }

  // ✅ ImageManager에서 가져온 최신 이미지 데이터를 사용 (GIF 포함)
  (window as any).imageManagementGeneratedImages = allImages;
  (window as any).generatedImages = allImages;

  try {
    displayGeneratedImages(allImages as any);
  } catch {
    // ignore
  }

  try {
    // ✅ 작은 그리드 업데이트: allImages 전달 (기존 perHeadingImages는 오래된 데이터일 수 있음)
    updatePromptItemsWithImages(allImages as any);
  } catch {
    // ignore
  }

  try {
    ImageManager.updateHeadingAnalysisPreview();
  } catch {
    // ignore
  }
}

function filterImagesForPublish(structuredContent: any, images: any[]): any[] {
  const headings = Array.isArray(structuredContent?.headings) ? structuredContent.headings : [];
  const byNorm = new Map<string, { title: string; index: number }>();
  const byTitle = new Map<string, { title: string; index: number }>();

  headings.forEach((h: any, idx: number) => {
    const title = typeof h === 'string' ? String(h || '').trim() : String(h?.title || h || '').trim();
    if (!title) return;
    byTitle.set(title, { title, index: idx });
    try {
      const n = normalizeHeadingKeyForVideoCache(title);
      if (n) byNorm.set(n, { title, index: idx });
    } catch {
      // ignore
    }
  });

  const fallbackFromInput = new Map<string, any[]>();
  (images || []).forEach((img: any) => {
    const rawHeading = String(img?.heading || '').trim();
    if (!rawHeading) return;

    let resolved: { title: string; index: number } | undefined = byTitle.get(rawHeading);
    if (!resolved) {
      try {
        const n = normalizeHeadingKeyForVideoCache(rawHeading);
        if (n) resolved = byNorm.get(n);
      } catch {
        // ignore
      }
    }
    if (!resolved) return;

    const list = fallbackFromInput.get(resolved.title) || [];
    list.push({
      ...img,
      heading: resolved.title,
      headingIndex: typeof img?.headingIndex === 'number' ? img.headingIndex : resolved.index,
    });
    fallbackFromInput.set(resolved.title, list);
  });

  const result: any[] = [];
  headings.forEach((h: any, idx: number) => {
    const title = typeof h === 'string' ? String(h || '').trim() : String(h?.title || h || '').trim();
    if (!title) return;

    let isUnset = false;
    try {
      isUnset = ImageManager.isHeadingUnset(title);
    } catch {
      isUnset = false;
    }
    if (isUnset) {
      // ✅ 영상(또는 영상→GIF) 모드: 소제목이 unset이어도 해당 소제목에 등록된 모든 이미지를 발행에 포함
      // (기존: gif-from-video만 포함 → 수정: 모든 이미지 포함)
      let headingImages: any[] = [];
      try {
        headingImages = ImageManager.getImages(title) || [];
      } catch {
        headingImages = [];
      }

      // ✅ 이미지가 하나라도 있으면 모두 포함 (GIF 우선 정렬)
      if (Array.isArray(headingImages) && headingImages.length > 0) {
        // GIF를 맨 앞으로 정렬
        const gifs = headingImages.filter((img: any) => String(img?.provider || '') === 'gif-from-video');
        const others = headingImages.filter((img: any) => String(img?.provider || '') !== 'gif-from-video');
        const sorted = [...gifs, ...others];

        sorted.forEach((img: any) => {
          result.push({
            ...img,
            heading: title,
            headingIndex: typeof img?.headingIndex === 'number' ? img.headingIndex : idx,
          });
        });
      }

      return;
    }

    let headingImages: any[] = [];
    let primary: any = null;
    try {
      headingImages = ImageManager.getImages(title) || [];
      primary = ImageManager.getImage(title);
    } catch {
      headingImages = [];
      primary = null;
    }

    const ordered = (() => {
      const list = Array.isArray(headingImages) ? headingImages : [];
      const primaryKey = getStableImageKey(primary);
      if (!primaryKey) return list;
      const p = list.find((img: any) => getStableImageKey(img) === primaryKey);
      if (!p) return list;
      const rest = list.filter((img: any) => getStableImageKey(img) !== primaryKey);
      return [p, ...rest];
    })();

    if (Array.isArray(ordered) && ordered.length > 0) {
      ordered.forEach((img: any) => {
        result.push({
          ...img,
          heading: title,
          headingIndex: typeof img?.headingIndex === 'number' ? img.headingIndex : idx,
        });
      });
      return;
    }

    const fallback = fallbackFromInput.get(title);
    if (Array.isArray(fallback) && fallback.length > 0) {
      fallback.forEach((img: any) => {
        result.push({
          ...img,
          heading: title,
          headingIndex: typeof img?.headingIndex === 'number' ? img.headingIndex : idx,
        });
      });
    }
  });

  return result;
}

function ensurePromptCardRemoveHandler(): void {
  const promptsContainer = document.getElementById('prompts-container') as HTMLDivElement | null;
  if (!promptsContainer) return;
  if ((promptsContainer as any)._imageButtonsHandler) return;

  const existing = (promptsContainer as any)._promptCardRemoveHandler;
  if (existing) return;

  const handler = (e: Event) => {
    const target = e.target as HTMLElement;
    const btn = target.closest('.remove-image-from-preview-btn') as HTMLElement | null;
    if (!btn) return;
    e.preventDefault();
    e.stopPropagation();

    const index = parseInt(btn.getAttribute('data-image-index') || '0', 10);
    const promptItem = promptsContainer.querySelector(`.prompt-item[data-index="${index + 1}"]`) as HTMLDivElement | null;
    const headingTitle = (promptItem?.querySelector('.heading-title-text')?.textContent || `소제목 ${index + 1}`).trim();

    if (!headingTitle) return;
    if (!confirm('이 이미지를 제거하시겠습니까?')) return;

    try {
      pushImageHistorySnapshot('prompt-card-remove-image');
    } catch {
      // ignore
    }

    try {
      const titleKey = ImageManager.resolveHeadingKey(headingTitle);
      const imagesForHeading = ImageManager.getImages(titleKey);

      let targetIdx = -1;
      const selectedKey = (() => {
        try {
          return String(getHeadingSelectedImageKey(titleKey) || '').trim();
        } catch {
          return '';
        }
      })();
      if (selectedKey) {
        targetIdx = imagesForHeading.findIndex((img: any) => getStableImageKey(img) === selectedKey);
      }
      const currentImgEl = (promptItem?.querySelector('.generated-image img') || promptItem?.querySelector('.images-grid img')) as HTMLImageElement | null;
      if (currentImgEl && currentImgEl.src) {
        const normalizedRemoved = toFileUrlMaybe(String(currentImgEl.src || '').trim());
        if (targetIdx < 0) targetIdx = imagesForHeading.findIndex((img: any) => {
          const raw = img?.url || img?.filePath || img?.previewDataUrl || '';
          const norm = toFileUrlMaybe(String(raw || '').trim());
          return norm === normalizedRemoved;
        });
      }
      if (targetIdx < 0) targetIdx = 0;

      if (targetIdx >= 0 && targetIdx < imagesForHeading.length) {
        ImageManager.removeImageAtIndex(titleKey, targetIdx);
      }
    } catch (err) {
      console.error('[ImageManager] prompt-card remove handler failed:', err);
    }

    syncGlobalImagesFromImageManager();
  };

  (promptsContainer as any)._promptCardRemoveHandler = handler;
  promptsContainer.addEventListener('click', handler);
}

// ✅ [2026-01-25 모듈화] syncHeadingVideoInPromptItems
// → ./utils/headingVideoPreviewUtils.js로 이동됨 (window._impl 호출로 무한재귀 방지)
function syncHeadingVideoInPromptItems(): void {
  if (typeof (window as any).syncHeadingVideoInPromptItems_impl === 'function') {
    (window as any).syncHeadingVideoInPromptItems_impl();
  }
}

// ✅ [2026-01-25 모듈화] getReviewHeadingSeed
// → ./utils/headingVideoPreviewUtils.js로 이동됨 (상단 import 참조)
// getReviewHeadingSeed는 import { getReviewHeadingSeed }로 직접 사용


async function openApplyVideoToHeadingModal(filePath: string, displayName?: string): Promise<void> {
  const headings = getHeadingsForVeo();
  if (headings.length === 0) {
    toastManager.warning('소제목이 없습니다. 먼저 AI 글을 생성해서 소제목을 만든 뒤 다시 시도하세요.');
    return;
  }
  if (typeof (window.api as any)?.applyHeadingVideo !== 'function') {
    toastManager.error('소제목 배치 기능이 아직 로드되지 않았습니다.');
    return;
  }

  const existing = document.getElementById('apply-video-heading-modal');
  if (existing) existing.remove();

  const overlay = document.createElement('div');
  overlay.id = 'apply-video-heading-modal';
  overlay.setAttribute('aria-hidden', 'false');
  overlay.style.position = 'fixed';
  overlay.style.inset = '0';
  overlay.style.background = 'rgba(0,0,0,0.6)';
  overlay.style.zIndex = '9999';
  overlay.style.display = 'flex';
  overlay.style.alignItems = 'center';
  overlay.style.justifyContent = 'center';

  const modal = document.createElement('div');
  modal.style.width = 'min(720px, 92vw)';
  modal.style.maxHeight = '80vh';
  modal.style.overflow = 'hidden';
  modal.style.background = 'var(--bg-primary)';
  modal.style.border = '1px solid var(--border-light)';
  modal.style.borderRadius = '12px';
  modal.style.boxShadow = '0 20px 60px rgba(0,0,0,0.35)';
  modal.style.display = 'flex';
  modal.style.flexDirection = 'column';

  const header = document.createElement('div');
  header.style.display = 'flex';
  header.style.alignItems = 'center';
  header.style.justifyContent = 'space-between';
  header.style.padding = '1rem 1.25rem';
  header.style.borderBottom = '1px solid var(--border-light)';
  header.innerHTML = `
    <div style="font-weight:800; color: var(--text-strong); font-size: 1.05rem;">🎞️ 영상 배치할 소제목 선택</div>
    <button type="button" id="apply-video-heading-close" style="background: transparent; border: none; color: var(--text-muted); font-size: 1.2rem; cursor: pointer;">×</button>
  `;

  const body = document.createElement('div');
  body.style.padding = '1rem 1.25rem';
  body.style.overflowY = 'auto';
  body.style.display = 'flex';
  body.style.flexDirection = 'column';
  body.style.gap = '0.5rem';

  const meta = document.createElement('div');
  meta.style.color = 'var(--text-muted)';
  meta.style.fontSize = '0.85rem';
  meta.style.marginBottom = '0.25rem';
  meta.textContent = `선택한 영상: ${displayName || 'video.mp4'}`;

  const list = document.createElement('div');
  list.style.display = 'grid';
  list.style.gridTemplateColumns = '1fr';
  list.style.gap = '0.5rem';

  headings.forEach((h, idx) => {
    const item = document.createElement('label');
    item.style.display = 'flex';
    item.style.alignItems = 'flex-start';
    item.style.gap = '0.65rem';
    item.style.padding = '0.75rem';
    item.style.border = '1px solid var(--border-light)';
    item.style.borderRadius = '10px';
    item.style.cursor = 'pointer';
    item.style.background = 'var(--bg-secondary)';
    const safeTitle = escapeHtml(h.title);
    item.innerHTML = `
      <input type="radio" name="apply-video-heading" value="${idx}" style="margin-top: 0.2rem; transform: scale(1.1);" ${idx === 0 ? 'checked' : ''} />
      <div style="min-width:0; flex:1;">
        <div style="font-weight:800; color: var(--text-strong); word-break: break-word;">${safeTitle}</div>
      </div>
    `;
    list.appendChild(item);
  });

  body.appendChild(meta);
  body.appendChild(list);

  const footer = document.createElement('div');
  footer.style.display = 'flex';
  footer.style.gap = '0.5rem';
  footer.style.justifyContent = 'flex-end';
  footer.style.padding = '1rem 1.25rem';
  footer.style.borderTop = '1px solid var(--border-light)';
  footer.innerHTML = `
    <button type="button" id="apply-video-heading-cancel" style="padding: 0.65rem 1rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 10px; cursor: pointer; font-weight: 700;">취소</button>
    <button type="button" id="apply-video-heading-confirm" style="padding: 0.65rem 1rem; background: linear-gradient(135deg, #22c55e, #16a34a); color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: 900;">선택 소제목에 배치</button>
  `;

  modal.appendChild(header);
  modal.appendChild(body);
  modal.appendChild(footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  const close = () => overlay.remove();
  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) close();
  });

  (header.querySelector('#apply-video-heading-close') as HTMLButtonElement | null)?.addEventListener('click', close);
  (footer.querySelector('#apply-video-heading-cancel') as HTMLButtonElement | null)?.addEventListener('click', close);

  (footer.querySelector('#apply-video-heading-confirm') as HTMLButtonElement | null)?.addEventListener('click', async () => {
    const selected = overlay.querySelector('input[name="apply-video-heading"]:checked') as HTMLInputElement | null;
    const idx = selected ? Number(selected.value) : 0;
    const chosen = headings[idx] || headings[0];
    const rawHeadingTitle = String(chosen?.title || '').trim();
    const headingTitle = normalizeHeadingKeyForVideoCache(rawHeadingTitle);
    if (!headingTitle) return;

    const lockKey = `applyVideo:${headingTitle}`;
    const locked = await runUiActionLocked(lockKey, '중복사용은 금합니다', async () => {
      appendLog(`🎞️ 소제목 영상 배치 시작: "${headingTitle}" ← ${displayName || 'video.mp4'}`);
      const url = toFileUrlMaybe(filePath);
      const updatedAt = Date.now();
      const res = await (window.api as any).applyHeadingVideo(headingTitle, {
        provider: 'mp4',
        filePath,
        previewDataUrl: url,
        updatedAt,
      });

      if (!res?.success) {
        toastManager.error(res?.message || '소제목에 영상 배치 실패');
        appendLog(`❌ 소제목 영상 배치 실패: "${headingTitle}" (${res?.message || 'unknown'})`);
        return;
      }

      // ✅ 영상 배치 즉시 기존 소제목 이미지는 제거(완전 교체) -> GIF 변환 완료 전에도 UI에서 바로 사라지게 함
      try {
        const titleKey = ImageManager.resolveHeadingKey(rawHeadingTitle || headingTitle);
        ImageManager.unsetHeadings.add(titleKey);
        syncGlobalImagesFromImageManager();
      } catch {
        // ignore
      }

      headingVideoPreviewCache.set(headingTitle, { url, updatedAt });
      headingVideoPreviewInFlight.delete(headingTitle);
      ImageManager.syncAllPreviews();
      try {
        const sc: any = (window as any).currentStructuredContent;
        const imgs = (window as any).imageManagementGeneratedImages || generatedImages || [];
        if (sc?.headings) updateUnifiedImagePreview(sc.headings, imgs);
      } catch {
        // ignore
      }
      syncHeadingVideoInPromptItems();
      syncHeadingVideoSlotsInUnifiedPreview();
      toastManager.success(`✅ "${headingTitle}" 소제목에 영상이 배치되었습니다.`);
      appendLog(`✅ 소제목 영상 배치 완료: "${headingTitle}"`);
      // 소제목 영상이 배치되면 해당 mp4를 GIF로 변환해 이미지로도 자동 등록
      await ensureGifImageForHeading(rawHeadingTitle || headingTitle, filePath);
      close();
    });
    if (locked === null) return;
  });
}

async function removeHeadingVideoByTitle(headingTitle: string): Promise<void> {
  const heading = normalizeHeadingKeyForVideoCache(String(headingTitle || '').trim());
  if (!heading) return;
  if (typeof (window.api as any)?.removeHeadingVideo !== 'function') {
    toastManager.error('소제목 영상 제거 기능을 사용할 수 없습니다.');
    return;
  }
  const res = await (window.api as any).removeHeadingVideo(heading);
  if (!res?.success) {
    toastManager.error(res?.message || '영상 제거에 실패했습니다.');
    return;
  }
  headingVideoPreviewCache.set(heading, null);
  headingVideoPreviewInFlight.delete(heading);

  // ✅ 이 소제목에 연결된 GIF 이미지도 함께 제거 (mp4 → GIF 썸네일 정리)
  try {
    const rawTitle = String(headingTitle || '').trim();
    let targetHeading = rawTitle;

    try {
      const norm = normalizeHeadingKeyForVideoCache(rawTitle);
      const keys = Array.from(ImageManager.imageMap.keys()) as string[];
      for (const key of keys) {
        const keyStr = String(key || '');
        const keyNorm = normalizeHeadingKeyForVideoCache(keyStr);
        if (keyStr === rawTitle || (norm && keyNorm === norm)) {
          targetHeading = keyStr;
          break;
        }
      }
    } catch {
      // 매칭 실패 시 rawTitle 그대로 사용
    }

    const imagesForHeading = ImageManager.getImages(targetHeading) || [];
    for (let i = imagesForHeading.length - 1; i >= 0; i -= 1) {
      const img: any = imagesForHeading[i];
      if (String(img?.provider || '') === 'gif-from-video') {
        ImageManager.removeImageAtIndex(targetHeading, i);
      }
    }

    syncGlobalImagesFromImageManager();
  } catch {
    // ignore
  }

  ImageManager.syncAllPreviews();
  syncHeadingVideoInPromptItems();
  syncHeadingVideoSlotsInUnifiedPreview();
  toastManager.success('소제목 영상이 제거되었습니다.');
}

async function ensureGifImageForHeading(headingTitle: string, videoFilePath: string): Promise<void> {
  try {
    const api: any = (window as any).api;
    if (!api || typeof api.convertMp4ToGif !== 'function') {
      return;
    }

    const sourcePath = String(videoFilePath || '').trim();
    if (!sourcePath) return;

    const res = await runUiActionLocked(`gif:${sourcePath}`, '중복사용은 금합니다', async () => {
      return await api.convertMp4ToGif({ sourcePath });
    });
    if (!res) return;
    if (!res?.success || !res.gifPath) {
      if (res?.message) {
        appendLog(`⚠️ GIF 변환 실패: ${res.message}`);
      }
      return;
    }

    const gifPath = String(res.gifPath);

    // ✅ 실제 파일 존재/용량 확인 (0바이트/미생성 파일이면 그리드/발행에 등록 금지)
    try {
      let ok = true;
      if (typeof api.getFileStats === 'function') {
        const st = await api.getFileStats(gifPath);
        ok = Boolean(st?.isFile) && Number(st?.size || 0) > 1024;
      } else if (typeof api.checkFileExists === 'function') {
        ok = await api.checkFileExists(gifPath);
      }

      if (!ok) {
        toastManager.error('GIF 파일 저장에 실패했습니다. (파일이 생성되지 않음)');
        appendLog(`❌ GIF 파일 저장 실패: ${gifPath}`);
        return;
      }
    } catch {
      // ignore
    }

    const gifUrl = toFileUrlMaybe(gifPath);
    const rawTitle = String(headingTitle || '').trim();

    // ImageManager 키와 최대한 매칭 (원본 제목 또는 정규화된 제목)
    let targetHeading = rawTitle;
    try {
      const norm = normalizeHeadingKeyForVideoCache(rawTitle);
      const keys = Array.from(ImageManager.imageMap.keys()) as string[];
      for (const key of keys) {
        const keyStr = String(key || '');
        const keyNorm = normalizeHeadingKeyForVideoCache(keyStr);
        if (keyStr === rawTitle || (norm && keyNorm === norm)) {
          targetHeading = keyStr;
          break;
        }
      }
    } catch {
      // 매칭 실패 시 rawTitle 그대로 사용
    }

    const titleKey = ImageManager.resolveHeadingKey(targetHeading);

    // ✅ 기존 이미지 유지 + gif-from-video만 교체 (덮어쓰기 금지)
    const existing = ImageManager.getImages(titleKey) || [];
    const withoutGifs = existing.filter((img: any) => String(img?.provider || '') !== 'gif-from-video');

    const imageObj: any = {
      heading: titleKey,
      filePath: gifPath,
      previewDataUrl: gifUrl,
      provider: 'gif-from-video',
      prompt: rawTitle || targetHeading,
      timestamp: Date.now(),
    };

    // GIF는 대표 미디어로 앞에 배치
    const withoutPrimary = (withoutGifs || []).filter((_img: any, idx: number) => idx !== 0);
    ImageManager.imageMap.set(titleKey, [imageObj, ...withoutPrimary]);
    ImageManager.unsetHeadings.delete(titleKey);
    try {
      const keyNorm = normalizeHeadingKeyForVideoCache(titleKey);
      headingVideoPreviewCache.set(keyNorm, { url: toFileUrlMaybe(videoFilePath), updatedAt: Date.now() });
    } catch {
      // ignore
    }

    syncGlobalImagesFromImageManager();

    // ✅ 추가: 통합 미리보기 업데이트 (syncGlobalImagesFromImageManager에서 처리하지 않는 부분)
    try {
      const allImagesAfter = ImageManager.getAllImages();
      const sc: any = (window as any).currentStructuredContent || currentStructuredContent;
      if (sc?.headings) updateUnifiedImagePreview(sc.headings, allImagesAfter);
    } catch {
      // ignore
    }

    try {
      ImageManager.syncAllPreviews();
    } catch {
      // ignore
    }

    // ✅ 추가: 생성된 이미지 목록 UI 업데이트 (GIF 표시)
    try {
      const allImagesAfterGif = ImageManager.getAllImages();
      (window as any).imageManagementGeneratedImages = allImagesAfterGif;
      displayGeneratedImages(allImagesAfterGif);
      updatePromptItemsWithImages(allImagesAfterGif); // ✅ 영어 프롬프트 이미지 미리보기 업데이트
    } catch {
      // ignore
    }

    appendLog(`✅ GIF 이미지 생성 및 배치 완료: ${headingTitle}`);
  } catch (error) {
    console.error('[GIF] mp4 → GIF 변환 실패:', error);
    appendLog(`❌ GIF 변환 실패: ${(error as Error).message}`);
  }
}

async function applyHeadingVideoFromFile(headingTitle: string, filePath: string, provider: string): Promise<void> {
  const heading = normalizeHeadingKeyForVideoCache(String(headingTitle || '').trim());
  const path = String(filePath || '').trim();
  const prov = String(provider || '').trim() || 'mp4';
  if (!heading || !path) return;
  if (typeof (window.api as any)?.applyHeadingVideo !== 'function') {
    throw new Error('소제목 배치 기능이 아직 로드되지 않았습니다.');
  }
  appendLog(`🎞️ 소제목 영상 배치 시작: "${heading}" ← ${path.split(/[\\/]/).pop() || 'video.mp4'}`);
  const url = toFileUrlMaybe(path);
  const updatedAt = Date.now();
  const applyRes = await (window.api as any).applyHeadingVideo(heading, {
    provider: prov,
    filePath: path,
    previewDataUrl: url,
    updatedAt,
  });
  if (!applyRes?.success) {
    appendLog(`❌ 소제목 영상 배치 실패: "${heading}" (${applyRes?.message || 'unknown'})`);
    throw new Error(applyRes?.message || '소제목에 영상 배치 실패');
  }

  try {
    const titleKey = ImageManager.resolveHeadingKey(headingTitle);
    ImageManager.unsetHeadings.add(titleKey);
  } catch {
    // ignore
  }

  headingVideoPreviewCache.set(heading, { url, updatedAt });
  headingVideoPreviewInFlight.delete(heading);
  ImageManager.syncAllPreviews();
  syncHeadingVideoInPromptItems();
  try {
    const sc: any = (window as any).currentStructuredContent;
    const imgs = (window as any).imageManagementGeneratedImages || generatedImages || [];
    if (sc?.headings) updateUnifiedImagePreview(sc.headings, imgs);
  } catch {
    // ignore
  }
  syncHeadingVideoSlotsInUnifiedPreview();
  appendLog(`✅ 소제목 영상 배치 완료: "${heading}"`);
  await ensureGifImageForHeading(headingTitle, path);
}

async function createKenBurnsFallbackVideoForHeading(headingTitle: string, referenceImagePath: string, aspectRatio: '16:9' | '9:16' = '16:9'): Promise<{ success: boolean; filePath?: string; message?: string }> {
  try {
    const api: any = (window as any).api;
    if (!api || typeof api.createKenBurnsVideo !== 'function') {
      return { success: false, message: 'KenBurns 영상 생성 기능이 아직 로드되지 않았습니다.' };
    }

    const imgPath = String(referenceImagePath || '').trim();
    if (!imgPath) {
      return { success: false, message: '참조 이미지 경로가 없습니다.' };
    }

    appendLog(`🎞️ 정책 차단 폴백: 로컬 KenBurns 영상 생성 시작 (소제목: "${String(headingTitle || '').trim()}")`);
    const res = await api.createKenBurnsVideo({
      imagePath: imgPath,
      heading: String(headingTitle || '').trim(),
      durationSeconds: 6,
      aspectRatio,
    });
    if (!res?.success || !res?.filePath) {
      return { success: false, message: String(res?.message || 'KenBurns 영상 생성 실패') };
    }

    await applyHeadingVideoFromFile(headingTitle, String(res.filePath || '').trim(), 'kenburns');
    return { success: true, filePath: String(res.filePath || '').trim() };
  } catch (e) {
    return { success: false, message: (e as Error).message || String(e) };
  }
}

async function regenerateHeadingVideoByTitle(headingTitle: string): Promise<void> {
  const heading = normalizeHeadingKeyForVideoCache(String(headingTitle || '').trim());
  if (!heading) return;
  if (typeof (window.api as any)?.applyHeadingVideo !== 'function') {
    toastManager.error('소제목 배치 기능이 아직 로드되지 않았습니다.');
    return;
  }

  const provider = getCurrentVideoProvider();
  setCurrentVideoProvider(provider);

  const locked = await runUiActionLocked(`regenerateVideo:${heading}`, '중복사용은 금합니다', async () => {

    const headings = getHeadingsForVeo();
    const entry = headings.find((h) => h.title === heading);
    const rawPrompt = String((entry?.prompt || heading || '')).trim();
    const { prompt } = buildHeadingAlignedVeoPrompt(heading, rawPrompt);
    if (!prompt) {
      toastManager.error('프롬프트가 비어있습니다.');
      return;
    }

    const toLocalPath = (p: string): string => {
      const raw = String(p || '').trim();
      if (!raw) return '';
      if (/^file:\/\//i.test(raw)) {
        return raw.replace(/^file:\/\//i, '').replace(/^\/+/, '').replace(/\\/g, '/');
      }
      return raw.replace(/\\/g, '/');
    };

    const resolveReferenceImagePath = async (): Promise<string> => {
      const norm = normalizeHeadingKeyForVideoCache(headingTitle);
      let imgEntry: any = null;
      try {
        imgEntry = ImageManager.getImage(headingTitle);
      } catch {
        imgEntry = null;
      }

      if (!imgEntry) {
        const allCandidates: any[] = [];
        try {
          const fromManager = ImageManager.getAllImages();
          if (Array.isArray(fromManager) && fromManager.length > 0) allCandidates.push(...fromManager);
        } catch {
          // ignore
        }
        const globalAll = (window as any).imageManagementGeneratedImages;
        if (Array.isArray(globalAll) && globalAll.length > 0) allCandidates.push(...globalAll);
        if (Array.isArray(generatedImages) && generatedImages.length > 0) allCandidates.push(...generatedImages);

        imgEntry =
          allCandidates.find((img: any) => normalizeHeadingKeyForVideoCache(String(img?.heading || '').trim()) === norm) ||
          null;
      }

      let filePath = toLocalPath(String(imgEntry?.filePath || '').trim());
      if (!filePath) {
        const urlCandidate = String(imgEntry?.url || imgEntry?.previewDataUrl || '').trim();
        filePath = toLocalPath(urlCandidate);
      }

      let exists = false;
      try {
        if (filePath && typeof (window.api as any)?.checkFileExists === 'function') {
          exists = await (window.api as any).checkFileExists(filePath);
        }
      } catch {
        exists = false;
      }

      if ((!filePath || !exists) && typeof (window.api as any)?.downloadAndSaveImage === 'function') {
        const urlCandidate = String(imgEntry?.url || imgEntry?.previewDataUrl || '').trim();
        if (/^https?:\/\//i.test(urlCandidate)) {
          const postTitle = String((window as any).currentStructuredContent?.selectedTitle || currentStructuredContent?.selectedTitle || '').trim();
          const postId = currentPostId || undefined;
          const res = await (window.api as any).downloadAndSaveImage(urlCandidate, headingTitle, postTitle || undefined, postId);
          if (res?.success) {
            const savedPath = String(res?.filePath || res?.savedToLocal || '').trim();
            if (savedPath) {
              filePath = toLocalPath(savedPath);
              try {
                ImageManager.setImage(headingTitle, {
                  ...(imgEntry || {}),
                  heading: headingTitle,
                  filePath,
                  url: toFileUrlMaybe(filePath),
                  previewDataUrl: toFileUrlMaybe(filePath),
                  savedToLocal: true,
                });
                syncGlobalImagesFromImageManager();
                ImageManager.syncAllPreviews();
              } catch {
                // ignore
              }
            }
          }
        }
      }

      return String(filePath || '').trim();
    };

    const imagePath = await resolveReferenceImagePath();
    if (!imagePath) {
      toastManager.warning(`"${headingTitle}" 소제목에 배치된 이미지가 없습니다. 먼저 이미지를 생성/배치한 뒤 영상을 생성해주세요.`);
      return;
    }

    showVeoProgressOverlay(heading);
    setVeoProgressOverlay(provider === 'kenburns' ? '로컬 영상 생성 중...' : '생성 요청 전송 중...', 2);
    try {
      if (provider === 'kenburns') {
        appendLog(`🎞️ KenBurns 영상 생성 시작(재생성): "${heading}"`);
        const fb = await createKenBurnsFallbackVideoForHeading(headingTitle, imagePath, '16:9');
        if (!fb?.success) {
          hideVeoProgressOverlay(0);
          const msg = String(fb?.message || 'KenBurns 영상 생성 실패');
          toastManager.error(msg);
          appendLog(`❌ KenBurns 영상 생성 실패(재생성): "${heading}" (${msg})`);
          return;
        }
        setVeoProgressOverlay('완료!', 100);
        hideVeoProgressOverlay(800);
        toastManager.success('✅ 소제목 영상 재생성 완료(KenBurns)');
        appendLog(`✅ KenBurns 영상 생성 및 배치 완료(재생성): "${heading}"`);
        try {
          await refreshMp4FilesList();
        } catch {
          // ignore
        }
        return;
      }

      if (typeof (window.api as any)?.generateVeoVideo !== 'function') {
        toastManager.error('AI 영상 기능이 아직 로드되지 않았습니다.');
        hideVeoProgressOverlay(0);
        return;
      }

      appendLog(`🎬 AI 영상 생성 시작(재생성): "${heading}"`);
      let result = await generateVeoVideoWithRetry(
        {
          prompt,
          negativePrompt: 'audio, speech, voice, voiceover, narration, music, singing, lyrics, dialogue',
          model: 'veo-3.1-generate-preview',
          durationSeconds: 6,
          aspectRatio: '16:9',
          heading: heading,
          imagePath,
        },
        heading,
      );

      if (!result?.success) {
        const rawMsg = String(result?.message || '');
        if (isVeoQuotaExceededMessage(rawMsg)) {
          hideVeoProgressOverlay(0);
          lockVeoQuota(10, rawMsg);
          return;
        }
        const msgLower = rawMsg.toLowerCase();
        const isPolicyChildren = msgLower.includes('photorealistic children');
        const isPolicyCelebrity = msgLower.includes('celebrity or their likenesses');

        if (isPolicyChildren || isPolicyCelebrity) {
          appendLog(
            `🛡️ Veo 정책 차단 감지(재생성): "${heading}" (사유: ${rawMsg || 'unknown'})`,
          );
          appendLog(
            '🔁 정책을 준수하는 방향으로 프롬프트를 정제한 뒤 다시 시도합니다.',
          );
          setVeoProgressOverlay('정책 준수 프롬프트로 다시 시도 중...', 5);

          let safePrompt = prompt;
          try {
            const safeTitle = String(heading || '').trim();
            if (safeTitle && safePrompt.toLowerCase().includes(safeTitle.toLowerCase())) {
              const escaped = safeTitle.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              const pattern = new RegExp(escaped, 'gi');
              safePrompt = safePrompt.replace(pattern, '').trim();
            }
          } catch {
            // ignore
          }

          if (isPolicyChildren) {
            safePrompt = `${safePrompt} (no children, only adults or objects, no faces of minors)`;
          } else if (isPolicyCelebrity) {
            safePrompt = `${safePrompt} (no specific celebrities, no recognizable real people, generic subject only)`;
          }

          const fallbackResult = await generateVeoVideoWithRetry(
            {
              prompt: safePrompt || prompt,
              negativePrompt:
                'audio, speech, voice, voiceover, narration, music, singing, lyrics, dialogue',
              model: 'veo-3.1-generate-preview',
              durationSeconds: 6,
              aspectRatio: '16:9',
              imagePath,
            },
            heading,
          );

          if (!fallbackResult?.success) {
            appendLog('🎞️ 정책 차단으로 Veo 생성 실패(재생성): 로컬 KenBurns 영상으로 폴백 시도합니다.');
            setVeoProgressOverlay('정책 차단: 로컬 영상 생성 중...', 20);
            const fb = await createKenBurnsFallbackVideoForHeading(heading, imagePath, '16:9');
            if (fb?.success) {
              setVeoProgressOverlay('완료!', 100);
              hideVeoProgressOverlay(800);
              appendLog(`✅ KenBurns 폴백 영상 생성 및 배치 완료(재생성): "${heading}"`);
              toastManager.success('✅ 소제목 영상 재생성 완료(폴백)');
              try {
                await refreshMp4FilesList();
              } catch {
                // ignore
              }
              return;
            }

            hideVeoProgressOverlay(0);
            const finalMsg = String(fb?.message || fallbackResult?.message || rawMsg || 'AI 영상 생성 실패');
            toastManager.error(finalMsg);
            appendLog(
              `❌ AI 영상 생성 실패(재생성, 정책 차단 후 재시도+폴백도 실패): "${heading}" (${finalMsg})`,
            );
            return;
          }

          result = fallbackResult;
        } else {
          hideVeoProgressOverlay(0);
          const msg = rawMsg || 'AI 영상 생성 실패';
          toastManager.error(msg);
          appendLog(
            `❌ AI 영상 생성 실패(재생성): "${heading}" (${String(msg || 'unknown')})`,
          );
          return;
        }
      }

      const filePath = String(result.filePath || '').trim();
      const url = toFileUrlMaybe(filePath);
      const updatedAt = Date.now();

      const applyRes = await (window.api as any).applyHeadingVideo(heading, {
        provider: 'veo',
        filePath,
        previewDataUrl: url,
        updatedAt,
      });

      if (!applyRes?.success) {
        hideVeoProgressOverlay(0);
        toastManager.error(applyRes?.message || '소제목에 영상 배치 실패');
        appendLog(`❌ 소제목 영상 배치 실패(재생성): "${heading}" (${String(applyRes?.message || 'unknown')})`);
        return;
      }

      try {
        const titleKey = ImageManager.resolveHeadingKey(headingTitle);
        ImageManager.unsetHeadings.add(titleKey);
        syncGlobalImagesFromImageManager();
      } catch {
        // ignore
      }

      headingVideoPreviewCache.set(heading, { url, updatedAt });
      headingVideoPreviewInFlight.delete(heading);
      ImageManager.syncAllPreviews();
      syncHeadingVideoSlotsInUnifiedPreview();
      setVeoProgressOverlay('완료!', 100);
      hideVeoProgressOverlay(800);
      toastManager.success('✅ 소제목 영상 재생성 완료');
      appendLog(`✅ AI 영상 생성 완료(재생성): "${heading}"`);
      await refreshMp4FilesList();
      await ensureGifImageForHeading(heading, filePath);
    } catch (e) {
      hideVeoProgressOverlay(0);
      toastManager.error(`AI 영상 생성 오류: ${(e as Error).message}`);
      appendLog(`❌ AI 영상 생성 오류(재생성): "${heading}" (${(e as Error).message})`);
    }
  });
  if (locked === null) return;
}

async function generateHeadingVideoForPrompt(headingIndex: number, headingTitle: string): Promise<void> {
  const safeIndex = Number.isFinite(headingIndex as any) ? headingIndex : 0;
  const title = String(
    headingTitle ||
    (window as any)._headingTitles?.[safeIndex] ||
    '',
  ).trim();

  if (!title) {
    toastManager.warning('소제목 정보를 찾을 수 없습니다. 먼저 글과 소제목을 생성해주세요.');
    return;
  }

  if (typeof (window.api as any)?.applyHeadingVideo !== 'function') {
    toastManager.error('소제목 영상 배치 기능이 아직 로드되지 않았습니다.');
    return;
  }

  const provider = getCurrentVideoProvider();
  setCurrentVideoProvider(provider);

  if (provider === 'veo' && typeof (window.api as any)?.generateVeoVideo !== 'function') {
    toastManager.error('AI 영상 기능이 아직 로드되지 않았습니다.');
    return;
  }

  try {
    // 1) 영어 프롬프트 가져오기 (전역 배열 우선, 없으면 카드 DOM에서)
    const promptsContainer = document.getElementById('prompts-container') as HTMLDivElement | null;
    if (!promptsContainer) {
      toastManager.error('소제목 분석 정보를 찾을 수 없습니다. 먼저 분석을 실행해주세요.');
      return;
    }
    const promptItems = promptsContainer.querySelectorAll('.prompt-item');
    const promptItem = promptItems[safeIndex] as HTMLElement | undefined;
    if (!promptItem) {
      toastManager.error('해당 소제목의 영어 프롬프트를 찾을 수 없습니다. 먼저 분석을 실행해주세요.');
      return;
    }

    // 1-1) 이 소제목에 배치된 이미지 필수 사용 (이미지 없으면 생성 중단)
    let rawPrompt = '';
    const promptTextEl = promptItem.querySelector('.prompt-text');
    if (promptTextEl) {
      rawPrompt = String(promptTextEl.textContent || '').trim();
    }
    if (!rawPrompt) {
      rawPrompt = String(promptItem?.textContent || '').trim();
    }

    const toLocalPath = (p: string): string => {
      const raw = String(p || '').trim();
      if (!raw) return '';
      if (/^file:\/\//i.test(raw)) {
        return raw.replace(/^file:\/\//i, '').replace(/^\/+/, '').replace(/\\/g, '/');
      }
      return raw.replace(/\\/g, '/');
    };

    const resolvePlacedImageForHeading = async (): Promise<any | null> => {
      const resolvedKey = (() => {
        try {
          return ImageManager.resolveHeadingKey(title);
        } catch {
          return title;
        }
      })();

      let entry: any = null;
      const selectedKey = (() => {
        try {
          return String(getHeadingSelectedImageKey(resolvedKey) || '').trim();
        } catch {
          return '';
        }
      })();

      if (selectedKey) {
        try {
          const imgs = ImageManager.getImages(resolvedKey) || [];
          entry = (imgs || []).find((img: any) => getStableImageKey(img) === selectedKey) || null;
        } catch {
          entry = null;
        }
      }

      if (!entry) {
        try {
          entry = ImageManager.getImage(title);
        } catch {
          entry = null;
        }
      }

      if (!entry) {
        const norm = normalizeHeadingKeyForVideoCache(title);
        const allCandidates: any[] = [];
        try {
          const fromManager = ImageManager.getAllImages();
          if (Array.isArray(fromManager) && fromManager.length > 0) allCandidates.push(...fromManager);
        } catch {
          // ignore
        }
        const globalAll = (window as any).imageManagementGeneratedImages;
        if (Array.isArray(globalAll) && globalAll.length > 0) allCandidates.push(...globalAll);
        if (Array.isArray(generatedImages) && generatedImages.length > 0) allCandidates.push(...generatedImages);

        const byIndex = allCandidates.find((img: any) => Number(img?.headingIndex) === safeIndex);
        const byHeading = allCandidates.find((img: any) => {
          const h = String(img?.heading || '').trim();
          return h && normalizeHeadingKeyForVideoCache(h) === norm;
        });

        entry = byIndex || byHeading || null;
        if (entry) {
          try {
            const headingKey = String(entry?.heading || title).trim() || title;
            ImageManager.setImage(headingKey, { ...entry, heading: headingKey });
            syncGlobalImagesFromImageManager();
          } catch {
            // ignore
          }
        }
      }
      return entry;
    };

    let imgEntry: any = await resolvePlacedImageForHeading();
    if (!imgEntry) {
      toastManager.warning(`"${title}" 소제목에 배치된 이미지가 없습니다. 먼저 이미지를 생성/배치한 뒤 영상을 생성해주세요.`);
      return;
    }

    // filePath 없고 file:// url만 있는 케이스 보정
    let imagePath = toLocalPath(String(imgEntry.filePath || ''));
    if (!imagePath) {
      const urlCandidate = String(imgEntry.url || imgEntry.previewDataUrl || '').trim();
      imagePath = toLocalPath(urlCandidate);
    }

    // 로컬 존재 확인
    let exists = false;
    try {
      if (imagePath && typeof (window.api as any)?.checkFileExists === 'function') {
        exists = await (window.api as any).checkFileExists(imagePath);
      }
    } catch {
      exists = false;
    }

    // 원격 URL이면 자동 저장 후 진행
    if ((!imagePath || !exists) && typeof (window.api as any)?.downloadAndSaveImage === 'function') {
      const urlCandidate = String(imgEntry.url || imgEntry.previewDataUrl || '').trim();
      if (/^https?:\/\//i.test(urlCandidate)) {
        try {
          const postTitle = String((window as any).currentStructuredContent?.selectedTitle || currentStructuredContent?.selectedTitle || '').trim();
          const postId = currentPostId || undefined;
          const res = await (window.api as any).downloadAndSaveImage(urlCandidate, title, postTitle || undefined, postId);
          if (!res?.success) {
            throw new Error(String(res?.message || '이미지 저장 실패'));
          }
          const savedPath = String(res?.filePath || res?.savedToLocal || '').trim();
          if (!savedPath) throw new Error('저장된 이미지 경로를 찾을 수 없습니다.');
          imagePath = toLocalPath(savedPath);

          try {
            ImageManager.setImage(title, {
              ...imgEntry,
              heading: title,
              filePath: imagePath,
              url: toFileUrlMaybe(imagePath),
              previewDataUrl: toFileUrlMaybe(imagePath),
              savedToLocal: true,
            });
            syncGlobalImagesFromImageManager();
            ImageManager.syncAllPreviews();
          } catch {
            // ignore
          }
        } catch (err) {
          toastManager.error(`이미지 저장 실패: ${(err as Error).message}`);
          return;
        }
      }
    }

    if (!imagePath) {
      toastManager.warning(`"${title}" 소제목에 배치된 이미지가 없습니다. 먼저 이미지를 생성/배치한 뒤 영상을 생성해주세요.`);
      return;
    }

    if (provider === 'kenburns') {
      appendLog(`🎞️ KenBurns 영상 생성 시작: "${title}"`, 'images-log-output');
      showVeoProgressOverlay(title);
      setVeoProgressOverlay('로컬 영상 생성 중...', 20);
      const fb = await createKenBurnsFallbackVideoForHeading(title, imagePath, '16:9');
      if (!fb?.success) {
        hideVeoProgressOverlay(0);
        const msg = String(fb?.message || 'KenBurns 영상 생성 실패');
        appendLog(`❌ KenBurns 영상 생성 실패: "${title}" (${msg})`, 'images-log-output');
        toastManager.error(msg);
        return;
      }
      setVeoProgressOverlay('완료!', 100);
      hideVeoProgressOverlay(800);
      appendLog(`✅ KenBurns 영상 생성 및 배치 완료: "${title}"`, 'images-log-output');
      toastManager.success(`✅ "${title}" 소제목에 로컬 영상이 배치되었습니다.`);
      try {
        await refreshMp4FilesList();
      } catch {
        // ignore
      }
      return;
    }

    // 2) 이미지 프롬프트를 최우선으로 사용하여 Veo용 안전 프롬프트 생성
    const imagePrompt = String(imgEntry.prompt || '').trim();
    const baseText = imagePrompt || rawPrompt || title;
    const combined = `${baseText}

Create a dynamic cinematic video version of this exact reference image. Match the same subject, camera angle, composition, background, lighting, facial expression, and overall mood.`;

    const { prompt, changed, reason } = buildVeoSafePrompt(combined);
    if (!prompt) {
      toastManager.error('영상용 프롬프트가 비어있습니다. 먼저 영어 프롬프트를 생성해주세요.');
      return;
    }

    appendLog(`🎬 소제목 영상 생성 시작: "${title}"`, 'images-log-output');
    if (changed) {
      appendLog(`🛡️ Veo 프롬프트 자동 보정 적용: ${reason || '정책 차단 방지'}`, 'images-log-output');
    }

    showVeoProgressOverlay(title);
    setVeoProgressOverlay('생성 요청 전송 중...', 2);

    // 3) 영상 생성 (이미지 참조 필수)
    let result = await generateVeoVideoWithRetry(
      {
        prompt,
        negativePrompt:
          'audio, speech, voice, voiceover, narration, music, singing, lyrics, dialogue, party, nightclub, dancing crowd, festival, concert',
        model: 'veo-3.1-generate-preview',
        durationSeconds: 6,
        aspectRatio: '16:9',
        imagePath,
      },
      title,
    );

    if (!result?.success) {
      const rawMsg = String(result?.message || '');
      const msgLower = rawMsg.toLowerCase();
      const isPolicyChildren = msgLower.includes('photorealistic children');
      const isPolicyCelebrity = msgLower.includes('celebrity or their likenesses');

      if (isPolicyChildren || isPolicyCelebrity) {
        appendLog(
          `🛡️ Veo 정책 차단 감지: "${title}" (사유: ${rawMsg || 'unknown'})`,
          'images-log-output',
        );
        appendLog(
          '🔁 정책을 준수하는 방향으로 이미지 제거 및 프롬프트 정제 후 다시 시도합니다.',
          'images-log-output',
        );
        setVeoProgressOverlay('정책 준수 설정으로 다시 시도 중...', 5);

        // 이미지 참조 제거 (imagePath 미전달)
        let safePrompt = prompt;
        try {
          const safeTitle = String(title || '').trim();
          if (safeTitle && safePrompt.toLowerCase().includes(safeTitle.toLowerCase())) {
            const escaped = safeTitle.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const pattern = new RegExp(escaped, 'gi');
            safePrompt = safePrompt.replace(pattern, '').trim();
          }
        } catch {
          // ignore
        }

        if (isPolicyChildren) {
          safePrompt = `${safePrompt} (no children, only adults or objects, no faces of minors)`;
        } else if (isPolicyCelebrity) {
          safePrompt = `${safePrompt} (no specific celebrities, no recognizable real people, generic subject only)`;
        }

        const fallbackResult = await generateVeoVideoWithRetry(
          {
            prompt: safePrompt || prompt,
            negativePrompt:
              'audio, speech, voice, voiceover, narration, music, singing, lyrics, dialogue',
            model: 'veo-3.1-generate-preview',
            durationSeconds: 6,
            aspectRatio: '16:9',
            imagePath,
          },
          title,
        );

        if (!fallbackResult?.success) {
          appendLog('🎞️ 정책 차단으로 Veo 생성 실패: 로컬 KenBurns 영상으로 폴백 시도합니다.', 'images-log-output');
          setVeoProgressOverlay('정책 차단: 로컬 영상 생성 중...', 20);
          const fb = await createKenBurnsFallbackVideoForHeading(title, imagePath, '16:9');
          if (fb?.success) {
            setVeoProgressOverlay('완료!', 100);
            hideVeoProgressOverlay(800);
            appendLog(`✅ KenBurns 폴백 영상 생성 및 배치 완료: "${title}"`, 'images-log-output');
            toastManager.success(`✅ "${title}" 소제목에 폴백 영상이 배치되었습니다.`);
            try {
              await refreshMp4FilesList();
            } catch {
              // ignore
            }
            return;
          }

          hideVeoProgressOverlay(0);
          const finalMsg = String(fb?.message || fallbackResult?.message || rawMsg || 'AI 영상 생성 실패');
          appendLog(
            `❌ 소제목 영상 생성 실패(정책 차단 후 재시도+폴백도 실패): "${title}" (${finalMsg})`,
            'images-log-output',
          );
          toastManager.error(finalMsg);
          return;
        }

        result = fallbackResult;
      } else {
        hideVeoProgressOverlay(0);
        const msg = rawMsg || 'AI 영상 생성 실패';
        appendLog(`❌ 소제목 영상 생성 실패: "${title}" (${msg})`, 'images-log-output');
        toastManager.error(msg);
        return;
      }
    }

    // 5) 소제목에 바로 배치
    setVeoProgressOverlay('소제목에 영상 배치 중...', 90);
    const filePath = String(result.filePath || '').trim();

    try {
      await applyHeadingVideoFromFile(title, filePath, 'veo');
      setVeoProgressOverlay('완료!', 100);
      hideVeoProgressOverlay(800);
      appendLog(`✅ 소제목 영상 생성 및 배치 완료: "${title}"`, 'images-log-output');
      toastManager.success(`✅ "${title}" 소제목에 AI 영상이 배치되었습니다.`);
    } catch (err) {
      hideVeoProgressOverlay(0);
      appendLog(`❌ 소제목 영상 배치 실패: "${title}" (${(err as Error).message})`, 'images-log-output');
      toastManager.error(`소제목 영상 배치 실패: ${(err as Error).message}`);
      return;
    }

    // 6) AI 영상 목록 새로고침
    try {
      await refreshMp4FilesList();
    } catch {
      // ignore
    }
  } catch (error) {
    hideVeoProgressOverlay(0);
    appendLog(`❌ 소제목 영상 생성 중 오류: "${title}" (${(error as Error).message})`, 'images-log-output');
    toastManager.error(`AI 영상 생성 실패: ${(error as Error).message}`);
  }
}

function getHeadingsForVeo(): Array<{ title: string; prompt: string }> {
  const content: any = (window as any).currentStructuredContent || currentStructuredContent;
  const headings: any[] = Array.isArray(content?.headings) ? content.headings : [];
  return headings
    .map((h) => {
      const title = typeof h === 'string' ? h : (h?.title || '');
      const p = typeof h === 'string' ? '' : (h?.imagePrompt || h?.prompt || '');
      return { title: String(title || '').trim(), prompt: String(p || '').trim() };
    })
    .filter((x) => x.title.length > 0);
}

// ✅ [2026-01-25 모듈화] HeadingVideoPreviewCacheEntry, headingVideoPreviewCache, headingVideoPreviewInFlight
// → ./utils/headingVideoPreviewUtils.js로 이동됨 (상단 import 참조)

// ✅ [2026-01-25 모듈화] ensureKenBurnsStyles
// → ./utils/kenBurnsStyles.js로 이동됨 (상단 import 참조)

// ✅ [2026-01-25 모듈화] ensureUnifiedPreviewVideoDelegation
// → ./utils/headingVideoPreviewUtils.js로 이동됨 (window._impl 호출로 무한재귀 방지)
function ensureUnifiedPreviewVideoDelegation(): void {
  if (typeof (window as any).ensureUnifiedPreviewVideoDelegation_impl === 'function') {
    (window as any).ensureUnifiedPreviewVideoDelegation_impl(showVideoModal);
  }
}

// ✅ [2026-01-25 모듈화] toFileUrlMaybe, normalizeHeadingKeyForVideoCache
// → ./utils/headingKeyUtils.js로 이동됨 (상단 import 참조)

function ensurePreGenerationSelectionsOrWarn(): boolean {
  // ✅ [2026-01-16] 버그 수정: 카테고리/콘텐츠 모드/톤 검증을 완전히 비활성화
  // 이유: unified-article-type 요소 참조 문제로 카테고리가 선택되어도 검증 실패
  // 카테고리 선택은 CategoryModal에서 별도로 관리되므로 여기서 검증할 필요 없음
  console.log('[ensurePreGenerationSelectionsOrWarn] 검증 비활성화됨 - 항상 통과');
  return true;
}


// ✅ [2026-01-25 모듈화] syncHeadingVideoSlotsInUnifiedPreview
// → ./utils/headingVideoPreviewUtils.js로 이동됨 (window._impl 호출로 무한재귀 방지)
function syncHeadingVideoSlotsInUnifiedPreview(): void {
  if (typeof (window as any).syncHeadingVideoSlots_impl === 'function') {
    (window as any).syncHeadingVideoSlots_impl(ImageManager);
  }
}

async function getAiVideoFolderPath(): Promise<string> {
  const basePath = await getRequiredImageBasePath();
  return `${basePath}/mp4`.replace(/\\/g, '/');
}

let mp4ListSearchQuery = '';
let mp4ListLastFiles: any[] = [];
let mp4ListPage = 1;

async function refreshMp4FilesList(): Promise<void> {
  const listEl = document.getElementById('mp4-files-list');
  if (!listEl) return;

  if (typeof (window.api as any)?.listMp4Files !== 'function') {
    listEl.innerHTML = `<div style="color: var(--text-muted); font-style: italic; text-align: center; padding: 1.5rem;">AI 영상 목록 API를 사용할 수 없습니다.</div>`;
    return;
  }

  try {
    listEl.innerHTML = `<div style="color: var(--text-muted); font-style: italic; text-align: center; padding: 1.5rem;">AI 영상 목록 불러오는 중...</div>`;
    const dirPath = await getAiVideoFolderPath();
    const res = await (window.api as any).listMp4Files({ dirPath });
    if (!res?.success) {
      listEl.innerHTML = `<div style="color: var(--text-muted); font-style: italic; text-align: center; padding: 1.5rem;">AI 영상 목록을 불러오지 못했습니다.</div>`;
      return;
    }

    const files = Array.isArray(res?.files) ? res.files : [];
    mp4ListLastFiles = files;
    if (files.length === 0) {
      listEl.innerHTML = `<div style="color: var(--text-muted); font-style: italic; text-align: center; padding: 1.5rem;">AI 영상이 아직 없습니다. 위에서 AI 영상 만들기를 눌러보세요.</div>`;
      return;
    }

    const formatBytes = (bytes: number): string => {
      const n = Number(bytes || 0);
      if (!Number.isFinite(n) || n <= 0) return '0 B';
      const units = ['B', 'KB', 'MB', 'GB'];
      const idx = Math.min(units.length - 1, Math.floor(Math.log(n) / Math.log(1024)));
      const val = n / Math.pow(1024, idx);
      return `${val.toFixed(idx === 0 ? 0 : 1)} ${units[idx]}`;
    };

    const rootDir = String(dirPath || '').replace(/\\/g, '/').replace(/\/+$/g, '');
    const getFolderKey = (f: any): { key: string; label: string; baseName: string } => {
      const fullPathNorm = String(f?.fullPath || '').replace(/\\/g, '/');
      let rel = fullPathNorm.startsWith(`${rootDir}/`) ? fullPathNorm.slice(rootDir.length + 1) : fullPathNorm;
      const parts = rel.split('/').filter(Boolean);
      const folder = parts.length > 1 ? parts[0] : '기타';
      const rawName = String(f?.name || 'video.mp4');
      const slashIdx = rawName.indexOf('/');
      const baseName = slashIdx >= 0 ? rawName.slice(slashIdx + 1) : rawName;
      const label = folder === '기타' ? '기타(폴더 없음)' : folder;
      return { key: folder, label, baseName };
    };

    const renderMp4List = (rawFiles: any[], query: string): void => {
      const q = String(query || '').toLowerCase().trim();
      const filteredFiles = (rawFiles || []).filter((f: any) => {
        if (!q) return true;
        const { key, label, baseName } = getFolderKey(f);
        const fullName = String(f?.name || '').toLowerCase();
        return (
          String(key || '').toLowerCase().includes(q) ||
          String(label || '').toLowerCase().includes(q) ||
          String(baseName || '').toLowerCase().includes(q) ||
          fullName.includes(q)
        );
      });

      filteredFiles.sort((a: any, b: any) => Number(b?.mtime || 0) - Number(a?.mtime || 0));

      const totalCount = filteredFiles.length;
      const pageSize = 5;
      const totalPages = Math.max(1, Math.ceil(totalCount / pageSize));
      if (mp4ListPage < 1) mp4ListPage = 1;
      if (mp4ListPage > totalPages) mp4ListPage = totalPages;
      const start = (mp4ListPage - 1) * pageSize;
      const pageItems = filteredFiles.slice(start, start + pageSize);

      const searchHtml = `
        <div style="display:flex; gap: 0.5rem; align-items:center; margin-bottom: 0.75rem;">
          <div style="flex:1; position: relative;">
            <input id="mp4-search-input" type="text" placeholder="🔍 영상 검색 (소제목/파일명)" value="${escapeHtml(query || '')}" style="width: 100%; padding: 0.6rem 0.75rem 0.6rem 2.25rem; background: var(--bg-tertiary); border: 1px solid var(--border-light); border-radius: 10px; color: var(--text-strong); font-size: 0.9rem;" />
            <span style="position:absolute; left: 0.7rem; top: 50%; transform: translateY(-50%); font-size: 1rem;">🔍</span>
          </div>
          <div id="mp4-search-count" style="color: var(--text-muted); font-size: 0.8rem; white-space: nowrap;">${totalCount}개</div>
        </div>
      `;

      const pagingHtml = `
        <div style="display:flex; align-items:center; justify-content: space-between; gap: 0.5rem; margin-bottom: 0.75rem;">
          <button type="button" id="mp4-page-prev" ${mp4ListPage <= 1 ? 'disabled' : ''} style="padding: 0.45rem 0.75rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 10px; cursor: pointer; font-weight: 900; opacity: ${mp4ListPage <= 1 ? 0.5 : 1};">이전</button>
          <div style="color: var(--text-muted); font-size: 0.85rem; font-weight: 800;">${totalCount === 0 ? '0/0' : `${mp4ListPage}/${totalPages}`}</div>
          <button type="button" id="mp4-page-next" ${mp4ListPage >= totalPages ? 'disabled' : ''} style="padding: 0.45rem 0.75rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 10px; cursor: pointer; font-weight: 900; opacity: ${mp4ListPage >= totalPages ? 0.5 : 1};">다음</button>
        </div>
      `;

      const listHtml = pageItems
        .map((f: any) => {
          const { label, baseName } = getFolderKey(f);
          const name = escapeHtml(baseName);
          const folderLabel = escapeHtml(label);
          const fullPath = String(f?.fullPath || '').replace(/\\/g, '/');
          const url = escapeHtml(toFileUrlMaybe(fullPath));
          const mtime = Number(f?.mtime || 0);
          const when = mtime ? new Date(mtime).toLocaleString() : '';
          const size = formatBytes(Number(f?.size || 0));
          return `
            <div style="display:flex; gap: 0.9rem; padding: 0.85rem; border: 1px solid var(--border-light); border-radius: 12px; background: var(--bg-primary); margin-bottom: 0.75rem;">
              <div class="ai-video-thumb" data-video-url="${url}" data-video-title="${name}" style="width: 220px; aspect-ratio: 16/9; border-radius: 10px; overflow:hidden; background: #000; cursor: pointer; flex: 0 0 auto;">
                <video src="${url}" muted autoplay loop playsinline preload="metadata" style="width: 100%; height: 100%; object-fit: cover;"></video>
              </div>
              <div style="flex: 1 1 auto; min-width: 0; display:flex; flex-direction: column; justify-content: space-between; gap: 0.6rem;">
                <div style="min-width:0;">
                  <div style="display:flex; gap: 0.5rem; align-items: baseline; min-width:0;">
                    <div style="font-weight: 800; color: var(--text-strong); white-space: nowrap; overflow:hidden; text-overflow: ellipsis;" title="${name}">${name}</div>
                    <div style="font-size: 0.75rem; color: var(--text-muted); white-space: nowrap;">📁 ${folderLabel}</div>
                  </div>
                  <div style="font-size: 0.8rem; color: var(--text-muted); margin-top: 0.25rem;">${escapeHtml(when)}${when ? ' · ' : ''}${escapeHtml(size)}</div>
                </div>
                <div style="display:flex; gap: 0.5rem; flex-wrap: wrap;">
                  <button type="button" class="open-ai-video-file-btn" data-video-path="${escapeHtml(fullPath)}" style="padding: 0.45rem 0.75rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 10px; cursor: pointer; font-weight: 800;">열기</button>
                  <button type="button" class="assign-ai-video-btn" data-video-path="${escapeHtml(fullPath)}" data-video-name="${escapeHtml(String(f?.name || 'video.mp4'))}" style="padding: 0.45rem 0.75rem; background: rgba(34, 197, 94, 0.12); color: #22c55e; border: 1px solid rgba(34, 197, 94, 0.45); border-radius: 10px; cursor: pointer; font-weight: 900;">소제목에 배치</button>
                  <button type="button" class="regenerate-ai-video-btn" data-video-name="${escapeHtml(String(f?.name || 'video.mp4'))}" style="padding: 0.45rem 0.75rem; background: rgba(59, 130, 246, 0.12); color: #3b82f6; border: 1px solid rgba(59, 130, 246, 0.45); border-radius: 10px; cursor: pointer; font-weight: 900;">재생성</button>
                  <button type="button" class="delete-ai-video-file-btn" data-video-path="${escapeHtml(fullPath)}" data-video-name="${escapeHtml(String(f?.name || 'video.mp4'))}" style="padding: 0.45rem 0.75rem; background: rgba(239, 68, 68, 0.12); color: #ef4444; border: 1px solid rgba(239, 68, 68, 0.45); border-radius: 10px; cursor: pointer; font-weight: 900;">삭제</button>
                </div>
              </div>
            </div>
          `;
        })
        .join('');

      listEl.innerHTML = searchHtml + pagingHtml + (listHtml || `<div style="color: var(--text-muted); font-style: italic; text-align: center; padding: 1.5rem;">검색 결과가 없습니다.</div>`);

      const searchInput = listEl.querySelector('#mp4-search-input') as HTMLInputElement | null;
      if (searchInput) {
        searchInput.addEventListener('input', () => {
          mp4ListSearchQuery = searchInput.value;
          mp4ListPage = 1;
          renderMp4List(mp4ListLastFiles, mp4ListSearchQuery);
        });
      }

      const prevBtn = listEl.querySelector('#mp4-page-prev') as HTMLButtonElement | null;
      if (prevBtn) {
        prevBtn.addEventListener('click', () => {
          if (mp4ListPage > 1) mp4ListPage -= 1;
          renderMp4List(mp4ListLastFiles, mp4ListSearchQuery);
        });
      }
      const nextBtn = listEl.querySelector('#mp4-page-next') as HTMLButtonElement | null;
      if (nextBtn) {
        nextBtn.addEventListener('click', () => {
          if (mp4ListPage < totalPages) mp4ListPage += 1;
          renderMp4List(mp4ListLastFiles, mp4ListSearchQuery);
        });
      }

      listEl.querySelectorAll('.ai-video-thumb video').forEach((video) => {
        const v = video as HTMLVideoElement;
        v.addEventListener('error', () => {
          const wrap = v.closest('.ai-video-thumb') as HTMLElement | null;
          if (!wrap) return;
          wrap.style.background = 'linear-gradient(135deg, rgba(239, 68, 68, 0.25), rgba(0, 0, 0, 0.75))';
        });
        try {
          v.play().catch(() => {
            // ignore
          });
        } catch {
          // ignore
        }
      });

      listEl.querySelectorAll('.ai-video-thumb').forEach((el) => {
        el.addEventListener('click', () => {
          const videoUrl = String((el as HTMLElement).getAttribute('data-video-url') || '').trim();
          const title = String((el as HTMLElement).getAttribute('data-video-title') || '').trim();
          if (videoUrl) showVideoModal(videoUrl, title);
        });
      });

      listEl.querySelectorAll('.open-ai-video-file-btn').forEach((btn) => {
        btn.addEventListener('click', async (e) => {
          e.stopPropagation();
          try {
            const p = String((btn as HTMLElement).getAttribute('data-video-path') || '').trim();
            if (!p) return;
            if (window.api.openPath) {
              await window.api.openPath(p);
            }
          } catch {
            toastManager.error('영상을 열 수 없습니다.');
          }
        });
      });

      listEl.querySelectorAll('.assign-ai-video-btn').forEach((btn) => {
        btn.addEventListener('click', async (e) => {
          e.stopPropagation();
          const p = String((btn as HTMLElement).getAttribute('data-video-path') || '').trim();
          const name = String((btn as HTMLElement).getAttribute('data-video-name') || '').trim();
          if (!p) return;
          await openApplyVideoToHeadingModal(p, name);
        });
      });

      listEl.querySelectorAll('.regenerate-ai-video-btn').forEach((btn) => {
        btn.addEventListener('click', async (e) => {
          e.stopPropagation();
          const name = String((btn as HTMLElement).getAttribute('data-video-name') || '').trim();
          const headingFromFolder = String(name.split('/')[0] || '').trim();
          if (headingFromFolder) {
            const headings = getHeadingsForVeo();
            const matched = headings.find((h) => String(h.title || '').trim() === headingFromFolder);
            if (matched) {
              await regenerateHeadingVideoByTitle(headingFromFolder);
              return;
            }
          }
          toastManager.warning('이 영상이 어떤 소제목의 영상인지 자동으로 찾지 못했습니다. 소제목 선택 창에서 재생성해주세요.');
          await openVeoHeadingSelectModal();
        });
      });

      listEl.querySelectorAll('.delete-ai-video-file-btn').forEach((btn) => {
        btn.addEventListener('click', async (e) => {
          e.stopPropagation();
          const p = String((btn as HTMLElement).getAttribute('data-video-path') || '').trim();
          if (!p) return;
          if (!window.confirm('이 영상 파일을 삭제하시겠습니까?')) return;
          if (typeof (window.api as any)?.deleteFile !== 'function') {
            toastManager.error('파일 삭제 API를 사용할 수 없습니다.');
            return;
          }
          try {
            const res = await (window.api as any).deleteFile(p);
            if (!res?.success) {
              toastManager.error(res?.message || '파일 삭제 실패');
              return;
            }

            try {
              const name = String((btn as HTMLElement).getAttribute('data-video-name') || '').trim();
              const headingFromFolder = String(name.split('/')[0] || '').trim();
              if (headingFromFolder) {
                const headings = getHeadingsForVeo();
                const matched = headings.find((h) => String(h.title || '').trim() === headingFromFolder);
                if (matched) {
                  const titleKey = String(matched.title || headingFromFolder).trim();
                  try {
                    await removeHeadingVideoByTitle(titleKey);
                  } catch {
                    // ignore
                  }
                  try {
                    const imagesForHeading = ImageManager.getImages(titleKey) || [];
                    for (let i = imagesForHeading.length - 1; i >= 0; i -= 1) {
                      const img: any = imagesForHeading[i];
                      if (String(img?.provider || '') === 'gif-from-video') {
                        ImageManager.removeImageAtIndex(titleKey, i);
                      }
                    }
                    syncGlobalImagesFromImageManager();
                  } catch {
                    // ignore
                  }
                }
              }
            } catch {
              // ignore
            }

            toastManager.success('영상 파일이 삭제되었습니다.');
            mp4ListLastFiles = mp4ListLastFiles.filter((f: any) => String(f?.fullPath || '').replace(/\\/g, '/') !== String(p || '').replace(/\\/g, '/'));
            renderMp4List(mp4ListLastFiles, mp4ListSearchQuery);
          } catch (err) {
            toastManager.error(`파일 삭제 오류: ${(err as Error).message}`);
          }
        });
      });
    };

    renderMp4List(mp4ListLastFiles, mp4ListSearchQuery);

  } catch (e) {
    console.error('[AI-VIDEO] listMp4Files 실패:', e);
    appendLog(`❌ AI 영상 목록 불러오기 실패: ${(e as Error).message || String(e)}`);
    listEl.innerHTML = `<div style="color: var(--text-muted); font-style: italic; text-align: center; padding: 1.5rem;">AI 영상 목록을 불러오지 못했습니다.</div>`;
  }
}

// ✅ [2026-01-25 모듈화] getHeadingVideoPreviewFromCache
// → ./utils/headingVideoPreviewUtils.js로 이동됨 (상단 import 참조)

// ✅ [2026-01-26 FIX] wrapper 함수들 - window.xxx_impl만 호출 (fallback 절대 금지!)
// 번들링 후 xxxModule이 xxx로 바뀌어서 자기 자신 호출 → 무한재귀 발생
// 해결: fallback 없이 _impl만 호출. _impl이 없으면 빈 값 반환 (안전)

function prefetchHeadingVideoPreview(heading: string): void {
  // _impl은 veoVideoUtils.ts에서 window에 노출됨 (인라인됨)
  if (typeof (window as any).prefetchHeadingVideoPreview_impl === 'function') {
    (window as any).prefetchHeadingVideoPreview_impl(heading);
  }
  // fallback 없음 - 무한재귀 방지
}

function buildMinimalSilentVeoPrompt(headingTitle: string): string {
  if (typeof (window as any).buildMinimalSilentVeoPrompt_impl === 'function') {
    return (window as any).buildMinimalSilentVeoPrompt_impl(headingTitle);
  }
  return ''; // fallback 없음
}

function getReviewProductAnchor(): string {
  if (typeof (window as any).getReviewProductAnchor_impl === 'function') {
    return (window as any).getReviewProductAnchor_impl();
  }
  return ''; // fallback 없음
}

function buildHeadingAlignedVeoPrompt(headingTitle: string, rawHeadingPrompt?: string): { prompt: string; changed: boolean; reason: string } {
  if (typeof (window as any).buildHeadingAlignedVeoPrompt_impl === 'function') {
    return (window as any).buildHeadingAlignedVeoPrompt_impl(headingTitle, rawHeadingPrompt);
  }
  return { prompt: '', changed: false, reason: '' }; // fallback 없음
}

// ✅ [2026-01-25 모듈화] buildVeoSafePrompt, isVeoAudioBlockedMessage
// → ./utils/veoSafetyUtils.js로 이동됨 (상단 import 참조)

// ✅ [2026-01-25 모듈화] isImageStylePromptForVeo
// → ./utils/videoProviderUtils.js로 이동됨

// ✅ [2026-01-25 모듈화] VEO 쿼터 상태 변수
// → ./utils/veoVideoUtils.js로 이동됨 (상단 import에서 getVeoQuotaLockUntil, setVeoQuotaLockUntil 참조)

// ✅ [2026-01-25 모듈화] lockVeoQuota
// → ./utils/veoVideoUtils.js로 이동됨, window._impl 호출 (무한재귀 방지)
function lockVeoQuota(minutes: number, rawMessage?: string): string {
  if (typeof (window as any).lockVeoQuota_impl === 'function') {
    return (window as any).lockVeoQuota_impl(minutes, rawMessage, {
      showToastError: (msg: string) => toastManager.error(msg),
      appendLog: (msg: string, target?: string) => appendLog(msg, target)
    });
  }
  return ''; // fallback 없음
}

// ✅ [2026-01-25 모듈화] generateVeoVideoWithRetry
// → ./utils/veoVideoUtils.js로 이동됨, window._impl 호출 (무한재귀 방지)
async function generateVeoVideoWithRetry(params: any, headingTitleForFallback: string): Promise<any> {
  if (typeof (window as any).generateVeoVideoWithRetry_impl === 'function') {
    return (window as any).generateVeoVideoWithRetry_impl(params, headingTitleForFallback, {
      appendLog: (msg: string, target?: string) => appendLog(msg, target),
      showToastError: (msg: string) => toastManager.error(msg)
    });
  }
  return null; // fallback 없음
}

async function openVeoHeadingSelectModal(): Promise<void> {
  const headings = getHeadingsForVeo();
  if (headings.length === 0) {
    toastManager.warning('소제목이 없습니다. 먼저 AI 글을 생성해서 소제목을 만든 뒤 다시 시도하세요.');
    return;
  }

  const getSelectedVideoProvider = (): 'veo' | 'kenburns' => {
    return getCurrentVideoProvider();
  };

  const persistSelectedVideoProvider = (provider: 'veo' | 'kenburns'): void => {
    setCurrentVideoProvider(provider);
  };

  const existing = document.getElementById('veo-heading-select-modal');
  if (existing) {
    existing.remove();
  }

  const overlay = document.createElement('div');
  overlay.id = 'veo-heading-select-modal';
  overlay.setAttribute('aria-hidden', 'false');
  overlay.style.position = 'fixed';
  overlay.style.inset = '0';
  overlay.style.background = 'rgba(0,0,0,0.6)';
  overlay.style.zIndex = '9999';
  overlay.style.display = 'flex';
  overlay.style.alignItems = 'center';
  overlay.style.justifyContent = 'center';

  const modal = document.createElement('div');
  modal.style.width = 'min(720px, 92vw)';
  modal.style.maxHeight = '80vh';
  modal.style.overflow = 'hidden';
  modal.style.background = 'var(--bg-primary)';
  modal.style.border = '1px solid var(--border-light)';
  modal.style.borderRadius = '12px';
  modal.style.boxShadow = '0 20px 60px rgba(0,0,0,0.35)';
  modal.style.display = 'flex';
  modal.style.flexDirection = 'column';

  const header = document.createElement('div');
  header.style.display = 'flex';
  header.style.alignItems = 'center';
  header.style.justifyContent = 'space-between';
  header.style.padding = '1rem 1.25rem';
  header.style.borderBottom = '1px solid var(--border-light)';
  header.innerHTML = `
    <div style="font-weight:800; color: var(--text-strong); font-size: 1.05rem;">🎬 AI 영상 만들 소제목 선택</div>
    <button type="button" id="veo-heading-close" style="background: transparent; border: none; color: var(--text-muted); font-size: 1.2rem; cursor: pointer;">×</button>
  `;

  const body = document.createElement('div');
  body.style.padding = '1rem 1.25rem';
  body.style.overflowY = 'auto';
  body.style.display = 'flex';
  body.style.flexDirection = 'column';
  body.style.gap = '0.5rem';

  const list = document.createElement('div');
  list.style.display = 'grid';
  list.style.gridTemplateColumns = '1fr';
  list.style.gap = '0.5rem';

  headings.forEach((h, idx) => {
    const item = document.createElement('label');
    item.style.display = 'flex';
    item.style.alignItems = 'flex-start';
    item.style.gap = '0.65rem';
    item.style.padding = '0.75rem';
    item.style.border = '1px solid var(--border-light)';
    item.style.borderRadius = '10px';
    item.style.cursor = 'pointer';
    item.style.background = 'var(--bg-secondary)';

    const promptText = (h.prompt || h.title).trim();
    const safeTitle = escapeHtml(h.title);
    const safePrompt = escapeHtml(promptText);

    item.innerHTML = `
      <input type="radio" name="veo-heading" value="${idx}" style="margin-top: 0.2rem; transform: scale(1.1);" ${idx === 0 ? 'checked' : ''} />
      <div style="min-width:0; flex:1;">
        <div style="font-weight:800; color: var(--text-strong); word-break: break-word;">${safeTitle}</div>
        <div style="margin-top: 0.25rem; color: var(--text-muted); font-size: 0.85rem; line-height: 1.35;">${safePrompt}</div>
      </div>
    `;
    list.appendChild(item);
  });

  body.appendChild(list);

  const ratioLabel = document.createElement('div');
  ratioLabel.style.margin = '1rem 0 0.5rem 0';
  ratioLabel.style.fontWeight = '800';
  ratioLabel.style.fontSize = '0.9rem';
  ratioLabel.style.color = 'var(--text-gold)';
  ratioLabel.innerText = '🎥 영상 비율 설정';
  body.appendChild(ratioLabel);

  const ratioSelect = document.createElement('select');
  ratioSelect.id = 'veo-aspect-ratio';
  ratioSelect.style.width = '100%';
  ratioSelect.style.padding = '0.75rem';
  ratioSelect.style.background = 'var(--bg-input)';
  ratioSelect.style.color = 'var(--text-strong)';
  ratioSelect.style.border = '1px solid var(--border-light)';
  ratioSelect.style.borderRadius = '10px';
  ratioSelect.innerHTML = `
    <option value="16:9">가로형 (16:9)</option>
    <option value="9:16">세로형 (9:16)</option>
    <option value="1:1" selected>정사각형 (1:1)</option>
    <option value="original">Original (원본 비율)</option>
  `;
  body.appendChild(ratioSelect);

  const footer = document.createElement('div');
  footer.style.display = 'flex';
  footer.style.gap = '0.5rem';
  footer.style.justifyContent = 'flex-end';
  footer.style.padding = '1rem 1.25rem';
  footer.style.borderTop = '1px solid var(--border-light)';
  footer.innerHTML = `
    <button type="button" id="veo-heading-cancel" style="padding: 0.65rem 1rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 10px; cursor: pointer; font-weight: 700;">취소</button>
    <button type="button" id="veo-heading-generate" style="padding: 0.65rem 1rem; background: linear-gradient(135deg, #22c55e, #16a34a); color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: 800;">선택 소제목으로 생성</button>
  `;

  modal.appendChild(header);
  modal.appendChild(body);
  modal.appendChild(footer);
  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  const close = () => {
    overlay.remove();
  };

  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) close();
  });

  (header.querySelector('#veo-heading-close') as HTMLButtonElement | null)?.addEventListener('click', close);
  (footer.querySelector('#veo-heading-cancel') as HTMLButtonElement | null)?.addEventListener('click', close);

  (footer.querySelector('#veo-heading-generate') as HTMLButtonElement | null)?.addEventListener('click', async () => {
    const selected = overlay.querySelector('input[name="veo-heading"]:checked') as HTMLInputElement | null;
    const idx = selected ? Number(selected.value) : 0;
    const chosen = headings[idx] || headings[0];
    const provider = getSelectedVideoProvider();
    persistSelectedVideoProvider(provider);
    const rawPrompt = String((chosen?.prompt || chosen?.title || '')).trim();
    const { prompt, changed, reason } = buildHeadingAlignedVeoPrompt(String(chosen?.title || ''), rawPrompt);
    if (!prompt) {
      toastManager.warning('선택한 소제목 프롬프트가 비어있습니다.');
      return;
    }

    close();

    if (provider === 'kenburns') {
      // ✅ 로컬 KenBurns 영상 생성 (이미지 참조 필수)
      try {
        const chosenHeadingKey = normalizeHeadingKeyForVideoCache(String(chosen?.title || '').trim());
        const chosenImage = chosenHeadingKey ? (ImageManager.getImage(chosenHeadingKey) as any) : null;
        const chosenImagePath = String(chosenImage?.filePath || '').trim();
        if (!chosenImagePath) {
          toastManager.warning('KenBurns 영상 생성에는 소제목에 배치된 이미지가 필요합니다. 먼저 이미지를 생성/배치해주세요.');
          return;
        }
        appendLog(`🎞️ KenBurns 영상 생성 요청: ${chosen.title}`);
        showVeoProgressOverlay(chosen.title);
        setVeoProgressOverlay('로컬 영상 생성 중...', 20);

        const selectedRatio = (overlay.querySelector('#veo-aspect-ratio') as HTMLSelectElement)?.value as any || '16:9';
        const fb = await createKenBurnsFallbackVideoForHeading(String(chosen?.title || '').trim(), chosenImagePath, selectedRatio);
        if (!fb?.success) {
          hideVeoProgressOverlay(0);
          toastManager.error(fb?.message || 'KenBurns 영상 생성 실패');
          appendLog(`❌ KenBurns 영상 생성 실패: ${String(fb?.message || 'unknown')}`);
          return;
        }

        setVeoProgressOverlay('완료! 목록 갱신 중...', 100);
        hideVeoProgressOverlay(800);
        toastManager.success('✅ KenBurns 영상 생성 및 배치 완료');
        appendLog('✅ KenBurns 영상 생성 및 배치 완료');
        await refreshMp4FilesList();
      } catch (e) {
        hideVeoProgressOverlay(0);
        const msg = (e as Error).message || String(e);
        toastManager.error(`KenBurns 영상 생성 오류: ${msg}`);
        appendLog(`❌ KenBurns 영상 생성 중 오류: ${msg}`);
      }
      return;
    }

    // ✅ Veo
    if (typeof (window.api as any)?.generateVeoVideo !== 'function') {
      toastManager.error('AI 영상 기능이 아직 로드되지 않았습니다. 앱을 종료 후 다시 실행하세요.');
      appendLog('❌ AI 영상 기능이 아직 로드되지 않았습니다. (preload/renderer 미반영)');
      return;
    }

    appendLog(`🎬 AI 영상 생성 요청: ${chosen.title}`);
    if (changed) {
      appendLog(`🛡️ Veo 프롬프트 자동 보정 적용: ${reason || '정책 차단 방지'}`);
    }
    showVeoProgressOverlay(chosen.title);
    setVeoProgressOverlay('생성 요청 전송 중...', 2);
    try {
      const chosenHeadingKey = normalizeHeadingKeyForVideoCache(String(chosen?.title || '').trim());
      const chosenImage = chosenHeadingKey ? (ImageManager.getImage(chosenHeadingKey) as any) : null;
      const chosenImagePath = String(chosenImage?.filePath || '').trim();
      const result = await generateVeoVideoWithRetry(
        {
          prompt,
          negativePrompt: 'audio, speech, voice, voiceover, narration, music, singing, lyrics, dialogue',
          model: 'veo-3.1-generate-preview',
          durationSeconds: 6,
          aspectRatio: (overlay.querySelector('#veo-aspect-ratio') as HTMLSelectElement)?.value as any || '16:9',
          imagePath: chosenImagePath || undefined,
        },
        String(chosen?.title || '')
      );

      if (!result?.success) {
        hideVeoProgressOverlay(0);
        toastManager.error(result?.message || 'AI 영상 생성 실패');
        appendLog(`❌ AI 영상 생성 실패: ${result?.message || '알 수 없는 오류'}`);
        return;
      }

      setVeoProgressOverlay('완료! 목록 갱신 중...', 100);
      hideVeoProgressOverlay(800);
      toastManager.success(`✅ AI 영상 생성 완료: ${result.fileName}`);
      appendLog(`✅ AI 영상 생성 완료: ${result.fileName}`);
      await refreshMp4FilesList();
    } catch (e) {
      hideVeoProgressOverlay(0);
      const msg = (e as Error).message || String(e);
      toastManager.error(`AI 영상 생성 오류: ${msg}`);
      appendLog(`❌ AI 영상 생성 중 오류: ${msg}`);
    }
  });
}

// 전역 진행상황 모달 인스턴스
let progressModal: ProgressModal | null = null;

function getProgressModal(): ProgressModal {
  if (!progressModal) {
    progressModal = new ProgressModal();
  }
  return progressModal;
}

// ✅ [2026-01-25 모듈화] VeoProgressOverlay
// → ./components/VeoProgressOverlay.js로 이동됨 (상단 import 참조)

// 타입 정의
type RendererAutomationImage = {
  heading: string;
  filePath: string;
  provider: string;
  alt?: string;
  caption?: string;
};

type RendererStatus =
  | { success: true }
  | { success: false; cancelled?: boolean; message?: string };

type RendererAutomationPayload = {
  naverId: string;
  naverPassword: string;
  title?: string;
  content?: string;
  lines?: string[];
  selectedHeadings?: string[];
  structuredContent?: StructuredContent;
  generatedImages?: RendererAutomationImage[];
  hashtags?: string[];
  generator?: 'gemini' | 'openai' | 'claude';
  keywords?: string[];
  draft?: string;
  rssUrl?: string;
  autoGenerate?: boolean;
  publishMode?: 'draft' | 'publish' | 'schedule';
  scheduleDate?: string;
  scheduleType?: 'app-schedule' | 'naver-server'; // 예약 발행 타입: 앱 스케줄 관리 vs 네이버 서버 예약
  ctaLink?: string;
  ctaText?: string;
  ctas?: Array<{ text: string; link?: string }>;
  ctaPosition?: 'top' | 'middle' | 'bottom'; // ✅ CTA 위치
  skipCta?: boolean; // ✅ CTA 없이 발행
  skipImages?: boolean;
  targetAge?: '20s' | '30s' | '40s' | '50s' | 'all';
  toneStyle?: 'professional' | 'friendly' | 'casual' | 'formal' | 'humorous' | 'community_fan' | 'mom_cafe';
  keepBrowserOpen?: boolean; // ✅ 브라우저 유지 여부
  thumbnailPath?: string;
  skipDailyLimitWarning?: boolean;
  imageMode?: 'full-auto' | 'semi-auto' | 'manual' | 'skip';
  collectedImages?: Array<{ id: string; url: string; thumbnailUrl: string; title: string; source: string; tags?: string[] }>;
  postId?: string; // ✅ 글 ID 추가
  categoryName?: string; // ✅ 카테고리명 추가
  // ✅ Stability AI & 비디오 관련 필드 추가
  stabilityModel?: string;
  convertToGif?: boolean;
  videoProvider?: string;
  // ✅ 지능형 이미지 배치 관련 플래그
  useIntelligentImagePlacement?: boolean;
  onlyImagePlacement?: boolean;
  useAiImage?: boolean; // ✅ AI 이미지 생성(나노바나나프로 등) 사용 여부
  createProductThumbnail?: boolean; // ✅ 제품 이미지 기반 썸네일 합성 여부
  affiliateLink?: string; // ✅ 제휴마케팅 링크 추가
  contentMode?: string; // ✅ 콘텐츠 모드 추가
  useAffiliateVideo?: boolean; // ✅ 쇼핑 비디오 변환 옵션 추가
  includeThumbnailText?: boolean; // ✅ 썸네일에 텍스트 포함 여부
  customBannerPath?: string; // ✅ [2026-01-18] 커스텀 CTA 배너 이미지 경로
  useAiTableImage?: boolean; // ✅ [2026-01-18] 장단점 표 AI 이미지 생성 여부
  useAiBanner?: boolean; // ✅ [2026-01-18] CTA 배너 AI 이미지 생성 여부
  autoBannerGenerate?: boolean; // ✅ [2026-01-21] 배너 자동 랜덤 생성 (연속발행용)
  // ✅ [2026-01-22] 이전글 연결 정보
  previousPostTitle?: string;
  previousPostUrl?: string;
};


function readUnifiedCtasFromUi(): Array<{ text: string; link?: string }> {
  const container = document.getElementById('unified-cta-items-container');
  const items: Array<{ text: string; link?: string }> = [];

  // 1. 새 row UI에서 읽기
  if (container) {
    const rows = Array.from(container.querySelectorAll('.unified-cta-item')) as HTMLElement[];
    for (const row of rows) {
      const textEl = row.querySelector('.unified-cta-text') as HTMLInputElement | null;
      const linkEl = row.querySelector('.unified-cta-link') as HTMLInputElement | null;
      const text = String(textEl?.value || '').trim();
      const link = String(linkEl?.value || '').trim();
      if (text) items.push({ text, link: link || undefined });
    }
  }

  // 2. 레거시 입력도 항상 읽기 (새 row가 비어있거나 없을 때)
  const legacyText = (document.getElementById('unified-cta-text') as HTMLInputElement | null)?.value?.trim() || '';
  const legacyLink = (document.getElementById('unified-cta-link') as HTMLInputElement | null)?.value?.trim() || '';

  if (legacyText) {
    // 레거시 입력에 값이 있으면 추가 (중복 방지: 같은 텍스트가 없을 때만)
    const alreadyExists = items.some(item => item.text === legacyText);
    if (!alreadyExists) {
      items.push({ text: legacyText, link: legacyLink || undefined });
    }
  }

  return items;
}


// RendererAutomationPayload 타입은 global.d.ts에서 정의됨

// 기본 요소 참조
const form = document.getElementById('automation-form') as HTMLFormElement;
const runButton = document.getElementById('run-button') as HTMLButtonElement;
const publishOnlyButton = document.getElementById('publish-only-button') as HTMLButtonElement;
const cancelButton = document.getElementById('cancel-button') as HTMLButtonElement;
const publishModeSelect = document.getElementById('publish-mode-select') as HTMLSelectElement;
const unifiedPublishModeInput = document.getElementById('unified-publish-mode') as HTMLInputElement;
const scheduleDateContainer = document.getElementById('schedule-date-container') as HTMLDivElement;
const scheduleDateInput = document.getElementById('schedule-date') as HTMLInputElement;
const logOutput = document.getElementById('log-output') as HTMLElement;
const progressContainer = document.getElementById('progress-container') as HTMLDivElement;
const progressBar = document.getElementById('progress-bar') as HTMLDivElement;
const progressStatus = document.getElementById('progress-status') as HTMLSpanElement;

// 위험 지표 요소
const riskSummaryElement = document.getElementById('risk-summary') as HTMLElement || document.getElementById('risk-summary-fixed') as HTMLElement;
const riskAiValue = (document.querySelector('[data-risk-ai]') as HTMLElement) ?? null;
const riskLegalValue = (document.querySelector('[data-risk-legal]') as HTMLElement) ?? null;
const riskSeoValue = (document.querySelector('[data-risk-seo]') as HTMLElement) ?? null;
const riskDailyValue = (document.querySelector('[data-risk-daily]') as HTMLElement) ?? null;
const riskWarning = (document.querySelector('[data-risk-warning]') as HTMLElement) ?? null;

// 우측 상단 고정 버튼들
const licenseButtonFixed = document.getElementById('license-button-fixed') as HTMLButtonElement;
const settingsButtonFixed = document.getElementById('settings-button-fixed') as HTMLButtonElement;
const externalLinksButtonFixed = document.getElementById('external-links-button-fixed') as HTMLButtonElement;

// 모달들
const licenseModal = document.getElementById('license-modal') as HTMLDivElement;
const settingsModal = document.getElementById('settings-modal') as HTMLDivElement;
const externalLinksModal = document.getElementById('external-links-modal') as HTMLDivElement;
const calendarDateModal = document.getElementById('calendar-date-modal') as HTMLDivElement;

// 시계와 달력 초기화
if (typeof window !== 'undefined') {
  initClockAndCalendar();
}

// ============================================
// 날짜 형식 변환 헬퍼 함수
// ============================================

// ✅ [2026-01-25 모듈화] convertDatetimeLocalToScheduleFormat, getScheduleDateFromInput
// → ./utils/dateUtils.js로 이동됨 (상단 import 참조)

// DOM 요소 캐시 (성능 최적화)
const UnifiedDOMCache = {
  // 통합 탭 요소들
  unifiedGenerator: null as HTMLSelectElement | null,
  unifiedToneStyle: null as HTMLSelectElement | null,
  unifiedImageSource: null as HTMLSelectElement | null,
  unifiedUrlInputs: null as NodeListOf<HTMLInputElement> | null,

  // 캐시 초기화
  init() {
    this.unifiedGenerator = document.getElementById('unified-generator') as HTMLSelectElement;
    this.unifiedToneStyle = document.getElementById('unified-tone-style') as HTMLSelectElement; // ✅ 드롭다운에서 글톤 값 읽기 복원
    this.unifiedImageSource = document.getElementById('unified-image-source') as HTMLSelectElement;
  },

  // 캐시 갱신
  refresh() {
    this.unifiedUrlInputs = document.querySelectorAll('.unified-url-input') as NodeListOf<HTMLInputElement>;
  },

  // 안전한 getter
  getGenerator(): string {
    // ✅ [2026-01-26 FIX] 환경설정에서 perplexity-sonar 선택 시 'perplexity' 반환
    const appConfig = (window as any).appConfig || {};
    const selectedModel = appConfig.primaryGeminiTextModel || appConfig.geminiModel || '';
    if (selectedModel === 'perplexity-sonar' || String(selectedModel).toLowerCase().startsWith('perplexity')) {
      return 'perplexity';
    }
    return this.unifiedGenerator?.value || 'gemini';
  },

  getToneStyle(context?: 'ma' | 'continuous' | 'normal'): string {
    // 1. 컨텍스트별 전용 셀렉트 확인
    if (context === 'ma') {
      const maSel = document.getElementById('ma-tone-style-select') as HTMLSelectElement;
      if (maSel) return maSel.value;
    } else if (context === 'continuous') {
      const contSel = document.getElementById('continuous-tone-style-select') as HTMLSelectElement;
      if (contSel) return contSel.value;
    }

    // 2. 기본 드롭다운 확인
    if (this.unifiedToneStyle) return this.unifiedToneStyle.value;

    // 3. 최후의 수단 (DOM 직접 확인)
    const fallback = document.getElementById('unified-tone-style') as HTMLSelectElement;
    return fallback?.value || 'professional';
  },

  getImageSource(): string {
    // 1. 선택된 버튼 우선 확인
    const selectedBtn = document.querySelector('.unified-img-source-btn.selected');
    if (selectedBtn) {
      return selectedBtn.getAttribute('data-source') || 'dalle';
    }

    // 2. 드롭다운(select) 확인
    if (this.unifiedImageSource) {
      return this.unifiedImageSource.value || 'dalle';
    }

    // 3. 최후의 보루 (DOM 직접 확인)
    const fallbackSelect = document.getElementById('unified-image-source') as HTMLSelectElement;
    return fallbackSelect?.value || 'dalle';
  },

  getRealCategory(): string | undefined {
    return (document.getElementById('real-blog-category-select') as HTMLSelectElement)?.value || undefined;
  }
};

// API 키들을 자동으로 로드하는 함수
// ✅ 배포 시 안전: API 키는 사용자 로컬 설정 파일(settings.json)에만 저장됨
// ✅ 소스 코드에 API 키가 포함되지 않음
async function autoLoadApiKeys() {
  console.log('[AutoLoad] API 키 자동 로드 시작');

  try {
    // 현재 설정 로드
    console.log('[AutoLoad] 설정 로드 시작...');
    const currentConfig = await window.api.getConfig();

    if (!currentConfig) {
      console.warn('[AutoLoad] ⚠️ 설정이 null 또는 undefined입니다.');
      return;
    }

    console.log('[AutoLoad] 현재 설정 로드 성공:', Object.keys(currentConfig || {}).length, '개 항목');

    // 저장된 API 키들 확인
    const apiKeyFields = [
      'openai-api-key', 'gemini-api-key', 'claude-api-key', 'pexels-api-key',
      'stability-api-key', 'falai-api-key', 'groq-api-key',
      'perplexity-api-key', // ✅ [2026-01-25] Perplexity API 키 추가
      'naver-client-id', 'naver-client-secret', // ✅ [2026-01-25] 네이버 검색 API 키 추가
      'naver-ad-api-key', 'naver-ad-secret-key', 'naver-ad-customer-id', // ✅ [2026-01-25] 네이버 광고 API 키 추가
    ];

    for (const key of apiKeyFields) {
      if (currentConfig[key] && currentConfig[key].trim() !== '') {
        console.log(`[AutoLoad] ${key} 이미 설정됨`);

        // 입력 필드에 값 설정
        const input = document.getElementById(key) as HTMLInputElement;
        if (input) {
          input.value = currentConfig[key];
        }
      } else {
        console.log(`[AutoLoad] ${key} 미설정 - 환경설정에서 입력 필요`);
      }
    }

    console.log('[AutoLoad] API 키 로드 완료 ✅');

  } catch (error) {
    const errorMsg = (error as Error).message || '알 수 없는 오류';
    console.error('[AutoLoad] ❌ API 키 자동 로드 실패:', errorMsg);
    // 오류가 발생해도 앱은 계속 실행되도록 함 (치명적이지 않음)
  }
}

// 여러 방식으로 이벤트 리스너 연결 시도
function setupHeaderButtons() {
  console.log('[Setup] 헤더 버튼 설정 시작');

  const settingsButton = document.getElementById('settings-button-fixed') as HTMLButtonElement;
  const externalLinksButton = document.getElementById('external-links-button-fixed') as HTMLButtonElement;
  const settingsModal = document.getElementById('settings-modal') as HTMLDivElement;
  const externalLinksModal = document.getElementById('external-links-modal') as HTMLDivElement;

  console.log('[Setup] ===== 상세 DOM 요소 분석 =====');
  console.log('[Setup] settingsButton:', settingsButton);
  console.log('[Setup] settingsButton.tagName:', settingsButton?.tagName);
  console.log('[Setup] settingsButton.id:', settingsButton?.id);
  console.log('[Setup] settingsButton.className:', settingsButton?.className);

  console.log('[Setup] externalLinksButton:', externalLinksButton);
  console.log('[Setup] externalLinksButton.tagName:', externalLinksButton?.tagName);
  console.log('[Setup] externalLinksButton.id:', externalLinksButton?.id);
  console.log('[Setup] externalLinksButton.className:', externalLinksButton?.className);

  console.log('[Setup] settingsModal:', settingsModal);
  console.log('[Setup] settingsModal.tagName:', settingsModal?.tagName);
  console.log('[Setup] settingsModal.id:', settingsModal?.id);
  console.log('[Setup] settingsModal.className:', settingsModal?.className);
  console.log('[Setup] settingsModal.style.display (현재):', settingsModal?.style.display);
  console.log('[Setup] settingsModal.getAttribute(aria-hidden):', settingsModal?.getAttribute('aria-hidden'));

  console.log('[Setup] externalLinksModal:', externalLinksModal);
  console.log('[Setup] externalLinksModal.tagName:', externalLinksModal?.tagName);
  console.log('[Setup] externalLinksModal.id:', externalLinksModal?.id);
  console.log('[Setup] externalLinksModal.className:', externalLinksModal?.className);
  console.log('[Setup] externalLinksModal.style.display (현재):', externalLinksModal?.style.display);
  console.log('[Setup] externalLinksModal.getAttribute(aria-hidden):', externalLinksModal?.getAttribute('aria-hidden'));

  console.log('[Setup] ===== CSS 스타일 확인 =====');
  if (settingsModal) {
    const computedStyle = window.getComputedStyle(settingsModal);
    console.log('[Setup] settingsModal computed style:');
    console.log('  display:', computedStyle.display);
    console.log('  visibility:', computedStyle.visibility);
    console.log('  opacity:', computedStyle.opacity);
    console.log('  z-index:', computedStyle.zIndex);
    console.log('  position:', computedStyle.position);
  }

  if (externalLinksModal) {
    const computedStyle = window.getComputedStyle(externalLinksModal);
    console.log('[Setup] externalLinksModal computed style:');
    console.log('  display:', computedStyle.display);
    console.log('  visibility:', computedStyle.visibility);
    console.log('  opacity:', computedStyle.opacity);
    console.log('  z-index:', computedStyle.zIndex);
    console.log('  position:', computedStyle.position);
  }

  // 환경설정 버튼
  if (settingsButton) {
    settingsButton.onclick = function (e) {
      console.log('[Button] ===== 환경설정 버튼 클릭 시작 =====');
      console.log('[Button] 이벤트 객체:', e);
      console.log('[Button] 이벤트 타입:', e.type);
      console.log('[Button] 이벤트 타겟:', e.target);
      console.log('[Button] 이벤트 currentTarget:', e.currentTarget);

      e.preventDefault();
      e.stopPropagation();

      console.log('[Button] preventDefault와 stopPropagation 완료');

      if (settingsModal) {
        console.log('[Button] settingsModal 찾음, 표시 시도');
        console.log('[Button] 설정 전 aria-hidden:', settingsModal.getAttribute('aria-hidden'));
        console.log('[Button] 설정 전 display:', settingsModal.style.display);

        settingsModal.setAttribute('aria-hidden', 'false');
        settingsModal.style.display = 'flex';

        console.log('[Button] 설정 후 aria-hidden:', settingsModal.getAttribute('aria-hidden'));
        console.log('[Button] 설정 후 display:', settingsModal.style.display);

        // 강제로 스타일 적용
        settingsModal.style.position = 'fixed';
        settingsModal.style.top = '0';
        settingsModal.style.left = '0';
        settingsModal.style.width = '100%';
        settingsModal.style.height = '100%';
        settingsModal.style.backgroundColor = 'rgba(0,0,0,0.5)';
        settingsModal.style.zIndex = '9999';

        console.log('[Button] 강제 스타일 적용 완료');
        console.log('[Button] 최종 computed style:');
        const computedStyle = window.getComputedStyle(settingsModal);
        console.log('  display:', computedStyle.display);
        console.log('  visibility:', computedStyle.visibility);
        console.log('  z-index:', computedStyle.zIndex);

        // 모달 내용도 확인
        const modalContent = settingsModal.querySelector('.modal-content') as HTMLElement;
        console.log('[Button] modal-content 존재:', !!modalContent);
        if (modalContent) {
          modalContent.style.backgroundColor = 'white';
          modalContent.style.borderRadius = '8px';
          modalContent.style.padding = '20px';
          modalContent.style.maxWidth = '500px';
          modalContent.style.width = '90%';
          modalContent.style.maxHeight = '80vh';
          modalContent.style.overflow = 'auto';
        }

        console.log('[Button] 환경설정 모달 표시 작업 완료');
      } else {
        console.error('[Button] settingsModal이 존재하지 않음');
      }
    };

    settingsButton.addEventListener('click', function (e) {
      console.log('[Button] 환경설정 버튼 클릭됨 (addEventListener)');
      console.log('[Button] addEventListener 이벤트 객체:', e);
    });

    console.log('[Setup] 환경설정 버튼 이벤트 리스너 연결됨');
  } else {
    console.debug('[Setup] settingsButton이 존재하지 않음 (레거시 - 무시 가능)');
  }

  // 외부유입 버튼
  if (externalLinksButton) {
    externalLinksButton.onclick = async function (e) {
      console.log('[Button] ===== 외부유입 버튼 클릭 시작 =====');
      console.log('[Button] 이벤트 객체:', e);
      console.log('[Button] 이벤트 타입:', e.type);
      console.log('[Button] 이벤트 타겟:', e.target);
      console.log('[Button] 이벤트 currentTarget:', e.currentTarget);

      e.preventDefault();
      e.stopPropagation();

      console.log('[Button] preventDefault와 stopPropagation 완료');

      try {
        const isPackaged = await window.api.isPackaged();
        console.log('[Button] isPackaged:', isPackaged);

        if (!isPackaged) {
          console.log('[Button] 개발 모드로 처리');
          if (externalLinksModal) {
            console.log('[Button] externalLinksModal 찾음, 표시 시도');
            console.log('[Button] 설정 전 aria-hidden:', externalLinksModal.getAttribute('aria-hidden'));
            console.log('[Button] 설정 전 display:', externalLinksModal.style.display);

            externalLinksModal.setAttribute('aria-hidden', 'false');
            externalLinksModal.style.display = 'flex';

            console.log('[Button] 설정 후 aria-hidden:', externalLinksModal.getAttribute('aria-hidden'));
            console.log('[Button] 설정 후 display:', externalLinksModal.style.display);

            // 강제로 스타일 적용
            externalLinksModal.style.position = 'fixed';
            externalLinksModal.style.top = '0';
            externalLinksModal.style.left = '0';
            externalLinksModal.style.width = '100%';
            externalLinksModal.style.height = '100%';
            externalLinksModal.style.backgroundColor = 'rgba(0,0,0,0.5)';
            externalLinksModal.style.zIndex = '9999';

            console.log('[Button] 강제 스타일 적용 완료');
            console.log('[Button] 최종 computed style:');
            const computedStyle = window.getComputedStyle(externalLinksModal);
            console.log('  display:', computedStyle.display);
            console.log('  visibility:', computedStyle.visibility);
            console.log('  z-index:', computedStyle.zIndex);

            // 모달 내용도 확인
            const modalContent = externalLinksModal.querySelector('.modal-content') as HTMLElement;
            console.log('[Button] modal-content 존재:', !!modalContent);
            if (modalContent) {
              modalContent.style.backgroundColor = 'white';
              modalContent.style.borderRadius = '8px';
              modalContent.style.padding = '20px';
              modalContent.style.maxWidth = '500px';
              modalContent.style.width = '90%';
              modalContent.style.maxHeight = '80vh';
              modalContent.style.overflow = 'auto';
            }

            console.log('[Button] 외부유입 모달 표시 작업 완료 (개발 모드)');
          } else {
            console.error('[Button] externalLinksModal이 존재하지 않음');
          }
          return;
        }

        // ✅ 배포 모드에서도 외부유입 모달 바로 표시 (라이선스 체크 완화)
        console.log('[Button] 배포 모드 - 외부유입 모달 표시');

        // 라이선스 확인은 로그만 남기고 모달은 항상 열기
        try {
          const licenseResult = await window.api.getLicense();
          console.log('[Button] 라이선스 결과:', licenseResult);

          if (licenseResult.license && licenseResult.license.expiresAt) {
            const expirationDate = new Date(licenseResult.license.expiresAt);
            console.log('[Button] 라이선스 만료일:', expirationDate.toLocaleDateString('ko-KR'));
          } else {
            console.log('[Button] 라이선스 정보 없음 - 기본 모드로 진행');
          }
        } catch (licenseError) {
          console.warn('[Button] 라이선스 확인 실패, 기본 모드로 진행:', licenseError);
        }

        // ✅ 외부유입 모달 항상 표시
        if (externalLinksModal) {
          externalLinksModal.setAttribute('aria-hidden', 'false');
          externalLinksModal.style.display = 'flex';
          console.log('[Button] 외부유입 모달 표시됨');
        } else {
          console.error('[Button] externalLinksModal이 존재하지 않음');
        }
      } catch (error) {
        console.error('[Button] 오류 발생:', error);
        alert('외부유입 모달을 여는 중 오류가 발생했습니다.');
      }
    };

    console.log('[Setup] 외부유입 버튼 이벤트 리스너 연결됨');
  } else {
    console.debug('[Setup] externalLinksButton이 존재하지 않음 (레거시 - 무시 가능)');
  }
}

// 여러 타이밍에 이벤트 리스너 연결 시도 (중복 방지)
// 첫 번째 DOMContentLoaded 리스너는 setupHeaderButtons만 담당
// 중복 방지 플래그를 사용하지 않고, 두 번째 리스너보다 먼저 실행되도록 함
document.addEventListener('DOMContentLoaded', () => {
  console.log('[DOMContentLoaded] 헤더 버튼 초기화 시작');

  // 헤더 버튼 설정만 담당 (다른 초기화와 충돌 없음)
  setTimeout(() => {
    setupHeaderButtons();
    console.log('[DOMContentLoaded] 헤더 버튼 초기화 완료');
  }, 50); // 두 번째 리스너보다 먼저 실행 (50ms vs 100ms)
});

// window.load와 즉시 실행은 제거 - initializeApplication에서 한 번만 실행

// 이벤트 위임 방식도 추가 (입력 필드는 제외)
document.addEventListener('click', (e) => {
  const target = e.target as HTMLElement;

  // ✅ 입력 필드나 텍스트 영역은 이벤트 위임에서 제외
  if (target.tagName === 'INPUT' ||
    target.tagName === 'TEXTAREA' ||
    target.tagName === 'SELECT' ||
    target.closest('input, textarea, select')) {
    return; // 입력 필드는 기본 동작 유지
  }

  console.log('[Delegate] 문서 클릭 감지, 타겟:', target.id || target.tagName);

  if (target.id === 'settings-button-fixed') {
    console.log('[Delegate] ===== 환경설정 버튼 클릭 감지 (위임) =====');
    console.log('[Delegate] 이벤트 객체:', e);
    console.log('[Delegate] 이벤트 타겟:', e.target);
    console.log('[Delegate] 이벤트 currentTarget:', e.currentTarget);

    e.preventDefault();
    e.stopPropagation();

    const modal = document.getElementById('settings-modal') as HTMLDivElement;
    console.log('[Delegate] settings-modal 찾음:', !!modal);

    if (modal) {
      console.log('[Delegate] 모달 표시 시도');
      console.log('[Delegate] 설정 전 aria-hidden:', modal.getAttribute('aria-hidden'));
      console.log('[Delegate] 설정 전 display:', modal.style.display);

      modal.setAttribute('aria-hidden', 'false');
      modal.style.display = 'flex';

      // 강제 스타일 적용 (위임 방식)
      modal.style.position = 'fixed !important';
      modal.style.top = '0 !important';
      modal.style.left = '0 !important';
      modal.style.width = '100% !important';
      modal.style.height = '100% !important';
      modal.style.backgroundColor = 'rgba(0,0,0,0.8) !important';
      modal.style.zIndex = '10000 !important';

      console.log('[Delegate] 설정 후 aria-hidden:', modal.getAttribute('aria-hidden'));
      console.log('[Delegate] 설정 후 display:', modal.style.display);
      console.log('[Delegate] 환경설정 모달 표시됨 (위임)');
    } else {
      console.error('[Delegate] settings-modal이 존재하지 않음');
    }
  }

  if (target.id === 'external-links-button-fixed') {
    console.log('[Delegate] ===== 외부유입 버튼 클릭 감지 (위임) =====');
    console.log('[Delegate] 이벤트 객체:', e);

    e.preventDefault();
    e.stopPropagation();

    const modal = document.getElementById('external-links-modal') as HTMLDivElement;
    console.log('[Delegate] external-links-modal 찾음:', !!modal);

    if (modal) {
      modal.setAttribute('aria-hidden', 'false');
      modal.style.display = 'flex';

      // 강제 스타일 적용 (위임 방식)
      modal.style.position = 'fixed !important';
      modal.style.top = '0 !important';
      modal.style.left = '0 !important';
      modal.style.width = '100% !important';
      modal.style.height = '100% !important';
      modal.style.backgroundColor = 'rgba(0,0,0,0.8) !important';
      modal.style.zIndex = '10000 !important';

      console.log('[Delegate] 외부유입 모달 표시됨 (위임)');
    } else {
      console.error('[Delegate] external-links-modal이 존재하지 않음');
    }
  }

  // API 키 발급 가이드 버튼 처리 - 위임 로직 제거 (initApiGuideModal에서 통합 관리)


  // 외부유입 링크 처리 - 브라우저에서 열기
  if (target.classList.contains('external-link-item') || target.classList.contains('external-link-btn')) {
    console.log('[Delegate] 외부 링크 버튼 클릭 감지');
    e.preventDefault();
    e.stopPropagation();

    const url = (target as HTMLElement).getAttribute('data-url');
    if (url) {
      console.log('[Delegate] 외부 브라우저에서 링크 열기:', url);
      window.api.openExternalUrl(url);
    } else {
      console.error('[Delegate] data-url 속성이 없음');
    }
  }

  // 닫기 버튼 처리
  if (target.classList.contains('modal-close') || target.hasAttribute('data-close-settings') || target.hasAttribute('data-close-external-links') || target.hasAttribute('data-close-license') || target.hasAttribute('data-close-continuous')) {
    console.log('[Delegate] 모달 닫기 버튼 클릭 감지');
    const modal = target.closest('.modal-backdrop') as HTMLDivElement;
    if (modal) {
      modal.setAttribute('aria-hidden', 'true');
      modal.style.display = 'none';
      console.log('[Delegate] 모달 닫힘');
    }
  }
});

// 외부유입 탭 전환 함수
function switchExternalLinksTab(tabName: string) {
  console.log('[Tab] 외부유입 탭 전환:', tabName);

  // 모든 탭 버튼에서 active 제거
  const tabButtons = document.querySelectorAll('.external-links-tabs .tab-btn');
  tabButtons.forEach(btn => {
    btn.classList.remove('active');
    (btn as HTMLElement).style.background = 'var(--bg-tertiary)';
    (btn as HTMLElement).style.color = 'var(--text-strong)';
    (btn as HTMLElement).style.borderBottom = 'none';
  });

  // 선택된 탭 버튼 활성화
  const activeButton = document.querySelector(`.tab-btn[data-tab="${tabName}"]`) as HTMLElement;
  if (activeButton) {
    activeButton.classList.add('active');
    activeButton.style.background = 'var(--primary)';
    activeButton.style.color = 'white';
  }

  // 모든 탭 내용 숨김
  const tabContents = document.querySelectorAll('.links-container .tab-content');
  tabContents.forEach(content => {
    (content as HTMLElement).style.display = 'none';
  });

  // 선택된 탭 내용 표시
  const activeContent = document.getElementById(`${tabName}-content`) as HTMLElement;
  if (activeContent) {
    activeContent.style.display = 'block';
    console.log('[Tab] 탭 내용 표시됨:', tabName);
  }
}

// 연속 발행 기능 함수들
function startContinuousMode(urls: string[]): void {
  console.log('[Continuous] startContinuousMode 호출됨');
  console.log('[Continuous] 입력받은 URL들:', urls);

  if (urls.length === 0) {
    console.log('[Continuous] URL이 없어서 중단');
    appendLog('❌ 연속 발행할 URL이 없습니다.');
    return;
  }

  console.log('[Continuous] 연속 발행 모드 시작 준비');
  isContinuousMode = true;
  continuousQueue = [...urls];
  console.log('[Continuous] 큐에 저장된 URL들:', continuousQueue);
  appendLog(`🚀 연속 발행 모드 시작: ${urls.length}개 포스팅`);

  // ✅ [2026-01-20] 연속발행 프리셋 썸네일 적용
  const continuousPreset = applyPresetThumbnailIfExists('continuous');
  if (continuousPreset.applied) {
    // 전역 변수에 프리셋 썸네일 저장 (발행 시 사용)
    (window as any).continuousPresetThumbnail = continuousPreset.forHeading;
    (window as any).continuousPresetThumbnailPath = continuousPreset.forThumbnail;
    appendLog('🎨 미리 세팅된 썸네일이 연속발행에 적용됩니다!');
  }

  console.log('[Continuous] processNextInQueue 호출');
  processNextInQueue();
}

function processNextInQueue(): void {
  if (!isContinuousMode) return;

  let item: any = continuousQueueV2.find(i => i.status === 'pending');
  if (!item && continuousQueue.length > 0) {
    // ✅ 현재 UI에서 선택된 발행 모드 가져오기 (버그 수정: 'publish' 하드코딩 → 실제 선택값)
    const currentPublishMode = (document.getElementById('unified-publish-mode') as HTMLInputElement)?.value || 'publish';
    const currentScheduleDate = (document.getElementById('unified-schedule-date') as HTMLInputElement)?.value;
    item = {
      type: 'url',
      value: continuousQueue[0],
      status: 'pending',
      publishMode: currentPublishMode,
      scheduleDate: currentPublishMode === 'schedule' ? currentScheduleDate : undefined
    };
  }

  if (!item) {
    console.log('[Continuous] 모든 포스팅 완료');
    appendLog('✅ 모든 포스팅 발행 완료!');
    stopContinuousMode('complete');
    return;
  }

  // V1 처리용 (큐에서 제거)
  if (continuousQueue.length > 0 && item.value === continuousQueue[0]) {
    continuousQueue.shift();
  } else {
    // V2 처리용 (상태 변경)
    item.status = 'processing';
    renderQueueListV2();
  }

  const nextUrl = item.value;
  console.log('[Continuous] 다음 포스팅 처리 시작:', nextUrl, `(${item.publishMode})`);
  appendLog(`📝 다음 포스팅 처리: ${nextUrl} (${item.publishMode})`);

  // ✅ UI 동기화 (발행 모드 및 예약 설정)
  try {
    // 1. URL 입력
    const urlInputs = document.querySelectorAll('.unified-url-input') as NodeListOf<HTMLInputElement>;
    urlInputs.forEach(input => {
      input.value = nextUrl;
      input.dispatchEvent(new Event('input', { bubbles: true }));
      input.dispatchEvent(new Event('change', { bubbles: true }));
    });

    // 2. 발행 모드 동기화
    const modeBtn = document.querySelector(`.publish-mode-btn[data-mode="${item.publishMode}"]`) as HTMLElement;
    if (modeBtn) {
      modeBtn.click();
    }

    // 3. 예약 날짜/시간 동기화
    if (item.publishMode === 'schedule' && item.scheduleDate) {
      const dateInput = document.getElementById('unified-schedule-date') as HTMLInputElement;
      if (dateInput) {
        dateInput.value = item.scheduleDate;
        dateInput.dispatchEvent(new Event('change', { bubbles: true }));
      }

      const scheduleTypeInput = document.getElementById('unified-schedule-type') as HTMLInputElement;
      if (scheduleTypeInput) scheduleTypeInput.value = item.scheduleType || 'naver-server';
    }

    // 4. 이미지 소스 동기화 (있는 경우)
    if (item.imageSource) {
      const imgSourceSelect = document.getElementById('unified-image-source') as HTMLSelectElement;
      if (imgSourceSelect) {
        imgSourceSelect.value = item.imageSource;
        imgSourceSelect.dispatchEvent(new Event('change', { bubbles: true }));
      }
    }
  } catch (e) {
    console.warn('[Continuous] UI 동기화 중 오류 (무시 가능):', e);
  }

  // 풀오토 발행 자동 시작 (약간의 지연)
  console.log('[Continuous] 1.5초 후 풀오토 발행 시작');
  setTimeout(() => {
    const fullAutoPublishBtn = document.getElementById('full-auto-publish-btn') as HTMLButtonElement | null;
    if (fullAutoPublishBtn) {
      console.log('[Continuous] 풀오토 발행 실행 버튼 클릭!');
      fullAutoPublishBtn.click();
    } else {
      console.log('[Continuous] 풀오토 발행 실행 버튼을 찾을 수 없음');
      toastManager.error('발행 버튼을 찾을 수 없어 중단되었습니다.');
      stopContinuousMode();
    }
  }, 1500);
}

function stopContinuousMode(reason: 'manual' | 'complete' = 'manual'): void {
  console.log(`[Continuous] stopContinuousMode 호출됨 (사유: ${reason})`);

  // ✅ [2026-01-21] 이미지 생성 락 즉시 해제 - 중단 후 재시작 시 락 충돌 방지
  clearImageGenerationLocks();

  isContinuousMode = false;

  // ✅ [FIX] 전역 중지 플래그 설정 - 진행 중인 모든 발행 중지
  (window as any).stopFullAutoPublish = true;
  (window as any).stopBatchPublish = true;

  // ✅ [FIX] 현재 진행 중인 자동화 작업 취소
  try {
    window.api.cancelAutomation().catch((err: any) => {
      console.warn('[Continuous] 자동화 취소 중 오류 (무시 가능):', err);
    });
  } catch (e) {
    console.warn('[Continuous] cancelAutomation 호출 실패:', e);
  }

  // ✅ [FIX] 중지 시 큐를 초기화하지 않음 - 대기 중인 항목은 유지
  // continuousQueue = [];
  // continuousQueueV2 = [];

  // ✅ [FIX] 진행 중(processing)이던 항목을 'cancelled' 상태로 변경
  continuousQueueV2.forEach(item => {
    if (item.status === 'processing') {
      item.status = 'cancelled'; // cancelled 상태로 변경
    }
  });

  currentQueuePageV2 = 0;

  // UI 요소 복구
  const startBtn = document.getElementById('continuous-start-btn');
  const stopBtn = document.getElementById('continuous-stop-btn');
  const statusIndicator = document.getElementById('continuous-status-indicator');
  const statusText = document.getElementById('continuous-status-text');

  if (startBtn) (startBtn as HTMLElement).style.display = 'flex';
  if (stopBtn) (stopBtn as HTMLElement).style.display = 'none';

  // ✅ 상태 표시 업데이트
  if (statusIndicator) {
    statusIndicator.style.background = reason === 'complete' ? '#22c55e' : 'var(--text-muted)';
  }
  if (statusText) {
    statusText.textContent = reason === 'complete' ? '발행 완료' : '중지됨';
  }

  // 진행 모달 닫기
  const progressModal = document.getElementById('continuous-progress-modal');
  if (progressModal) progressModal.style.display = 'none';

  if (continuousInterval) {
    clearInterval(continuousInterval);
    continuousInterval = null;
  }
  continuousCountdown = 0;

  const countdownElement = document.getElementById('continuous-countdown');
  if (countdownElement) {
    countdownElement.style.display = 'none';
  }

  if (reason === 'complete') {
    appendLog('✅ 모든 연속 발행 작업이 완료되었습니다.');
    toastManager.success('✅ 모든 발행이 완료되었습니다!');
  } else {
    appendLog('⏹️ 연속 발행 모드 중단됨');
    toastManager.info('🛑 연속 발행이 중지되었습니다.');
  }

  renderQueueListV2(); // 큐 리스트 갱신
}

function scheduleNextPosting(): void {
  console.log('[Continuous] scheduleNextPosting 호출됨');
  if (!isContinuousMode) {
    console.log('[Continuous] 연속 모드가 아니어서 중단');
    return;
  }

  // ✅ 사용자 설정 시간 가져오기 (기본값 15초)
  const intervalInput = document.getElementById('continuous-interval-seconds') as HTMLInputElement;
  const userInterval = intervalInput ? parseInt(intervalInput.value) || 15 : 15;
  continuousCountdown = Math.max(5, Math.min(3600, userInterval)); // 5초 ~ 1시간 범위 제한

  console.log(`[Continuous] ${continuousCountdown}초 카운트다운 시작 (사용자 설정)`);
  appendLog(`⏰ 다음 포스팅까지 ${continuousCountdown}초 대기...`);

  const countdownElement = document.getElementById('continuous-countdown');
  console.log('[Continuous] 카운트다운 엘리먼트 찾음:', countdownElement ? '있음' : '없음');

  if (countdownElement) {
    countdownElement.style.display = 'block';
    countdownElement.textContent = `다음 포스팅까지 ${continuousCountdown}초 남음`;
    console.log('[Continuous] 카운트다운 표시 시작');
  }

  if (continuousInterval) {
    console.log('[Continuous] 기존 인터벌 정리');
    clearInterval(continuousInterval);
  }

  continuousInterval = setInterval(() => {
    continuousCountdown--;
    console.log('[Continuous] 카운트다운:', continuousCountdown);

    if (countdownElement) {
      countdownElement.textContent = `다음 포스팅까지 ${continuousCountdown}초 남음`;
    }

    if (continuousCountdown <= 0) {
      console.log('[Continuous] 카운트다운 완료, 다음 포스팅 처리');
      if (continuousInterval) {
        clearInterval(continuousInterval);
        continuousInterval = null;
      }
      if (countdownElement) {
        countdownElement.style.display = 'none';
        console.log('[Continuous] 카운트다운 표시 숨김');
      }
      processNextInQueue();
    }
  }, 1000);
}

// 연속 발행 URL 입력 모달 토글
function toggleContinuousModeModal(): void {
  console.log('[Continuous] toggleContinuousModeModal 호출됨');
  const modal = document.getElementById('continuous-mode-modal');
  console.log('[Continuous] 모달 엘리먼트 찾음:', modal ? '있음' : '없음');

  if (modal) {
    const currentDisplay = modal.style.display;
    const newDisplay = currentDisplay === 'none' ? 'flex' : 'none';
    console.log('[Continuous] 모달 표시 상태 변경:', currentDisplay, '->', newDisplay);
    modal.style.display = newDisplay;

    // 모달 열 때 초기화
    if (newDisplay === 'flex') {
      console.log('[Continuous] 모달 열림, V2 초기화');
      initContinuousPublishingV2();
    }
  } else {
    console.log('[Continuous] 모달 엘리먼트를 찾을 수 없음');
  }
}

// 연속 발행 URL 필드 관리
function initContinuousUrlFields(): void {
  const addBtn = document.getElementById('continuous-add-url-field-btn') as HTMLButtonElement;
  const container = document.getElementById('continuous-url-fields-container') as HTMLDivElement;

  if (addBtn && container) {
    addBtn.addEventListener('click', () => {
      const urlItems = container.querySelectorAll('.continuous-url-field-item');
      const newIndex = urlItems.length;

      const newItem = document.createElement('div');
      newItem.className = 'continuous-url-field-item';
      newItem.style.cssText = 'display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem;';
      newItem.innerHTML = `
        <input type="url" class="continuous-url-field-input" placeholder="https://example.com/article${newIndex + 1}" style="flex: 1; background: var(--bg-secondary); border: 1px solid var(--border-medium); border-radius: 8px; color: var(--text-strong); padding: 0.75rem;" data-url-index="${newIndex}">
        <button type="button" class="continuous-url-field-remove" style="padding: 0.25rem 0.5rem; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer;" title="삭제">×</button>
      `;

      container.appendChild(newItem);
      updateContinuousUrlFieldRemoveButtons();

      // 새로 추가된 입력 필드에 포커스
      const newInput = newItem.querySelector('.continuous-url-field-input') as HTMLInputElement;
      if (newInput) {
        setTimeout(() => newInput.focus(), 100);
      }
    });
  }

  // 이벤트 위임으로 삭제 버튼 처리
  container.addEventListener('click', (e) => {
    const target = e.target as HTMLElement;
    if (target.classList.contains('continuous-url-field-remove')) {
      const urlItems = container.querySelectorAll('.continuous-url-field-item');
      if (urlItems.length > 1) {
        target.closest('.continuous-url-field-item')?.remove();
        updateContinuousUrlFieldRemoveButtons();
      }
    }
  });

  // ✅ 연속발행 예약 발행 모드 이벤트 처리
  initContinuousScheduleEvents();

  // ✅ 키워드 필드 추가 버튼
  initContinuousKeywordFields();
}

// ✅ 연속발행 키워드 필드 관리
function initContinuousKeywordFields(): void {
  const addBtn = document.getElementById('continuous-add-keyword-field-btn') as HTMLButtonElement;
  const container = document.getElementById('continuous-keyword-fields-container') as HTMLDivElement;

  if (addBtn && container) {
    addBtn.addEventListener('click', () => {
      const keywordItems = container.querySelectorAll('.continuous-keyword-field-item');
      const newIndex = keywordItems.length;

      const newItem = document.createElement('div');
      newItem.className = 'continuous-keyword-field-item';
      newItem.style.cssText = 'display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem;';
      newItem.innerHTML = `
        <input type="text" class="continuous-keyword-field-input" placeholder="키워드 입력 ${newIndex + 1}" style="flex: 1; background: var(--bg-secondary); border: 1px solid var(--border-medium); border-radius: 8px; color: var(--text-strong); padding: 0.75rem;" data-keyword-index="${newIndex}">
        <button type="button" class="continuous-keyword-field-remove" style="padding: 0.25rem 0.5rem; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer;" title="삭제">×</button>
      `;

      container.appendChild(newItem);
      updateContinuousKeywordFieldRemoveButtons();

      const newInput = newItem.querySelector('.continuous-keyword-field-input') as HTMLInputElement;
      if (newInput) {
        setTimeout(() => newInput.focus(), 100);
      }
    });
  }

  // 이벤트 위임으로 삭제 버튼 처리
  if (container) {
    container.addEventListener('click', (e) => {
      const target = e.target as HTMLElement;
      if (target.classList.contains('continuous-keyword-field-remove')) {
        const keywordItems = container.querySelectorAll('.continuous-keyword-field-item');
        if (keywordItems.length > 1) {
          target.closest('.continuous-keyword-field-item')?.remove();
          updateContinuousKeywordFieldRemoveButtons();
        }
      }
    });
  }
}

function updateContinuousKeywordFieldRemoveButtons(): void {
  const container = document.getElementById('continuous-keyword-fields-container') as HTMLDivElement;
  const keywordItems = container?.querySelectorAll('.continuous-keyword-field-item');

  if (keywordItems) {
    keywordItems.forEach((item, index) => {
      const removeBtn = item.querySelector('.continuous-keyword-field-remove') as HTMLButtonElement;
      if (removeBtn) {
        removeBtn.style.display = index === 0 ? 'none' : 'inline-block';
      }
    });
  }
}

// ✅ 연속발행 제목 필드 관리
function initContinuousTitleFields(): void {
  return;
}

function updateContinuousTitleFieldRemoveButtons(): void {
  return;
}

// ✅ 연속발행 예약 발행 이벤트 초기화
function initContinuousScheduleEvents(): void {
  const publishModeRadios = document.querySelectorAll('input[name="continuous-publish-mode"]') as NodeListOf<HTMLInputElement>;
  const scheduleContainer = document.getElementById('continuous-schedule-container');
  const scheduleInput = document.getElementById('continuous-schedule-date') as HTMLInputElement;
  const schedulePreview = document.getElementById('continuous-schedule-preview');
  const confirmBtn = document.getElementById('continuous-schedule-confirm-btn') as HTMLButtonElement;

  // 발행 모드 변경 시 예약 컨테이너 표시/숨김
  publishModeRadios.forEach(radio => {
    radio.addEventListener('change', () => {
      if (scheduleContainer) {
        if (radio.value === 'schedule' && radio.checked) {
          scheduleContainer.style.display = 'block';

          // 최소 예약 시간 설정 (현재 시간 + 5분)
          if (scheduleInput) {
            const now = new Date();
            const minDate = new Date(now.getTime() + 5 * 60000); // 5분 후
            const year = minDate.getFullYear();
            const month = String(minDate.getMonth() + 1).padStart(2, '0');
            const day = String(minDate.getDate()).padStart(2, '0');
            const hours = String(minDate.getHours()).padStart(2, '0');
            const minutes = String(minDate.getMinutes()).padStart(2, '0');
            const formattedDateTime = `${year}-${month}-${day}T${hours}:${minutes}`;
            scheduleInput.min = formattedDateTime;
            scheduleInput.value = formattedDateTime;

            // 달력 자동 열기
            setTimeout(() => {
              scheduleInput.showPicker?.();
            }, 200);
          }
        } else if (radio.value !== 'schedule') {
          scheduleContainer.style.display = 'none';
        }
      }
    });
  });

  // 날짜/시간 선택 시 미리보기 및 확인 버튼 활성화
  if (scheduleInput) {
    scheduleInput.addEventListener('change', () => {
      if (scheduleInput.value) {
        const selectedDate = new Date(scheduleInput.value);
        const formattedDate = selectedDate.toLocaleString('ko-KR', {
          year: 'numeric',
          month: 'long',
          day: 'numeric',
          weekday: 'short',
          hour: '2-digit',
          minute: '2-digit',
        });

        // 미리보기 표시
        if (schedulePreview) {
          schedulePreview.innerHTML = `📅 첫 글: <strong>${formattedDate}</strong><br>💡 이후 글은 30분 간격`;
          schedulePreview.style.display = 'block';
        }

        // 확인 버튼 활성화
        if (confirmBtn) {
          confirmBtn.disabled = false;
          confirmBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
          confirmBtn.style.cursor = 'pointer';
          confirmBtn.innerHTML = `
            <span style="display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
              <span>✅</span>
              <span>예약 설정 완료</span>
            </span>
          `;
        }
      } else {
        // 값이 없으면 비활성화
        if (schedulePreview) {
          schedulePreview.style.display = 'none';
        }
        if (confirmBtn) {
          confirmBtn.disabled = true;
          confirmBtn.style.background = 'linear-gradient(135deg, #9ca3af, #6b7280)';
          confirmBtn.style.cursor = 'not-allowed';
          confirmBtn.innerHTML = `
            <span style="display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
              <span>⏰</span>
              <span>날짜와 시간을 선택하세요</span>
            </span>
          `;
        }
      }
    });
  }

  // 확인 버튼 클릭 시
  if (confirmBtn) {
    confirmBtn.addEventListener('click', () => {
      if (scheduleInput?.value) {
        const selectedDate = new Date(scheduleInput.value);
        const formattedDate = selectedDate.toLocaleString('ko-KR', {
          year: 'numeric',
          month: 'long',
          day: 'numeric',
          weekday: 'short',
          hour: '2-digit',
          minute: '2-digit',
        });

        toastManager.success(`✅ 예약 설정 완료! 첫 글: ${formattedDate}`);

        // 버튼 상태 변경 (설정 완료 표시)
        confirmBtn.innerHTML = `
          <span style="display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
            <span>🎉</span>
            <span>예약 완료! (${selectedDate.getMonth() + 1}/${selectedDate.getDate()} ${String(selectedDate.getHours()).padStart(2, '0')}:${String(selectedDate.getMinutes()).padStart(2, '0')})</span>
          </span>
        `;
        confirmBtn.style.background = 'linear-gradient(135deg, #3b82f6, #2563eb)';
      }
    });
  }
}

function updateContinuousUrlFieldRemoveButtons(): void {
  const container = document.getElementById('continuous-url-fields-container') as HTMLDivElement;
  const urlItems = container?.querySelectorAll('.continuous-url-field-item');

  if (urlItems) {
    urlItems.forEach((item, index) => {
      const removeBtn = item.querySelector('.continuous-url-field-remove') as HTMLButtonElement;
      if (removeBtn) {
        // 첫 번째 항목은 삭제 불가, 나머지는 삭제 가능
        removeBtn.style.display = index === 0 ? 'none' : 'inline-block';
      }
    });
  }
}

function getContinuousUrls(): string[] {
  const container = document.getElementById('continuous-url-fields-container') as HTMLDivElement;
  if (!container) return [];

  const urlInputs = container.querySelectorAll('.continuous-url-field-input') as NodeListOf<HTMLInputElement>;
  return Array.from(urlInputs)
    .map(input => input.value.trim())
    .filter(url => url.length > 0 && /^https?:\/\//i.test(url));
}

// 연속 발행 시작
function startContinuousPublishing(): void {
  console.log('[Continuous] startContinuousPublishing 시작');
  startContinuousPublishingV2().catch((error) => {
    appendLog(`❌ 연속 발행 시작 실패: ${(error as Error).message}`);
  });
}

// ✅ 연속 발행 키워드 수집 (개별 필드 방식)
function getContinuousKeywords(): string[] {
  const container = document.getElementById('continuous-keyword-fields-container') as HTMLDivElement;
  if (!container) return [];

  const keywordInputs = container.querySelectorAll('.continuous-keyword-field-input') as NodeListOf<HTMLInputElement>;
  return Array.from(keywordInputs)
    .map(input => input.value.trim())
    .filter(keyword => keyword.length > 0);
}

// ✅ 연속 발행 제목 수집 (개별 필드 방식)
function getContinuousTitles(): string[] {
  return [];
}

// ✅ 향상된 연속 발행 모드 V2
interface ContinuousQueueItem {
  id: string;
  type: 'url' | 'keyword';
  value: string;
  additionalUrls?: string[]; // ✅ [2026-01-21] 다중 URL 지원 - 추가 소스 URL 목록
  customTitle?: string;
  customKeyword?: string;
  imageSource: string;
  interval: number;
  publishMode: 'publish' | 'draft' | 'schedule';
  scheduleDate?: string;
  scheduleTime?: string;  // ✅ 예약 시간 (HH:mm) 추가
  scheduleType?: 'app-schedule' | 'naver-server';
  status: 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled';
  ctaType?: string;
  ctaUrl?: string;
  ctaText?: string;
  category?: string;  // ✅ 카테고리 (entertainment, health, etc.)
  contentMode?: 'seo' | 'homefeed' | 'affiliate' | 'custom';  // ✅ 4가지 콘텐츠 모드
  toneStyle?: string; // ✅ 글톤 추가
  realCategory?: string; // ✅ 실제 블로그 카테고리 추가
  realCategoryName?: string; // ✅ 실제 블로그 카테고리 이름 추가
  includeThumbnailText?: boolean; // ✅ 썸네일 텍스트 포함 여부 (AI 필드)
  useAiImage?: boolean; // ✅ AI 이미지 생성 사용 여부
  createProductThumbnail?: boolean; // ✅ 제품 이미지 기반 썸네일 합성 여부
  affiliateLink?: string; // ✅ 쇼핑 커넥트 제휴 링크
  videoOption?: boolean; // ✅ VEO 영상 변환 옵션
}

let continuousQueueV2: ContinuousQueueItem[] = [];
let continuousPublishQueue: Array<{ type: 'url' | 'keyword'; value: string; publishMode: string; scheduleDate?: string; toneStyle?: string }> = [];

// ✅ [2026-01-25 모듈화] applyKeywordPrefixToTitle → ./utils/titleUtils.js로 이동됨
// 기존 호출 호환성을 위한 래퍼 함수
function applyKeywordPrefixToTitleContinuous(title: string, keyword: string): string {
  return applyKeywordPrefixToTitle(title, keyword);
}

function applyContinuousTitleOverrides(item: ContinuousQueueItem, structuredContent: any): void {
  if (!structuredContent) return;

  const keyword = (item.customKeyword || '').trim();
  const requestedTitle = (item.customTitle || '').trim();
  const currentTitle = String(structuredContent.selectedTitle || '').trim();

  let finalTitle = currentTitle;

  if (requestedTitle) {
    finalTitle = requestedTitle;
  }

  if (keyword) {
    finalTitle = applyKeywordPrefixToTitleContinuous(finalTitle, keyword);
  }

  if (!finalTitle) return;

  structuredContent.selectedTitle = finalTitle;
  if (Array.isArray(structuredContent.titleAlternatives) && structuredContent.titleAlternatives.length > 0) {
    structuredContent.titleAlternatives = structuredContent.titleAlternatives.map((t: string) => applyKeywordPrefixToTitleContinuous(String(t || ''), keyword || '')).filter(Boolean);
  }
  if (Array.isArray(structuredContent.titleCandidates) && structuredContent.titleCandidates.length > 0) {
    structuredContent.titleCandidates = structuredContent.titleCandidates.map((c: any) => ({
      ...c,
      text: applyKeywordPrefixToTitleContinuous(String(c?.text || ''), keyword || ''),
    }));
  }

  const titleInput = document.getElementById('unified-generated-title') as HTMLInputElement;
  if (titleInput) {
    titleInput.value = finalTitle;
    titleInput.readOnly = false;
  }

  (window as any).currentStructuredContent = structuredContent;
  updateUnifiedPreview(structuredContent);
}

// ✅ 연속 발행 V2 초기화
function initContinuousPublishingV2(): void {
  if (__continuousV2Initialized) {
    console.log('[Continuous] V2 이미 초기화됨, 건너뜀');
    return;
  }
  __continuousV2Initialized = true;
  console.log('[Continuous] V2 초기화 시작');
  // 탭 전환 이벤트
  const tabs = document.querySelectorAll('.continuous-input-tab');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      const tabName = (tab as HTMLElement).dataset.tab;

      // 모든 탭 비활성화
      tabs.forEach(t => {
        (t as HTMLElement).style.background = 'transparent';
        (t as HTMLElement).style.color = 'var(--text-muted)';
        t.classList.remove('active');
      });

      // 선택한 탭 활성화
      (tab as HTMLElement).style.background = 'var(--primary)';
      (tab as HTMLElement).style.color = 'white';
      tab.classList.add('active');

      // 입력 섹션 전환
      document.querySelectorAll('.continuous-input-section').forEach(section => {
        (section as HTMLElement).style.display = 'none';
      });
      const activeSection = document.getElementById(`continuous-${tabName}-input-section`);
      if (activeSection) activeSection.style.display = 'block';
    });
  });

  // ✅ 상세 설정 모달 열기 버튼
  const openSettingsModalBtn = document.getElementById('continuous-open-settings-modal-btn');
  const settingsModal = document.getElementById('continuous-settings-modal');

  if (openSettingsModalBtn && settingsModal) {
    // 모달 열기
    // ✅ [NEW] 연속발행 설정 동기화 함수
    function syncContinuousSettings(source: 'main' | 'modal') {
      const fields = [
        { main: 'continuous-content-mode-select', modal: 'continuous-modal-content-mode' },
        { main: 'continuous-tone-style-select', modal: 'continuous-modal-tone-style' },
        { main: 'continuous-image-source-select', modal: 'continuous-modal-image-source' },
        { main: 'continuous-cta-type', modal: 'continuous-modal-cta-type' },
        { main: 'continuous-cta-url', modal: 'continuous-modal-cta-url' },
        { main: 'continuous-cta-text', modal: 'continuous-modal-cta-text' },
        { main: 'continuous-interval-value', modal: 'continuous-modal-interval-value' },
        { main: 'continuous-interval-unit', modal: 'continuous-modal-interval-unit' },
        { main: 'continuous-include-thumbnail-text', modal: 'continuous-modal-include-thumbnail-text' }
      ];

      fields.forEach(f => {
        const mainEl = document.getElementById(f.main) as any;
        const modalEl = document.getElementById(f.modal) as any;
        if (!mainEl || !modalEl) return;

        if (source === 'main') {
          if (mainEl.type === 'checkbox') modalEl.checked = mainEl.checked;
          else modalEl.value = mainEl.value;
        } else {
          if (mainEl.type === 'checkbox') mainEl.checked = modalEl.checked;
          else mainEl.value = modalEl.value;
        }
      });

      // 카테고리 동기화 (Hidden input 및 텍스트)
      const mainCatInput = document.getElementById('continuous-category-select') as HTMLInputElement;
      const modalCatInput = document.getElementById('continuous-modal-category-select') as HTMLInputElement;
      const mainCatText = document.getElementById('continuous-category-text');
      const modalCatText = document.getElementById('continuous-modal-category-text');

      if (source === 'main' && mainCatInput && modalCatInput) {
        modalCatInput.value = mainCatInput.value;
        if (modalCatText) modalCatText.textContent = mainCatText?.textContent || '일반';
      } else if (source === 'modal' && mainCatInput && modalCatInput) {
        mainCatInput.value = modalCatInput.value;
        if (mainCatText) mainCatText.textContent = modalCatText?.textContent || '일반';
      }

      // 실제 블로그 카테고리 동기화
      const mainRealCat = document.getElementById('continuous-real-category-select') as HTMLSelectElement;
      const modalRealCat = document.getElementById('continuous-modal-real-category') as HTMLSelectElement;
      if (source === 'main' && mainRealCat && modalRealCat) {
        modalRealCat.innerHTML = mainRealCat.innerHTML;
        modalRealCat.value = mainRealCat.value;
        const container = document.getElementById('continuous-modal-real-category-container');
        if (container) container.style.display = mainRealCat.value ? 'block' : 'none';
      } else if (source === 'modal' && mainRealCat && modalRealCat) {
        mainRealCat.innerHTML = modalRealCat.innerHTML;
        mainRealCat.value = modalRealCat.value;
      }

      // 발행 모드 (라디오 버튼)
      if (source === 'main') {
        const checked = document.querySelector('input[name="continuous-publish-mode"]:checked') as HTMLInputElement;
        if (checked) {
          const modalRadio = document.querySelector(`input[name="continuous-modal-publish-mode"][value="${checked.value}"]`) as HTMLInputElement;
          if (modalRadio) modalRadio.checked = true;
          const modalSchedule = document.getElementById('continuous-modal-schedule-container');
          if (modalSchedule) modalSchedule.style.display = checked.value === 'schedule' ? 'block' : 'none';
        }
      } else {
        const checked = document.querySelector('input[name="continuous-modal-publish-mode"]:checked') as HTMLInputElement;
        if (checked) {
          const mainRadio = document.querySelector(`input[name="continuous-publish-mode"][value="${checked.value}"]`) as HTMLInputElement;
          if (mainRadio) mainRadio.checked = true;
        }
      }
    }

    // ✅ 메인 UI 이벤트 리스너 등록 (변경 시 모달로 동기화)
    ['continuous-content-mode-select', 'continuous-tone-style-select', 'continuous-image-source-select',
      'continuous-cta-type', 'continuous-cta-url', 'continuous-cta-text',
      'continuous-interval-value', 'continuous-interval-unit', 'continuous-include-thumbnail-text',
      'continuous-category-select'].forEach(id => {
        document.getElementById(id)?.addEventListener('change', () => syncContinuousSettings('main'));
      });
    document.querySelectorAll('input[name="continuous-publish-mode"]').forEach(el => {
      el.addEventListener('change', () => syncContinuousSettings('main'));
    });

    // 메인 UI 카테고리 버튼 리스너
    document.getElementById('continuous-category-btn')?.addEventListener('click', () => {
      (window as any).openCategoryModalInContinuousMode?.('main');
    });

    // ✅ [2026-01-19] 배너 커스터마이징 바로가기 버튼들 - 이벤트 위임 방식 (동적 버튼 지원)
    document.addEventListener('click', (e) => {
      const target = e.target as HTMLElement;
      const btn = target.closest('#continuous-open-banner-settings-btn, #fullauto-open-banner-settings-btn, #ma-open-banner-settings-btn, #ma-shopping-goto-banner-btn') as HTMLElement;

      if (!btn) return;

      const btnId = btn.id;
      console.log('[BannerNav] 배너 버튼 클릭됨:', btnId);

      // ✅ [2026-01-21] 모든 관련 모달 강제 닫기 (display + aria-hidden)
      const modalsToClose = ['continuous-mode-modal', 'ma-publish-modal', 'continuous-settings-modal', 'ma-account-edit-modal'];
      modalsToClose.forEach(modalId => {
        const modal = document.getElementById(modalId);
        if (modal) {
          modal.style.display = 'none';
          modal.setAttribute('aria-hidden', 'true');
        }
      });

      // 썸네일/배너 생성기 탭으로 이동
      const imageToolsTab = document.querySelector('[data-tab="image-tools"]') as HTMLElement;
      console.log('[BannerNav] imageToolsTab 찾기:', !!imageToolsTab);
      if (imageToolsTab) {
        imageToolsTab.click();

        // 쇼핑커넥트 배너 서브탭으로 이동
        setTimeout(() => {
          const bannerSubtab = document.querySelector('[data-subtab="shopping-banner"]') as HTMLElement;
          console.log('[BannerNav] bannerSubtab 찾기:', !!bannerSubtab);
          if (bannerSubtab) {
            bannerSubtab.click();
            toastManager.info('🎨 배너 설정 화면입니다.');
          }
        }, 150);
      }
    });

    // ✅ [2026-01-20] 수동 썸네일 커스터마이징 버튼들 - 이벤트 위임 방식
    document.addEventListener('click', (e) => {
      const target = e.target as HTMLElement;
      const btn = target.closest('#continuous-goto-thumbnail-btn, #ma-shopping-goto-thumbnail-btn, #fullauto-open-thumbnail-settings-btn, #ma-setting-goto-thumbnail-btn') as HTMLElement;

      if (!btn) return;

      const btnId = btn.id;
      console.log('[ThumbnailNav] 썸네일 버튼 클릭됨:', btnId);

      // ✅ [2026-01-21] 모든 관련 모달 강제 닫기 (display + aria-hidden)
      const modalsToClose = ['continuous-mode-modal', 'ma-publish-modal', 'continuous-settings-modal', 'ma-account-edit-modal'];
      modalsToClose.forEach(modalId => {
        const modal = document.getElementById(modalId);
        if (modal) {
          modal.style.display = 'none';
          modal.setAttribute('aria-hidden', 'true');
        }
      });

      // 썸네일/배너 생성기 탭으로 이동
      const imageToolsTab = document.querySelector('[data-tab="image-tools"]') as HTMLElement;
      console.log('[ThumbnailNav] imageToolsTab 찾기:', !!imageToolsTab);
      if (imageToolsTab) {
        imageToolsTab.click();

        // 썸네일 서브탭으로 이동 (기본 서브탭)
        setTimeout(() => {
          const thumbnailSubtab = document.querySelector('[data-subtab="thumbnail-generator"]') as HTMLElement;
          console.log('[ThumbnailNav] thumbnailSubtab 찾기:', !!thumbnailSubtab);
          if (thumbnailSubtab) {
            thumbnailSubtab.click();
            toastManager.info('🎨 썸네일 생성기 화면입니다.');
          }
        }, 150);
      }
    });

    openSettingsModalBtn.addEventListener('click', () => {
      // 편집 인덱스 초기화 (-1 = 새 항목용)
      const editingIndexInput = document.getElementById('continuous-settings-editing-index') as HTMLInputElement;
      if (editingIndexInput) editingIndexInput.value = '-1';

      const modal = document.getElementById('continuous-settings-modal');
      if (modal) {
        // 모달 제목 및 버튼 텍스트 원복
        const titleEl = modal.querySelector('h3');
        if (titleEl) titleEl.innerHTML = '⚙️ 상세 설정 (연속 발행)';
        const saveBtn = document.getElementById('continuous-settings-modal-save');
        if (saveBtn) saveBtn.innerHTML = '💾 설정 저장 및 닫기';
      }

      // ✅ 예약 날짜 기본값 설정 (오늘 날짜로)
      const scheduleDateInput = document.getElementById('continuous-modal-schedule-date') as HTMLInputElement;
      if (scheduleDateInput && !scheduleDateInput.value) {
        const today = new Date();
        const yyyy = today.getFullYear();
        const mm = String(today.getMonth() + 1).padStart(2, '0');
        const dd = String(today.getDate()).padStart(2, '0');
        scheduleDateInput.value = `${yyyy}-${mm}-${dd}`;
      }

      // 열 때 현재 메인 UI 값을 모달에 반영
      syncContinuousSettings('main');

      settingsModal.style.display = 'flex';
      settingsModal.setAttribute('aria-hidden', 'false');
    });

    // ✅ 발행 모드 라디오 버튼 변경 시 예약 컨테이너 토글
    document.querySelectorAll('input[name="continuous-modal-publish-mode"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        const target = e.target as HTMLInputElement;
        const scheduleContainer = document.getElementById('continuous-modal-schedule-container');
        if (scheduleContainer) {
          scheduleContainer.style.display = target.value === 'schedule' ? 'block' : 'none';
        }
      });
    });

    // ✅ [2026-01-20] 서브탭 전환 이벤트 핸들러
    document.querySelectorAll('.continuous-modal-subtab-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const subtab = (btn as HTMLElement).dataset.subtab;
        if (!subtab) return;

        // 모든 버튼 비활성화
        document.querySelectorAll('.continuous-modal-subtab-btn').forEach(b => {
          (b as HTMLElement).style.borderBottomColor = 'transparent';
          (b as HTMLElement).style.color = 'var(--text-muted)';
          b.classList.remove('active');
        });

        // 클릭한 버튼 활성화
        (btn as HTMLElement).style.borderBottomColor = 'var(--primary)';
        (btn as HTMLElement).style.color = 'var(--primary)';
        btn.classList.add('active');

        // 모든 서브탭 콘텐츠 숨기기
        document.querySelectorAll('.continuous-modal-subtab-content').forEach(c => {
          (c as HTMLElement).style.display = 'none';
        });

        // 선택한 서브탭 콘텐츠 표시
        const content = document.getElementById(`continuous-modal-subtab-${subtab}-content`);
        if (content) content.style.display = 'block';

        console.log(`[연속발행모달] 서브탭 전환: ${subtab}`);
      });
    });

    // ✅ [2026-01-20] 썸네일 커스터마이징 버튼 → 썸네일 생성기 탭으로 이동
    document.getElementById('continuous-modal-goto-thumbnail-btn')?.addEventListener('click', () => {
      const modal = document.getElementById('continuous-settings-modal');
      if (modal) modal.style.display = 'none';

      // 이미지 도구 탭으로 이동
      const imageToolsTab = document.querySelector('[data-tab="image-tools"]') as HTMLElement;
      if (imageToolsTab) {
        imageToolsTab.click();
        setTimeout(() => {
          const thumbnailSubtab = document.querySelector('[data-subtab="thumbnail"]') as HTMLElement;
          if (thumbnailSubtab) {
            thumbnailSubtab.click();
            toastManager.info('🎨 썸네일 커스터마이징 화면입니다. 설정 후 연속발행으로 돌아가세요.');
          }
        }, 150);
      }
    });

    // ✅ [2026-01-20] 배너 커스터마이징 버튼 → 배너 생성기 탭으로 이동
    document.getElementById('continuous-modal-goto-banner-btn')?.addEventListener('click', () => {
      const modal = document.getElementById('continuous-settings-modal');
      if (modal) modal.style.display = 'none';

      const imageToolsTab = document.querySelector('[data-tab="image-tools"]') as HTMLElement;
      if (imageToolsTab) {
        imageToolsTab.click();
        setTimeout(() => {
          const bannerSubtab = document.querySelector('[data-subtab="shopping-banner"]') as HTMLElement;
          if (bannerSubtab) {
            bannerSubtab.click();
            toastManager.info('🎨 배너 커스터마이징 화면입니다.');
          }
        }, 150);
      }
    });

    // ✅ [2026-01-20] 예약 설정 서브탭 - 간격 프리셋 버튼
    document.querySelectorAll('.schedule-interval-preset').forEach(btn => {
      btn.addEventListener('click', () => {
        const value = (btn as HTMLElement).dataset.value || '2';
        const unit = (btn as HTMLElement).dataset.unit || '60';
        const intervalInput = document.getElementById('continuous-modal-schedule-interval-subtab') as HTMLInputElement;
        const unitSelect = document.getElementById('continuous-modal-schedule-interval-unit-subtab') as HTMLSelectElement;
        if (intervalInput) intervalInput.value = value;
        if (unitSelect) unitSelect.value = unit;
      });
    });

    // ✅ [2026-01-20] 예약 설정 - 대기열 전체 순차 예약 적용 버튼
    document.getElementById('continuous-modal-apply-schedule-btn')?.addEventListener('click', () => {
      const dateInput = document.getElementById('continuous-modal-schedule-date-subtab') as HTMLInputElement;
      const timeInput = document.getElementById('continuous-modal-schedule-time-subtab') as HTMLInputElement;
      const intervalInput = document.getElementById('continuous-modal-schedule-interval-subtab') as HTMLInputElement;
      const unitSelect = document.getElementById('continuous-modal-schedule-interval-unit-subtab') as HTMLSelectElement;
      const randomOffsetCheck = document.getElementById('continuous-modal-schedule-random-offset-subtab') as HTMLInputElement;

      const intervalValue = parseInt(intervalInput?.value || '2', 10);
      const intervalUnit = parseInt(unitSelect?.value || '60', 10);
      const useRandomOffset = randomOffsetCheck?.checked ?? true;
      const intervalMinutes = intervalValue * intervalUnit;

      // ✅ [2026-01-20] 날짜 미선택 시 현재 시간부터 시작 (지금부터 자동 시작)
      let baseTime: Date;
      if (dateInput?.value) {
        const startTime = timeInput?.value || '09:00';
        baseTime = new Date(`${dateInput.value}T${startTime}`);
      } else {
        // 현재 시간부터 시작
        baseTime = new Date();
        console.log('[순차예약] 날짜 미선택 → 현재 시간부터 시작:', baseTime.toLocaleString());
      }

      // continuousQueueV2에 순차 예약 적용
      if (typeof continuousQueueV2 !== 'undefined' && continuousQueueV2.length > 0) {


        continuousQueueV2.forEach((item: any, i: number) => {
          const offsetMinutes = i * intervalMinutes;
          const randomOffset = useRandomOffset ? Math.floor(Math.random() * 31) - 15 : 0;
          const scheduledTime = new Date(baseTime.getTime() + (offsetMinutes + randomOffset) * 60000);

          const yyyy = scheduledTime.getFullYear();
          const mm = String(scheduledTime.getMonth() + 1).padStart(2, '0');
          const dd = String(scheduledTime.getDate()).padStart(2, '0');
          const hh = String(scheduledTime.getHours()).padStart(2, '0');
          const mi = String(scheduledTime.getMinutes()).padStart(2, '0');

          item.scheduleDate = `${yyyy}-${mm}-${dd}T${hh}:${mi}`;
          item.publishMode = 'schedule';
        });

        toastManager.success(`✅ ${continuousQueueV2.length}개 항목에 순차 예약이 적용되었습니다!`);
        renderQueueListV2?.();
      } else {
        toastManager.warning('📋 대기열에 항목이 없습니다. 먼저 항목을 추가해주세요.');
      }
    });

    // 모달 닫기 버튼
    document.getElementById('continuous-settings-modal-close')?.addEventListener('click', () => {
      settingsModal.style.display = 'none';
      settingsModal.setAttribute('aria-hidden', 'true');
    });

    document.getElementById('continuous-settings-modal-cancel')?.addEventListener('click', () => {
      settingsModal.style.display = 'none';
      settingsModal.setAttribute('aria-hidden', 'true');
    });

    // 모달 저장 버튼
    document.getElementById('continuous-settings-modal-save')?.addEventListener('click', () => {
      const editingIndexInput = document.getElementById('continuous-settings-editing-index') as HTMLInputElement;
      const editingIndex = parseInt(editingIndexInput?.value || '-1', 10);

      // 모달에서 설정값 읽기
      const categorySelect = document.getElementById('continuous-modal-category-select') as HTMLInputElement;
      const contentModeSelect = document.getElementById('continuous-modal-content-mode') as HTMLSelectElement;
      const toneStyleSelect = document.getElementById('continuous-modal-tone-style') as HTMLSelectElement;
      const imageSourceSelect = document.getElementById('continuous-modal-image-source') as HTMLSelectElement;
      const ctaTypeSelect = document.getElementById('continuous-modal-cta-type') as HTMLSelectElement;
      const ctaUrlInput = document.getElementById('continuous-modal-cta-url') as HTMLInputElement;
      const ctaTextInput = document.getElementById('continuous-modal-cta-text') as HTMLInputElement;
      const intervalValueInput = document.getElementById('continuous-modal-interval-value') as HTMLInputElement;
      const intervalUnitSelect = document.getElementById('continuous-modal-interval-unit') as HTMLSelectElement;
      const publishModeRadio = document.querySelector('input[name="continuous-modal-publish-mode"]:checked') as HTMLInputElement;
      const includeThumbnailTextCheck = document.getElementById('continuous-modal-include-thumbnail-text') as HTMLInputElement;
      const useAiImageCheck = document.getElementById('continuous-modal-use-ai-image') as HTMLInputElement;
      const createThumbnailCheck = document.getElementById('continuous-modal-create-product-thumbnail') as HTMLInputElement;

      if (editingIndex >= 0) {
        // ✅ [항목 수정 모드] 큐 항목 업데이트
        const item = continuousQueueV2[editingIndex];
        if (item) {
          const realCategorySelect = document.getElementById('continuous-modal-real-category') as HTMLSelectElement;
          const realCategory = realCategorySelect?.value || '';
          const realCategoryName = (realCategorySelect?.selectedIndex >= 0) ? realCategorySelect.options[realCategorySelect.selectedIndex].text : '';

          // 예약 날짜/시간
          let scheduleDate = item.scheduleDate;
          if (publishModeRadio?.value === 'schedule') {
            const dateVal = (document.getElementById('continuous-modal-schedule-date') as HTMLInputElement).value;
            const timeVal = (document.getElementById('continuous-modal-schedule-time') as HTMLInputElement).value;
            if (dateVal && timeVal) scheduleDate = `${dateVal}T${timeVal}`;
          }

          continuousQueueV2[editingIndex] = {
            ...item,
            category: categorySelect?.value || 'entertainment',
            contentMode: (contentModeSelect?.value || 'seo') as any,
            toneStyle: toneStyleSelect?.value || 'professional',
            imageSource: imageSourceSelect?.value || 'nano-banana-pro',
            ctaType: ctaTypeSelect?.value || 'none',
            ctaUrl: ctaUrlInput?.value || '',
            ctaText: ctaTextInput?.value || '',
            publishMode: (publishModeRadio?.value || 'publish') as any,
            interval: parseInt(intervalValueInput?.value || '30') * parseInt(intervalUnitSelect?.value || '1'),
            realCategory,
            realCategoryName,
            scheduleDate,
            includeThumbnailText: includeThumbnailTextCheck?.checked || false,
            useAiImage: useAiImageCheck?.checked ?? true,
            createProductThumbnail: createThumbnailCheck?.checked ?? false
          };
          renderQueueListV2();
          toastManager.success('✅ 항목이 수정되었습니다.');
        }
      } else {
        // ✅ [일반 설정 저장 모드] 메인 UI로 동기화
        syncContinuousSettings('modal');
        toastManager.success('✅ 설정이 저장되었습니다.');
      }

      settingsModal.style.display = 'none';
      settingsModal.setAttribute('aria-hidden', 'true');
    });

    // 발행 간격 프리셋 버튼
    document.querySelectorAll('.continuous-modal-interval-preset').forEach(btn => {
      btn.addEventListener('click', () => {
        const value = (btn as HTMLButtonElement).dataset.value || '30';
        const unit = (btn as HTMLButtonElement).dataset.unit || '1';
        const valueInput = document.getElementById('continuous-modal-interval-value') as HTMLInputElement;
        const unitSelect = document.getElementById('continuous-modal-interval-unit') as HTMLSelectElement;
        if (valueInput) valueInput.value = value;
        if (unitSelect) unitSelect.value = unit;
      });
    });

    // ✅ 일괄 예약 자동 시간 세팅 버튼
    document.getElementById('continuous-modal-auto-schedule-btn')?.addEventListener('click', () => {
      const startDateInput = document.getElementById('continuous-modal-schedule-date') as HTMLInputElement;
      const startTimeInput = document.getElementById('continuous-modal-schedule-time') as HTMLInputElement;
      const intervalInput = document.getElementById('continuous-modal-schedule-interval') as HTMLInputElement;
      const intervalUnitSelect = document.getElementById('continuous-modal-schedule-interval-unit') as HTMLSelectElement;

      // 큐에 있는 항목 개수 확인
      const queue = continuousQueueV2;
      const queueCount = queue.length;

      if (queueCount === 0) {
        toastManager.warning('⚠️ 먼저 발행 대기열에 항목을 추가해주세요.');
        return;
      }

      if (!startDateInput?.value || !startTimeInput?.value) {
        toastManager.warning('⚠️ 시작 날짜와 시간을 선택해주세요.');
        return;
      }

      // 시작 시간 파싱
      const startDate = new Date(`${startDateInput.value}T${startTimeInput.value}`);
      const avgIntervalMinutes = parseInt(intervalInput?.value || '1') * parseInt(intervalUnitSelect?.value || '60');

      console.log(`[AutoSchedule] 자동 예약 시간 생성: ${queueCount}개 항목, 평균 간격 ${avgIntervalMinutes}분`);

      // 랜덤 시간 생성 함수 (홀수/짝수 분 혼합)
      function generateRandomScheduleTimes(start: Date, count: number, avgInterval: number): Date[] {
        const times: Date[] = [];
        let currentTime = new Date(start);

        for (let i = 0; i < count; i++) {
          if (i === 0) {
            // 첫 번째는 시작 시간 기준 ± 랜덤 분(0~10분)
            const randomMinuteOffset = Math.floor(Math.random() * 11); // 0~10분
            currentTime = new Date(currentTime.getTime() + randomMinuteOffset * 60000);
          } else {
            // 평균 간격 ± 랜덤 편차 (5~25분)
            const variance = Math.floor(Math.random() * 21) + 5; // 5~25분
            const direction = Math.random() > 0.5 ? 1 : -1;
            const actualInterval = avgInterval + (variance * direction);
            currentTime = new Date(currentTime.getTime() + Math.max(10, actualInterval) * 60000); // 최소 10분 간격
          }

          // 분을 홀수/짝수 랜덤으로 조정 (더 자연스럽게)
          const currentMinutes = currentTime.getMinutes();
          const shouldBeOdd = Math.random() > 0.5;
          if (shouldBeOdd && currentMinutes % 2 === 0) {
            currentTime.setMinutes(currentMinutes + 1);
          } else if (!shouldBeOdd && currentMinutes % 2 === 1) {
            currentTime.setMinutes(currentMinutes + 1);
          }

          times.push(new Date(currentTime));
        }

        return times;
      }

      const scheduledTimes = generateRandomScheduleTimes(startDate, queueCount, avgIntervalMinutes);

      // 각 큐 항목에 예약 시간 적용
      queue.forEach((item, index) => {
        const scheduledTime = scheduledTimes[index];
        const yyyy = scheduledTime.getFullYear();
        const mm = String(scheduledTime.getMonth() + 1).padStart(2, '0');
        const dd = String(scheduledTime.getDate()).padStart(2, '0');
        const hh = String(scheduledTime.getHours()).padStart(2, '0');
        const mi = String(scheduledTime.getMinutes()).padStart(2, '0');

        item.scheduleDate = `${yyyy}-${mm}-${dd}`;
        item.scheduleTime = `${hh}:${mi}`;
        item.publishMode = 'schedule';

        console.log(`[AutoSchedule] ${index + 1}번 항목: ${item.scheduleDate} ${item.scheduleTime}`);
      });

      // UI 업데이트
      (window as any).renderContinuousQueue?.();

      // 성공 메시지
      const firstTime = scheduledTimes[0];
      const lastTime = scheduledTimes[scheduledTimes.length - 1];
      const firstTimeStr = `${firstTime.getHours()}:${String(firstTime.getMinutes()).padStart(2, '0')}`;
      const lastTimeStr = `${lastTime.getHours()}:${String(lastTime.getMinutes()).padStart(2, '0')}`;
      toastManager.success(`✅ ${queueCount}개 항목에 랜덤 예약 시간 설정 완료!\n${firstTimeStr} ~ ${lastTimeStr}`);
    });
    document.getElementById('continuous-modal-category-btn')?.addEventListener('click', () => {
      (window as any).openCategoryModalInContinuousMode?.('continuous-settings');
    });

    // ✅ 모달 블로그 카테고리 분석 버튼 이벤트
    document.getElementById('continuous-modal-analyze-category-btn')?.addEventListener('click', async () => {
      const btn = document.getElementById('continuous-modal-analyze-category-btn') as HTMLButtonElement;
      if (!btn) return;

      try {
        btn.disabled = true;
        btn.innerHTML = '⏳ 분석중...';

        // 스마트 자동발행 탭에서 선택된 계정 정보 가져오기
        const naverIdInput = document.getElementById('naver-id') as HTMLInputElement;
        const naverPasswordInput = document.getElementById('naver-password') as HTMLInputElement;

        let naverId = naverIdInput?.value?.trim() || '';
        let naverPassword = naverPasswordInput?.value?.trim() || '';

        if (!naverId || !naverPassword) {
          const config = await window.api.getConfig();
          if (!naverId && (config as any)?.savedNaverId) {
            naverId = (config as any).savedNaverId;
          }
          if (!naverPassword && (config as any)?.savedNaverPassword) {
            naverPassword = (config as any).savedNaverPassword;
          }
        }

        if (!naverId) {
          toastManager.warning('스마트 자동발행 탭에서 네이버 계정을 먼저 설정해주세요.');
          return;
        }

        const response = await (window.api as any).fetchBlogCategories({
          naverId,
          naverPassword
        });

        if (response.success && response.categories && response.categories.length > 0) {
          const realCatContainer = document.getElementById('continuous-modal-real-category-container');
          const realCatSelect = document.getElementById('continuous-modal-real-category') as HTMLSelectElement;

          if (realCatContainer && realCatSelect) {
            realCatSelect.innerHTML = response.categories.map((cat: any) =>
              `<option value="${cat.categoryNo || cat.id}">${cat.categoryName || cat.name}</option>`
            ).join('');
            realCatContainer.style.display = 'block';
          }

          toastManager.success(`✅ ${response.categories.length}개의 블로그 카테고리 분석 완료`);
        } else {
          toastManager.error(response.message || '카테고리 분석 실패');
        }
      } catch (err) {
        console.error('카테고리 분석 오류:', err);
        toastManager.error('분석 중 오류 발생');
      } finally {
        btn.disabled = false;
        btn.innerHTML = '<span style="font-size: 1rem;">🔍</span> <span>블로그 카테고리 분석하기</span>';
      }
    });
  }

  // ✅ [2026-01-22] 리뷰형 글쓰기가 가능한 카테고리 목록 (쇼핑커넥트 모드 활성화)
  // 모든 상품 리뷰/추천이 가능한 카테고리를 포함하도록 확장
  const AFFILIATE_ENABLED_CATEGORIES = [
    // ===== 기존 카테고리 =====
    'it_computer',        // IT/컴퓨터 (가전, 디지털)
    'shopping_review',    // 상품리뷰
    'fashion',            // 패션/뷰티
    'food_recipe',        // 요리/레시피
    'tasty_restaurant',   // 맛집
    'parenting',          // 육아/결혼 (유아용품)
    'interior',           // 인테리어/DIY (가구, 소품)
    'pet',                // 반려동물 (펫용품)
    'car',                // 자동차 (자동차용품)
    'game',               // 게임 (게임기, 주변기기)
    'hobby',              // 취미 (취미용품)
    'travel_domestic',    // 국내여행 (여행용품)
    'travel_world',       // 세계여행 (여행용품)

    // ===== 추가 카테고리 (2026-01-22) =====
    'health',             // 건강/의학 (건강식품, 운동기구)
    'sports',             // 스포츠 (스포츠용품)
    'gardening',          // 원예/재배 (원예용품)
    'photo',              // 사진 (카메라, 촬영장비)
    'business_economy',   // 비즈니스/경제 (사무용품, 책)
    'education_scholarship', // 교육/학문 (교재, 학습기기)
    'language',           // 어학/외국어 (어학교재)
    'realestate',         // 부동산 (인테리어, 가구)
    'self_dev',           // 자기계발 (도서, 강의)
    'general',            // 일상/생각 (일상용품)
    'literature',         // 문학/책 (도서)
    'movie',              // 영화 (영화용품, DVD)
    'art_design',         // 미술/디자인 (미술용품)
    'music',              // 음악 (악기, 음향기기)
    'good_writing',       // 좋은글/이미지 (인테리어소품)
    'cartoon',            // 만화/애니 (피규어, 굿즈)
  ];

  // 카테고리에 따라 쇼핑커넥트 옵션 표시/숨김
  function updateAffiliateOptionVisibility(categoryValue: string, modeSelectId: string) {
    const affiliateOption = document.querySelector(`#${modeSelectId} option[value="affiliate"]`) as HTMLOptionElement;
    if (affiliateOption) {
      const isAffiliateEnabled = AFFILIATE_ENABLED_CATEGORIES.includes(categoryValue);
      affiliateOption.style.display = isAffiliateEnabled ? 'block' : 'none';
      // 쇼핑커넥트가 선택된 상태에서 비활성화되면 SEO로 변경
      const modeSelect = document.getElementById(modeSelectId) as HTMLSelectElement;
      if (modeSelect && modeSelect.value === 'affiliate' && !isAffiliateEnabled) {
        modeSelect.value = 'seo';
      }
    }
  }

  // 전역에 함수 등록
  (window as any).updateAffiliateOptionVisibility = updateAffiliateOptionVisibility;
  (window as any).AFFILIATE_ENABLED_CATEGORIES = AFFILIATE_ENABLED_CATEGORIES;

  // ✅ 연속발행 콘텐츠 모드 변경 시 쇼핑 커넥트 설정 UI 토글
  const continuousContentModeSelect = document.getElementById('continuous-content-mode-select') as HTMLSelectElement;
  if (continuousContentModeSelect) {
    continuousContentModeSelect.addEventListener('change', () => {
      const isAffiliateMode = continuousContentModeSelect.value === 'affiliate';
      const shoppingConnectSettings = document.getElementById('continuous-shopping-connect-settings');
      if (shoppingConnectSettings) {
        shoppingConnectSettings.style.display = isAffiliateMode ? 'block' : 'none';
      }
    });
  }

  // ✅ 상세 설정 모달의 콘텐츠 모드 변경 시 쇼핑 커넥트 설정 UI 토글
  const continuousModalContentModeSelect = document.getElementById('continuous-modal-content-mode') as HTMLSelectElement;
  if (continuousModalContentModeSelect) {
    continuousModalContentModeSelect.addEventListener('change', () => {
      const isAffiliateMode = continuousModalContentModeSelect.value === 'affiliate';
      const modalShoppingConnectSettings = document.getElementById('continuous-modal-shopping-connect-settings');
      if (modalShoppingConnectSettings) {
        modalShoppingConnectSettings.style.display = isAffiliateMode ? 'block' : 'none';
      }
    });
  }

  // ✅ 풀오토 다중계정 세팅 모달의 콘텐츠 모드 변경 시 쇼핑 커넥트 이미지 옵션 토글
  const maContentModeSelect = document.getElementById('ma-setting-content-mode') as HTMLSelectElement;
  if (maContentModeSelect) {
    maContentModeSelect.addEventListener('change', () => {
      const isAffiliateMode = maContentModeSelect.value === 'affiliate';
      // 수집 이미지 기반 AI 생성 옵션 (쇼핑커넥트 전용)
      const maImageOptions = document.getElementById('ma-shopping-connect-image-options');
      if (maImageOptions) {
        maImageOptions.style.display = isAffiliateMode ? 'grid' : 'none';
      }
      // 쇼핑 커넥트 설정 섹션 (제휴 링크 등)
      const maShoppingConnectSettings = document.getElementById('ma-shopping-connect-settings');
      if (maShoppingConnectSettings) {
        maShoppingConnectSettings.style.display = isAffiliateMode ? 'block' : 'none';
      }
    });
  }

  // ✅ 이전글 선택 모달 표시 함수
  function showContinuousPrevPostModal(): void {
    try {
      // 생성된 포스트 목록 로드
      const posts = loadGeneratedPosts();
      const publishedPosts = posts.filter((p: any) => p.publishedUrl && p.publishedUrl.trim() !== '');

      if (publishedPosts.length === 0) {
        toastManager.warning('발행된 이전 글이 없습니다. 먼저 글을 발행한 뒤 다시 시도하세요.');
        return;
      }

      // 포스트 선택 모달 생성
      const modalHtml = `
        <div id="prev-post-selection-modal" class="modal-backdrop" style="display: flex; z-index: 30000; backdrop-filter: blur(8px);">
          <div class="modal-panel" style="max-width: 600px; width: 95%; max-height: 80vh; overflow: hidden; background: var(--bg-primary); border-radius: 16px; border: 2px solid rgba(59, 130, 246, 0.4);">
            <div style="padding: 1.25rem; border-bottom: 1px solid var(--border-light); background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(0,0,0,0)); display: flex; align-items: center; justify-content: space-between;">
              <h3 style="margin: 0; color: #3b82f6; font-size: 1.1rem; display: flex; align-items: center; gap: 0.5rem;">
                <span style="font-size: 1.3rem;">📋</span> 이전글 선택
              </h3>
              <button type="button" id="prev-post-modal-close" style="font-size: 1.5rem; border: none; background: transparent; color: var(--text-muted); cursor: pointer;">&times;</button>
            </div>
            <div style="padding: 1rem; max-height: 50vh; overflow-y: auto;">
              ${publishedPosts.map((post: any) => `
                <div class="prev-post-item" data-url="${post.publishedUrl}" data-title="${escapeHtml(post.title || '무제')}" 
                  style="padding: 0.75rem; margin-bottom: 0.5rem; background: rgba(255,255,255,0.03); border: 1px solid var(--border-light); border-radius: 8px; cursor: pointer; transition: all 0.2s;"
                  onmouseover="this.style.borderColor='#3b82f6'; this.style.background='rgba(59, 130, 246, 0.1)';"
                  onmouseout="this.style.borderColor='var(--border-light)'; this.style.background='rgba(255,255,255,0.03)';">
                  <div style="font-weight: 600; color: var(--text-strong); font-size: 0.9rem; margin-bottom: 0.25rem;">
                    📄 ${escapeHtml(post.title || '무제')}
                  </div>
                  <div style="font-size: 0.75rem; color: var(--text-muted);">
                    ${post.publishedAt ? new Date(post.publishedAt).toLocaleDateString('ko-KR') : '발행일 없음'} | ${categoryNames[post.category] || post.category || '일반'}
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        </div>
      `;

      // 모달 추가
      document.body.insertAdjacentHTML('beforeend', modalHtml);
      const modal = document.getElementById('prev-post-selection-modal');
      if (!modal) return;

      // 닫기 버튼
      document.getElementById('prev-post-modal-close')?.addEventListener('click', () => {
        modal.remove();
      });

      // 배경 클릭으로 닫기
      modal.addEventListener('click', (e) => {
        if (e.target === modal) modal.remove();
      });

      // 포스트 선택
      modal.querySelectorAll('.prev-post-item').forEach(item => {
        item.addEventListener('click', () => {
          const url = (item as HTMLElement).dataset.url || '';
          const title = (item as HTMLElement).dataset.title || '';

          // 모달 상태에 따라 다른 입력 필드에 값 설정
          const modalCtaUrl = document.getElementById('continuous-modal-cta-url') as HTMLInputElement;
          const modalCtaText = document.getElementById('continuous-modal-cta-text') as HTMLInputElement;
          const mainCtaUrl = document.getElementById('continuous-cta-url') as HTMLInputElement;
          const mainCtaText = document.getElementById('continuous-cta-text') as HTMLInputElement;

          if (modalCtaUrl) modalCtaUrl.value = url;
          if (modalCtaText) modalCtaText.value = `📖 ${title}`;
          if (mainCtaUrl) mainCtaUrl.value = url;
          if (mainCtaText) mainCtaText.value = `📖 ${title}`;

          toastManager.success(`✅ "${title}" 이전글이 선택되었습니다.`);
          modal.remove();
        });
      });

    } catch (error) {
      console.error('[showContinuousPrevPostModal] 오류:', error);
      toastManager.error('포스팅 목록을 불러오지 못했습니다.');
    }
  }

  // 이전 글 선택 버튼 (메인 설정)
  const prevPostBtn = document.getElementById('continuous-select-prevpost-btn');
  if (prevPostBtn) {
    prevPostBtn.addEventListener('click', showContinuousPrevPostModal);
  }

  // 이전 글 선택 버튼 (모달 상세 설정)
  const modalPrevPostBtn = document.getElementById('continuous-modal-select-prevpost-btn');
  if (modalPrevPostBtn) {
    modalPrevPostBtn.addEventListener('click', showContinuousPrevPostModal);
  }

  // 큐에 추가 버튼
  const addBtn = document.getElementById('continuous-add-to-queue-btn');
  if (addBtn) {
    addBtn.addEventListener('click', addItemToQueueV2);
  }

  // 전체 삭제 버튼
  const clearBtn = document.getElementById('continuous-clear-queue-btn');
  if (clearBtn) {
    clearBtn.addEventListener('click', () => {
      continuousQueueV2 = [];
      currentQueuePageV2 = 0;
      renderQueueListV2();
    });
  }

  // ✅ [NEW] 페이지네이션 이벤트
  document.getElementById('queue-page-prev')?.addEventListener('click', () => {
    if (currentQueuePageV2 > 0) {
      currentQueuePageV2--;
      renderQueueListV2();
    }
  });

  document.getElementById('queue-page-next')?.addEventListener('click', () => {
    const totalPages = Math.ceil(continuousQueueV2.length / QUEUE_PAGE_SIZE);
    if (currentQueuePageV2 < totalPages - 1) {
      currentQueuePageV2++;
      renderQueueListV2();
    }
  });

  // ✅ [NEW] 전체 보기 모달
  document.getElementById('continuous-queue-fullview-btn')?.addEventListener('click', showQueueFullViewModal);

  // 전체 보기 모달 내 전체 삭제 버튼
  document.getElementById('continuous-clear-queue-fullview-btn')?.addEventListener('click', () => {
    if (confirm('대기열의 모든 항목을 삭제하시겠습니까?')) {
      continuousQueueV2 = [];
      showQueueFullViewModal();
      renderQueueListV2();
    }
  });

  // ✅ 브라우저 세션 종료 버튼 이벤트 리스너 추가
  document.getElementById('close-browser-session-btn')?.addEventListener('click', async () => {
    if (confirm('현재 열려 있는 모든 브라우저 세션을 종료하시겠습니까?')) {
      try {
        const result = await (window as any).api.closeBrowser();
        if (result && result.success) {
          if ((window as any).showToast) {
            (window as any).showToast('🛑 브라우저 세션이 성공적으로 종료되었습니다.', 'success');
          } else {
            alert('브라우저 세션이 종료되었습니다.');
          }
        } else {
          alert('브라우저 종료 실패: ' + (result?.message || '알 수 없는 오류'));
        }
      } catch (error) {
        console.error('브라우저 종료 버튼 클릭 오류:', error);
        alert('오류 발생: ' + (error as Error).message);
      }
    }
  });

  // ✅ [FIX] 창 최소화 버튼 이벤트 리스너 (이벤트 위임 방식으로 변경하여 안정성 확보)
  document.addEventListener('click', async (e) => {
    const target = e.target as HTMLElement;
    // 버튼 자체거나 버튼 내부 요소(아이콘 등)를 클릭한 경우 모두 처리
    if (target.id === 'minimize-app-btn' || target.closest('#minimize-app-btn')) {
      console.log('📉 창 최소화 버튼 클릭됨 (위임)');
      try {
        await (window as any).api.minimizeWindow();
      } catch (error) {
        console.error('창 최소화 오류:', error);
      }
    }
  });

  // 모달 닫기 버튼들 (data-close-fullview 속성)
  document.querySelectorAll('[data-close-fullview]').forEach(btn => {
    btn.addEventListener('click', () => {
      const modal = document.getElementById('continuous-queue-fullview-modal');
      if (modal) modal.style.display = 'none';
    });
  });
}


// ✅ 이전 글 선택 모달
async function showContinuousPrevPostModal(): Promise<void> {
  try {
    const modal = document.createElement('div');
    modal.className = 'unified-modal-overlay';
    modal.style.cssText = `position: fixed; top: 0; left: 0; width: 100 %; height: 100 %; background: rgba(0, 0, 0, 0.7); z - index: 20000; display: flex; align - items: center; justify - content: center; `;

    modal.innerHTML = `
                < div style = "background: var(--bg-primary); border-radius: 12px; padding: 1.5rem; max-width: 600px; width: 95%; max-height: 80vh; overflow-y: auto;" >
                  <h3 style="margin: 0 0 1rem 0; color: var(--text-strong);" >🔗 이전 글에서 CTA 데이터 가져오기 </h3>
                    < p style = "font-size: 0.85rem; color: var(--text-muted); margin-bottom: 1rem;" > 현재 선택된 계정의 최근 글 목록입니다.링크를 가져올 글을 선택하세요.</p>
                      < div id = "prev-post-list-container" style = "min-height: 200px; display: flex; align-items: center; justify-content: center;" >
                        <div class="loader-small" > </div>
                          </div>
                          < div style = "margin-top: 1.5rem; display: flex; justify-content: flex-end;" >
                            <button type="button" id = "prev-post-modal-cancel" style = "padding: 0.6rem 1.2rem; background: var(--bg-tertiary); color: var(--text-muted); border: 1px solid var(--border-light); border-radius: 6px; cursor: pointer;" > 취소 </button>
                              </div>
                              </div>
                                `;

    document.body.appendChild(modal);

    const closeModal = () => {
      document.body.removeChild(modal);
    };

    modal.querySelector('#prev-post-modal-cancel')?.addEventListener('click', closeModal);

    // ✅ 로컬에 저장된 생성된 글 목록에서 이전글 가져오기 (계정 무관)
    const listContainer = modal.querySelector('#prev-post-list-container')!;
    listContainer.innerHTML = '<div style="color: var(--text-muted);">저장된 글 목록을 불러오는 중...</div>';

    // loadGeneratedPosts()로 로컬 저장된 글 가져오기
    const allPosts = loadGeneratedPosts();
    // 발행된 글만 필터링 (publishedUrl이 있는 글)
    const publishedPosts = allPosts.filter((p: any) => p.publishedUrl && p.publishedUrl.trim());

    if (publishedPosts.length === 0) {
      // 발행된 글이 없으면 모든 글 표시
      if (allPosts.length === 0) {
        listContainer.innerHTML = '<div style="color: var(--text-muted);">저장된 글이 없습니다. 먼저 글을 생성해주세요.</div>';
        return;
      }
      listContainer.innerHTML = '<div style="color: #f59e0b;">⚠️ 발행된 글이 없습니다. 아래에서 생성된 글을 선택하세요.</div>';
    }

    // 발행된 글 우선, 없으면 전체 글 표시
    const postsToShow = publishedPosts.length > 0 ? publishedPosts : allPosts;

    listContainer.innerHTML = `
                              < div style = "width: 100%;" >
                                <div style="padding: 0.5rem; background: var(--bg-tertiary); border-radius: 6px; margin-bottom: 0.75rem; font-size: 0.85rem; color: var(--text-muted);" >
              📝 총 ${allPosts.length}개 글(발행됨: ${publishedPosts.length}개)
                </div>
            ${postsToShow.slice(0, 20).map((p: any) => `
                <div style="padding: 0.75rem; border-bottom: 1px solid var(--border-light); cursor: pointer; transition: background 0.2s;" class="prev-post-row" data-url="${p.publishedUrl || ''}" data-title="${(p.title || '').replace(/"/g, '&quot;')}">
                    <div style="font-weight: 600; font-size: 0.9rem; color: var(--text-strong);">${p.title || '(제목 없음)'}</div>
                    <div style="font-size: 0.75rem; color: var(--text-muted);">
                      ${p.publishedUrl ? '✅ 발행됨' : '⏳ 미발행'} | ${new Date(p.createdAt || Date.now()).toLocaleDateString('ko-KR')}
                    </div>
                    ${p.publishedUrl ? `<div style="font-size: 0.7rem; color: var(--primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${p.publishedUrl}</div>` : ''}
                </div>
            `).join('')
      }
              </div>
                `;

    modal.querySelectorAll('.prev-post-row').forEach(row => {
      row.addEventListener('click', () => {
        const url = (row as HTMLElement).dataset.url || '';
        const title = (row as HTMLElement).dataset.title || '';

        const ctaUrlInput = document.getElementById('continuous-cta-url') as HTMLInputElement;
        const ctaTextInput = document.getElementById('continuous-cta-text') as HTMLInputElement;
        const ctaTypeSelect = document.getElementById('continuous-cta-type') as HTMLSelectElement;

        if (ctaUrlInput) ctaUrlInput.value = url;
        if (ctaTextInput) ctaTextInput.value = `이전 글: ${title} `;
        if (ctaTypeSelect) ctaTypeSelect.value = 'previous-post';

        toastManager.success('이전 글 링크가 CTA 설정에 반영되었습니다.');
        closeModal();
      });
    });

  } catch (error) {
    console.error('showContinuousPrevPostModal Error:', error);
    toastManager.error('포스팅 목록을 불러오는데 실패했습니다.');
  }
}

// ✅ 큐에 항목 추가
function addItemToQueueV2(): void {
  const activeTab = document.querySelector('.continuous-input-tab.active') as HTMLElement;
  const tabType = activeTab?.dataset.tab || 'url';

  let rawInputValue = '';

  if (tabType === 'url') {
    rawInputValue = (document.getElementById('continuous-url-input') as HTMLInputElement)?.value?.trim() || '';
  } else if (tabType === 'keyword') {
    rawInputValue = (document.getElementById('continuous-keyword-input') as HTMLInputElement)?.value?.trim() || '';
  }

  if (!rawInputValue) {
    toastManager.warning('입력값을 입력해주세요.');
    return;
  }

  // ✅ 줄바꿈(\n)으로만 입력값 분리 (벌크 추가 지원) - 콤마는 키워드에 포함될 수 있으므로 제외
  const inputValues = rawInputValue.split(/\n+/).map((v: string) => v.trim()).filter((v: string) => v.length > 0);

  if (inputValues.length === 0) {
    toastManager.warning('유효한 입력값이 없습니다.');
    return;
  }

  const imageSource = (document.getElementById('continuous-image-source-select') as HTMLSelectElement)?.value || 'nano-banana-pro';
  const intervalValue = parseInt((document.getElementById('continuous-interval-value') as HTMLInputElement)?.value || '30');
  const intervalUnit = parseInt((document.getElementById('continuous-interval-unit') as HTMLSelectElement)?.value || '1');
  const interval = intervalValue * intervalUnit;
  const publishModeRadio = document.querySelector('input[name="continuous-publish-mode"]:checked') as HTMLInputElement;
  const publishMode = (publishModeRadio?.value || 'publish') as 'publish' | 'draft' | 'schedule';

  // CTA 정보 수집
  const ctaType = (document.getElementById('continuous-cta-type') as HTMLSelectElement)?.value || 'none';
  const ctaUrl = (document.getElementById('continuous-cta-url') as HTMLInputElement)?.value?.trim() || '';
  const ctaText = (document.getElementById('continuous-cta-text') as HTMLInputElement)?.value?.trim() || '';

  // ✅ 카테고리 및 콘텐츠 모드 수집
  // [FIX] 카테고리는 상세설정 모달의 hidden input에서 가져오기 (continuous-category-select는 존재하지 않음)
  const category = (document.getElementById('continuous-modal-category-select') as HTMLInputElement)?.value ||
    (document.getElementById('continuous-category-select') as HTMLInputElement)?.value ||
    'entertainment';
  // ✅ [FIX] select 요소에서 콘텐츠 모드 가져오기 (라디오 버튼이 아닌 select 사용)
  const contentModeSelect = document.getElementById('continuous-content-mode-select') as HTMLSelectElement;
  const contentMode = (contentModeSelect?.value || 'seo') as 'seo' | 'homefeed' | 'affiliate' | 'custom';

  // [FIX] 실제 블로그 카테고리는 메인 폼 또는 모달에서 가져오기
  const realCatSelect = document.getElementById('continuous-real-category-select') as HTMLSelectElement ||
    document.getElementById('continuous-modal-real-category') as HTMLSelectElement;
  const realCategory = realCatSelect?.value || '';
  const realCategoryName = (realCatSelect?.options && realCatSelect.selectedIndex >= 0)
    ? realCatSelect.options[realCatSelect.selectedIndex]?.text || ''
    : '';

  let addedCount = 0;

  // ✅ 예약 발행 모드인 경우 시작 시간 가져오기
  let nextScheduleDate: Date | null = null;
  if (publishMode === 'schedule') {
    const modalDateInput = document.getElementById('continuous-modal-schedule-date') as HTMLInputElement;
    const modalTimeInput = document.getElementById('continuous-modal-schedule-time') as HTMLInputElement;

    if (modalDateInput?.value && modalTimeInput?.value) {
      nextScheduleDate = new Date(`${modalDateInput.value}T${modalTimeInput.value}`);
    } else if (modalDateInput?.value) {
      nextScheduleDate = new Date(`${modalDateInput.value}T09:00`);
    } else {
      nextScheduleDate = new Date(Date.now() + 10 * 60000); // 기본 10분 후
    }

    // 이미 큐에 예약된 항목이 있다면 그 이후부터 예약
    const lastScheduledItem = [...continuousQueueV2].reverse().find(i => i.publishMode === 'schedule' && i.scheduleDate);
    if (lastScheduledItem && lastScheduledItem.scheduleDate) {
      const lastDate = new Date(lastScheduledItem.scheduleDate);
      if (!isNaN(lastDate.getTime())) {
        nextScheduleDate = new Date(lastDate.getTime() + 30 * 60000); // 30분 간격
      }
    }
  }

  for (const val of inputValues) {
    let itemScheduleDate: string | undefined = undefined;
    let itemScheduleTime: string | undefined = undefined;
    if (publishMode === 'schedule' && nextScheduleDate) {
      // YYYY-MM-DD 형식으로 날짜 저장
      const yyyy = nextScheduleDate.getFullYear();
      const mm = String(nextScheduleDate.getMonth() + 1).padStart(2, '0');
      const dd = String(nextScheduleDate.getDate()).padStart(2, '0');
      const hh = String(nextScheduleDate.getHours()).padStart(2, '0');
      const mi = String(nextScheduleDate.getMinutes()).padStart(2, '0');
      itemScheduleDate = `${yyyy}-${mm}-${dd}`;
      itemScheduleTime = `${hh}:${mi}`;
      // 다음 항목을 위해 30분 추가
      nextScheduleDate = new Date(nextScheduleDate.getTime() + 30 * 60000);
    }

    const newItem: ContinuousQueueItem = {
      id: `item - ${Date.now()} -${Math.random().toString(36).substr(2, 9)} `,
      type: tabType as 'url' | 'keyword',
      value: val,
      customTitle: undefined,
      customKeyword: (tabType === 'keyword') ? val : undefined,
      imageSource,
      interval: Math.max(5, Math.min(86400, interval)), // 최대 24시간 확장
      publishMode,
      scheduleDate: itemScheduleDate,
      scheduleTime: itemScheduleTime,  // ✅ 예약 시간 별도 저장
      scheduleType: 'naver-server', // 연속 발행 예약은 네이버 서버 예약이 기본
      status: 'pending',
      ctaType,
      ctaUrl,
      ctaText,
      category,       // ✅ 카테고리 추가
      contentMode,    // ✅ 콘텐츠 모드 추가
      toneStyle: (document.getElementById('continuous-tone-style-select') as HTMLSelectElement)?.value || 'professional', // ✅ 글톤 추가
      realCategory,   // ✅ 실제 블로그 카테고리 추가
      realCategoryName, // ✅ 실제 블로그 카테고리 이름 추가
      includeThumbnailText: (document.getElementById('continuous-modal-include-thumbnail-text') as HTMLInputElement)?.checked || false,
      affiliateLink: contentMode === 'affiliate' ? ((document.getElementById('continuous-affiliate-link') as HTMLInputElement)?.value?.trim() || '') : undefined,
      videoOption: contentMode === 'affiliate' ? ((document.getElementById('continuous-video-option') as HTMLInputElement)?.checked || false) : undefined
    };
    continuousQueueV2.push(newItem);
    addedCount++;
  }

  renderQueueListV2();

  // 입력 필드 초기화 (제목/키워드는 유지할지 말지 고민되나, 일단 값만 초기화)
  if (tabType === 'url') {
    (document.getElementById('continuous-url-input') as HTMLInputElement).value = '';
    // 키워드/제목은 대량 등록 시 공유할 수 있으므로 명시적으로 초기화하지 않음 (사용자 편의)
  } else if (tabType === 'keyword') {
    (document.getElementById('continuous-keyword-input') as HTMLInputElement).value = '';
  }

  toastManager.success(`${addedCount}개 항목이 큐에 추가되었습니다. (총 ${continuousQueueV2.length}개)`);
}

let currentQueuePageV2 = 0;
const QUEUE_PAGE_SIZE = 5;

const imageSourceNames: Record<string, string> = {
  'nano-banana-pro': '🍌 나노바나나',
  'imagen4': '🖼️ Imagen4',
  'naver': '🔍 네이버',
  'prodia': '⚡ Prodia',
  'stability': '🚀 Stability',
  'skip': '🚫 없음'
};

const typeIcons: Record<string, string> = {
  'url': '🔗',
  'keyword': '🏷️'
};

const publishModeNames: Record<string, string> = {
  'publish': '🚀 즉시',
  'draft': '📝 임시',
  'schedule': '📅 예약'
};

const statusColors: Record<string, string> = {
  'pending': 'var(--text-muted)',
  'processing': '#f59e0b',
  'completed': '#10b981',
  'failed': '#ef4444',
  'cancelled': '#f97316'  // 주황색 - 중지됨
};

const toneStyleNames: Record<string, string> = {
  'friendly': '😊 친근한',
  'professional': '💼 전문적',
  'casual': '🎒 캐주얼',
  'formal': '🎩 격식체',
  'humorous': '😄 유머',
  'community_fan': '🔥 찐팬',
  'mom_cafe': '👩‍👧 맘카페'
};

const contentModeNames: Record<string, string> = {
  'seo': '🔍 SEO',
  'homefeed': '🏠 홈판',
  'affiliate': '💰 제휴',
  'custom': '✏️ 커스텀'
};

// ✅ 카테고리 이름 맵핑 (영어 → 한국어)
const categoryNames: Record<string, string> = {
  'general': '일반',
  'entertainment': '연예/이슈',
  'celebrity': '스타·연예인',
  'broadcast': '방송',
  'drama': '드라마',
  'health': '건강/의학',
  'finance': '경제/금융',
  'it_computer': 'IT/컴퓨터',
  'it_review': 'IT 리뷰',
  'shopping_review': '상품리뷰',
  'fashion': '패션/미용',
  'food_recipe': '요리/레시피',
  'tasty_restaurant': '맛집',
  'travel_domestic': '국내여행',
  'travel_world': '세계여행',
  'parenting': '육아/결혼',
  'pet': '반려동물',
  'interior': '인테리어/DIY',
  'car': '자동차',
  'game': '게임',
  'sports': '스포츠',
  'hobby': '취미',
  'movie': '영화',
  'music': '음악',
  'literature': '문학/책',
  'art_design': '미술/디자인',
  'performance': '공연/전시',
  'cartoon': '만화/애니',
  'tips': '생활 꿀팁',
  'good_writing': '좋은글/이미지',
  'gardening': '원예/재배',
  'photo': '사진',
  'society_politics': '사회/정치',
  'business_economy': '비즈니스/경제',
  'language': '어학/외국어',
  'education_scholarship': '교육/학문',
  'realestate': '부동산',
  'self_dev': '자기계발'
};

// ✅ window에 노출 (renderQueueListV2에서 사용)
(window as any).categoryNames = categoryNames;

// ✅ 큐 리스트 렌더링
function renderQueueListV2(): void {
  const container = document.getElementById('continuous-queue-list');
  if (!container) return;
  const totalItems = continuousQueueV2.length;
  const totalPages = Math.ceil(totalItems / QUEUE_PAGE_SIZE) || 1;

  // 페이지 범위 보정
  if (currentQueuePageV2 >= totalPages) currentQueuePageV2 = totalPages - 1;
  if (currentQueuePageV2 < 0) currentQueuePageV2 = 0;

  const startIdx = currentQueuePageV2 * QUEUE_PAGE_SIZE;
  const pageItems = continuousQueueV2.slice(startIdx, startIdx + QUEUE_PAGE_SIZE);

  // 페이지네이션 UI 업데이트
  const paginationEl = document.getElementById('continuous-queue-pagination');
  const pageInfoEl = document.getElementById('queue-page-info');
  const prevBtn = document.getElementById('queue-page-prev') as HTMLButtonElement;
  const nextBtn = document.getElementById('queue-page-next') as HTMLButtonElement;

  const clearBtn = document.getElementById('continuous-clear-queue-btn');

  if (paginationEl) paginationEl.style.display = totalItems > 0 ? 'block' : 'none';
  if (pageInfoEl) pageInfoEl.textContent = `${currentQueuePageV2 + 1} / ${totalPages}`;
  if (prevBtn) prevBtn.disabled = currentQueuePageV2 === 0;
  if (nextBtn) nextBtn.disabled = currentQueuePageV2 === totalPages - 1;
  if (clearBtn) clearBtn.style.display = totalItems > 0 ? 'block' : 'none';

  container.innerHTML = pageItems.map((item, localIdx) => {
    const globalIndex = startIdx + localIdx;
    return `
    <div class="continuous-queue-item" data-id="${item.id}" style="background: var(--bg-primary); border-radius: 8px; padding: 0.75rem; margin-bottom: 0.5rem; border-left: 3px solid ${statusColors[item.status]};">
      <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
        <span style="font-size: 0.9rem;">${typeIcons[item.type]}</span>
        <span style="flex: 1; font-size: 0.85rem; color: var(--text-strong); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${item.value}">${item.value.length > 30 ? item.value.substring(0, 30) + '...' : item.value}</span>
        <span style="font-size: 0.7rem; color: var(--text-muted);">#${globalIndex + 1}</span>
      </div>
      <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; line-height: 1.4;">
        ${(item.customTitle || item.customKeyword) ? `
          <div style="margin-bottom: 2px;">
            ${item.customKeyword ? `<span style="color: var(--text-strong);">🔑 ${item.customKeyword}</span>` : ''}
            ${item.customKeyword && item.customTitle ? ' • ' : ''}
            ${item.customTitle ? `<span>✍️ ${item.customTitle}</span>` : ''}
          </div>
        ` : ''}
        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 4px; align-items: center;">
           <span style="color: #3b82f6; font-weight: 700; background: rgba(59, 130, 246, 0.1); padding: 1px 4px; border-radius: 4px;">📂 ${categoryNames[item.category || 'general'] || item.category || '일반'}</span>
           ${item.realCategoryName ? `<span style="color: #10b981; font-weight: 600; font-size: 0.7rem; border-left: 1px solid var(--border-light); padding-left: 4px;">🏷️ ${item.realCategoryName}</span>` : ''}
           <span style="color: #8b5cf6;">🎯 ${contentModeNames[item.contentMode || 'homefeed'] || '홈판'}</span>
           <span style="color: #f59e0b;">✍️ ${toneStyleNames[item.toneStyle || 'professional'] || '전문적'}</span>
        </div>
        ${item.ctaType && item.ctaType !== 'none' ? `
          <div style="color: #60a5fa;">📢 CTA: ${item.ctaType === 'previous-post' ? '이전글' : '커스텀'}</div>
        ` : ''}
      </div>
      <div style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.75rem; color: var(--text-muted);">
        <span style="color: ${item.publishMode === 'schedule' ? 'var(--primary)' : 'inherit'}; font-weight: ${item.publishMode === 'schedule' ? '600' : '400'};">
          ${publishModeNames[item.publishMode] || '🚀 즉시'}
          ${item.publishMode === 'schedule' && (item.scheduleDate || item.scheduleTime) ? ` (${item.scheduleTime || (item.scheduleDate?.includes('T') ? item.scheduleDate.split('T')[1]?.substring(0, 5) : '')})` : ''}
        </span>
        <span>•</span>
        <span>${imageSourceNames[item.imageSource] || item.imageSource}</span>
        <span>•</span>
        <span>${item.interval >= 3600 ? Math.floor(item.interval / 3600) + '시간' : (item.interval >= 60 ? Math.floor(item.interval / 60) + '분' : item.interval + '초')}</span>
        ${item.status === 'pending' ? `
          <div style="margin-left: auto; display: flex; gap: 0.25rem;">
            ${item.type === 'url' ? `<button type="button" class="queue-addurl-btn" data-id="${item.id}" style="padding: 0.25rem 0.5rem; background: rgba(34, 197, 94, 0.1); border: 1px solid rgba(34, 197, 94, 0.3); border-radius: 4px; color: #22c55e; cursor: pointer; font-size: 0.7rem;" title="추가 URL 입력">+URL${item.additionalUrls && item.additionalUrls.length > 0 ? ` (${item.additionalUrls.length})` : ''}</button>` : ''}
            <button type="button" class="queue-edit-btn" data-id="${item.id}" style="padding: 0.25rem 0.5rem; background: var(--bg-tertiary); border: 1px solid var(--border-light); border-radius: 4px; color: var(--text-muted); cursor: pointer; font-size: 0.7rem;">✏️</button>
            <button type="button" class="queue-delete-btn" data-id="${item.id}" style="padding: 0.25rem 0.5rem; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 4px; color: #ef4444; cursor: pointer; font-size: 0.7rem;">🗑️</button>
          </div>
        ` : `
          <span style="margin-left: auto; font-size: 0.7rem; color: ${statusColors[item.status]};">
            ${item.status === 'processing' ? '⏳ 발행 중' : item.status === 'completed' ? '✅ 완료' : item.status === 'cancelled' ? '🛑 중지됨' : '❌ 실패'}
          </span>
        `}
      </div>
    </div>
  `;
  }).join('');

  // 삭제 버튼 이벤트
  container.querySelectorAll('.queue-delete-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const id = (btn as HTMLElement).dataset.id;
      continuousQueueV2 = continuousQueueV2.filter(item => item.id !== id);
      renderQueueListV2();
    });
  });

  // 수정 버튼 이벤트
  container.querySelectorAll('.queue-edit-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const id = (btn as HTMLElement).dataset.id;
      const item = continuousQueueV2.find(i => i.id === id);
      if (item) showEditQueueItemModal(item);
    });
  });

  // ✅ [2026-01-21] URL 추가 버튼 이벤트 (다중 소스 지원)
  container.querySelectorAll('.queue-addurl-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const id = (btn as HTMLElement).dataset.id;
      const item = continuousQueueV2.find(i => i.id === id);
      if (!item) return;

      // 기존 추가 URL 목록 표시
      const existingUrls = item.additionalUrls || [];
      const existingList = existingUrls.length > 0
        ? `\n\n현재 추가된 URL (${existingUrls.length}개):\n${existingUrls.map((u, i) => `${i + 1}. ${u}`).join('\n')}`
        : '';

      const newUrl = prompt(`추가할 URL을 입력하세요:\n(여러 개를 한 번에 추가하려면 줄바꿈으로 구분)${existingList}`);

      if (newUrl && newUrl.trim()) {
        // 줄바꿈으로 구분된 여러 URL 처리
        const urls = newUrl.split('\n')
          .map(u => u.trim())
          .filter(u => u.length > 0 && /^https?:\/\//i.test(u));

        if (urls.length > 0) {
          if (!item.additionalUrls) item.additionalUrls = [];
          item.additionalUrls.push(...urls);
          console.log(`[Continuous] ✅ ${urls.length}개 URL 추가됨 (총 ${item.additionalUrls.length}개)`);
          toastManager.success(`✅ ${urls.length}개 URL이 추가되었습니다!`);
          renderQueueListV2();
        } else {
          toastManager.warning('⚠️ 유효한 URL이 없습니다. http:// 또는 https://로 시작해야 합니다.');
        }
      }
    });
  });
}

// ✅ 전체 보기 모달
function showQueueFullViewModal(): void {
  const modal = document.getElementById('continuous-queue-fullview-modal') as HTMLElement;
  const container = document.getElementById('fullview-queue-container') as HTMLElement;
  if (!modal || !container) return;

  if (continuousQueueV2.length === 0) {
    container.innerHTML = `
      <div style="text-align: center; padding: 3rem 1rem; color: var(--text-muted);">
        <div style="font-size: 3rem; margin-bottom: 1rem;">📭</div>
        <div>큐가 비어있습니다</div>
      </div>
    `;
  } else {
    container.innerHTML = continuousQueueV2.map((item, index) => {
      const intervalText = item.interval >= 3600
        ? Math.floor(item.interval / 3600) + '시간'
        : (item.interval >= 60 ? Math.floor(item.interval / 60) + '분' : item.interval + '초');

      return `
        <div class="fullview-queue-item" style="background: var(--bg-secondary); border-radius: 12px; padding: 1.25rem; border-left: 5px solid ${statusColors[item.status]}; display: flex; align-items: center; gap: 1.25rem; box-shadow: 0 2px 8px rgba(0,0,0,0.15);">
          <div style="font-weight: 800; color: var(--text-muted); width: 40px; font-size: 1.1rem; text-align: center;">#${index + 1}</div>
          <div style="flex: 1; min-width: 0;">
            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.25rem;">
              <span style="font-size: 1.1rem;">${typeIcons[item.type]}</span>
              <div style="font-weight: 700; color: var(--text-strong); font-size: 1rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${item.value}</div>
            </div>
            <div style="font-size: 0.85rem; color: var(--text-muted); display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap;">
              <span style="background: rgba(139, 92, 246, 0.15); color: #a78bfa; padding: 0.15rem 0.5rem; border-radius: 6px; font-size: 0.75rem; font-weight: 600;">${imageSourceNames[item.imageSource] || item.imageSource}</span>
              <span style="background: rgba(16, 185, 129, 0.15); color: #34d399; padding: 0.15rem 0.5rem; border-radius: 6px; font-size: 0.75rem; font-weight: 600;">${publishModeNames[item.publishMode] || '🚀 즉시'}</span>
              <span style="background: rgba(59, 130, 246, 0.15); color: #60a5fa; padding: 0.15rem 0.5rem; border-radius: 6px; font-size: 0.75rem; font-weight: 600;">📂 ${(window as any).categoryNames?.[item.category || 'general'] || item.category || '일반'}</span>
              ${item.realCategoryName ? `<span style="background: rgba(16, 185, 129, 0.1); color: #10b981; padding: 0.15rem 0.5rem; border-radius: 6px; font-size: 0.75rem; font-weight: 600;">🏷️ ${item.realCategoryName}</span>` : ''}
              <span style="background: rgba(245, 158, 11, 0.15); color: #f59e0b; padding: 0.15rem 0.5rem; border-radius: 6px; font-size: 0.75rem; font-weight: 600;">🎯 ${contentModeNames[item.contentMode || 'homefeed'] || '홈판'}</span>
              <span style="background: rgba(139, 92, 246, 0.1); color: #a78bfa; padding: 0.15rem 0.5rem; border-radius: 6px; font-size: 0.75rem; font-weight: 600;">✍️ ${toneStyleNames[item.toneStyle || 'professional'] || '전문적'}</span>
              <span>•</span>
              <span>⏱️ ${intervalText}</span>
              <span>•</span>
              <span style="color: ${statusColors[item.status]}; font-weight: 700;">
                ${item.status === 'pending' ? '⏳ 대기 중' : item.status === 'processing' ? '🔄 진행 중' : item.status === 'completed' ? '✅ 완료' : item.status === 'cancelled' ? '🛑 중지됨' : '⚠️ 실패'}
              </span>
            </div>
            ${(item.ctaType && item.ctaType !== 'none') ? `
              <div style="margin-top: 0.5rem; font-size: 0.8rem; color: #60a5fa; display: flex; align-items: center; gap: 0.5rem;">
                <span>📢 CTA: ${item.ctaType === 'previous-post' ? '이전글' : '커스텀'}</span>
                <span style="opacity: 0.6;">|</span>
                <span style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${item.ctaUrl}</span>
              </div>
            ` : ''}
          </div>
          <div style="display: flex; gap: 0.5rem;">
            ${item.status === 'pending' ? `
              <button type="button" class="fullview-edit-btn" data-id="${item.id}" style="padding: 0.6rem 1rem; background: var(--bg-tertiary); border: 2px solid var(--border-light); border-radius: 8px; color: var(--text-strong); cursor: pointer; font-size: 0.85rem; font-weight: 600; transition: all 0.2s;">✏️ 수정</button>
              <button type="button" class="fullview-delete-btn" data-id="${item.id}" style="padding: 0.6rem 1rem; background: rgba(239, 68, 68, 0.1); border: 2px solid rgba(239, 68, 68, 0.3); border-radius: 8px; color: #ef4444; cursor: pointer; font-size: 0.85rem; font-weight: 600; transition: all 0.2s;">🗑️ 삭제</button>
            ` : ''}
          </div>
        </div>
      `;
    }).join('');
  }

  // 삭제 버튼 이벤트
  container.querySelectorAll('.fullview-delete-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const id = (btn as HTMLElement).dataset.id;
      if (confirm('이 항목을 삭제하시겠습니까?')) {
        continuousQueueV2 = continuousQueueV2.filter(item => item.id !== id);
        showQueueFullViewModal();
        renderQueueListV2();
      }
    });
  });

  // 수정 버튼 이벤트
  container.querySelectorAll('.fullview-edit-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const id = (btn as HTMLElement).dataset.id;
      const item = continuousQueueV2.find(i => i.id === id);
      if (item) {
        // 수정 모달을 띄울 때 전체 보기 모달은 숨기지 않고 위에 띄움
        // fromFullView 옵션을 주어 갱신 가능하게 함
        showEditQueueItemModal(item, { fromFullView: true });
      }
    });
  });

  modal.style.display = 'flex';
}

// ✅ 항목 수정 모달 (상세 설정 모달과 동일한 UI)
// ✅ 통합 항목 수정 모달 (기존 상세 설정 모달 재사용)
function showEditQueueItemModal(item: ContinuousQueueItem, options?: { fromFullView?: boolean }): void {
  const modal = document.getElementById('continuous-settings-modal');
  if (!modal) return;

  // 인덱스 찾기
  const idx = continuousQueueV2.findIndex(i => i.id === item.id);
  if (idx === -1) return;

  (window as any).editingIndex = idx;
  const editingIndexInput = document.getElementById('continuous-settings-editing-index') as HTMLInputElement;
  if (editingIndexInput) editingIndexInput.value = String(idx);

  // 모달 제목 및 버튼 변경
  const titleEl = modal.querySelector('h3');
  if (titleEl) titleEl.innerHTML = `✏️ 항목 수정 (#${idx + 1})`;
  const saveBtn = document.getElementById('continuous-settings-modal-save');
  if (saveBtn) saveBtn.innerHTML = '💾 수정사항 적용';

  // 항목 데이터로 모달 필드 채우기 (null 체크 추가)
  const contentModeEl = document.getElementById('continuous-modal-content-mode') as HTMLSelectElement | null;
  if (contentModeEl) contentModeEl.value = item.contentMode || 'seo';

  const toneStyleEl = document.getElementById('continuous-modal-tone-style') as HTMLSelectElement | null;
  if (toneStyleEl) toneStyleEl.value = item.toneStyle || 'professional';

  const imageSourceEl = document.getElementById('continuous-modal-image-source') as HTMLSelectElement | null;
  if (imageSourceEl) imageSourceEl.value = item.imageSource || 'nano-banana-pro';

  const radio = modal.querySelector(`input[name="continuous-modal-publish-mode"][value="${item.publishMode}"]`) as HTMLInputElement;
  if (radio) {
    radio.checked = true;
    const scheduleContainer = document.getElementById('continuous-modal-schedule-container');
    if (scheduleContainer) scheduleContainer.style.display = item.publishMode === 'schedule' ? 'block' : 'none';
  }

  if (item.scheduleDate) {
    const [date, time] = item.scheduleDate.split('T');
    const scheduleDateEl = document.getElementById('continuous-modal-schedule-date') as HTMLInputElement | null;
    if (scheduleDateEl) scheduleDateEl.value = date || '';
    const scheduleTimeEl = document.getElementById('continuous-modal-schedule-time') as HTMLInputElement | null;
    if (scheduleTimeEl) scheduleTimeEl.value = item.scheduleTime || (time ? time.substring(0, 5) : '09:00');
  }

  // 카테고리
  const modalCatInput = document.getElementById('continuous-modal-category-select') as HTMLInputElement;
  const modalCatText = document.getElementById('continuous-modal-category-text');
  if (modalCatInput) modalCatInput.value = item.category || 'general';
  if (modalCatText) modalCatText.textContent = categoryNames[item.category || 'general'] || item.category || '일반';

  // 실제 블로그 카테고리
  const modalRealCat = document.getElementById('continuous-modal-real-category') as HTMLSelectElement;
  if (modalRealCat) {
    if (item.realCategory) {
      modalRealCat.innerHTML = `<option value="${item.realCategory}" selected>${item.realCategoryName || item.realCategory}</option>`;
    } else {
      modalRealCat.innerHTML = '';
    }
  }

  // CTA 및 기타 (null 체크 추가)
  const ctaTypeEl = document.getElementById('continuous-modal-cta-type') as HTMLSelectElement | null;
  if (ctaTypeEl) ctaTypeEl.value = item.ctaType || 'none';

  const ctaUrlEl = document.getElementById('continuous-modal-cta-url') as HTMLInputElement | null;
  if (ctaUrlEl) ctaUrlEl.value = item.ctaUrl || '';

  const ctaTextEl = document.getElementById('continuous-modal-cta-text') as HTMLInputElement | null;
  if (ctaTextEl) ctaTextEl.value = item.ctaText || '';

  const thumbnailTextEl = document.getElementById('continuous-modal-include-thumbnail-text') as HTMLInputElement | null;
  if (thumbnailTextEl) thumbnailTextEl.checked = !!item.includeThumbnailText;

  // AI 이미지 생성 옵션 (신규)
  const useAiImageCheck = document.getElementById('continuous-modal-use-ai-image') as HTMLInputElement | null;
  if (useAiImageCheck) useAiImageCheck.checked = item.useAiImage ?? true;

  const createThumbnailCheck = document.getElementById('continuous-modal-create-product-thumbnail') as HTMLInputElement | null;
  if (createThumbnailCheck) createThumbnailCheck.checked = !!item.createProductThumbnail;

  const intervalValueEl = document.getElementById('continuous-modal-interval-value') as HTMLInputElement | null;
  if (intervalValueEl) intervalValueEl.value = String(item.interval < 60 ? item.interval : (item.interval < 3600 ? Math.floor(item.interval / 60) : Math.floor(item.interval / 3600)));

  const intervalUnitEl = document.getElementById('continuous-modal-interval-unit') as HTMLSelectElement | null;
  if (intervalUnitEl) intervalUnitEl.value = String(item.interval < 60 ? 1 : (item.interval < 3600 ? 60 : 3600));

  modal.style.display = 'flex';
}

// ✅ 진행 모달 업데이트 헬퍼
function updateContinuousProgressModal(data: {
  title?: string;
  step?: string;
  percentage?: number;
  total?: number;
  success?: number;
  fail?: number;
  log?: string;
}) {
  const modal = document.getElementById('continuous-progress-modal');
  if (!modal) return;

  if (data.title !== undefined) {
    const el = document.getElementById('cp-current-item-info');
    if (el) el.textContent = data.title;
  }
  if (data.step !== undefined) {
    const el = document.getElementById('cp-step-text');
    if (el) el.textContent = data.step;
  }
  if (data.percentage !== undefined) {
    const elP = document.getElementById('cp-percentage');
    const elB = document.getElementById('cp-progress-bar');
    if (elP) elP.textContent = `${Math.round(data.percentage)}%`;
    if (elB) elB.style.width = `${data.percentage}%`;
  }
  if (data.total !== undefined) {
    const el = document.getElementById('cp-total-count');
    if (el) el.textContent = String(data.total);
  }
  if (data.success !== undefined) {
    const el = document.getElementById('cp-success-count');
    if (el) el.textContent = String(data.success);
  }
  if (data.fail !== undefined) {
    const el = document.getElementById('cp-fail-count');
    if (el) el.textContent = String(data.fail);
  }
  if (data.log !== undefined) {
    const el = document.getElementById('cp-detail-log');
    if (el) {
      const now = new Date();
      const timeStr = `[${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}]`;
      const newLog = document.createElement('p');
      newLog.style.cssText = 'margin: 0 0 0.5rem 0; color: #cbd5e1; font-size: 0.85rem; border-left: 2px solid rgba(59, 130, 246, 0.4); padding-left: 0.5rem;';
      newLog.innerHTML = `<span style="color: #60a5fa; font-weight: 600; margin-right: 0.5rem;">${timeStr}</span> ${data.log}`;
      el.appendChild(newLog);
      // 자동 스크롤 하단 고정
      el.scrollTop = el.scrollHeight;
    }
  }
}

// ✅ 연속 발행 모달 숨기기 (발행은 백그라운드에서 계속 진행)
function hideContinuousProgressModal(): void {
  const modal = document.getElementById('continuous-progress-modal');
  if (modal) {
    modal.style.display = 'none';
    toastManager.info('📂 발행이 백그라운드에서 진행 중입니다. 메인 하단 인디케이터에서 상황을 확인할 수 있습니다.', 4000);
  }
}
(window as any).hideContinuousProgressModal = hideContinuousProgressModal;

// ✅ 인터럽트 가능한 대기 함수
async function waitWithInterrupt(seconds: number): Promise<boolean> {
  const start = Date.now();
  const ms = seconds * 1000;
  while (Date.now() - start < ms) {
    if (!isContinuousMode) return false; // 중지됨

    // 모달 로그 업데이트 (카운트다운 시각화)
    const remaining = Math.max(0, Math.ceil((ms - (Date.now() - start)) / 1000));
    updateContinuousProgressModal({
      step: '다음 항목 대기 중...',
      log: `⏰ ${remaining}초 후 다음 발행을 시작합니다.`
    });

    await new Promise(resolve => setTimeout(resolve, 500)); // 0.5초마다 체크
  }
  return true;
}

// ✅ 연속 발행 V2 시작
async function startContinuousPublishingV2(): Promise<void> {
  if (continuousQueueV2.length === 0) {
    toastManager.warning('발행할 항목이 없습니다. 먼저 항목을 추가해주세요.');
    return;
  }

  const pendingItems = continuousQueueV2.filter(i => i.status === 'pending');
  if (pendingItems.length === 0) {
    toastManager.warning('발행 대기 중인 항목이 없습니다.');
    return;
  }

  isContinuousMode = true;

  // ✅ [2026-01-21] 연속 발행 시작 시 락 강제 해제 (이전 세션 잔여 락 제거)
  clearImageGenerationLocks();
  console.log('[Continuous] 🔓 이미지 생성 락 초기화 완료');

  // ✅ 진행 모달 표시
  const progressModal = document.getElementById('continuous-progress-modal');
  if (progressModal) progressModal.style.display = 'flex';

  // 초기화
  let successCount = 0;
  let failCount = 0;
  const totalCount = pendingItems.length;

  updateContinuousProgressModal({
    total: totalCount,
    success: 0,
    fail: 0,
    percentage: 0,
    step: '준비 중...',
    log: '발행 프로세스를 시작합니다.'
  });

  // UI 업데이트 (기존 인디케이터 등)
  const startBtn = document.getElementById('continuous-start-btn');
  const stopBtn = document.getElementById('continuous-stop-btn');
  const statusIndicator = document.getElementById('continuous-status-indicator');
  const statusText = document.getElementById('continuous-status-text');

  if (startBtn) (startBtn as HTMLElement).style.display = 'none';
  if (stopBtn) (stopBtn as HTMLElement).style.display = 'flex';
  if (statusIndicator) statusIndicator.style.background = '#f59e0b';

  appendLog(`🚀 연속 발행 시작: ${pendingItems.length}개 항목`);

  const publishModeLabels: Record<string, string> = {
    'publish': '즉시발행',
    'draft': '임시저장',
    'schedule': '네이버 예약발행'
  };

  const includeThumbnailTextEl = document.getElementById('continuous-include-thumbnail-text') as HTMLInputElement | null;
  const includeThumbnailText = includeThumbnailTextEl?.checked || false;

  // ✅ [2026-01-21] 배너 자동 생성 체크박스 읽기
  const autoBannerGenerateEl = document.getElementById('continuous-auto-banner-generate') as HTMLInputElement | null;
  const autoBannerGenerate = autoBannerGenerateEl?.checked || false;
  console.log(`[Continuous] 🎨 배너 자동 생성 옵션: ${autoBannerGenerate ? '활성화' : '비활성화'}`);

  // ✅ 카테고리 정보 수집
  const selectedCategory = (document.getElementById('real-blog-category-select') as HTMLSelectElement)?.value || undefined;

  for (let i = 0; i < continuousQueueV2.length; i++) {
    const item = continuousQueueV2[i];
    if (!isContinuousMode) break;
    if (item.status !== 'pending') continue;

    const currentIdx = successCount + failCount + 1;
    const progress = ((currentIdx - 0.5) / totalCount) * 100;

    item.status = 'processing';
    renderQueueListV2();

    updateContinuousProgressModal({
      title: `${item.value.substring(0, 30)}${item.value.length > 30 ? '...' : ''}`,
      step: '콘텐츠 생성 중...',
      log: `[${currentIdx}/${totalCount}] AI가 콘텐츠를 생성하고 있습니다.`,
      percentage: progress
    });

    // ✅ 이미지 상태 초기화 (이전 발행 이미지 잔상 제거)
    try {
      if (typeof ImageManager !== 'undefined' && ImageManager.clearAll) {
        ImageManager.clearAll();
      }
      (window as any).generatedImages = [];
      (window as any).currentStructuredContent = null;
    } catch (e) {
      console.warn('[Continuous] 상태 초기화 중 오류 (무시 가능):', e);
    }

    try {
      const modeLabel = publishModeLabels[item.publishMode] || '즉시발행';
      appendLog(`📝 처리 중: ${item.value.substring(0, 40)}... (${modeLabel})`);

      if (statusText) statusText.textContent = `발행 중... (${currentIdx}/${totalCount})`;

      // 콘텐츠 생성
      // 콘텐츠 생성
      if (item.type === 'url') {
        const customKeyword = item.customKeyword || '';
        // ✅ [2026-01-21] 다중 URL 지원: 메인 URL + additionalUrls 합치기
        let combinedUrls = item.value;
        if (item.additionalUrls && item.additionalUrls.length > 0) {
          combinedUrls = [item.value, ...item.additionalUrls].join('\n');
          console.log(`[Continuous] 📚 다중 URL 사용: ${1 + item.additionalUrls.length}개 소스`);
        }
        await generateContentFromUrl(combinedUrls, customKeyword, item.toneStyle, true, item.contentMode, item.category);
      } else {
        await generateContentFromKeywords(item.customTitle || '', item.value, item.toneStyle, true, item.contentMode, item.category);
      }

      if (!isContinuousMode) break;

      // 발행 실행
      const structuredContent = (window as any).currentStructuredContent;
      if (structuredContent) {
        updateContinuousProgressModal({
          step: '블로그 발행 중...',
          log: '네이버 블로그에 포스팅을 전송하고 있습니다.',
          percentage: (currentIdx / totalCount) * 100 - 5
        });

        // ✅ 연속발행: 사용자 지정 제목/키워드가 있으면 최종 제목을 강제 세팅
        applyContinuousTitleOverrides(item, structuredContent);

        const skipImages = item.imageSource === 'skip';
        if (!skipImages) {
          updateContinuousProgressModal({
            step: '이미지 생성 중...',
            log: `[${currentIdx}/${totalCount}] 이미지를 생성/수집하고 있습니다.`,
            percentage: (currentIdx / totalCount) * 100 - 15
          });

          try {
            const headings = structuredContent.headings || [];

            // ✅ [2026-01-21] 연속 발행: 이미지 생성 전 락 강제 해제 (이전 글 락 잔여 방지)
            clearImageGenerationLocks();

            // generateImagesForAutomation 호출
            const generatedImgs = await generateImagesForAutomation(
              item.imageSource,
              headings,
              structuredContent.selectedTitle,
              {
                stopCheck: () => !isContinuousMode,
                onProgress: (msg) => {
                  appendLog(msg);
                  // 진행 모달에 로그 업데이트 (너무 빈번하면 생략 가능)
                  const modalLog = document.getElementById('continuous-progress-log');
                  if (modalLog) modalLog.textContent = msg;
                },
                allowThumbnailText: includeThumbnailText // ✅ 1번 이미지 텍스트 포함 옵션 전달
              }
            );

            if (!isContinuousMode) break;

            // 전역 변수 설정 (executeUnifiedAutomation에서 사용)
            (window as any).generatedImages = generatedImgs;

            // ImageManager에도 동기화 (필요시)
            try {
              if (typeof ImageManager !== 'undefined') {
                ImageManager.clear();
                if (headings.length > 0) ImageManager.setHeadings(headings);

                generatedImgs.forEach((img: any) => {
                  const h = img.heading || structuredContent.selectedTitle;
                  if (h) ImageManager.addImage(h, img);
                });
                (window as any).imageManagementGeneratedImages = ImageManager.getAllImages();
              }
            } catch (e) {
              console.warn('[Continuous] ImageManager 동기화 실패:', e);
            }

          } catch (imgErr) {
            console.error('[Continuous] 이미지 생성 실패:', imgErr);
            appendLog(`⚠️ 이미지 생성 실패: ${(imgErr as Error).message}`);
            // 실패해도 계속 진행 (이미지 없이)
          }
        }

        // ✅ [2026-01-23 FIX] 생성된 글 목록에 저장 (다중계정 발행과 동일한 방식으로 통일)
        // 이미지 생성 후에 저장해야 이미지도 함께 저장됨
        const generatedImgsForSave = (window as any).generatedImages || [];
        const savedPostId = saveGeneratedPostFromData(structuredContent, generatedImgsForSave, {
          category: item.category || selectedCategory,
          toneStyle: item.toneStyle,
          ctaText: item.ctaText || '',
          ctaLink: item.ctaUrl || '',
        });
        if (savedPostId) {
          currentPostId = savedPostId;
          console.log(`[Continuous] 💾 글 저장 완료 (postId: ${savedPostId}, 이미지: ${generatedImgsForSave.length}개)`);
        }

        const formData = {
          mode: 'full-auto',
          structuredContent,
          imageSource: skipImages ? 'nano-banana-pro' : item.imageSource,
          skipImages,
          publishMode: item.publishMode,
          // ✅ scheduleDate와 scheduleTime을 합쳐서 'YYYY-MM-DD HH:mm' 형식으로 전달
          // scheduleTime이 없으면 scheduleDate에 시간이 포함되어 있을 수 있으므로 그대로 사용
          scheduleDate: item.publishMode === 'schedule' && item.scheduleDate
            ? (item.scheduleTime
              ? `${item.scheduleDate} ${item.scheduleTime}`
              : (item.scheduleDate.includes('T')
                ? item.scheduleDate.replace('T', ' ')
                : item.scheduleDate))
            : undefined,
          scheduleType: item.scheduleType || 'naver-server',
          includeThumbnailText,
          keywords: item.customKeyword,
          ctaType: item.ctaType,
          ctaUrl: item.ctaUrl,
          ctaText: item.ctaText,
          category: item.category || selectedCategory, // ✅ [2026-01-22 FIX] 연속발행 항목의 콘텐츠 카테고리 우선 사용 (CTA 이전글 찾기용)
          contentMode: item.contentMode, // ✅ 콘텐츠 모드 추가
          affiliateLink: item.affiliateLink, // ✅ 제휴 링크 추가
          keepBrowserOpen: true, // ✅ 연속발행 시 항상 브라우저 세션 유지
          autoBannerGenerate, // ✅ [2026-01-21] 배너 자동 생성 옵션
        };
        await executeUnifiedAutomation(formData);
      }

      item.status = 'completed';
      successCount++;
      appendLog(`✅ 완료: ${item.value.substring(0, 30)}... (${modeLabel})`);

      updateContinuousProgressModal({
        success: successCount,
        step: '발행 완료',
        log: '성공적으로 발행되었습니다.',
        percentage: (currentIdx / totalCount) * 100
      });

    } catch (error) {
      item.status = 'failed';
      failCount++;
      appendLog(`❌ 실패: ${(error as Error).message}`);

      updateContinuousProgressModal({
        fail: failCount,
        step: '발행 실패',
        log: `오류: ${(error as Error).message}`,
        percentage: (currentIdx / totalCount) * 100
      });
    }

    renderQueueListV2();

    // 다음 항목 대기
    const nextPending = continuousQueueV2.find(it => it.status === 'pending');
    if (nextPending && isContinuousMode) {
      const waitOk = await waitWithInterrupt(item.interval);
      if (!waitOk) break;
    }
  }

  // 완료 처리
  if (isContinuousMode) {
    isContinuousMode = false;
    if (startBtn) (startBtn as HTMLElement).style.display = 'flex';
    if (stopBtn) (stopBtn as HTMLElement).style.display = 'none';
    if (statusIndicator) statusIndicator.style.background = '#10b981';
    if (statusText) statusText.textContent = '발행 완료';

    updateContinuousProgressModal({
      step: '🎉 모든 작업 완료',
      log: `총 ${totalCount}개 중 ${successCount}개 성공, ${failCount}개 실패`,
      percentage: 100
    });

    appendLog('✅ 모든 연속 발행 완료!');
    toastManager.success(`모든 발행이 완료되었습니다! (성공: ${successCount}, 실패: ${failCount})`);

    // ✅ [2026-01-20 추가] 메모리 정리 - 연속발행 완료 후 이미지 데이터 초기화
    try {
      console.log('[Continuous] 🧹 메모리 정리 시작...');

      // 전역 이미지 배열 초기화
      (window as any).generatedImages = [];
      (window as any).imageManagementGeneratedImages = [];
      (window as any).continuousPresetThumbnail = null;
      (window as any).continuousPresetThumbnailPath = null;

      // ImageManager 초기화
      if (typeof ImageManager !== 'undefined') {
        ImageManager.clear();
      }

      // 연속발행 큐 완료 항목 정리 (pending 상태만 유지)
      // continuousQueueV2는 UI 표시용이므로 유지

      console.log('[Continuous] ✅ 메모리 정리 완료');
    } catch (memErr) {
      console.warn('[Continuous] 메모리 정리 중 오류:', memErr);
    }

    // 3초 후 모달 자동 닫기 (사용자가 결과를 볼 수 있게)
    setTimeout(() => {
      const modal = document.getElementById('continuous-progress-modal');
      if (modal) modal.style.display = 'none';
    }, 4000);
  }
}
(window as any).startContinuousPublishingV2 = startContinuousPublishingV2;

// ✅ 다음 5개 건너뛰기
function skipNextFiveItemsV2(): void {
  if (continuousQueueV2.length === 0) {
    toastManager.warning('대기열이 비어있습니다.');
    return;
  }

  // pending 상태인 항목 중 앞에서 5개 제거
  let removedCount = 0;
  for (let i = 0; i < continuousQueueV2.length && removedCount < 5; i++) {
    if (continuousQueueV2[i].status === 'pending') {
      continuousQueueV2.splice(i, 1);
      i--; // 인덱스 조정
      removedCount++;
    }
  }

  if (removedCount > 0) {
    toastManager.success(`${removedCount}개 항목을 건너뛰었습니다.`);
    renderQueueListV2();
  } else {
    toastManager.warning('건너뛸 대기 중인 항목이 없습니다.');
  }
}
(window as any).skipNextFiveItemsV2 = skipNextFiveItemsV2;
(window as any).stopContinuousMode = stopContinuousMode;

function startContinuousModeEnhanced(queue: typeof continuousPublishQueue): void {
  continuousPublishQueue = [...queue];
  isContinuousMode = true;
  processNextInQueueEnhanced();
}

async function processNextInQueueEnhanced(): Promise<void> {
  if (!isContinuousMode || continuousPublishQueue.length === 0) {
    if (continuousPublishQueue.length === 0) {
      appendLog('✅ 모든 연속 발행 완료!');
      stopContinuousMode('complete');
    }
    return;
  }

  const item = continuousPublishQueue.shift();
  if (!item) return;

  const remaining = continuousPublishQueue.length;
  appendLog(`📝 [${remaining + 1}개 남음] ${item.type === 'url' ? 'URL' : '키워드'}: ${item.value.substring(0, 50)}...`);

  try {
    if (item.type === 'url') {
      // URL 기반 발행 (suppressModal: true)
      await generateContentFromUrl(item.value, undefined, item.toneStyle, true);
    } else if (item.type === 'keyword') {
      // 키워드 기반 발행 (suppressModal: true)
      await generateContentFromKeywords('', item.value, item.toneStyle, true);
    }

    // 콘텐츠 생성 후 발행
    const structuredContent = (window as any).currentStructuredContent;
    if (structuredContent) {
      await executeContinuousPublish(structuredContent, item.publishMode, item.scheduleDate);
    }

    appendLog(`✅ 발행 완료: ${item.value.substring(0, 30)}...`);
  } catch (error) {
    appendLog(`❌ 발행 실패: ${(error as Error).message}`);
  }

  // 다음 항목 처리 (사용자 설정 시간 대기)
  if (continuousPublishQueue.length > 0) {
    const intervalInput = document.getElementById('continuous-interval-seconds') as HTMLInputElement;
    const userInterval = intervalInput ? parseInt(intervalInput.value) || 30 : 30;
    const waitTime = Math.max(5, Math.min(3600, userInterval));
    appendLog(`⏰ ${waitTime}초 후 다음 발행 시작...`);
    setTimeout(() => processNextInQueueEnhanced(), waitTime * 1000);
  } else {
    appendLog('✅ 모든 연속 발행 완료!');
    stopContinuousMode('complete');
  }
}

// ✅ 연속 발행 실행 (발행 모드 지원)
async function executeContinuousPublish(structuredContent: any, publishMode: string, scheduleDate?: string): Promise<void> {
  // ✅ 사용자 설정 이미지 소스 가져오기 (리뉴얼 모달: select 우선, 구형 UI: radio fallback)
  const imageSourceSelect = document.getElementById('continuous-image-source-select') as HTMLSelectElement | null;
  const imageSourceRadio = document.querySelector('input[name="continuous-image-source"]:checked') as HTMLInputElement | null;
  const imageSource = imageSourceSelect?.value || imageSourceRadio?.value || 'nano-banana-pro';
  const skipImages = imageSource === 'skip';

  // ✅ 연속발행: 1번 이미지 텍스트 포함 옵션
  const includeThumbnailTextEl = document.getElementById('continuous-include-thumbnail-text') as HTMLInputElement | null;
  const includeThumbnailText = includeThumbnailTextEl?.checked || false;

  console.log(`[Continuous] 이미지 소스: ${imageSource}, 이미지 건너뛰기: ${skipImages}, 1번 텍스트 포함: ${includeThumbnailText}`);

  const formData = {
    mode: 'full-auto',
    generator: (document.getElementById('unified-generator') as HTMLSelectElement)?.value || 'gemini',
    toneStyle: (document.getElementById('unified-tone-style') as HTMLInputElement)?.value || 'friendly',
    structuredContent,
    imageSource: skipImages ? 'nano-banana-pro' : imageSource,
    skipImages,
    publishMode, // publish, draft, schedule
    scheduleDate,
    includeThumbnailText,
  };

  await executeUnifiedAutomation(formData);
}

// API 키 및 풀오토 발행 테스트 함수들
async function testApiKeysAndFullAuto() {
  console.log('[Test] API 키 및 풀오토 발행 테스트 시작');

  try {
    // 1. 현재 설정된 API 키들 확인
    const config = await window.api.getConfig();
    console.log('[Test] 현재 설정:', {
      'gemini-api-key': config['gemini-api-key'] ? config['gemini-api-key'].substring(0, 20) + '...' : '없음',
      'openai-api-key': config['openai-api-key'] ? config['openai-api-key'].substring(0, 20) + '...' : '없음',
      'claude-api-key': config['claude-api-key'] ? config['claude-api-key'].substring(0, 20) + '...' : '없음',
      'pexels-api-key': config['pexels-api-key'] ? config['pexels-api-key'].substring(0, 20) + '...' : '없음'
    });

    appendLog('🔑 API 키 상태 확인 중...');
    appendLog(`🤖 Gemini API: ${config['gemini-api-key'] ? '설정됨' : '미설정'}`);
    appendLog(`🧠 OpenAI API: ${config['openai-api-key'] ? '설정됨' : '미설정'}`);
    appendLog(`🦾 Claude API: ${config['claude-api-key'] ? '설정됨' : '미설정'}`);
    appendLog(`📷 Pexels API: ${config['pexels-api-key'] ? '설정됨' : '미설정'}`);

    // 2. API 키 유효성 간단 테스트 (실제 호출은 하지 않음)
    appendLog('🧪 API 키 유효성 테스트 시작...');

    if (config['gemini-api-key']) {
      appendLog('✅ Gemini API 키가 설정되어 있습니다');
    }
    if (config['openai-api-key']) {
      appendLog('✅ OpenAI API 키가 설정되어 있습니다');
    }
    if (config['claude-api-key']) {
      appendLog('✅ Claude API 키가 설정되어 있습니다');
    }
    if (config['pexels-api-key']) {
      appendLog('✅ Pexels API 키가 설정되어 있습니다');
    }

    // 3. 풀오토 발행 테스트용 데이터 준비
    appendLog('🚀 풀오토 발행 테스트 준비 중...');

    // 테스트용 URL (실제로는 사용자가 입력한 값 사용)
    const testUrls = ['https://example.com/test-article'];
    const testTitle = 'API 테스트용 제목';
    const testKeywords = '테스트, API, 자동화';

    // 4. 풀오토 발행 시뮬레이션 (실제로는 handleFullAutoPublish 호출)
    appendLog('📝 풀오토 발행 시뮬레이션 시작...');

    // 콘텐츠 생성 단계
    appendLog('🔄 콘텐츠 생성 단계...');
    try {
      // 실제로는 generateContentFromUrl 호출
      appendLog('📡 URL에서 콘텐츠 생성 시도...');
      // await generateContentFromUrl(testUrls[0]); // 실제 호출하려면 주석 해제

      appendLog('✅ 콘텐츠 생성 완료 (시뮬레이션)');
    } catch (error) {
      appendLog(`❌ 콘텐츠 생성 실패: ${(error as Error).message}`);
    }

    // 이미지 생성 단계
    appendLog('🎨 이미지 생성 단계...');
    try {
      // 실제로는 이미지 생성 API 호출
      appendLog('🖼️ 이미지 생성 시도...');
      appendLog('✅ 이미지 생성 완료 (시뮬레이션)');
    } catch (error) {
      appendLog(`❌ 이미지 생성 실패: ${(error as Error).message}`);
    }

    // 발행 단계
    appendLog('📤 블로그 발행 단계...');
    try {
      // 실제로는 executeBlogPublishing 호출
      appendLog('📝 블로그 발행 시도...');
      appendLog('✅ 블로그 발행 완료 (시뮬레이션)');
    } catch (error) {
      appendLog(`❌ 블로그 발행 실패: ${(error as Error).message}`);
    }

    appendLog('🎉 API 키 및 풀오토 발행 테스트 완료!');

  } catch (error) {
    console.error('[Test] 테스트 실패:', error);
    appendLog(`❌ 테스트 실패: ${(error as Error).message}`);
  }
}

// 실제 풀오토 발행 테스트 (실제 API 호출)
async function runRealFullAutoTest() {
  console.log('[RealTest] 실제 풀오토 발행 테스트 시작');

  try {
    appendLog('🔥 실제 풀오토 발행 테스트 시작...');

    // 테스트용 데이터
    const testFormData = {
      mode: 'full-auto',
      generator: 'gemini',
      targetAge: 'all',
      toneStyle: 'professional',
      imageSource: 'pollinations',
      skipImages: false,
      publishMode: 'publish',
      scheduleDate: undefined,
      title: 'API 테스트 - 자동화 시스템 확인',
      keywords: '테스트, API, 자동화, 네이버 블로그',
      urls: [] // URL 없이 키워드 기반으로 테스트
    };

    appendLog('📝 테스트용 콘텐츠 생성 시작...');

    // 실제 콘텐츠 생성 호출
    await generateContentFromKeywords(
      testFormData.title,
      testFormData.keywords
    );

    // 생성된 콘텐츠 확인 (전역 변수에서 가져옴)
    const structuredContent = (window as any).currentStructuredContent;

    if (structuredContent) {
      appendLog('✅ 콘텐츠 생성 성공!');
      appendLog(`📄 제목: ${structuredContent.selectedTitle}`);
      appendLog(`📝 본문 길이: ${structuredContent.bodyPlain?.length || 0}자`);
      appendLog(`🏷️ 해시태그: ${structuredContent.hashtags?.join(', ') || '없음'}`);

      // 실제 이미지 생성 테스트 (생략 가능)
      appendLog('🎨 이미지 생성 단계 (테스트에서는 생략)...');

      // 실제 발행 테스트 (주의: 실제로 발행됨)
      const confirmPublish = confirm('⚠️ 실제로 블로그에 발행하시겠습니까? (테스트용)');
      if (confirmPublish) {
        appendLog('📤 실제 블로그 발행 시작...');

        // 실제 발행 실행
        await executeUnifiedAutomation({
          ...testFormData,
          structuredContent
        });

        appendLog('🎉 실제 발행 테스트 완료!');
      } else {
        appendLog('ℹ️ 발행 테스트를 취소했습니다.');
      }
    } else {
      appendLog('❌ 콘텐츠 생성 실패 - 생성된 콘텐츠를 찾을 수 없습니다');
    }

  } catch (error) {
    console.error('[RealTest] 실제 테스트 실패:', error);
    appendLog(`❌ 실제 테스트 실패: ${(error as Error).message}`);
  }
}

// 전역 함수로 등록
(window as any).switchExternalLinksTab = switchExternalLinksTab;
(window as any).toggleContinuousModeModal = toggleContinuousModeModal;
(window as any).startContinuousPublishing = startContinuousPublishing;
(window as any).stopContinuousMode = stopContinuousMode;
(window as any).testApiKeysAndFullAuto = testApiKeysAndFullAuto;
(window as any).runRealFullAutoTest = runRealFullAutoTest;
(window as any).showImageModal = showImageModal; // ✅ 이미지 크게 보기
(window as any).showHeadingImagesModal = showHeadingImagesModal;

// 달력 날짜 메모 모달
const calendarDateCloseButtons = Array.from(document.querySelectorAll<HTMLButtonElement>('[data-close-calendar-date]'));
const selectedDateText = document.getElementById('selected-date-text') as HTMLHeadingElement;
const calendarDateMemoInput = document.getElementById('calendar-date-memo') as HTMLTextAreaElement;
const saveDateMemoBtn = document.getElementById('save-date-memo-btn') as HTMLButtonElement;
const calendarDatePostsList = document.getElementById('calendar-date-posts-list') as HTMLDivElement;

// ✅ [2026-01-25 모듈화] 발행 글 저장소 유틸리티
// getPublishedPostsKey, loadPublishedPosts, savePublishedPost,
// GENERATED_POSTS_KEY, POSTS_MIGRATION_DONE_KEY,
// getPostsStorageKey, getCurrentNaverId
// → ./utils/postStorageUtils.js로 이동됨 (상단 import 참조)

interface GeneratedPost {
  id: string;
  title: string;
  content: string;
  hashtags: string[];
  headings: any[];
  structuredContent?: StructuredContent; // ✅ 전체 구조화된 콘텐츠 저장
  createdAt: string;
  updatedAt?: string; // ✅ 마지막 수정일
  images?: Array<{ heading?: string; filePath?: string; previewDataUrl?: string; provider?: string; savedToLocal?: boolean; url?: string; thumbnail?: string }>;
  imageCount?: number; // ✅ 이미지 개수
  isFavorite?: boolean; // ✅ 즐겨찾기
  category?: string; // ✅ 카테고리
  publishedUrl?: string; // ✅ 발행된 URL
  publishedAt?: string; // ✅ 발행일
  isPublished?: boolean; // ✅ 발행 상태
  toneStyle?: string; // ✅ 글 톤 저장
  ctaText?: string; // ✅ CTA 텍스트
  ctaLink?: string; // ✅ CTA 링크
  ctas?: Array<{ text: string; link?: string }>; // ✅ CTA 여러개
  articleType?: string; // ✅ 기사 유형 (레거시 호환용)
  naverId?: string; // ✅ [2026-01-22] 계정 ID (계정별 분리용)
  affiliateLink?: string; // ✅ [2026-01-22] 제휴링크 (쇼핑커넥트 글 구분용)
  contentMode?: string; // ✅ [2026-01-22] 콘텐츠 모드 (shopping-connect, seo, homefeed 등)
}

// ✅ [100점 수정] 카테고리 정규화 매핑 테이블 (영어 → 한글 통일)
// ✅ [2026-01-23] 네이버 블로그 카테고리를 앱의 콘텐츠 카테고리로 포괄적 매핑
// ✅ [2026-01-25 모듈화] CATEGORY_NORMALIZE_MAP, normalizeCategory
// → ./utils/categoryNormalizeUtils.js로 이동됨 (상단 import 참조)



/**

 * ✅ [100점 수정] 기존 저장된 글의 카테고리 마이그레이션
 * 영어 카테고리를 한글로 자동 통일
 */
function migratePostCategories(): number {
  try {
    const data = localStorage.getItem(GENERATED_POSTS_KEY);
    if (!data) return 0;

    const posts: GeneratedPost[] = JSON.parse(data);
    let migrated = 0;

    posts.forEach(post => {
      const oldCategory = post.category || post.articleType || '';
      const normalized = normalizeCategory(oldCategory);

      if (normalized && normalized !== post.category) {
        post.category = normalized;
        migrated++;
        console.log(`[Migration] "${post.title}" 카테고리: "${oldCategory}" → "${normalized}"`);
      }
    });

    if (migrated > 0) {
      localStorage.setItem(GENERATED_POSTS_KEY, JSON.stringify(posts));
      console.log(`[Migration] ✅ ${migrated}개 글 카테고리 정규화 완료`);
    }

    return migrated;
  } catch (error) {
    console.error('[Migration] 카테고리 마이그레이션 실패:', error);
    return 0;
  }
}

// ✅ 앱 시작 시 마이그레이션 자동 실행
let categoryMigrationDone = false;
function ensureCategoryMigration(): void {
  if (categoryMigrationDone) return;
  categoryMigrationDone = true;
  const count = migratePostCategories();
  if (count > 0) {
    console.log(`[Migration] 🔄 ${count}개 글 카테고리가 한글로 통일되었습니다.`);
  }
}

function saveGeneratedPost(structuredContent: any, isUpdate: boolean = false, overrides?: { category?: string }): string | null {
  try {
    const posts = loadGeneratedPosts();
    const title = structuredContent.selectedTitle || '';

    // ✅ 중복 저장 방지: 같은 제목의 글이 60초 이내에 저장되었으면 해당 postId 재사용
    if (!isUpdate && title) {
      const now = Date.now();
      const recentPost = posts.find(p => {
        const createdAt = new Date(p.createdAt).getTime();
        const isRecent = (now - createdAt) < 60000; // 60초 이내
        const sameTitle = p.title === title;
        return isRecent && sameTitle;
      });

      if (recentPost) {
        console.log(`[saveGeneratedPost] 중복 방지: 같은 제목의 글이 최근에 저장됨 (ID: ${recentPost.id})`);
        currentPostId = recentPost.id;
        return recentPost.id; // 기존 postId 반환 (새로 저장하지 않음)
      }
    }

    // ✅ 새 글 저장은 항상 새 postId 생성 (이전 글 덮어쓰기 방지)
    // ✅ 업데이트 저장(isUpdate=true)만 currentPostId 재사용
    const postId = (isUpdate && currentPostId)
      ? currentPostId
      : `post_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    currentPostId = postId; // 전역 변수에 저장

    const now = new Date().toISOString();

    // 기존 글 찾기
    const existingIndex = posts.findIndex(p => p.id === postId);
    const existingPost = existingIndex >= 0 ? posts[existingIndex] : null;

    // ✅ CTA 필드 값 가져오기
    const ctas = readUnifiedCtasFromUi();
    const ctaText = ctas[0]?.text || (document.getElementById('unified-cta-text') as HTMLInputElement)?.value?.trim() || '';
    const ctaLink = ctas[0]?.link || (document.getElementById('unified-cta-link') as HTMLInputElement)?.value?.trim() || '';

    // ✅ [100점 수정] 카테고리: 블로그 폴더 카테고리 우선 사용 (기사 유형이 아님!)
    const blogFolderCategory = UnifiedDOMCache.getRealCategory() || '';
    const categoryFromContent = String((structuredContent as any)?.category || '').trim();
    // ✅ overrides.category 우선 적용, 그 다음 블로그 폴더, 콘텐츠 순
    const rawCategory = overrides?.category || blogFolderCategory || categoryFromContent || (existingPost?.category || '');
    // ✅ 카테고리 정규화 적용 (영어 → 한글 통일)
    const resolvedCategory = normalizeCategory(rawCategory);

    const imagesForSave = (() => {
      try {
        const fromWindow = (window as any).imageManagementGeneratedImages;
        if (Array.isArray(fromWindow) && fromWindow.length > 0) return fromWindow;
      } catch {
        // ignore
      }
      try {
        const fromManager = ImageManager.getAllImages();
        if (Array.isArray(fromManager) && fromManager.length > 0) return fromManager;
      } catch {
        // ignore
      }
      return Array.isArray(generatedImages) ? generatedImages : [];
    })();

    const normalizedImagesForSave = (imagesForSave || []).map((img: any) => ({
      heading: img.heading || '',
      provider: img.provider || img.source || img.engine || 'unknown',
      filePath: img.filePath || img.url || img.previewDataUrl || '',
      previewDataUrl: img.previewDataUrl || img.url || img.filePath || '',
      url: img.url || img.link || img.previewDataUrl || img.filePath || '',
      thumbnail: img.thumbnail || '',
      savedToLocal: img.savedToLocal || false,
    }));

    // ✅ [2026-01-22] 현재 계정 ID 가져오기
    const currentNaverId = getCurrentNaverId();

    // ✅ [2026-01-22] 쇼핑커넥트 모드 정보 가져오기
    const affiliateLinkInput = document.getElementById('unified-affiliate-link') as HTMLInputElement | null;
    const affiliateLinkValue = affiliateLinkInput?.value?.trim() || structuredContent.affiliateLink || '';
    const contentModeValue = structuredContent.contentMode ||
      (document.querySelector('input[name="article-type"]:checked') as HTMLInputElement)?.value ||
      'seo';

    const post: GeneratedPost = {
      id: postId,
      title: structuredContent.selectedTitle || '',
      content: structuredContent.bodyPlain || structuredContent.content || '',
      hashtags: structuredContent.hashtags || [],
      headings: structuredContent.headings || [],
      structuredContent: structuredContent, // ✅ 전체 구조화된 콘텐츠 저장
      createdAt: existingPost?.createdAt || now, // 기존 생성일 유지
      updatedAt: isUpdate ? now : (existingPost?.updatedAt || now), // 업데이트 시에만 수정일 갱신
      // ✅ 새 글에서는 이전 글 이미지 상속 금지 (미리보기 이미지 섞임 방지)
      images: normalizedImagesForSave.length > 0
        ? normalizedImagesForSave
        : (isUpdate ? (existingPost?.images || undefined) : undefined),
      isFavorite: existingPost?.isFavorite || false, // 기존 즐겨찾기 유지
      category: resolvedCategory || undefined,
      publishedUrl: existingPost?.publishedUrl || undefined, // 기존 발행 URL 유지
      publishedAt: existingPost?.publishedAt || undefined, // 기존 발행일 유지
      toneStyle: structuredContent.toneStyle || 'professional', // ✅ 글 톤 저장
      ctaText: ctaText || existingPost?.ctaText || '', // ✅ CTA 텍스트 저장
      ctaLink: ctaLink || existingPost?.ctaLink || '', // ✅ CTA 링크 저장
      ctas: ctas.length > 0 ? ctas : (existingPost as any)?.ctas || undefined,
      naverId: currentNaverId || existingPost?.naverId || undefined, // ✅ [2026-01-22] 계정 ID 저장
      // ✅ [2026-01-22] 쇼핑커넥트 구분용 필드 추가
      affiliateLink: affiliateLinkValue || existingPost?.affiliateLink || undefined,
      contentMode: contentModeValue || existingPost?.contentMode || undefined,
    };

    // 기존 글 업데이트 또는 새로 추가
    if (existingIndex >= 0) {
      posts[existingIndex] = post; // 기존 글 업데이트
    } else {
      posts.unshift(post); // 최신 글을 맨 위에
      if (posts.length > 100) posts.pop(); // 최대 100개만 저장
    }

    // ✅ [2026-01-24 FIX] 전역 저장소에 저장 (계정별 분리 제거)
    safeLocalStorageSetItem(GENERATED_POSTS_KEY, JSON.stringify(posts));
    appendLog(`💾 생성된 글이 목록에 저장되었습니다. (ID: ${postId})`);

    // ✅ [2026-01-23 FIX] 저장 후 UI 갱신 (모든 발행 모드에서 글 목록 반영)
    try {
      refreshGeneratedPostsList();
    } catch (e) {
      console.warn('[saveGeneratedPost] UI 갱신 실패:', e);
    }

    return postId;
  } catch (error) {
    console.error('생성된 글 저장 실패:', error);
    return null;
  }
}

// ✅ 발행 완료 시 글 정보 업데이트
// ✅ [2026-01-24 FIX] 전역 저장소 사용 (계정별 분리 제거)
function updatePostAfterPublish(postId: string, publishedUrl: string): void {
  try {
    const posts = loadGeneratedPosts();
    const post = posts.find(p => p.id === postId);
    if (post) {
      post.publishedUrl = publishedUrl;
      post.publishedAt = new Date().toISOString();
      post.updatedAt = new Date().toISOString();
      post.isPublished = true; // ✅ 발행 상태 추가
      post.naverId = getCurrentNaverId() || post.naverId; // ✅ naverId 업데이트

      const index = posts.findIndex(p => p.id === postId);
      if (index >= 0) {
        posts[index] = post;
        safeLocalStorageSetItem(GENERATED_POSTS_KEY, JSON.stringify(posts));
        appendLog(`✅ 발행 정보가 업데이트되었습니다: "${post.title}"`);
        refreshGeneratedPostsList();
      }
    }
  } catch (error) {
    console.error('발행 정보 업데이트 실패:', error);
  }
}

// ✅ 발행 완료 시 이미지 정보 업데이트
// ✅ [2026-01-24 FIX] 전역 저장소 사용 (계정별 분리 제거)
function updatePostImages(postId: string, images: any[]): void {
  try {
    const posts = loadGeneratedPosts();
    const post = posts.find(p => p.id === postId);
    if (post) {
      // 이미지 정보 저장 (URL, provider, heading 등)
      post.images = images.map((img: any) => ({
        heading: img.heading || '',
        provider: img.provider || 'unknown',
        // ✅ 미리보기에서 필요한 필드 보존
        filePath: img.filePath || '',
        previewDataUrl: img.previewDataUrl || '',
        url: img.url || img.link || img.previewDataUrl || img.filePath || '',
        thumbnail: img.thumbnail || '',
        savedToLocal: img.savedToLocal || false,
      }));
      post.imageCount = images.length;
      post.updatedAt = new Date().toISOString();

      // ✅ [2026-01-24 FIX] 전역 저장소에 저장
      const index = posts.findIndex(p => p.id === postId);
      if (index >= 0) {
        posts[index] = post;
        safeLocalStorageSetItem(GENERATED_POSTS_KEY, JSON.stringify(posts));
        appendLog(`✅ 이미지 정보가 업데이트되었습니다: ${images.length}개`);
        refreshGeneratedPostsList();
      }
    }
  } catch (error) {
    console.error('이미지 정보 업데이트 실패:', error);
  }
}

// ✅ [2026-01-24] 기존 계정별 저장소 데이터를 전역 저장소로 병합 마이그레이션
// 계정별 분리를 제거하고 모든 글을 전역 저장소에 통합
const GLOBAL_MIGRATION_DONE_KEY = 'naver_blog_posts_migration_global_done';

function migrateAccountPostsToGlobal(): void {
  if (localStorage.getItem(GLOBAL_MIGRATION_DONE_KEY)) return; // 이미 완료됨

  try {
    console.log('[Migration] 🔄 계정별 저장소 → 전역 저장소 병합 시작...');

    const allPosts: GeneratedPost[] = [];
    const seenIds = new Set<string>();

    // 1. 기존 전역 저장소의 글 먼저 로드
    const globalData = localStorage.getItem(GENERATED_POSTS_KEY);
    if (globalData) {
      const globalPosts: GeneratedPost[] = JSON.parse(globalData);
      globalPosts.forEach(p => {
        if (!seenIds.has(p.id)) {
          seenIds.add(p.id);
          allPosts.push(p);
        }
      });
    }

    // 2. 계정별 저장소에서도 글 병합
    // localStorage의 모든 키를 확인하여 계정별 저장소 찾기
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith('naver_blog_generated_posts_') && key !== GENERATED_POSTS_KEY) {
        try {
          const accountData = localStorage.getItem(key);
          if (accountData) {
            const accountPosts: GeneratedPost[] = JSON.parse(accountData);
            accountPosts.forEach(p => {
              if (!seenIds.has(p.id)) {
                seenIds.add(p.id);
                allPosts.push(p);
              }
            });
            console.log(`[Migration] ✅ ${key}: ${accountPosts.length}개 글 병합`);
          }
        } catch (e) {
          console.warn(`[Migration] ⚠️ ${key} 파싱 실패:`, e);
        }
      }
    }

    // 3. 전역 저장소에 통합 저장
    localStorage.setItem(GENERATED_POSTS_KEY, JSON.stringify(allPosts));
    console.log(`[Migration] ✅ 전역 저장소에 총 ${allPosts.length}개 글 통합 완료`);

    // 마이그레이션 완료 표시
    localStorage.setItem(GLOBAL_MIGRATION_DONE_KEY, 'true');
    console.log(`[Migration] ✅ 전역 저장소 마이그레이션 완료!`);
  } catch (error) {
    console.error('[Migration] ❌ 전역 마이그레이션 실패:', error);
  }
}

// ✅ [레거시 호환] 기존 함수명 유지 (호출부 오류 방지)
function migratePostsToPerAccount(): void {
  migrateAccountPostsToGlobal();
}

// ✅ [2026-01-24 FIX] 계정별 분리 제거 - 전역 저장소에서 모든 글 로드
// 카테고리별로만 필터링하면 되므로 계정 구분 불필요
function loadGeneratedPosts(naverId?: string): GeneratedPost[] {
  // 기존 계정별 데이터를 전역으로 병합 (한 번만)
  migrateAccountPostsToGlobal();

  try {
    const data = localStorage.getItem(GENERATED_POSTS_KEY);
    if (data) {
      return JSON.parse(data);
    }
    return [];
  } catch (error) {
    console.error('생성된 글 목록 로드 실패:', error);
    return [];
  }
}

// ✅ [2026-01-24 FIX] 모든 글 로드 - loadGeneratedPosts와 동일 (계정별 분리 제거됨)
function loadAllGeneratedPosts(): GeneratedPost[] {
  return loadGeneratedPosts();
}

function loadGeneratedPost(postId: string): GeneratedPost | null {
  // 현재 계정에서 먼저 찾기
  const currentPosts = loadGeneratedPosts();
  const found = currentPosts.find(p => p.id === postId);
  if (found) return found;

  // 전역에서도 찾기 (레거시 호환)
  try {
    const globalData = localStorage.getItem(GENERATED_POSTS_KEY);
    if (globalData) {
      const allPosts: GeneratedPost[] = JSON.parse(globalData);
      return allPosts.find(p => p.id === postId) || null;
    }
  } catch { /* ignore */ }

  return null;
}

// ✅ [2026-01-22] 계정별 글 삭제
function deleteGeneratedPost(postId: string): void {
  try {
    const naverId = getCurrentNaverId();
    const key = getPostsStorageKey(naverId);
    const posts = loadGeneratedPosts(naverId);
    const filtered = posts.filter(p => p.id !== postId);
    safeLocalStorageSetItem(key, JSON.stringify(filtered));

    // ✅ 이미지 폴더도 삭제
    if (postId) {
      deletePostImageFolder(postId);
    }

    appendLog(`🗑️ 생성된 글이 삭제되었습니다. (ID: ${postId})`);
  } catch (error) {
    console.error('생성된 글 삭제 실패:', error);
  }
}

// ✅ [2026-01-22] 계정별 글 복사
function copyGeneratedPost(postId: string): void {
  const post = loadGeneratedPost(postId);
  if (!post) {
    alert('글을 찾을 수 없습니다.');
    return;
  }

  try {
    const naverId = getCurrentNaverId();
    const key = getPostsStorageKey(naverId);
    const posts = loadGeneratedPosts(naverId);
    const newPostId = `post_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    const copiedPost: GeneratedPost = {
      ...post,
      id: newPostId,
      createdAt: new Date().toISOString(),
      title: `${post.title} (복사본)`,
      naverId: naverId || post.naverId // 현재 계정으로 설정
    };

    posts.unshift(copiedPost);
    if (posts.length > 100) posts.pop();

    safeLocalStorageSetItem(key, JSON.stringify(posts));
    appendLog(`📋 글이 복사되었습니다. (새 ID: ${newPostId})`);
    refreshGeneratedPostsList();
    alert('✅ 글이 복사되었습니다!');
  } catch (error) {
    console.error('글 복사 실패:', error);
    alert('글 복사에 실패했습니다.');
  }
}

// ✅ [2026-01-25 모듈화] formatContentForPreview, normalizeReadableBodyText, formatParagraph
// → ./utils/textFormatUtils.js로 이동됨 (상단 import 참조)

// ✅ 글 미리보기 (모달) - 실제 블로그처럼 소제목 아래 이미지 배치
function previewGeneratedPost(postId: string): void {
  const post = loadGeneratedPost(postId);
  if (!post) {
    alert('글을 찾을 수 없습니다.');
    return;
  }

  const date = new Date(post.createdAt);
  const dateStr = date.toLocaleString('ko-KR');

  // ✅ 실제 블로그처럼 본문 구성 (소제목 + 내용 + 이미지)
  const buildBlogStyleContent = (): string => {
    const headings = post.headings || [];
    const images = post.images || [];

    // 썸네일 (첫 번째 이미지)
    const thumbnailImage = images.length > 0 ? images[0] : null;
    const thumbnailHtml = thumbnailImage ? `
      <div style="margin-bottom: 1.5rem; text-align: center;">
        <img src="${toFileUrlMaybe(thumbnailImage.previewDataUrl || thumbnailImage.filePath || thumbnailImage.url || '')}" 
             style="max-width: 100%; max-height: 400px; border-radius: 8px; object-fit: contain;" 
             onerror="this.style.display='none';">
      </div>
    ` : '';

    // 도입부 (introduction)
    const introduction = (post as any).introduction;
    const introHtml = introduction ? `
      <div style="margin-bottom: 2rem; line-height: 1.8; color: var(--text-strong);">
        ${introduction.split('\n').map((p: string) => `<p style="margin-bottom: 0.75rem;">${p}</p>`).join('')}
      </div>
    ` : '';

    // 소제목별 콘텐츠 + 이미지
    let contentHtml = '';
    if (headings.length > 0) {
      headings.forEach((heading: any, index: number) => {
        const headingTitle = heading.title || heading;
        const headingContent = heading.content || '';
        // 소제목 이미지 (썸네일 제외하고 인덱스+1)
        const headingImage = images[index + 1] || null;

        contentHtml += `
          <div style="margin-bottom: 2rem;">
            <h3 style="font-size: 1.25rem; font-weight: 700; color: var(--primary); margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 2px solid var(--primary);">
              ${headingTitle}
            </h3>
            ${headingImage ? `
              <div style="margin-bottom: 1rem; text-align: center;">
                <img src="${toFileUrlMaybe(headingImage.previewDataUrl || headingImage.filePath || headingImage.url || '')}" 
                     style="max-width: 100%; max-height: 350px; border-radius: 8px; object-fit: contain;" 
                     onerror="this.style.display='none';">
              </div>
            ` : ''}
            ${headingContent ? `
              <div style="line-height: 1.8; color: var(--text-strong);">
                ${headingContent.split('\n').map((p: string) => `<p style="margin-bottom: 0.75rem;">${p}</p>`).join('')}
              </div>
            ` : ''}
          </div>
        `;
      });
    } else {
      // 소제목이 없으면 기존 방식으로 본문 표시
      contentHtml = `<div style="line-height: 1.8; color: var(--text-strong);">${formatContentForPreview(post.content)}</div>`;
    }

    // 마무리 (conclusion)
    const conclusion = (post as any).conclusion;
    const conclusionHtml = conclusion ? `
      <div style="margin-top: 2rem; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px; line-height: 1.8; color: var(--text-strong);">
        ${conclusion.split('\n').map((p: string) => `<p style="margin-bottom: 0.5rem;">${p}</p>`).join('')}
      </div>
    ` : '';

    return thumbnailHtml + introHtml + contentHtml + conclusionHtml;
  };

  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.7); z-index: 10000; display: flex;
    align-items: center; justify-content: center; padding: 2rem;
  `;

  modal.innerHTML = `
    <div style="background: var(--bg-primary); border-radius: 12px; padding: 2rem; max-width: 800px; width: 100%; max-height: 90vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.3); position: relative;">
      <button type="button" class="close-preview-btn" style="position: absolute; top: 1rem; right: 1rem; background: var(--bg-tertiary); border: none; border-radius: 50%; width: 32px; height: 32px; cursor: pointer; font-size: 1.25rem; display: flex; align-items: center; justify-content: center;">×</button>
      
      <!-- 제목 -->
      <h2 style="margin: 0 0 0.5rem 0; color: var(--text-strong); font-size: 1.75rem; padding-right: 2rem; line-height: 1.4;">${post.title || '(제목 없음)'}</h2>
      <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 1px solid var(--border-light);">
        📅 ${dateStr} | 📄 ${post.content.length.toLocaleString()}자 | 🖼️ ${post.images?.length || 0}개 이미지
      </div>
      
      <!-- 본문 (블로그 스타일) -->
      <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; margin-bottom: 1.5rem;">
        ${buildBlogStyleContent()}
      </div>
      
      <!-- 해시태그 -->
      ${post.hashtags.length > 0 ? `
        <div style="margin-bottom: 1.5rem;">
          <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
            ${post.hashtags.map(tag => `<span style="background: var(--bg-tertiary); padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.875rem; color: var(--primary);">#${tag.replace(/^#/, '')}</span>`).join('')}
          </div>
        </div>
      ` : ''}
      
      <!-- 버튼 -->
      <div style="display: flex; gap: 0.5rem; margin-top: 1.5rem;">
        <button type="button" class="load-from-preview-btn" data-post-id="${postId}" style="flex: 1; padding: 0.75rem; background: var(--primary); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">📂 불러오기</button>
        ${post.publishedUrl ? `<button type="button" class="open-published-btn" data-url="${post.publishedUrl}" style="padding: 0.75rem 1.5rem; background: #10b981; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">🔗 발행글 보기</button>` : ''}
        <button type="button" class="close-preview-btn" style="padding: 0.75rem 1.5rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 8px; cursor: pointer;">닫기</button>
      </div>
    </div>
  `;

  document.body.appendChild(modal);

  modal.querySelectorAll('.close-preview-btn').forEach(btn => {
    btn.addEventListener('click', () => modal.remove());
  });

  const loadBtn = modal.querySelector('.load-from-preview-btn');
  if (loadBtn) {
    loadBtn.addEventListener('click', () => {
      modal.remove();
      loadGeneratedPostToFields(postId);
    });
  }

  // ✅ 발행글 보기 버튼 이벤트
  const openPublishedBtn = modal.querySelector('.open-published-btn');
  if (openPublishedBtn) {
    openPublishedBtn.addEventListener('click', () => {
      const url = openPublishedBtn.getAttribute('data-url');
      if (url) window.open(url, '_blank');
    });
  }

  modal.addEventListener('click', (e) => {
    if (e.target === modal) modal.remove();
  });
}

// ✅ 글 이미지 폴더 열기
async function openPostImageFolder(postId: string): Promise<void> {
  try {
    if (!window.api.openPath) {
      appendLog('⚠️ 파일 시스템 API를 사용할 수 없습니다.');
      return;
    }

    const basePath = await getRequiredImageBasePath();

    const folderPath = `${basePath}/${postId}`.replace(/\\/g, '/');

    // 폴더 열기 (없으면 자동 생성됨)
    const result = await window.api.openPath(folderPath);

    if (result.success) {
      appendLog(`📂 이미지 폴더 열기: ${postId}`);
    } else {
      appendLog(`❌ 이미지 폴더 열기 실패: ${result.message || '알 수 없는 오류'}`);
    }
  } catch (error) {
    console.error('[Post] 이미지 폴더 열기 실패:', error);
    appendLog(`❌ 이미지 폴더 열기 실패: ${(error as Error).message}`);
  }
}

// ✅ 글 이미지 폴더 삭제
async function deletePostImageFolder(postId: string): Promise<void> {
  try {
    if (!window.api.checkFileExists) {
      console.error('[Delete] 파일 시스템 API를 사용할 수 없습니다.');
      return;
    }

    const basePath = await getRequiredImageBasePath();

    const folderPath = `${basePath}/${postId}`.replace(/\\/g, '/');

    // 폴더 존재 확인
    const exists = await window.api.checkFileExists(folderPath);

    if (exists && window.api.deleteFolder) {
      const result = await window.api.deleteFolder(folderPath);
      if (result) {
        appendLog(`🗑️ 이미지 폴더가 삭제되었습니다: ${postId}`);
      }
    }
  } catch (error) {
    console.error('폴더 삭제 실패:', error);
  }
}

// ✅ 선택한 글만 내보내기 (JSON)
function exportAllPosts(): void {
  try {
    // 체크박스로 선택한 글 가져오기
    const checkboxes = document.querySelectorAll('.post-checkbox:checked') as NodeListOf<HTMLInputElement>;
    const selectedPostIds = Array.from(checkboxes).map(cb => cb.getAttribute('data-post-id')).filter(id => id !== null) as string[];

    let posts: GeneratedPost[];
    if (selectedPostIds.length > 0) {
      // 선택한 글만 내보내기
      const allPosts = loadGeneratedPosts();
      posts = allPosts.filter(post => selectedPostIds.includes(post.id));
      if (posts.length === 0) {
        alert('선택한 글이 없습니다.');
        return;
      }
    } else {
      // 선택한 글이 없으면 전체 내보내기
      posts = loadGeneratedPosts();
      if (posts.length === 0) {
        alert('내보낼 글이 없습니다.');
        return;
      }
    }

    const dataStr = JSON.stringify(posts, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `naver-blog-posts-${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    appendLog(`📥 ${posts.length}개의 글이 내보내졌습니다.${selectedPostIds.length > 0 ? ` (선택한 ${selectedPostIds.length}개)` : ' (전체)'}`);
    alert(`✅ ${posts.length}개의 글이 내보내졌습니다!${selectedPostIds.length > 0 ? `\n\n선택한 ${selectedPostIds.length}개의 글만 내보냈습니다.` : '\n\n전체 글을 내보냈습니다.'}`);
  } catch (error) {
    console.error('글 내보내기 실패:', error);
    alert('글 내보내기에 실패했습니다.');
  }
}

// ✅ 글 가져오기 (JSON) - 선택 가능
function importPosts(): void {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.onchange = async (e) => {
    const file = (e.target as HTMLInputElement).files?.[0];
    if (!file) return;

    try {
      const text = await file.text();
      const importedPosts = JSON.parse(text) as GeneratedPost[];

      if (!Array.isArray(importedPosts)) {
        throw new Error('올바른 형식의 파일이 아닙니다.');
      }

      if (importedPosts.length === 0) {
        alert('가져올 글이 없습니다.');
        return;
      }

      // 여러 글인 경우 선택 모달 표시
      if (importedPosts.length > 1) {
        showImportPostsSelectionModal(importedPosts);
      } else {
        // 글 1개면 바로 가져오기
        await importSelectedPosts([importedPosts[0]]);
      }
    } catch (error) {
      console.error('글 가져오기 실패:', error);
      alert(`글 가져오기에 실패했습니다: ${(error as Error).message}`);
    }
  };
  input.click();
}

// ✅ 가져올 글 선택 모달
function showImportPostsSelectionModal(importedPosts: GeneratedPost[]): void {
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.7); z-index: 10000; display: flex;
    align-items: center; justify-content: center; padding: 2rem;
  `;

  modal.innerHTML = `
    <div style="background: var(--bg-primary); border-radius: 12px; padding: 2rem; max-width: 800px; max-height: 90vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.3); position: relative;">
      <button type="button" class="close-import-modal-btn" style="position: absolute; top: 1rem; right: 1rem; background: var(--bg-tertiary); border: none; border-radius: 50%; width: 32px; height: 32px; cursor: pointer; font-size: 1.25rem; display: flex; align-items: center; justify-content: center;">×</button>
      <h2 style="margin: 0 0 1rem 0; color: var(--text-strong); font-size: 1.5rem;">📤 가져올 글 선택</h2>
      <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 1.5rem;">
        총 ${importedPosts.length}개의 글 중 가져올 글을 선택하세요.
      </div>
      <div style="margin-bottom: 1rem;">
        <button type="button" class="select-all-import-btn" style="padding: 0.5rem 1rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 4px; cursor: pointer; font-size: 0.875rem; margin-right: 0.5rem;">전체 선택</button>
        <button type="button" class="deselect-all-import-btn" style="padding: 0.5rem 1rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 4px; cursor: pointer; font-size: 0.875rem;">전체 해제</button>
      </div>
      <div style="display: flex; flex-direction: column; gap: 0.75rem; max-height: 50vh; overflow-y: auto; margin-bottom: 1.5rem;">
        ${importedPosts.map((post, index) => `
          <div style="padding: 1rem; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border-light);">
            <label style="display: flex; align-items: start; gap: 0.75rem; cursor: pointer;">
              <input type="checkbox" class="import-post-checkbox" data-index="${index}" checked style="margin-top: 0.25rem; width: 18px; height: 18px; cursor: pointer;">
              <div style="flex: 1;">
                <div style="font-weight: 600; color: var(--text-strong); margin-bottom: 0.25rem;">${post.title || '(제목 없음)'}</div>
                <div style="font-size: 0.75rem; color: var(--text-muted);">
                  📄 ${post.content.length.toLocaleString()}자 | 🖼️ ${post.images?.length || 0}개 | 📑 ${post.headings?.length || 0}개
                </div>
              </div>
            </label>
          </div>
        `).join('')}
      </div>
      <div style="display: flex; gap: 0.5rem;">
        <button type="button" class="confirm-import-btn" style="flex: 1; padding: 0.75rem; background: var(--primary); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">가져오기</button>
        <button type="button" class="close-import-modal-btn" style="flex: 1; padding: 0.75rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 8px; cursor: pointer; font-weight: 600;">취소</button>
      </div>
    </div>
  `;

  document.body.appendChild(modal);

  // 전체 선택/해제
  modal.querySelector('.select-all-import-btn')?.addEventListener('click', () => {
    modal.querySelectorAll('.import-post-checkbox').forEach((cb: any) => {
      cb.checked = true;
    });
  });

  modal.querySelector('.deselect-all-import-btn')?.addEventListener('click', () => {
    modal.querySelectorAll('.import-post-checkbox').forEach((cb: any) => {
      cb.checked = false;
    });
  });

  // 가져오기 확인
  modal.querySelector('.confirm-import-btn')?.addEventListener('click', async () => {
    const checkboxes = modal.querySelectorAll('.import-post-checkbox:checked') as NodeListOf<HTMLInputElement>;
    const selectedIndices = Array.from(checkboxes).map(cb => parseInt(cb.getAttribute('data-index') || '0'));
    const selectedPosts = selectedIndices.map(idx => importedPosts[idx]);

    if (selectedPosts.length === 0) {
      alert('가져올 글을 최소 1개 이상 선택해주세요.');
      return;
    }

    modal.remove();
    await importSelectedPosts(selectedPosts);
  });

  // 닫기
  modal.querySelectorAll('.close-import-modal-btn').forEach(btn => {
    btn.addEventListener('click', () => modal.remove());
  });

  modal.addEventListener('click', (e) => {
    if (e.target === modal) modal.remove();
  });
}

// ✅ 선택한 글 가져오기
async function importSelectedPosts(selectedPosts: GeneratedPost[]): Promise<void> {
  try {
    const existingPosts = loadGeneratedPosts();
    const newPosts = selectedPosts.map(post => ({
      ...post,
      id: `post_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, // 새 ID 생성
      createdAt: new Date().toISOString() // 새 생성일
    }));

    const merged = [...newPosts, ...existingPosts];
    const unique = merged.filter((post, index, self) =>
      index === self.findIndex(p => p.id === post.id)
    );

    if (unique.length > 100) {
      unique.splice(100); // 최대 100개만 유지
    }

    localStorage.setItem(GENERATED_POSTS_KEY, JSON.stringify(unique));
    appendLog(`📤 ${newPosts.length}개의 글이 가져와졌습니다.`);
    refreshGeneratedPostsList();
    alert(`✅ ${newPosts.length}개의 글이 가져와졌습니다!`);
  } catch (error) {
    console.error('글 가져오기 실패:', error);
    alert(`글 가져오기에 실패했습니다: ${(error as Error).message}`);
  }
}

// 달력 날짜 모달 열기 함수 (window에 노출)
(window as any).openCalendarDateModal = (dateStr: string): void => {
  if (!calendarDateModal || !dateStr) return;

  const [year, month, day] = (dateStr || '').split('-').map(Number);
  const selectedDate = new Date(year, month - 1, day);
  const weekdays = ['일', '월', '화', '수', '목', '금', '토'];

  // 날짜 텍스트 업데이트
  if (selectedDateText) {
    selectedDateText.textContent = `${year}년 ${month}월 ${day}일 ${weekdays[selectedDate.getDay()]}요일`;
  }

  // 해당 날짜의 메모 로드
  if (calendarDateMemoInput) {
    const memo = loadCalendarMemo(selectedDate);
    calendarDateMemoInput.value = memo;
  }

  // 해당 날짜의 발행 글 로드
  if (calendarDatePostsList) {
    const posts = loadPublishedPosts(selectedDate);
    if (posts.length > 0) {
      calendarDatePostsList.innerHTML = posts.map(post => `
        <div class="calendar-date-post-item" data-url="${post.url}">
          <h4>${post.title}</h4>
          <div class="post-time">발행 시간: ${post.time}</div>
        </div>
      `).join('');

      // 더블클릭 이벤트 추가
      calendarDatePostsList.querySelectorAll('.calendar-date-post-item').forEach(item => {
        item.addEventListener('dblclick', () => {
          const url = item.getAttribute('data-url');
          if (url) {
            window.open(url, '_blank');
          }
        });
      });
    } else {
      calendarDatePostsList.innerHTML = '<p class="calendar-date-empty">발행한 글이 없습니다.</p>';
    }
  }

  // 모달 열기
  calendarDateModal.setAttribute('aria-hidden', 'false');
  calendarDateModal.style.display = 'flex';
};

// 달력 날짜 메모 저장
if (saveDateMemoBtn && calendarDateMemoInput && selectedDateText) {
  saveDateMemoBtn.addEventListener('click', () => {
    const dateStr = selectedDateText.textContent;
    if (!dateStr) return;

    const match = dateStr.match(/(\d+)년\s+(\d+)월\s+(\d+)일/);
    if (match) {
      const [, year, month, day] = match.map(Number);
      const selectedDate = new Date(year, month - 1, day);
      const memo = calendarDateMemoInput.value.trim();
      saveCalendarMemo(selectedDate, memo);
      alert('✅ 메모가 저장되었습니다.');

      // 달력 위젯 새로고침
      const calendarWidgetEl = document.getElementById('calendar-widget');
      if (calendarWidgetEl) {
        initClockAndCalendar();
      }
    }
  });
}

// ✅ 달력 날짜 메모 삭제
const deleteDateMemoBtn = document.getElementById('delete-date-memo-btn') as HTMLButtonElement;
if (deleteDateMemoBtn && calendarDateMemoInput && selectedDateText) {
  deleteDateMemoBtn.addEventListener('click', () => {
    const dateStr = selectedDateText.textContent;
    if (!dateStr) return;

    const match = dateStr.match(/(\d+)년\s+(\d+)월\s+(\d+)일/);
    if (match) {
      if (!confirm('정말로 이 날짜의 메모를 삭제하시겠습니까?')) return;

      const [, year, month, day] = match.map(Number);
      const selectedDate = new Date(year, month - 1, day);

      // 메모 삭제 (빈 문자열로 저장)
      saveCalendarMemo(selectedDate, '');
      calendarDateMemoInput.value = '';
      alert('✅ 메모가 삭제되었습니다.');

      // 달력 위젯 새로고침
      const calendarWidgetEl = document.getElementById('calendar-widget');
      if (calendarWidgetEl) {
        initClockAndCalendar();
      }
    }
  });
}

// 달력 날짜 모달 닫기
calendarDateCloseButtons.forEach(btn => {
  btn.addEventListener('click', () => {
    if (calendarDateModal) {
      calendarDateModal.setAttribute('aria-hidden', 'true');
      calendarDateModal.style.display = 'none';
    }
  });
});

// 모달 배경 클릭 시 닫기
if (calendarDateModal) {
  calendarDateModal.addEventListener('click', (e) => {
    if (e.target === calendarDateModal) {
      calendarDateModal.setAttribute('aria-hidden', 'true');
      calendarDateModal.style.display = 'none';
    }
  });
}

// 포스팅 완료 시 발행 글 저장 (자동화 완료 시)
if (typeof window !== 'undefined' && window.api) {
  window.api.onStatus((status: any) => {
    if (status.success) {
      const titleInput = document.getElementById('post-title') as HTMLInputElement;
      const title = titleInput?.value.trim();
      if (title) {
        const today = new Date();
        // ✅ 실제 발행 URL 사용
        const publishedUrl = status.url || `https://blog.naver.com/`;
        savePublishedPost(today, title, publishedUrl);

        // ✅ 현재 글에도 URL 저장
        if (status.url) {
          if (currentPostId) {
            updatePostAfterPublish(currentPostId, status.url);
          } else {
            // ✅ currentPostId가 없으면 제목으로 글 찾아서 URL 저장
            const posts = loadGeneratedPosts();
            const matchingPost = posts.find(p => p.title === title && !p.publishedUrl);
            if (matchingPost) {
              updatePostAfterPublish(matchingPost.id, status.url);
            }
          }
        }
      }
    }
  });
}

// 외부유입 링크 모달 초기화 (기존 코드와 연동)
const externalLinksTabsContainer = document.getElementById('external-links-tabs') as HTMLDivElement;
const externalLinksContentContainer = document.getElementById('external-links-content') as HTMLDivElement;

function initExternalLinksUI(): void {
  if (!externalLinksTabsContainer || !externalLinksContentContainer) return;

  // 이미 초기화되었으면 스킵
  if (externalLinksTabsContainer.hasAttribute('data-initialized')) {
    return;
  }
  externalLinksTabsContainer.setAttribute('data-initialized', 'true');

  const categories = Object.keys(externalLinks);

  // 탭 버튼 생성
  externalLinksTabsContainer.innerHTML = categories.map((category, index) => {
    return `<button type="button" class="link-tab-button ${index === 0 ? 'active' : ''}" data-link-category="${category}">${category}</button>`;
  }).join('');

  // 패널 생성
  externalLinksContentContainer.innerHTML = categories.map((category, index) => {
    return `
      <div class="links-grade-panel ${index === 0 ? 'active' : ''}">
        <div class="links-grid" id="links-grid-${category}"></div>
      </div>
    `;
  }).join('');

  // 첫 번째 카테고리 렌더링
  if (categories.length > 0) {
    renderExternalLinks(categories[0]);
  }

  // 탭 전환 이벤트 리스너 설정
  externalLinksTabsContainer.addEventListener('click', (e) => {
    const target = e.target as HTMLElement;
    if (target.classList.contains('link-tab-button')) {
      const category = target.getAttribute('data-link-category');
      if (category) {
        // 모든 탭 비활성화
        externalLinksTabsContainer.querySelectorAll('.link-tab-button').forEach(btn => {
          btn.classList.remove('active');
        });
        // 클릭한 탭 활성화
        target.classList.add('active');

        // 모든 패널 숨기기
        externalLinksContentContainer.querySelectorAll('.links-grade-panel').forEach(panel => {
          panel.classList.remove('active');
        });
        // 해당 패널 표시
        const panel = document.getElementById(`links-grid-${category}`)?.parentElement;
        if (panel) {
          panel.classList.add('active');
        }

        // 링크 렌더링
        renderExternalLinks(category);
      }
    }
  });
}

function renderExternalLinks(category: string): void {
  const links = externalLinks[category as keyof typeof externalLinks];
  if (!links) return;

  const gridId = `links-grid-${category}`;
  const grid = document.getElementById(gridId);

  if (!grid) return;

  grid.innerHTML = links.map(link => {
    const url = link.url.startsWith('http') ? link.url : `https://${link.url}`;
    return `
      <a href="${url}" target="_blank" rel="noopener noreferrer" class="external-link-item" data-external-url="${url}">
        <span class="link-name">${link.name}</span>
        <span class="link-url">${url}</span>
      </a>
    `;
  }).join('');

  // 외부 링크 클릭 이벤트 추가
  grid.querySelectorAll('.external-link-item').forEach(item => {
    item.addEventListener('click', async (e) => {
      e.preventDefault();
      const url = (item as HTMLElement).getAttribute('data-external-url');
      if (url && window.api.openExternalUrl) {
        try {
          const result = await window.api.openExternalUrl(url);
          if (!result.success) {
            console.error('외부 URL 열기 실패:', result.message);
            // 실패 시 새 탭으로 열기 시도
            window.open(url, '_blank', 'noopener,noreferrer');
          }
        } catch (error) {
          console.error('외부 URL 열기 오류:', error);
          // 오류 발생 시 새 탭으로 열기 시도
          window.open(url, '_blank', 'noopener,noreferrer');
        }
      } else if (url) {
        // API가 없는 경우 새 탭으로 열기
        window.open(url, '_blank', 'noopener,noreferrer');
      }
    });
  });
}

// 외부유입 링크 모달 초기화
if (externalLinksTabsContainer && externalLinksContentContainer) {
  initExternalLinksUI();
}

// 환경설정 모달 (기존 코드와 연동)
const settingsButton = document.getElementById('settings-button') as HTMLButtonElement;
const openSettingsFromLicense = document.getElementById('open-settings-from-license') as HTMLButtonElement;
const closeSettingsButtons = Array.from(document.querySelectorAll<HTMLButtonElement>('[data-close-settings]'));

if (settingsButton) {
  settingsButton.addEventListener('click', () => {
    if (settingsModal) {
      settingsModal.setAttribute('aria-hidden', 'false');
      settingsModal.style.display = 'flex';
    }
  });
}

if (openSettingsFromLicense) {
  openSettingsFromLicense.addEventListener('click', () => {
    if (licenseModal) {
      licenseModal.setAttribute('aria-hidden', 'true');
      licenseModal.style.display = 'none';
    }
    if (settingsModal) {
      settingsModal.setAttribute('aria-hidden', 'false');
      settingsModal.style.display = 'flex';
    }
  });
}

closeSettingsButtons.forEach(btn => {
  btn.addEventListener('click', () => {
    if (settingsModal) {
      settingsModal.setAttribute('aria-hidden', 'true');
      settingsModal.style.display = 'none';
    }
  });
});

// 외부유입 링크 모달 닫기
const openExternalLinksFromLicense = document.getElementById('open-external-links-from-license') as HTMLButtonElement;
const closeExternalLinksButtons = Array.from(document.querySelectorAll<HTMLButtonElement>('[data-close-external-links]'));

if (openExternalLinksFromLicense) {
  openExternalLinksFromLicense.addEventListener('click', async () => {
    // ✅ 라이선스 체크 완화 - 외부유입 모달 바로 표시
    console.log('[ExternalLinks] 외부유입 모달 열기 (라이선스 모달에서)');

    // 라이선스 확인은 로그만 남기고 모달은 항상 열기
    try {
      const licenseResult = await window.api.getLicense();
      if (licenseResult.license && licenseResult.license.expiresAt) {
        console.log('[ExternalLinks] 라이선스 만료일:', new Date(licenseResult.license.expiresAt).toLocaleDateString('ko-KR'));
      } else {
        console.log('[ExternalLinks] 라이선스 정보 없음 - 기본 모드로 진행');
      }
    } catch (licenseError) {
      console.warn('[ExternalLinks] 라이선스 확인 실패, 기본 모드로 진행:', licenseError);
    }

    // ✅ 외부유입 모달 항상 표시
    if (licenseModal) {
      licenseModal.setAttribute('aria-hidden', 'true');
      licenseModal.style.display = 'none';
    }
    if (externalLinksModal) {
      externalLinksModal.setAttribute('aria-hidden', 'false');
      externalLinksModal.style.display = 'flex';
    }
  });
}

closeExternalLinksButtons.forEach(btn => {
  btn.addEventListener('click', () => {
    if (externalLinksModal) {
      externalLinksModal.setAttribute('aria-hidden', 'true');
      externalLinksModal.style.display = 'none';
    }
  });
});

// ============================================
// 폼 제출 및 자동화 실행 핵심 기능
// ============================================
// 전역 상태 관리
// ============================================
let currentStructuredContent: StructuredContent | null = null;
let generatedImages: Array<{ heading: string; filePath: string; previewDataUrl: string; provider: string; url?: string; savedToLocal?: boolean }> = [];
let automationRunning = false;
let currentPostId: string | null = null; // ✅ 현재 글 ID (이미지 폴더 정리용)

type ImageHistoryEntry = { heading: string; images: any[] };
type ImageHistorySnapshot = ImageHistoryEntry[];

const imageHistoryStack: ImageHistorySnapshot[] = [];
let lastImageHistorySnapshotAt = 0;

function pushImageHistorySnapshot(reason: string): void {
  try {
    const now = Date.now();
    if (now - lastImageHistorySnapshotAt < 150) return;
    lastImageHistorySnapshotAt = now;
    const snapshot: ImageHistorySnapshot = [];
    ImageManager.imageMap.forEach((images, heading) => {
      snapshot.push({
        heading,
        images: images.map((img) => ({ ...img })),
      });
    });
    imageHistoryStack.push(snapshot);
    if (imageHistoryStack.length > 50) {
      imageHistoryStack.shift();
    }
    console.log('[ImageHistory] snapshot pushed:', reason, 'entries:', snapshot.length);
  } catch (error) {
    console.error('[ImageHistory] snapshot push 실패:', error);
  }
}

function undoLastImageChange(): void {
  if (imageHistoryStack.length === 0) {
    if (typeof (toastManager as any)?.warning === 'function') {
      (toastManager as any).warning('되돌릴 이미지 변경 내역이 없습니다.');
    }
    return;
  }

  const snapshot = imageHistoryStack.pop()!;
  try {
    ImageManager.imageMap.clear();
    snapshot.forEach((entry) => {
      const clonedImages = entry.images.map((img) => ({ ...img }));
      ImageManager.imageMap.set(entry.heading, clonedImages);
    });

    syncGlobalImagesFromImageManager();
    ImageManager.syncAllPreviews();

    if (typeof (toastManager as any)?.success === 'function') {
      (toastManager as any).success('마지막 이미지 변경을 되돌렸습니다.');
    }
    appendLog('↩️ 마지막 이미지 변경을 되돌렸습니다.', 'images-log-output');
  } catch (error) {
    console.error('[ImageHistory] undo 실패:', error);
    if (typeof (toastManager as any)?.error === 'function') {
      (toastManager as any).error('이미지 되돌리기 중 오류가 발생했습니다.');
    }
  }
}

// ============================================
// 🎯 통합 이미지 관리 시스템
// ============================================
/**
 * 3개의 미리보기(소제목 분석, 생성된 이미지, 저장된 이미지)를 완전히 연동
 * - 어디서든 이미지 추가/수정/삭제 시 모든 미리보기 자동 동기화
 * - 소제목별 이미지 매핑 관리
 * - 중복 방지 및 일관성 보장
 */
const ImageManager = {
  // 소제목별 이미지 매핑 (heading title -> image array) - ✅ 여러 이미지 지원
  imageMap: new Map<string, any[]>(),
  unsetHeadings: new Set<string>(),

  // 모든 소제목 목록
  headings: [] as any[],

  /**
   * ✅ 모든 이미지 및 상태 초기화
   */
  clearAll(): void {
    console.log('[ImageManager] 모든 데이터 초기화');
    this.imageMap.clear();
    this.unsetHeadings.clear();
    this.headings = [];
    try {
      (window as any).generatedImages = [];
      (window as any).imageManagementGeneratedImages = [];
      (window as any).currentStructuredContent = null;
    } catch {
      // ignore
    }
  },

  resolveHeadingKey(headingTitle: string): string {
    const rawTitle = String(headingTitle || '').trim();
    if (!rawTitle) return rawTitle;
    if (this.imageMap.has(rawTitle)) return rawTitle;

    try {
      const norm = normalizeHeadingKeyForVideoCache(rawTitle);
      if (!norm) return rawTitle;
      const keys = Array.from(this.imageMap.keys()) as string[];
      for (const key of keys) {
        const keyStr = String(key || '').trim();
        if (!keyStr) continue;
        if (keyStr === rawTitle) return keyStr;
        if (normalizeHeadingKeyForVideoCache(keyStr) === norm) return keyStr;
      }
    } catch {
      // ignore
    }

    return rawTitle;
  },

  /**
   * 소제목 목록 설정
   */
  setHeadings(headings: any[]): void {
    console.log('[ImageManager] 소제목 설정:', headings.length, '개');
    this.headings = headings;

    try {
      const normalizedHeadings2 = new Set<string>();
      (Array.isArray(this.headings) ? this.headings : []).forEach((h: any) => {
        const title = typeof h === 'string' ? String(h).trim() : String(h?.title || h || '').trim();
        const n = normalizeHeadingKeyForVideoCache(title);
        if (n) normalizedHeadings2.add(n);
      });
      const unsetKeys = Array.from(this.unsetHeadings.keys()) as string[];
      for (const key of unsetKeys) {
        const n = normalizeHeadingKeyForVideoCache(String(key || '').trim());
        if (n && !normalizedHeadings2.has(n)) {
          this.unsetHeadings.delete(key);
        }
      }
    } catch {
      // ignore
    }

    // ✅ 현재 소제목 목록에 없는 예전(테스트) 이미지 매핑 정리
    try {
      const normalizedHeadings = new Set<string>();
      (Array.isArray(this.headings) ? this.headings : []).forEach((h: any) => {
        const title = typeof h === 'string' ? String(h).trim() : String(h?.title || h || '').trim();
        const n = normalizeHeadingKeyForVideoCache(title);
        if (n) normalizedHeadings.add(n);
      });
      const keys = Array.from(this.imageMap.keys()) as string[];
      for (const key of keys) {
        const n = normalizeHeadingKeyForVideoCache(String(key || '').trim());
        if (n && !normalizedHeadings.has(n)) {
          this.imageMap.delete(key);
        }
      }
    } catch {
      // ignore
    }

    this.syncAllPreviews();
  },

  /**
   * ✅ 이미지 추가 (소제목당 여러 이미지 지원)
   */
  addImage(headingTitle: string, image: any): void {
    try {
      pushImageHistorySnapshot('ImageManager.addImage');
    } catch {
      // ignore
    }
    console.log('[ImageManager] 이미지 추가:', headingTitle);
    const titleKey = this.resolveHeadingKey(headingTitle);
    this.unsetHeadings.delete(titleKey);
    const images = this.imageMap.get(titleKey) || [];
    images.push({
      ...image,
      heading: titleKey,
      timestamp: Date.now()
    });
    this.imageMap.set(titleKey, images);

    this.syncGeneratedImagesArray();
    this.syncAllPreviews();
  },

  setPrimaryImageByKey(headingTitle: string, imageKey: string): void {
    const key = String(imageKey || '').trim();
    if (!key) return;
    try {
      pushImageHistorySnapshot('ImageManager.setPrimaryImageByKey');
    } catch {
      // ignore
    }
    const titleKey = this.resolveHeadingKey(headingTitle);
    const images = this.imageMap.get(titleKey) || [];
    const idx = images.findIndex((img: any) => getStableImageKey(img) === key);
    if (idx < 0) return;
    if (idx > 0) {
      const picked = images.splice(idx, 1)[0];
      images.unshift(picked);
    }
    this.imageMap.set(titleKey, images);
    this.unsetHeadings.delete(titleKey);
    this.syncGeneratedImagesArray();
    this.syncAllPreviews();
    try {
      (window as any).imageManagementGeneratedImages = this.getAllImages();
    } catch {
      // ignore
    }
    try {
      syncGlobalImagesFromImageManager();
    } catch {
      // ignore
    }

    try {
      updatePromptItemsWithImages(this.getAllImages());
    } catch {
      // ignore
    }
  },

  /**
   * ✅ 이미지 설정 (기존 이미지 교체 - 첫 번째 이미지로 설정)
   */
  setImage(headingTitle: string, image: any): void {
    try {
      pushImageHistorySnapshot('ImageManager.setImage');
    } catch {
      // ignore
    }
    console.log('[ImageManager] 이미지 설정:', headingTitle);
    const titleKey = this.resolveHeadingKey(headingTitle);
    this.unsetHeadings.delete(titleKey);
    const existingImages = this.imageMap.get(titleKey) || [];
    const newImage = {
      ...image,
      heading: titleKey,
      timestamp: Date.now()
    };

    // 첫 번째 이미지 교체, 나머지 유지
    if (existingImages.length > 0) {
      existingImages[0] = newImage;
      this.imageMap.set(titleKey, existingImages);
    } else {
      this.imageMap.set(titleKey, [newImage]);
    }

    this.syncGeneratedImagesArray();
    this.syncAllPreviews();
  },

  /**
   * ✅ 소제목의 모든 이미지 제거
   */
  removeImage(headingTitle: string): void {
    try {
      pushImageHistorySnapshot('ImageManager.removeImage');
    } catch {
      // ignore
    }
    console.log('[ImageManager] 이미지 전체 제거:', headingTitle);
    const titleKey = this.resolveHeadingKey(headingTitle);
    this.imageMap.delete(titleKey);
    this.unsetHeadings.add(titleKey);

    this.syncGeneratedImagesArray();
    this.syncAllPreviews();
  },

  /**
   * ✅ 특정 인덱스의 이미지 제거
   */
  removeImageAtIndex(headingTitle: string, index: number): void {
    try {
      pushImageHistorySnapshot('ImageManager.removeImageAtIndex');
    } catch {
      // ignore
    }
    console.log('[ImageManager] 이미지 제거:', headingTitle, '인덱스:', index);
    const titleKey = this.resolveHeadingKey(headingTitle);
    const images = this.imageMap.get(titleKey) || [];
    if (index >= 0 && index < images.length) {
      images.splice(index, 1);

      // ✅ 대표(0번) 삭제 후에도 다른 이미지가 남아있으면 다음 이미지를 대표로 사용
      if (images.length > 0) {
        if (index === 0) {
          const gifIdx = images.findIndex((img: any) => String(img?.provider || '') === 'gif-from-video');
          if (gifIdx >= 0) {
            const gif = images.splice(gifIdx, 1)[0];
            images.unshift(gif);
          }
        }
        this.unsetHeadings.delete(titleKey);
      } else {
        this.unsetHeadings.add(titleKey);
      }

      if (images.length === 0) {
        this.imageMap.delete(titleKey);
      } else {
        this.imageMap.set(titleKey, images);
      }
    }

    this.syncGeneratedImagesArray();
    this.syncAllPreviews();
  },

  /**
   * ✅ 특정 소제목의 이미지 가져오기 (첫 번째 이미지, 호환성 유지)
   */
  getImage(headingTitle: string): any | null {
    const titleKey = this.resolveHeadingKey(headingTitle);
    const images = this.imageMap.get(titleKey);
    if (!images || images.length === 0) return null;

    if (this.unsetHeadings.has(titleKey)) {
      const gif = images.find((img: any) => String(img?.provider || '') === 'gif-from-video');
      return gif || null;
    }

    return images[0];
  },

  isHeadingUnset(headingTitle: string): boolean {
    const titleKey = this.resolveHeadingKey(headingTitle);
    return this.unsetHeadings.has(titleKey);
  },

  /**
   * ✅ 특정 소제목의 모든 이미지 가져오기 (배열)
   */
  getImages(headingTitle: string): any[] {
    const titleKey = this.resolveHeadingKey(headingTitle);
    return this.imageMap.get(titleKey) || [];
  },

  /**
   * ✅ 특정 소제목의 이미지 개수
   */
  getImageCount(headingTitle: string): number {
    const titleKey = this.resolveHeadingKey(headingTitle);
    return (this.imageMap.get(titleKey) || []).length;
  },

  /**
   * 모든 이미지 가져오기 (배열 - 모든 소제목의 모든 이미지)
   */
  getAllImages(): any[] {
    const allImages: any[] = [];
    this.imageMap.forEach((images) => {
      allImages.push(...images);
    });
    return allImages;
  },

  /**
   * 소제목에 이미지가 있는지 확인
   */
  hasImage(headingTitle: string): boolean {
    const titleKey = this.resolveHeadingKey(headingTitle);
    const images = this.imageMap.get(titleKey);
    return images !== undefined && images.length > 0;
  },

  /**
   * 전체 초기화
   */
  clear(): void {
    console.log('[ImageManager] 전체 초기화');
    this.imageMap.clear();
    this.unsetHeadings.clear();
    this.headings = [];
    this.syncGeneratedImagesArray();
    this.syncAllPreviews();
  },

  /**
   * generatedImages 배열 동기화 (모든 소제목의 첫 번째 이미지만)
   */
  syncGeneratedImagesArray(): void {
    generatedImages = [];

    // ✅ 소제목 순서대로 1장씩 유지 (발행/썸네일/매칭 안정화)
    if (Array.isArray(this.headings) && this.headings.length > 0) {
      this.headings.forEach((h: any, idx: number) => {
        const title = typeof h === 'string' ? String(h).trim() : String(h?.title || h || '').trim();
        if (!title) return;
        const img = this.getImage(title);
        if (img) {
          // headingIndex가 없으면 추가
          if (img.headingIndex === undefined || img.headingIndex === null) {
            img.headingIndex = idx;
          }
          generatedImages.push(img);
        }
      });
    } else {
      // fallback
      this.imageMap.forEach((images) => {
        if (images.length > 0) {
          generatedImages.push(images[0]);
        }
      });
    }
    console.log('[ImageManager] generatedImages 동기화:', generatedImages.length, '개');
  },

  /**
   * 모든 미리보기 동기화
   */
  syncAllPreviews(): void {
    console.log('[ImageManager] 모든 미리보기 동기화 시작...');

    // 1. 소제목 분석 미리보기 업데이트
    this.updateHeadingAnalysisPreview();

    // 2. 생성된 이미지 미리보기 업데이트
    this.updateGeneratedImagesPreview();

    // 3. 저장된 이미지 모달 업데이트 (열려있을 경우)
    this.updateLocalImageModal();

    // 4. ✅ 예비 이미지 빠른 교체 썸네일 업데이트
    if (typeof updateReserveImagesThumbnails === 'function') {
      updateReserveImagesThumbnails();
    }

    console.log('[ImageManager] 모든 미리보기 동기화 완료');
  },

  /**
   * 1. 소제목 분석 미리보기 업데이트 (✅ 예비 이미지 빠른 교체 기능 추가)
   */
  updateHeadingAnalysisPreview(): void {
    const promptsContainer = document.getElementById('prompts-container');
    if (!promptsContainer) return;

    // ✅ window 객체를 통해 호출 (모듈 번들링 문제 방지)
    if (typeof (window as any).ensureKenBurnsStyles === 'function') {
      (window as any).ensureKenBurnsStyles();
    } else if (typeof ensureKenBurnsStyles === 'function') {
      ensureKenBurnsStyles();
    }

    const reserveImages: any[] = [];

    const promptItems = promptsContainer.querySelectorAll('.prompt-item');
    promptItems.forEach((item, index) => {
      const headingTitleEl = item.querySelector('.heading-title-text');
      if (!headingTitleEl) return;

      const headingTitle = headingTitleEl.textContent?.trim() || '';
      const image = this.getImage(headingTitle);
      const generatedImageDiv = item.querySelector('.generated-image') as HTMLElement;

      if (!generatedImageDiv) return;

      // ✅ 안전한 HTML 이스케이프 (data- 속성에 복잡한 문자열 넣지 않음)
      const safeTitle = escapeHtml(headingTitle);

      const getFromCache = (window as any).getHeadingVideoPreviewFromCache || getHeadingVideoPreviewFromCache;
      const cachedVideo = getFromCache(headingTitle);
      if (cachedVideo && cachedVideo.url) {
        const safeUrl = escapeHtml(String(cachedVideo.url));
        generatedImageDiv.innerHTML = `
          <div style="position: relative; width: 100%; height: 100%;">
            <video class="heading-video-preview" src="${safeUrl}" muted autoplay loop playsinline preload="metadata" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px; cursor: pointer; background: #000;"></video>
            <div style="position: absolute; top: 4px; right: 4px; display: flex; gap: 4px; z-index: 10;">
              <button class="remove-heading-video-btn" data-heading-index="${index}" data-heading-title="${safeTitle}" style="background: rgba(239, 68, 68, 0.95); color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 0.85rem; font-weight: 900;" title="삭제">✕</button>
            </div>
          </div>
        `;
        generatedImageDiv.style.border = '2px solid var(--success)';
        generatedImageDiv.style.background = 'var(--bg-secondary)';
        const vEl = generatedImageDiv.querySelector('.heading-video-preview') as HTMLVideoElement | null;
        if (vEl) {
          vEl.addEventListener('click', (e) => {
            e.stopPropagation();
            showVideoModal(cachedVideo.url, headingTitle);
          });
          try {
            vEl.play().catch(() => {
              // ignore
            });
          } catch {
            // ignore
          }
        }
        return;
      }

      prefetchHeadingVideoPreview(headingTitle);
      const headingVideoKey = normalizeHeadingKeyForVideoCache(headingTitle);
      if (!headingVideoKey) return;
      if (!headingVideoPreviewCache.has(headingVideoKey) && headingVideoPreviewInFlight.has(headingVideoKey)) {
        const currentHeadingSnapshot = headingTitle;
        const currentItem = item;
        const currentDiv = generatedImageDiv;
        headingVideoPreviewInFlight.get(headingVideoKey)!.then((entry: HeadingVideoPreviewCacheEntry) => {
          if (!entry || !entry.url) return;
          const headingTitleEl2 = currentItem.querySelector('.heading-title-text');
          const stillHeading = String(headingTitleEl2?.textContent || '').trim();
          if (stillHeading !== currentHeadingSnapshot) return;
          const safeUrl2 = escapeHtml(String(entry.url));
          currentDiv.innerHTML = `
            <div style="position: relative; width: 100%; height: 100%;">
              <video class="heading-video-preview" src="${safeUrl2}" muted autoplay loop playsinline preload="metadata" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px; cursor: pointer; background: #000;"></video>
              <div style="position: absolute; top: 4px; right: 4px; display: flex; gap: 4px; z-index: 10;">
                <button class="remove-heading-video-btn" data-heading-index="${index}" data-heading-title="${safeTitle}" style="background: rgba(239, 68, 68, 0.95); color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 0.85rem; font-weight: 900;" title="삭제">✕</button>
              </div>
            </div>
          `;
          currentDiv.style.border = '2px solid var(--success)';
          currentDiv.style.background = 'var(--bg-secondary)';
          const vEl2 = currentDiv.querySelector('.heading-video-preview') as HTMLVideoElement | null;
          if (vEl2) {
            vEl2.addEventListener('click', (e) => {
              e.stopPropagation();
              showVideoModal(entry.url, currentHeadingSnapshot);
            });
            try {
              vEl2.play().catch(() => {
                // ignore
              });
            } catch {
              // ignore
            }
          }
        });
      }

      if (image) {
        const imageRaw = image.url || image.filePath || image.previewDataUrl || '';
        const imageUrl = toFileUrlMaybe(String(imageRaw || '').trim());
        const prompt = image.prompt || headingTitle || '';

        // ✅ 예비 이미지 썸네일 HTML 생성 (최대 5개 표시)
        const reserveThumbnails = reserveImages.slice(0, 5).map((img: any, rIdx: number) => {
          const thumbRaw = img.url || img.filePath || img.previewDataUrl || '';
          const thumbUrl = toFileUrlMaybe(String(thumbRaw || '').trim());
          return `
            <img class="quick-replace-thumb" 
                 src="${thumbUrl}" 
                 data-heading-index="${index}"
                 data-reserve-index="${rIdx}"
                 data-heading-title="${safeTitle}"
                 style="width: 32px; height: 32px; object-fit: cover; border-radius: 4px; cursor: pointer; border: 2px solid transparent; transition: all 0.2s; opacity: 0.7;"
                 onmouseover="this.style.borderColor='#f59e0b'; this.style.opacity='1'; this.style.transform='scale(1.1)';"
                 onmouseout="this.style.borderColor='transparent'; this.style.opacity='0.7'; this.style.transform='scale(1)';"
                 title="클릭하면 이 이미지로 교체">
          `;
        }).join('');

        const hasReserve = reserveImages.length > 0;
        const reserveCountText = hasReserve ? `예비 ${reserveImages.length}개` : '';

        // 이미지 있음 - 표시 (✅ 예비 이미지 빠른 교체 UI 추가)
        generatedImageDiv.innerHTML = `
          <div style="position: relative; width: 100%; height: 100%;">
            <img src="${imageUrl}" 
                 alt="${safeTitle}" 
                 class="ken-burns-media"
                 style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px; cursor: pointer;"
                 onclick="showHeadingImagesModal('${encodeURIComponent(String(headingTitle || '').trim())}','${encodeURIComponent(String(imageUrl || '').trim())}')"
                 title="클릭하면 크게 보기">
            
            <!-- ✅ 상단 버튼들 -->
            <div style="position: absolute; top: 4px; right: 4px; display: flex; gap: 4px; z-index: 10;">
              <button class="remove-image-from-preview-btn" 
                      data-heading-index="${index}"
                      data-heading-title="${safeTitle}"
                      data-image-index="${index}"
                      style="background: rgba(239, 68, 68, 0.95); color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 0.85rem; font-weight: 900;"
                      title="삭제">✕</button>
            </div>
            
            <!-- ✅ 하단: 예비 이미지 빠른 교체 (있으면 표시) -->
            ${hasReserve ? `
            <div style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(transparent, rgba(0,0,0,0.8)); padding: 6px 4px 4px; border-radius: 0 0 8px 8px;">
              <div style="display: flex; align-items: center; gap: 4px; justify-content: center;">
                <span style="color: #f59e0b; font-size: 0.65rem; font-weight: 600; white-space: nowrap;">⚡${reserveCountText}</span>
                <div style="display: flex; gap: 2px; overflow: hidden;">
                  ${reserveThumbnails}
                </div>
                ${reserveImages.length > 5 ? `<span style="color: rgba(255,255,255,0.7); font-size: 0.6rem;">+${reserveImages.length - 5}</span>` : ''}
              </div>
            </div>
            ` : ''}
          </div>
        `;
        generatedImageDiv.style.border = '2px solid var(--success)';
        generatedImageDiv.style.background = 'var(--bg-secondary)';
      } else {
        // 이미지 없음 - 플레이스홀더 (✅ 예비 이미지 있으면 바로 배치 가능)
        if (reserveImages.length > 0) {
          const firstReserve = reserveImages[0];
          const thumbRaw = firstReserve.url || firstReserve.filePath || firstReserve.previewDataUrl || '';
          const thumbUrl = toFileUrlMaybe(String(thumbRaw || '').trim());
          generatedImageDiv.innerHTML = `
            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; gap: 4px;">
              <span style="color: var(--text-muted); font-size: 1.2rem;">🖼️</span>
              <span style="color: var(--text-muted); font-size: 0.65rem;">이미지 없음</span>
              <button class="quick-assign-reserve-btn"
                      data-heading-index="${index}"
                      data-heading-title="${safeTitle}"
                      style="background: linear-gradient(135deg, #f59e0b, #d97706); color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 0.65rem; font-weight: 600;"
                      title="예비 이미지 바로 배치">
                ⚡ 예비에서 배치
              </button>
            </div>
          `;
        } else {
          generatedImageDiv.innerHTML = '<span style="color: var(--text-muted); font-size: 1.5rem;">🖼️</span>';
        }
        generatedImageDiv.style.border = '2px dashed var(--border-color)';
        generatedImageDiv.style.background = 'var(--bg-tertiary)';
      }
    });
  },

  /**
   * 2. 생성된 이미지 미리보기 업데이트 (displayGeneratedImages와 동일한 UI 사용)
   * ✅ [100점 수정] DOM 요소가 없으면 재시도하여 100% 그리드 표시 보장
   */
  updateGeneratedImagesPreview(retryCount: number = 0): void {
    const MAX_RETRIES = 5;
    const RETRY_DELAY_MS = 100;

    const generatedImagesGrid = document.getElementById('generated-images-grid');

    // ✅ DOM 요소가 없으면 재시도 (비동기 렌더링 대응)
    if (!generatedImagesGrid) {
      if (retryCount < MAX_RETRIES) {
        console.log(`[ImageManager] generated-images-grid 찾기 재시도 ${retryCount + 1}/${MAX_RETRIES}`);
        setTimeout(() => this.updateGeneratedImagesPreview(retryCount + 1), RETRY_DELAY_MS);
      } else {
        console.warn('[ImageManager] generated-images-grid 요소를 찾을 수 없습니다 (재시도 횟수 초과)');
      }
      return;
    }

    // ✅ window 객체를 통해 호출 (모듈 번들링 문제 방지)
    if (typeof (window as any).ensureKenBurnsStyles === 'function') {
      (window as any).ensureKenBurnsStyles();
    } else if (typeof ensureKenBurnsStyles === 'function') {
      ensureKenBurnsStyles();
    }

    const images = this.getAllImages();

    // ✅ 이미지가 없으면 안내 메시지 표시
    if (images.length === 0) {
      generatedImagesGrid.style.display = 'flex';
      generatedImagesGrid.style.alignItems = 'center';
      generatedImagesGrid.style.justifyContent = 'center';
      generatedImagesGrid.innerHTML = `
        <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
          <div style="font-size: 3rem; margin-bottom: 1rem;">🖼️</div>
          <div style="font-size: 1rem; margin-bottom: 0.5rem;">이미지가 없습니다</div>
          <div style="font-size: 0.85rem;">이미지 소스를 선택하고 "이미지 생성하기"를 클릭하거나<br>"폴더에서 불러오기"로 이미지를 추가하세요</div>
        </div>
      `;
      return;
    }

    // ✅ 안전한 HTML 이스케이프 함수
    const escapeHtml = (str: string): string => {
      if (!str) return '';
      return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
    };

    // ✅ 그리드 스타일 강제 적용
    generatedImagesGrid.style.display = 'grid';
    generatedImagesGrid.style.gridTemplateColumns = 'repeat(3, 1fr)';
    generatedImagesGrid.style.gap = '1rem';

    generatedImagesGrid.innerHTML = images.map((image, index) => {
      const headingRaw = String(image.heading || `소제목 ${index + 1}`);
      const heading = escapeHtml(headingRaw);
      const prompt = escapeHtml(image.prompt || image.heading || `이미지 ${index + 1}`);
      const imageKey = escapeHtml(String(getStableImageKey(image) || ''));
      const imageRaw = image.url || image.filePath || image.previewDataUrl || '';
      const imageUrl = toFileUrlMaybe(String(imageRaw || '').trim());
      return `
        <div class="generated-image-item" data-image-index="${index}" data-heading-title="${heading}" data-image-key="${imageKey}" style="position: relative; background: var(--bg-secondary); border-radius: 12px; overflow: hidden; border: 2px solid var(--border-light); cursor: pointer; transition: all 0.3s ease; max-width: 220px; box-shadow: none;">
          <div style="position: relative; width: 100%; aspect-ratio: 1/1; overflow: hidden;">
            <img src="${imageUrl}" alt="${heading}" 
                 class="ken-burns-media"
                 style="width: 100%; height: 100%; object-fit: cover; transition: transform 0.3s ease;"
                 onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22%3E%3Crect width=%22100%22 height=%22100%22 fill=%22%232d2d2d%22/%3E%3Ctext x=%2250%22 y=%2250%22 text-anchor=%22middle%22 dominant-baseline=%22middle%22 fill=%22%23666%22 font-size=%228%22%3E이미지 로드 실패%3C/text%3E%3C/svg%3E';">
            <!-- 호버 오버레이 (6개 버튼) -->
            <div class="image-item-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(0,0,0,0.75)); display: none; flex-direction: column; align-items: center; justify-content: center; gap: 5px; padding: 8px; box-sizing: border-box;">
              <button type="button" class="view-image-btn" data-image-url="${imageUrl}" data-image-index="${index}" style="width: 100%; padding: 5px 8px; background: linear-gradient(135deg, #6366f1, #4f46e5); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.7rem; font-weight: 600;">🔍 크게 보기</button>
              <button type="button" class="assign-to-heading-btn" data-image-index="${index}" style="width: 100%; padding: 5px 8px; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.7rem; font-weight: 600;">📍 소제목에 배치</button>
              <button type="button" class="create-video-from-image-btn" data-image-index="${index}" style="width: 100%; padding: 5px 8px; background: linear-gradient(135deg, #22c55e, #16a34a); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.7rem; font-weight: 700;">🎬 영상 만들기</button>
              <button type="button" class="regenerate-single-image-btn" data-image-index="${index}" style="width: 100%; padding: 5px 8px; background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.7rem; font-weight: 600;">🔄 재생성</button>
              <button type="button" class="regenerate-ai-image-btn" data-image-index="${index}" style="width: 100%; padding: 5px 8px; background: linear-gradient(135deg, #8b5cf6, #7c3aed); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.7rem; font-weight: 600;">🤖 AI 이미지 생성</button>
              <button type="button" class="replace-from-folder-btn" data-image-index="${index}" data-heading-title="${heading}" data-image-key="${imageKey}" style="width: 100%; padding: 5px 8px; background: linear-gradient(135deg, #f59e0b, #d97706); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.7rem; font-weight: 600;">📁 폴더에서 교체</button>
              <button type="button" class="remove-generated-image-btn" data-image-index="${index}" data-heading-title="${heading}" data-image-key="${imageKey}" style="width: 100%; padding: 5px 8px; background: linear-gradient(135deg, #ef4444, #dc2626); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.7rem; font-weight: 600;">❌ 삭제</button>
            </div>
          </div>
          <div style="padding: 0.75rem;">
            <div style="font-size: 0.8rem; font-weight: 600; color: var(--text-strong); margin-bottom: 0.25rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${heading}">
            ${heading}
            </div>
            <div style="font-size: 0.7rem; color: var(--text-muted); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${prompt}">
              ${prompt}
            </div>
          </div>
        </div>
      `;
    }).join('');

    // ✅ 호버 이벤트 및 버튼 클릭 이벤트 연결
    this.attachImageItemEvents(generatedImagesGrid);
  },

  /**
   * ✅ 이미지 아이템 호버 이벤트 및 버튼 클릭 이벤트 연결
   */
  attachImageItemEvents(container: HTMLElement): void {
    const images = this.getAllImages();
    const imageItems = container.querySelectorAll('.generated-image-item');

    imageItems.forEach(item => {
      const overlay = item.querySelector('.image-item-overlay') as HTMLElement;
      const img = item.querySelector('img') as HTMLImageElement;
      if (!overlay) return;

      const indexStr = (item as HTMLElement).getAttribute('data-image-index') || '';
      const index = Number(indexStr);

      // 호버 이벤트 (오버레이 표시 + 이미지 확대)
      item.addEventListener('mouseenter', () => {
        overlay.style.display = 'flex';
        if (img) img.style.transform = 'scale(1.05)';
        (item as HTMLElement).style.borderColor = 'var(--primary)';
        (item as HTMLElement).style.boxShadow = '0 8px 24px rgba(59, 130, 246, 0.4)';
        (item as HTMLElement).style.transform = 'translateY(-4px)';
      });

      item.addEventListener('mouseleave', () => {
        overlay.style.display = 'none';
        if (img) img.style.transform = 'scale(1)';
        (item as HTMLElement).style.borderColor = 'var(--border-light)';
        (item as HTMLElement).style.boxShadow = 'none';
        (item as HTMLElement).style.transform = 'translateY(0)';
      });
    });

    // ✅ 크게 보기 버튼
    container.querySelectorAll('.view-image-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const idx = parseInt((e.target as HTMLElement).getAttribute('data-image-index') || '0', 10);
        const image = images[idx];
        const imageUrl = (e.target as HTMLElement).getAttribute('data-image-url') || '';
        const headingTitle = String(image?.heading || '').trim();
        if (headingTitle && imageUrl) {
          showHeadingImagesModal(encodeURIComponent(headingTitle), encodeURIComponent(String(imageUrl || '').trim()));
          return;
        }
        if (imageUrl) showImageModal(imageUrl);
      });
    });

    // ✅ 소제목에 배치하기 버튼
    container.querySelectorAll('.assign-to-heading-btn').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const index = parseInt((e.target as HTMLElement).getAttribute('data-image-index') || '0');
        const image = images[index];
        if (image) {
          await showHeadingSelectionModalV2(image, index);
        }
      });
    });

    // ✅ 선택 이미지로 AI 영상 만들기 (image-to-video)
    container.querySelectorAll('.create-video-from-image-btn').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const index = parseInt((e.target as HTMLElement).getAttribute('data-image-index') || '0');
        const image = images[index];
        if (!image) return;

        if (typeof (window.api as any)?.generateVeoVideo !== 'function') {
          toastManager.error('AI 영상 기능이 아직 로드되지 않았습니다. 앱을 종료 후 다시 실행하세요.');
          return;
        }

        const headingTitleRaw = String(image.heading || '').trim() || `소제목 ${index + 1}`;
        const heading = normalizeHeadingKeyForVideoCache(headingTitleRaw);

        const toLocalPath = (p: string): string => {
          const raw = String(p || '').trim();
          if (!raw) return '';
          if (/^file:\/\//i.test(raw)) {
            return raw.replace(/^file:\/\//i, '').replace(/^\/+/, '').replace(/\\/g, '/');
          }
          // 일반 경로는 그대로
          return raw.replace(/\\/g, '/');
        };

        let filePath = toLocalPath(String(image.filePath || ''));
        let exists = false;
        try {
          if (filePath && typeof (window.api as any)?.checkFileExists === 'function') {
            exists = await (window.api as any).checkFileExists(filePath);
          }
        } catch {
          exists = false;
        }

        if (!filePath || !exists) {
          // 1) file:// URL에서 경로 추출
          const urlCandidate = String(image.url || image.previewDataUrl || '').trim();
          const maybeLocal = toLocalPath(urlCandidate);
          let localFromUrlExists = false;
          try {
            if (maybeLocal && typeof (window.api as any)?.checkFileExists === 'function') {
              localFromUrlExists = await (window.api as any).checkFileExists(maybeLocal);
            }
          } catch {
            localFromUrlExists = false;
          }
          if (maybeLocal && localFromUrlExists) {
            filePath = maybeLocal;
          } else if (/^https?:\/\//i.test(urlCandidate) && typeof (window.api as any)?.downloadAndSaveImage === 'function') {
            // 2) 원격 URL이면 자동 저장 후 사용
            try {
              const postTitle = String((window as any).currentStructuredContent?.selectedTitle || currentStructuredContent?.selectedTitle || '').trim();
              const postId = currentPostId || undefined;
              const res = await (window.api as any).downloadAndSaveImage(urlCandidate, headingTitleRaw, postTitle || undefined, postId);
              if (!res?.success) {
                throw new Error(String(res?.message || '이미지 저장 실패'));
              }
              const savedPath = String(res?.filePath || res?.savedToLocal || '').trim();
              if (!savedPath) {
                throw new Error('저장된 이미지 경로를 찾을 수 없습니다.');
              }
              filePath = toLocalPath(savedPath);

              // ✅ 저장된 로컬 경로로 ImageManager도 갱신(다음부터는 로컬로 인식)
              try {
                ImageManager.setImage(headingTitleRaw, {
                  ...image,
                  heading: headingTitleRaw,
                  filePath,
                  url: toFileUrlMaybe(filePath),
                  previewDataUrl: toFileUrlMaybe(filePath),
                  provider: String(image.provider || 'local'),
                  savedToLocal: true,
                });
                syncGlobalImagesFromImageManager();
                ImageManager.syncAllPreviews();
              } catch {
                // ignore
              }
            } catch (err) {
              toastManager.error(`이미지 저장 실패: ${(err as Error).message}`);
              return;
            }
          } else {
            toastManager.warning('선택한 이미지가 로컬 파일이 아닙니다. 먼저 "이미지 저장하러 가기"로 저장 후 다시 시도하세요.');
            return;
          }
        }

        const imagePrompt = String(image.prompt || '').trim();
        const fallbackText = String(image.heading || heading || `소제목 ${index + 1}`).trim();
        const basePrompt = imagePrompt || fallbackText;
        const prompt = `${basePrompt} . Create a dynamic cinematic video version of this exact scene that closely matches the still image's subject, composition, background, lighting, and mood.`;
        if (!prompt.trim()) {
          toastManager.error('프롬프트가 비어있습니다.');
          return;
        }

        showVeoProgressOverlay(heading);
        setVeoProgressOverlay('이미지 기반 영상 생성 요청 전송 중...', 2);
        try {
          const result = await generateVeoVideoWithRetry(
            {
              prompt,
              negativePrompt: 'audio, speech, voice, voiceover, narration, music, singing, lyrics, dialogue, party, nightclub, dancing crowd, festival, concert',
              model: 'veo-3.1-generate-preview',
              durationSeconds: 6,
              aspectRatio: '16:9',
              heading,
              imagePath: filePath,
            },
            heading
          );

          if (!result?.success) {
            throw new Error(String(result?.message || 'AI 영상 생성에 실패했습니다.'));
          }

          const outPath = String(result.filePath || '').trim();
          if (!outPath) {
            throw new Error('생성된 영상 경로를 찾을 수 없습니다.');
          }

          await applyHeadingVideoFromFile(heading, outPath, 'veo');
          await refreshMp4FilesList();
          toastManager.success('✅ 이미지 기반 AI 영상 생성 완료!');
        } catch (err) {
          console.error('[AI-VIDEO] 이미지 기반 생성 실패:', err);
          toastManager.error(`이미지 기반 AI 영상 생성 실패: ${(err as Error).message}`);
        } finally {
          hideVeoProgressOverlay();
        }
      });
    });

    // ✅ 재생성 버튼
    container.querySelectorAll('.regenerate-single-image-btn').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const index = parseInt((e.target as HTMLElement).getAttribute('data-image-index') || '0');
        const image = images[index];
        const heading = image?.heading || `소제목 ${index + 1}`;
        appendLog(`🔄 ${heading} 이미지 재생성 중...`, 'images-log-output');
        toastManager.info(`🔄 이미지 재생성 중...`);
      });
    });

    // ✅ AI 이미지 새로 생성 버튼
    container.querySelectorAll('.regenerate-ai-image-btn').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const index = parseInt((e.target as HTMLElement).getAttribute('data-image-index') || '0');
        const image = images[index];
        const heading = image?.heading || `소제목 ${index + 1}`;
        await regenerateWithNewAI(index, heading);
      });
    });

    // ✅ 폴더에서 교체 버튼
    container.querySelectorAll('.replace-from-folder-btn').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const el = (e.currentTarget as HTMLElement | null) || (btn as HTMLElement);
        const index = parseInt(String(el?.getAttribute('data-image-index') || '0'), 10);
        const image = images[index];

        // Prefer explicit headingIndex if present, otherwise resolve from heading title
        const headingIndex = Number.isFinite(Number(image?.headingIndex)) ? Number(image?.headingIndex) : -1;
        if (headingIndex >= 0) {
          await showSavedImagesForReplace(headingIndex);
          return;
        }
        const headingTitle = String(image?.heading || '').trim();
        if (headingTitle) {
          const idx = ImageManager.headings.findIndex((h: any) => {
            const t = typeof h === 'string' ? h : (h?.title || '');
            return String(t || '').trim() === headingTitle;
          });
          await showSavedImagesForReplace(idx >= 0 ? idx : 0);
          return;
        }
        await showSavedImagesForReplace(index);
      });
    });

    // ✅ 삭제 버튼
    container.querySelectorAll('.remove-generated-image-btn').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const el = (e.currentTarget as HTMLElement | null) || (btn as HTMLElement);
        const index = parseInt(String(el?.getAttribute('data-image-index') || '0'), 10);
        const image = images[index];
        const headingTitle = String(image?.heading || '').trim();
        const key = String(getStableImageKey(image) || '').trim();

        if (confirm('이 이미지를 제거하시겠습니까?\n\n💡 하이브리드 모드: 일부 이미지만 남기고 나머지는 AI가 자동 생성합니다!')) {
          // ImageManager에서 해당 이미지 1개만 제거 (소제목 전체 삭제 방지)
          if (headingTitle && key) {
            try {
              const list = ImageManager.getImages(headingTitle) || [];
              const idx = list.findIndex((img: any) => getStableImageKey(img) === key);
              if (idx >= 0) {
                ImageManager.removeImageAtIndex(headingTitle, idx);
              } else {
                ImageManager.removeImageAtIndex(headingTitle, 0);
              }
            } catch {
              this.removeImage(headingTitle);
            }
          } else if (headingTitle) {
            this.removeImage(headingTitle);
          }

          toastManager.success(`✅ 이미지가 제거되었습니다!`);
          appendLog(`❌ [${index + 1}] 이미지 제거 완료`, 'images-log-output');
        }
      });
    });
  },

  /**
   * 3. 저장된 이미지 모달 업데이트 (열려있을 경우)
   */
  updateLocalImageModal(): void {
    // 모달이 열려있을 때만 업데이트
    const modal = document.querySelector('[data-modal-type="local-image-selection"]');
    if (!modal) return;

    const headingButtons = modal.querySelectorAll('.heading-select-btn');
    headingButtons.forEach((btn) => {
      const headingIndex = parseInt((btn as HTMLElement).dataset.headingIndex || '0');
      const heading = this.headings[headingIndex];
      const headingTitle = typeof heading === 'string' ? heading : (heading?.title || '');

      const hasImage = this.hasImage(headingTitle);

      if (hasImage) {
        (btn as HTMLElement).style.background = 'linear-gradient(135deg, #10b981, #059669)';
        (btn as HTMLElement).style.color = 'white';
        (btn as HTMLElement).style.borderColor = '#10b981';
        (btn as HTMLElement).style.borderWidth = '2px';
        (btn as HTMLElement).style.fontWeight = '600';

        const btnText = (btn as HTMLElement).textContent || '';
        if (!btnText.startsWith('✅')) {
          (btn as HTMLElement).textContent = '✅ ' + btnText.replace(/^✅\s*/, '');
        }
      } else {
        (btn as HTMLElement).style.background = 'var(--bg-tertiary)';
        (btn as HTMLElement).style.color = 'var(--text-strong)';
        (btn as HTMLElement).style.borderColor = 'var(--border-light)';
        (btn as HTMLElement).style.borderWidth = '1px';
        (btn as HTMLElement).style.fontWeight = '500';

        const btnText = (btn as HTMLElement).textContent || '';
        (btn as HTMLElement).textContent = btnText.replace(/^✅\s*/, '');
      }
    });
  }
};

// ✅ 전역 상태 초기화 함수
function resetGlobalState(): void {
  console.log('[GlobalState] 전역 상태 초기화');
  currentStructuredContent = null;
  generatedImages = [];
  automationRunning = false;
  currentPostId = null;
  ImageManager.clear(); // ✅ 이미지 관리자도 초기화
}

// ✅ 전역 상태 설정 함수
function setGlobalState(key: 'content' | 'images' | 'running' | 'postId', value: any): void {
  switch (key) {
    case 'content':
      currentStructuredContent = value;
      console.log('[GlobalState] currentStructuredContent 설정됨', value?.selectedTitle || '(제목 없음)');
      break;
    case 'images':
      generatedImages = value || [];
      console.log('[GlobalState] generatedImages 설정됨:', generatedImages.length, '개');
      break;
    case 'running':
      automationRunning = value;
      console.log('[GlobalState] automationRunning:', value);
      break;
    case 'postId':
      currentPostId = value;
      console.log('[GlobalState] currentPostId 설정됨:', value);
      break;
  }
}

// ✅ 전역 상태 조회 함수
function getGlobalState<T>(key: 'content' | 'images' | 'running' | 'postId'): T {
  switch (key) {
    case 'content':
      return currentStructuredContent as T;
    case 'images':
      return generatedImages as T;
    case 'running':
      return automationRunning as T;
    case 'postId':
      return currentPostId as T;
    default:
      return null as T;
  }
}

// ============================================
// 이벤트 리스너 중복 방지 시스템
// ============================================
const registeredEventListeners = new Map<string, { element: HTMLElement | Document | Window; type: string; handler: EventListener; }>();

function registerEventListener(
  key: string,
  element: HTMLElement | Document | Window,
  type: string,
  handler: EventListener,
  options?: AddEventListenerOptions
): void {
  // 이미 등록된 리스너가 있으면 제거
  if (registeredEventListeners.has(key)) {
    const existing = registeredEventListeners.get(key)!;
    existing.element.removeEventListener(existing.type, existing.handler);
    console.log(`[EventListener] 기존 리스너 제거: ${key}`);
  }

  // 새 리스너 등록
  element.addEventListener(type, handler, options);
  registeredEventListeners.set(key, { element, type, handler });
  console.log(`[EventListener] 새 리스너 등록: ${key}`);
}

function unregisterEventListener(key: string): void {
  if (registeredEventListeners.has(key)) {
    const { element, type, handler } = registeredEventListeners.get(key)!;
    element.removeEventListener(type, handler);
    registeredEventListeners.delete(key);
    console.log(`[EventListener] 리스너 제거: ${key}`);
  }
}

function clearAllEventListeners(): void {
  console.log(`[EventListener] 모든 리스너 제거: ${registeredEventListeners.size}개`);
  registeredEventListeners.forEach(({ element, type, handler }, key) => {
    element.removeEventListener(type, handler);
  });
  registeredEventListeners.clear();
}

// ============================================
// DOM 쿼리 캐싱 시스템
// ============================================
// ✅ performanceUtils.ts의 domCache를 사용 (중복 방지)
// import { domCache } from './performanceUtils.js'; // 이미 전역에서 사용 가능한 경우

// 기존 performanceUtils의 domCache를 사용하거나, 별도 인스턴스 사용
const rendererDomCache = new Map<string, HTMLElement | null>();
let domCacheEnabled = true;

function getElement<T extends HTMLElement = HTMLElement>(selector: string, refresh = false): T | null {
  if (!domCacheEnabled || refresh || !rendererDomCache.has(selector)) {
    const element = document.querySelector(selector) as T | null;
    if (domCacheEnabled) {
      rendererDomCache.set(selector, element);
    }
    return element;
  }
  return rendererDomCache.get(selector) as T | null;
}

function getElementById<T extends HTMLElement = HTMLElement>(id: string, refresh = false): T | null {
  return getElement<T>(`#${id}`, refresh);
}

function clearDomCache(): void {
  console.log(`[DOMCache] 캐시 클리어: ${rendererDomCache.size}개`);
  rendererDomCache.clear();
}

function disableDomCache(): void {
  domCacheEnabled = false;
  clearDomCache();
}

// ============================================
// API 호출 중복 방지 시스템
// ============================================
const apiCallsInProgress = new Map<string, Promise<any>>();

async function preventDuplicateApiCall<T>(
  key: string,
  apiFunction: () => Promise<T>
): Promise<T> {
  // 이미 진행 중인 API 호출이 있으면 대기
  if (apiCallsInProgress.has(key)) {
    console.log(`[API] 중복 호출 방지: ${key} (이미 진행 중)`);
    return apiCallsInProgress.get(key) as Promise<T>;
  }

  // 새로운 API 호출 시작
  const promise = apiFunction()
    .finally(() => {
      apiCallsInProgress.delete(key);
      console.log(`[API] 호출 완료: ${key}`);
    });

  apiCallsInProgress.set(key, promise);
  console.log(`[API] 호출 시작: ${key}`);
  return promise;
}

// ============================================
// 디바운스/스로틀 유틸리티
// ============================================
function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout | null = null;
  return (...args: Parameters<T>) => {
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };
}

function throttle<T extends (...args: any[]) => any>(
  func: T,
  limit: number
): (...args: Parameters<T>) => void {
  let inThrottle = false;
  return (...args: Parameters<T>) => {
    if (!inThrottle) {
      func(...args);
      inThrottle = true;
      setTimeout(() => (inThrottle = false), limit);
    }
  };
}

// ============================================
// 버튼 상태 관리 시스템
// ============================================
const buttonStates = new Map<string, { disabled: boolean; originalText: string; }>();

function setButtonLoading(buttonId: string, loadingText: string = '처리 중...'): void {
  const button = document.getElementById(buttonId) as HTMLButtonElement;
  if (!button) return;

  // 현재 상태 저장
  if (!buttonStates.has(buttonId)) {
    buttonStates.set(buttonId, {
      disabled: button.disabled,
      originalText: button.innerHTML
    });
  }

  button.disabled = true;
  button.innerHTML = loadingText;
  button.style.opacity = '0.7';
  button.style.cursor = 'not-allowed';
  console.log(`[Button] 로딩 상태: ${buttonId}`);
}

function resetButtonState(buttonId: string): void {
  const button = document.getElementById(buttonId) as HTMLButtonElement;
  if (!button) return;

  const savedState = buttonStates.get(buttonId);
  if (savedState) {
    button.disabled = savedState.disabled;
    button.innerHTML = savedState.originalText;
    button.style.opacity = '';
    button.style.cursor = '';
    buttonStates.delete(buttonId);
    console.log(`[Button] 상태 복원: ${buttonId}`);
  }
}

function disableButton(buttonId: string, disabled: boolean = true): void {
  const button = document.getElementById(buttonId) as HTMLButtonElement;
  if (!button) return;

  button.disabled = disabled;
  console.log(`[Button] disabled=${disabled}: ${buttonId}`);
}

// ============================================
// 에러 핸들링 유틸리티
// ============================================
async function withErrorHandling<T>(
  operation: () => Promise<T>,
  context: string,
  options: {
    showToast?: boolean;
    logError?: boolean;
    fallbackValue?: T;
  } = {}
): Promise<T | undefined> {
  const { showToast = true, logError = true, fallbackValue } = options;

  try {
    return await operation();
  } catch (error) {
    const message = (error as Error).message || '알 수 없는 오류';

    if (logError) {
      console.error(`[Error] ${context}:`, error);
      appendLog(`❌ ${context}: ${message}`);
    }

    if (showToast && (window as any).toastManager) {
      (window as any).toastManager.error(`❌ ${context}: ${message}`);
    }

    return fallbackValue;
  }
}

// ============================================
// 메모리 관리 유틸리티
// ============================================
const imageDataUrls = new Set<string>();

function createImageDataUrl(blob: Blob): string {
  const url = URL.createObjectURL(blob);
  imageDataUrls.add(url);
  return url;
}

function revokeImageDataUrl(url: string): void {
  if (imageDataUrls.has(url)) {
    URL.revokeObjectURL(url);
    imageDataUrls.delete(url);
    console.log(`[Memory] 이미지 URL 해제: ${url.substring(0, 50)}...`);
  }
}

function revokeAllImageDataUrls(): void {
  console.log(`[Memory] 모든 이미지 URL 해제: ${imageDataUrls.size}개`);
  imageDataUrls.forEach(url => URL.revokeObjectURL(url));
  imageDataUrls.clear();
}

// URL 필드 컨테이너에서 모든 URL 수집
function getAllUrls(): string[] {
  const urlFieldsContainer = document.getElementById('url-fields-container') as HTMLDivElement;
  if (!urlFieldsContainer) return [];
  const urlInputs = urlFieldsContainer.querySelectorAll<HTMLInputElement>('.url-field-input');
  return Array.from(urlInputs)
    .map(input => input.value.trim())
    .filter(url => url.length > 0 && /^https?:\/\//i.test(url));
}

function getUrlsAsString(): string {
  return getAllUrls().join('\n');
}

// 연속 발행 관련 전역 변수
let isContinuousMode = false;
let continuousCountdown = 0;
let continuousInterval: NodeJS.Timeout | null = null;
let continuousQueue: string[] = []; // 연속 발행할 URL/콘텐츠 큐
let __continuousV2Initialized = false; // V2 초기화 플래그

// 로그 표시 및 진행상황 표시 함수 개선 (중복 방지)
function appendLog(message: string, logOutputId?: string): void {
  // 중복 로그 방지 강화 - 같은 메시지는 2초 이내에 다시 표시하지 않음
  const now = Date.now();
  const lastMessage = (appendLog as any).lastMessage;
  const lastTime = (appendLog as any).lastTime;

  if (lastMessage === message && lastTime && now - lastTime < 2000) {
    console.log('[LOG] 중복 로그 방지됨:', message);
    return;
  }
  (appendLog as any).lastMessage = message;
  (appendLog as any).lastTime = now;

  console.log('[LOG] 진행상황:', message);

  // 진행 상황을 시각적으로 표시
  const progressIndicator = document.getElementById('progress-indicator');
  const progressText = document.getElementById('progress-text');

  if (progressIndicator && progressText) {
    progressIndicator.style.display = 'block';
    progressText.textContent = message;
    progressText.style.color = message.includes('❌') || message.includes('실패') ? '#ef4444' : '#10b981';

    // 성공 메시지는 3초, 에러 메시지는 5초 후 자동 숨김
    const hideDelay = message.includes('❌') || message.includes('실패') || message.includes('오류') ? 5000 : 3000;
    setTimeout(() => {
      if (progressIndicator && progressText.textContent === message) {
        progressIndicator.style.display = 'none';
      }
    }, hideDelay);
  }

  // 로그 출력 요소들
  let logOutputs: HTMLElement[] = [];

  if (logOutputId) {
    // 특정 로그 출력 요소만 사용
    const specificOutput = document.getElementById(logOutputId) as HTMLElement;
    if (specificOutput) {
      logOutputs = [specificOutput];
    }
  } else {
    // 기본 로그 출력 요소들
    logOutputs = [
      document.getElementById('unified-log-output') as HTMLElement, // 통합 탭 로그
      document.getElementById('log-output') as HTMLElement // 기존 로그
    ].filter(output => output !== null);
  }

  if (logOutputs.length === 0) {
    console.error('[LOG] 로그 출력 요소를 찾을 수 없음!');
    // 대안으로 alert로 표시
    alert(`진행상황: ${message}`);
    return;
  }

  const timestamp = new Date().toLocaleTimeString('ko-KR', {
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  });
  const logText = `[${timestamp}] ${message}`;

  // 각 로그 영역에 추가
  logOutputs.forEach(currentLogOutput => {
    // 기존 로그 지우기 (너무 많이 쌓이지 않도록, 200개까지 유지)
    while (currentLogOutput.children.length > 200) {
      currentLogOutput.removeChild(currentLogOutput.firstChild!);
    }

    const logEntry = document.createElement('div');
    logEntry.className = 'log-entry';
    logEntry.style.cssText = `
      padding: 4px 0;
      border-bottom: 1px solid rgba(212, 175, 55, 0.2);
      color: #F4D03F;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      line-height: 1.4;
      word-wrap: break-word;
    `;

    logEntry.textContent = logText;
    currentLogOutput.appendChild(logEntry);
    currentLogOutput.scrollTop = currentLogOutput.scrollHeight;
  });

  // ✅ 연속 발행 진행 모달 상세 로그창에도 추가 (열려있을 때만)
  const cpDetailLog = document.getElementById('cp-detail-log');
  const cpModal = document.getElementById('continuous-progress-modal');
  if (cpModal && cpModal.style.display !== 'none' && cpDetailLog) {
    const newLog = document.createElement('p');
    newLog.style.cssText = 'margin: 0 0 0.5rem 0; color: #cbd5e1; font-size: 0.85rem; border-left: 2px solid rgba(59, 130, 246, 0.4); padding-left: 0.5rem;';
    newLog.innerHTML = `<span style="color: #60a5fa; font-weight: 600; margin-right: 0.5rem;">[${timestamp}]</span> ${message}`;
    cpDetailLog.appendChild(newLog);
    cpDetailLog.scrollTop = cpDetailLog.scrollHeight;
  }

  console.log(`[LOG] 로그 표시 완료: ${message}`);
}

// 위험 지표 업데이트
function updateRiskIndicators(content: StructuredContent | null): void {
  if (!content?.quality) return;

  if (riskAiValue) {
    const risk = content.quality.aiDetectionRisk || 'low';
    riskAiValue.textContent = risk === 'low' ? '낮음' : risk === 'medium' ? '보통' : '높음';
    riskAiValue.className = `value risk-${risk}`;
  }

  if (riskLegalValue) {
    const risk = content.quality.legalRisk || 'safe';
    riskLegalValue.textContent = risk === 'safe' ? '안전' : risk === 'caution' ? '주의' : '위험';
    riskLegalValue.className = `value legal-${risk}`;
  }

  if (riskSeoValue) {
    riskSeoValue.textContent = `${content.quality.seoScore || 0}/100`;
  }

  if (riskSummaryElement) {
    riskSummaryElement.style.display = 'grid';
  }
}

// 진행 상태 업데이트
function updateProgress(percent: number, status: string): void {
  if (progressBar) {
    progressBar.style.width = `${percent}%`;
  }
  if (progressStatus) {
    progressStatus.textContent = status;
  }
  if (progressContainer) {
    progressContainer.style.display = percent > 0 ? 'block' : 'none';
  }
}

// 폼 데이터 수집
function collectFormData(skipImages: boolean = false): RendererAutomationPayload | null {
  const naverIdInput = document.getElementById('naver-id') as HTMLInputElement;
  const naverPasswordInput = document.getElementById('naver-password') as HTMLInputElement;
  const titleInput = document.getElementById('post-title') as HTMLInputElement;
  const contentTextarea = document.getElementById('post-content') as HTMLTextAreaElement;
  const generatorSelect = document.getElementById('generator') as HTMLSelectElement;
  const targetAgeSelect = document.getElementById('target-age') as HTMLSelectElement;

  if (!naverIdInput || !naverPasswordInput) {
    alert('네이버 아이디와 비밀번호를 입력해주세요.');
    return null;
  }

  const naverId = naverIdInput.value.trim();
  const naverPassword = naverPasswordInput.value.trim();

  if (!naverId || !naverPassword) {
    alert('네이버 아이디와 비밀번호를 입력해주세요.');
    return null;
  }

  const payload: RendererAutomationPayload = {
    naverId,
    naverPassword,
    generator: (generatorSelect?.value as 'gemini' | 'openai' | 'claude') || 'gemini',
    skipImages,
    targetAge: (targetAgeSelect?.value as '20s' | '30s' | '40s' | '50s' | 'all') || 'all',
    // ✅ Stability AI 모델 및 GIF 변환 옵션 추가
    stabilityModel: (document.getElementById('stability-model-select') as HTMLSelectElement)?.value || 'ultra',
    convertToGif: (document.getElementById('convert-to-gif-checkbox') as HTMLInputElement)?.checked || false,
    videoProvider: (document.getElementById('video-provider-select') as HTMLSelectElement)?.value || 'veo',
    keepBrowserOpen: true, // ✅ 항상 브라우저 세션 유지
    useIntelligentImagePlacement: false, // ✅ 기본값 false (공통 발행 모드에서는 비활성화)
    includeThumbnailText: (document.getElementById('thumbnail-text-option') as HTMLInputElement)?.checked || false,
    useAiImage: (document.getElementById('unified-use-ai-image') as HTMLInputElement)?.checked ?? true,
    createProductThumbnail: (document.getElementById('unified-create-product-thumbnail') as HTMLInputElement)?.checked ?? false,
    // ✅ [2026-01-18] 쇼핑커넥트 배너 관련 필드 추가
    affiliateLink: (document.getElementById('shopping-connect-affiliate-link') as HTMLInputElement)?.value?.trim() || (document.getElementById('batch-link-input') as HTMLInputElement)?.value?.trim() || undefined,
    customBannerPath: (window as any).customBannerPath || undefined,
    contentMode: ((document.getElementById('shopping-connect-affiliate-link') as HTMLInputElement)?.value?.trim() || (document.getElementById('batch-link-input') as HTMLInputElement)?.value?.trim()) ? 'affiliate' : 'seo',
    // ✅ [2026-01-18] AI 생성 옵션 체크박스
    useAiTableImage: (document.getElementById('ai-table-image-checkbox') as HTMLInputElement)?.checked || false,
    useAiBanner: (document.getElementById('ai-banner-checkbox') as HTMLInputElement)?.checked || false,
    // ✅ [2026-01-22] 배너 자동 랜덤 생성 옵션 (풀오토 발행용)
    autoBannerGenerate: (document.getElementById('shopping-connect-auto-banner') as HTMLInputElement)?.checked || false,
    // ✅ [2026-01-22 버그 수정] 발행 모드 및 예약 시간 수집 (연속발행 예약 모드 버그 수정)
    // 더 넓은 범위의 UI 요소 검색
    publishMode: (() => {
      // 1. 명시적 라디오 버튼 검색
      const scheduleModeRadio = document.querySelector('input[name="publish-mode"][value="schedule"]:checked') as HTMLInputElement;
      const draftModeRadio = document.querySelector('input[name="publish-mode"][value="draft"]:checked') as HTMLInputElement;

      if (scheduleModeRadio) return 'schedule' as const;
      if (draftModeRadio) return 'draft' as const;

      // 2. 셀렉트 박스 검색 (다양한 ID 패턴)
      const selectPatterns = [
        'unified-publish-mode-select',
        'continuous-modal-publish-mode',
        'publish-mode-select',
        'schedule-mode-select'
      ];
      for (const id of selectPatterns) {
        const select = document.getElementById(id) as HTMLSelectElement;
        if (select?.value === 'schedule') return 'schedule' as const;
        if (select?.value === 'draft') return 'draft' as const;
      }

      // 3. data-publish-mode 속성 검색 (현재 활성 아이템)
      const activeQueueItem = document.querySelector('.queue-item.active, [data-queue-item].active, .current-publishing-item');
      if (activeQueueItem?.getAttribute('data-publish-mode') === 'schedule') {
        return 'schedule' as const;
      }

      // 4. 글로벌 상태 변수 확인
      const globalMode = (window as any).currentPublishMode;
      if (globalMode === 'schedule') return 'schedule' as const;
      if (globalMode === 'draft') return 'draft' as const;

      // 기본값: publish (즉시 발행)
      return 'publish' as const;
    })(),
    scheduleDate: (() => {
      // 1. 다양한 ID 패턴으로 datetime-local 입력 검색
      const datetimePatterns = [
        'unified-schedule-datetime',
        'continuous-modal-schedule-datetime',
        'schedule-datetime',
        'reservation-datetime'
      ];
      for (const id of datetimePatterns) {
        const input = document.getElementById(id) as HTMLInputElement;
        if (input?.value) {
          return input.value.replace('T', ' ');
        }
      }

      // 2. 분리된 date/time 입력 검색
      const datePatterns = ['unified-schedule-date', 'continuous-modal-schedule-date', 'schedule-date'];
      const timePatterns = ['unified-schedule-time', 'continuous-modal-schedule-time', 'schedule-time'];

      for (let i = 0; i < datePatterns.length; i++) {
        const dateInput = document.getElementById(datePatterns[i]) as HTMLInputElement;
        const timeInput = document.getElementById(timePatterns[i]) as HTMLInputElement;
        if (dateInput?.value && timeInput?.value) {
          return `${dateInput.value} ${timeInput.value}`;
        }
      }

      // 3. data-schedule-date 속성 검색 (활성 큐 아이템)
      const activeQueueItem = document.querySelector('.queue-item.active, [data-queue-item].active, .current-publishing-item');
      const itemScheduleDate = activeQueueItem?.getAttribute('data-schedule-date');
      if (itemScheduleDate) {
        return itemScheduleDate.replace('T', ' ');
      }

      // 4. 글로벌 상태 변수 확인
      const globalScheduleDate = (window as any).currentScheduleDate;
      if (globalScheduleDate) return globalScheduleDate;

      // 5. input[type="datetime-local"] 전체 검색 (모달 내)
      const modalDatetimeInput = document.querySelector('.modal input[type="datetime-local"], .dialog input[type="datetime-local"]') as HTMLInputElement;
      if (modalDatetimeInput?.value) {
        return modalDatetimeInput.value.replace('T', ' ');
      }

      return undefined;
    })(),
    scheduleType: 'naver-server' as const, // 네이버 서버 예약 사용
  };

  // ✅ CTA (다중 CTA 우선)
  try {
    const ctas = readUnifiedCtasFromUi();
    if (ctas.length > 0) {
      payload.ctas = ctas;
      payload.ctaText = payload.ctaText || ctas[0]?.text;
      payload.ctaLink = payload.ctaLink || ctas[0]?.link;
    }
  } catch {
    // ignore
  }

  // 제목
  if (titleInput?.value.trim()) {
    payload.title = titleInput.value.trim();
  }

  // 본문
  if (contentTextarea?.value.trim()) {
    const normalized = normalizeReadableBodyText(contentTextarea.value.trim());
    payload.content = normalized;
    payload.lines = normalized.split('\n');
  }

  // 해시태그
  const hashtagsInput = document.getElementById('hashtags-input') as HTMLInputElement;
  if (hashtagsInput?.value?.trim()) {
    payload.hashtags = (hashtagsInput.value || '').split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);
  }

  // 구조화된 콘텐츠
  if (currentStructuredContent) {
    payload.structuredContent = currentStructuredContent;
    payload.title = payload.title || currentStructuredContent.selectedTitle;
    // 해시태그가 입력 필드에 있으면 우선 사용, 없으면 구조화 콘텐츠에서 가져오기
    if (!payload.hashtags || payload.hashtags.length === 0) {
      payload.hashtags = currentStructuredContent.hashtags;
    }
  }

  // 생성된 이미지
  if (!skipImages) {
    const imagesForPayload = (() => {
      try {
        const fromWindow = (window as any).imageManagementGeneratedImages;
        if (Array.isArray(fromWindow) && fromWindow.length > 0) return fromWindow;
      } catch {
        // ignore
      }
      try {
        const fromManager = ImageManager.getAllImages();
        if (Array.isArray(fromManager) && fromManager.length > 0) return fromManager;
      } catch {
        // ignore
      }
      return Array.isArray(generatedImages) ? generatedImages : [];
    })();

    const imagesForPublish = (() => {
      try {
        if (payload.structuredContent) {
          return filterImagesForPublish(payload.structuredContent, imagesForPayload);
        }
      } catch {
        // ignore
      }
      return imagesForPayload;
    })();

    if (imagesForPublish.length > 0) {
      payload.generatedImages = imagesForPublish
        .map((img: any) => ({
          heading: img.heading,
          filePath: img.filePath || img.url || img.previewDataUrl,
          provider: img.provider,
        }))
        .filter((img: any) => Boolean(img?.heading) && Boolean(img?.filePath));

      // ✅ 대표사진(썸네일) = 1번 이미지
      const thumbnailImage = payload.generatedImages?.[0] as any;
      if (thumbnailImage?.filePath) {
        payload.thumbnailPath = thumbnailImage.filePath;
        console.log(`[Thumbnail] 대표사진 설정: 1번 이미지 사용`);
      }
    }
  }

  // URL 수집
  const urls = getUrlsAsString();
  if (urls) {
    payload.rssUrl = urls;
  }

  // 발행 모드
  if (unifiedPublishModeInput) {
    payload.publishMode = (unifiedPublishModeInput.value || 'publish') as 'draft' | 'publish' | 'schedule';

    if (payload.publishMode === 'schedule' && scheduleDateInput?.value) {
      payload.scheduleDate = scheduleDateInput.value;
    }

    // ✅ 카테고리명 수집 고도화 (수동 입력이 우선, 비어있으면 선택된 카테고리명 사용)
    const categoryInput = document.getElementById('unified-category-name') as HTMLInputElement;
    const articleTypeSelect = document.getElementById('unified-article-type') as HTMLSelectElement;

    let categoryName = categoryInput?.value.trim() || '';

    // 수동 입력이 없고 카테고리가 선택되어 있다면 해당 텍스트 사용
    if (!categoryName && articleTypeSelect && articleTypeSelect.selectedIndex > 0) {
      categoryName = articleTypeSelect.options[articleTypeSelect.selectedIndex].text;
      // "건강/의학" -> "건강" 처럼 슬래시 앞부분만 취할지 고민했으나, 
      // 사용자가 네이버 카테고리를 UI와 동일하게 맞췄을 가능성이 크므로 전체 텍스트 사용
    }

    if (categoryName) {
      payload.categoryName = categoryName;
    }
  }

  // ✅ 사용자 정의 프롬프트 수집
  const customPromptInput = document.getElementById('unified-custom-prompt') as HTMLTextAreaElement;
  if (customPromptInput?.value.trim()) {
    (payload as any).customPrompt = customPromptInput.value.trim();
  }

  // ✅ [Add] 제휴마케팅 링크 및 비디오 옵션 수집
  // 먼저 shopping-connect-affiliate-link 확인, 없으면 batch-link-input (이미지 관리 탭) 사용
  const affiliateLinkInput = document.getElementById('shopping-connect-affiliate-link') as HTMLInputElement;
  const batchLinkInput = document.getElementById('batch-link-input') as HTMLInputElement;
  const affiliateLinkValue = affiliateLinkInput?.value?.trim() || batchLinkInput?.value?.trim();
  if (affiliateLinkValue) {
    payload.affiliateLink = affiliateLinkValue;
    console.log('[collectPayload] affiliateLink 설정됨:', affiliateLinkValue);
  }

  const affiliateVideoCheckbox = document.getElementById('shopping-connect-video-option') as HTMLInputElement;
  if (affiliateVideoCheckbox) {
    payload.useAffiliateVideo = affiliateVideoCheckbox.checked;
  }

  // ✅ [Add] 콘텐츠 모드 수집 (seo, homefeed, affiliate 등)
  const contentModeInput = document.getElementById('unified-content-mode') as HTMLInputElement;
  if (contentModeInput?.value) {
    (payload as any).contentMode = contentModeInput.value;
  }

  return payload;
}

// ✅ 풀오토 발행 중 플래그 (다른 모달 표시 방지)
let isFullAutoPublishing = false;

// ✅ AI 글생성 진행률 모달 관리
const aiProgressModal = {
  modal: null as HTMLElement | null,
  progressBar: null as HTMLElement | null,
  progressPercent: null as HTMLElement | null,
  progressStep: null as HTMLElement | null,
  progressLog: null as HTMLElement | null,
  progressTitle: null as HTMLElement | null,
  progressIcon: null as HTMLElement | null,
  intervalId: null as NodeJS.Timeout | null,

  ensureModalExists() {
    if (document.getElementById('ai-progress-modal')) return;

    const modalHtml = `
      <div id="ai-progress-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85); z-index: 9999999; justify-content: center; align-items: center; flex-direction: column; backdrop-filter: blur(5px);">
        <div style="background: linear-gradient(145deg, #1e1e24, #2a2a35); padding: 2.5rem; border-radius: 20px; width: 90%; max-width: 500px; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5); border: 1px solid rgba(255, 255, 255, 0.1); text-align: center; position: relative;">
          
          <button id="ai-progress-close-x" style="position: absolute; top: 15px; right: 15px; background: transparent; border: none; color: rgba(255,255,255,0.5); font-size: 1.5rem; cursor: pointer; transition: color 0.2s;">✕</button>
          
          <div style="font-size: 3rem; margin-bottom: 1rem; animation: float 3s ease-in-out infinite;" id="ai-progress-icon">🤖</div>
          
          <h3 id="ai-progress-title" style="color: #fff; font-size: 1.5rem; margin: 0 0 1rem 0; font-weight: 700;">AI 글 생성 중...</h3>
          
          <div style="width: 100%; height: 8px; background: rgba(255, 255, 255, 0.1); border-radius: 4px; overflow: hidden; margin-bottom: 1.5rem; position: relative;">
            <div id="ai-progress-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #3b82f6, #8b5cf6); border-radius: 4px; transition: width 0.3s ease; box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);"></div>
          </div>
          
          <div style="display: flex; justify-content: space-between; color: #a1a1aa; font-size: 0.85rem; margin-bottom: 1.5rem;">
            <span id="ai-progress-step">준비 중...</span>
            <span id="ai-progress-percent">0%</span>
          </div>
          
          <div id="ai-progress-log" style="background: rgba(0, 0, 0, 0.3); border-radius: 12px; padding: 1rem; height: 120px; overflow-y: auto; text-align: left; font-family: monospace; font-size: 0.8rem; color: #d4d4d8; margin-bottom: 1.5rem; border: 1px solid rgba(255, 255, 255, 0.05);">
            <div style="color: #6b7280;">⏳ 대기 중...</div>
          </div>
          
          <button id="ai-progress-cancel" style="background: rgba(255, 255, 255, 0.1); border: none; color: #fff; padding: 0.75rem 1.5rem; border-radius: 8px; cursor: pointer; transition: all 0.2s; font-size: 0.9rem; font-weight: 500;">
            🚫 취소하기
          </button>
        </div>
      </div>
    `;

    document.body.insertAdjacentHTML('beforeend', modalHtml);
  },

  init() {
    this.ensureModalExists();
    this.modal = document.getElementById('ai-progress-modal');
    this.progressBar = document.getElementById('ai-progress-bar');
    this.progressPercent = document.getElementById('ai-progress-percent');
    this.progressStep = document.getElementById('ai-progress-step');
    this.progressLog = document.getElementById('ai-progress-log');
    this.progressTitle = document.getElementById('ai-progress-title');
    this.progressIcon = document.getElementById('ai-progress-icon');

    // 취소 버튼
    const cancelBtn = document.getElementById('ai-progress-cancel');
    cancelBtn?.addEventListener('click', () => {
      // 진행 중일 때만 확인 창 띄우기
      if (document.getElementById('ai-progress-close-x')?.style.display === 'none') {
        if (confirm('작업을 취소하시겠습니까?')) {
          this.hide();
          cancelAutomation();
        }
      } else {
        this.hide();
      }
    });

    // 닫기 버튼 (X)
    const closeXBtn = document.getElementById('ai-progress-close-x');
    closeXBtn?.addEventListener('click', () => {
      if (automationRunning) {
        if (confirm('작업을 취소하시겠습니까?')) {
          this.hide();
          cancelAutomation();
        }
      } else {
        this.hide();
      }
    });

    // Hover effect for close button
    closeXBtn?.addEventListener('mouseenter', () => { closeXBtn.style.color = '#fff'; });
    closeXBtn?.addEventListener('mouseleave', () => { closeXBtn.style.color = 'rgba(255,255,255,0.5)'; });
  },

  show(
    title: string = 'AI 글 생성 중...',
    opts?: {
      autoAnimate?: boolean;
      icon?: string;
      initialLog?: string;
      steps?: { percent: number; step: string }[];
      mode?: string;
    }
  ) {
    // 항상 최신 DOM 요소를 가져오도록 초기화 강제 실행
    this.init();
    if (this.modal) {
      this.modal.style.display = 'flex';
      if (this.progressTitle) this.progressTitle.textContent = title;
      if (this.progressIcon && opts?.icon) this.progressIcon.textContent = String(opts.icon);
      if (this.progressLog) {
        const initial = String(opts?.initialLog || '⏳ AI 글 생성을 시작합니다...');
        this.progressLog.innerHTML = `<div>${escapeHtml(initial)}</div>`;
      }
      this.update(0, '준비 중...');

      // 초기화: 닫기 버튼 보이기 (항상 보임)
      const closeXBtn = document.getElementById('ai-progress-close-x');
      const cancelBtn = document.getElementById('ai-progress-cancel');
      if (closeXBtn) closeXBtn.style.display = 'block';
      if (cancelBtn) {
        cancelBtn.style.display = 'inline-block';
        cancelBtn.textContent = '🚫 취소하기';
      }

      const autoAnimate = opts?.autoAnimate !== false;
      if (autoAnimate) {
        // ✅ 모드 전달 (textOnly 또는 fullFlow)
        const mode = opts?.mode || (opts?.steps ? 'custom' : 'fullFlow');
        this.startAnimation(opts?.steps, mode as any);
      }
    }
  },

  hide() {
    if (this.modal) this.modal.style.display = 'none';
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
  },

  update(percent: number, step: string) {
    if (this.progressBar) this.progressBar.style.width = `${percent}%`;
    if (this.progressPercent) this.progressPercent.textContent = `${percent}%`;
    if (this.progressStep) this.progressStep.textContent = step;
  },

  addLog(message: string) {
    if (this.progressLog) {
      const logItem = document.createElement('div');
      logItem.textContent = message;
      logItem.style.marginTop = '0.25rem';
      this.progressLog.appendChild(logItem);
      this.progressLog.scrollTop = this.progressLog.scrollHeight;
    }
  },

  startAnimation(customSteps?: { percent: number; step: string }[], mode: 'textOnly' | 'fullFlow' | 'custom' = 'fullFlow') {
    let steps = customSteps;

    if (!steps) {
      if (mode === 'textOnly') {
        steps = [
          { percent: 15, step: '📝 키워드 분석 중...' },
          { percent: 30, step: '🔍 경쟁 블로그 분석 중...' },
          { percent: 60, step: '✍️ AI 글 작성 중...' },
          { percent: 85, step: '📄 콘텐츠 구조화 중...' },
        ];
      } else {
        steps = [
          { percent: 10, step: '📝 키워드 분석 중...' },
          { percent: 20, step: '🔍 경쟁 블로그 분석 중...' },
          { percent: 35, step: '✍️ AI 글 작성 중...' },
          { percent: 50, step: '📄 콘텐츠 구조화 중...' },
          { percent: 65, step: '🖼️ 이미지 생성 중...' },
          { percent: 80, step: '🔗 내부링크 삽입 중...' },
          { percent: 90, step: '📤 블로그 발행 준비...' },
        ];
      }
    }

    let stepIndex = 0;
    this.intervalId = setInterval(() => {
      if (stepIndex < steps!.length) {
        const step = steps![stepIndex];
        this.update(step.percent, step.step);
        stepIndex++;
      }
    }, 3000);
  },

  complete(
    success: boolean,
    opts?: {
      successTitle?: string;
      failureTitle?: string;
      successIcon?: string;
      failureIcon?: string;
      successLog?: string;
      failureLog?: string;
    }
  ) {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }

    if (success) {
      this.update(100, '✅ 완료!');
      this.addLog(String(opts?.successLog || '🎉 AI 글 생성 및 발행 완료!'));
      if (this.progressIcon) this.progressIcon.textContent = String(opts?.successIcon || '✅');
      if (this.progressTitle) this.progressTitle.textContent = String(opts?.successTitle || '글 생성 완료!');
    } else {
      this.update(0, '❌ 실패');
      this.addLog(String(opts?.failureLog || '❌ 글 생성 실패'));
      if (this.progressIcon) this.progressIcon.textContent = String(opts?.failureIcon || '❌');
      if (this.progressTitle) this.progressTitle.textContent = String(opts?.failureTitle || '글 생성 실패');
    }

    // 완료/실패 시: 닫기 버튼 보이기, 취소 버튼 숨기기 (또는 닫기로 변경)
    const closeXBtn = document.getElementById('ai-progress-close-x');
    const cancelBtn = document.getElementById('ai-progress-cancel');

    if (closeXBtn) closeXBtn.style.display = 'block';

    if (cancelBtn) {
      // 취소 버튼을 '닫기'로 변경하여 하단에서도 닫을 수 있게 함
      cancelBtn.textContent = '확인';
      // 이벤트 핸들러는 이미 조건부로 처리됨 or 재할당 필요없음 (hide 호출)
      // 하지만 명시적으로 동작을 변경하고 싶다면 cloneNode 하거나 상태변수 사용
      // 여기서는 init에서 close-x display 체크로 처리했음.
    }

    // 자동 닫기 제거 (사용자가 결과를 보고 직접 닫게 함)
    // setTimeout(() => this.hide(), 3000);
  }
};

// 자동화 실행
async function runAutomation(skipImages: boolean = false): Promise<void> {
  if (automationRunning) {
    alert('이미 자동화가 실행 중입니다.');
    return;
  }

  const payload = collectFormData(skipImages);
  if (!payload) return;

  automationRunning = true;
  if (runButton) runButton.disabled = true;
  if (publishOnlyButton) publishOnlyButton.disabled = true;
  if (cancelButton) cancelButton.disabled = false;

  // ✅ 진행률 모달 표시
  const isPublishSkipped = !payload.publishMode || (payload as any).skipPublish === true;
  const isTextOnly = skipImages && isPublishSkipped;
  aiProgressModal.show('AI 글 생성 중...', {
    mode: isTextOnly ? 'textOnly' : 'fullFlow'
  });

  updateProgress(0, '자동화 준비 중...');
  appendLog('🚀 자동화를 시작합니다...');

  // ✅ [2026-01-20] 프리셋 썸네일 적용 (풀오토 모드)
  if ((payload as any).isFullAuto) {
    const preset = applyPresetThumbnailIfExists('full-auto');
    if (preset.applied) {
      // generatedImages[0]에 프리셋 썸네일 주입
      if (!payload.generatedImages || payload.generatedImages.length === 0) {
        payload.generatedImages = [preset.forHeading];
      } else {
        payload.generatedImages[0] = preset.forHeading;
      }
      // thumbnailPath도 설정 (쇼핑커넥트 대비)
      if (preset.forThumbnail) {
        payload.thumbnailPath = preset.forThumbnail;
      }
      appendLog('🎨 미리 세팅된 썸네일이 적용되었습니다!');
    }
  }

  try {
    const status = await window.api.runAutomation(payload);

    if (status.success) {
      appendLog('✅ 자동화가 성공적으로 완료되었습니다!');
      updateProgress(100, '완료');
      aiProgressModal.complete(true);

      aiProgressModal.complete(true);

      // ✅ [Fix] 반자동 편집 미리보기 업데이트 (생성된 콘텐츠가 있으면)
      if ((status as any).structuredContent) {
        currentStructuredContent = (status as any).structuredContent;
        fillSemiAutoFields(currentStructuredContent);
        // 섹션 강제 표시
        const semiAutoElem = document.getElementById('unified-semi-auto-section');
        if (semiAutoElem) semiAutoElem.style.display = 'block';
      }

      // ✅ 어떤 모드든(즉시/임시/예약/글만) 성공 시 이미지 정보도 글목록에 저장
      try {
        const snapshot = (() => {
          try {
            const from = ImageManager.getAllImages();
            if (Array.isArray(from) && from.length > 0) return from;
          } catch {
            // ignore
          }
          const globalAll = (window as any).imageManagementGeneratedImages;
          if (Array.isArray(globalAll) && globalAll.length > 0) return globalAll;
          return generatedImages || [];
        })();

        if (currentPostId) {
          updatePostImages(currentPostId, snapshot);
        } else if (payload.title) {
          const posts = loadGeneratedPosts();
          const matchingPost = posts.find(p => p.title === payload.title);
          if (matchingPost) updatePostImages(matchingPost.id, snapshot);
        }
      } catch {
        // ignore
      }

      // 발행 글 저장
      if (payload.title) {
        const today = new Date();
        const defaultUrl = 'https://blog.naver.com/';
        savePublishedPost(today, payload.title, defaultUrl);
      }

      // ✅ [Fix] 발행/임시저장/예약 성공 시 자동으로 필드 초기화 (사용자 요청 반영)
      // 단, structuredContent만 받고 발행은 안 한 경우는 제외 (미리보기 모드)
      const isActualPublish = payload.publishMode === 'publish' || payload.publishMode === 'schedule' || payload.publishMode === 'draft';
      if (isActualPublish && status.success) {
        setTimeout(() => {
          resetAllFields();
          appendLog('🆕 다음 글 작성을 위해 필드가 초기화되었습니다.');
          if (typeof toastManager !== 'undefined') {
            toastManager.success('✅ 발행 완료! 새로운 글을 작성할 수 있습니다.');
          }
        }, 5000); // 5초 대기 (사용자가 성공 메시지를 볼 시간 충분히 부여)
      }
    } else {
      appendLog(`❌ 자동화 실패: ${status.message || '알 수 없는 오류'}`);
      updateProgress(0, '실패');
      aiProgressModal.complete(false);
    }
  } catch (error) {
    appendLog(`❌ 오류 발생: ${(error as Error).message}`);
    updateProgress(0, '오류');
    aiProgressModal.complete(false);
  } finally {
    automationRunning = false;
    if (runButton) runButton.disabled = false;
    if (publishOnlyButton) publishOnlyButton.disabled = false;
    if (cancelButton) cancelButton.disabled = true;

    setTimeout(() => {
      updateProgress(0, '');
    }, 3000);
  }
}

// 자동화 취소
async function cancelAutomation(): Promise<void> {
  if (!automationRunning) return;

  const confirmed = confirm('자동화를 취소하시겠습니까?');
  if (!confirmed) return;

  try {
    await window.api.cancelAutomation();
    appendLog('⏹️ 자동화가 취소되었습니다.');
    automationRunning = false;
    if (runButton) runButton.disabled = false;
    if (publishOnlyButton) publishOnlyButton.disabled = false;
    if (cancelButton) cancelButton.disabled = true;
    updateProgress(0, '취소됨');
  } catch (error) {
    appendLog(`❌ 취소 실패: ${(error as Error).message}`);
  }
}

// 로그 리스너
if (typeof window !== 'undefined' && window.api) {
  window.api.onLog((message: string) => {
    handleVeoLogForOverlay(message);
    appendLog(message);

    // ✅ [Log Bridging] 자동화 실행 중이면(Main 프로세스 로그 포함) 모달에도 로그 출력
    if ((window as any).stopFullAutoPublish === false) {
      try {
        const modal = getProgressModal();
        if (modal && modal.addLog) {
          modal.addLog(message);
        }
      } catch (e) {
        // 모달 접근 실패 시 무시
      }
    }
  });

  // ✅ 예약 발행 완료 후 자동 초기화 리스너
  if (window.api.on) {
    window.api.on('automation:reset-fields', () => {
      console.log('[Renderer] 예약 발행 완료 - 자동 초기화 시작');
      setTimeout(() => {
        resetAllFields();
        appendLog('🆕 다음 글 작성을 위해 필드가 초기화되었습니다.');
        toastManager.success('✅ 예약 발행 완료! 다음 글을 작성할 수 있습니다.');
      }, 2000); // 2초 후 초기화 (사용자가 완료 메시지를 볼 시간 제공)
    });
  }

  window.api.onStatus((status: any) => {
    if (status.success) {
      const titleInput = document.getElementById('post-title') as HTMLInputElement;
      const title = titleInput?.value.trim();
      if (title) {
        const today = new Date();
        // ✅ 실제 발행 URL 사용 (status에서 받아옴)
        const publishedUrl = status.url || 'https://blog.naver.com/';
        savePublishedPost(today, title, publishedUrl);

        // ✅ 현재 글에도 URL 저장
        if (status.url) {
          if (currentPostId) {
            updatePostAfterPublish(currentPostId, status.url);
            appendLog(`📎 발행 URL이 저장되었습니다: ${status.url}`);

            // ✅ 발행/임시/예약 등 어떤 모드든 이미지도 함께 저장
            try {
              const snapshot = (() => {
                try {
                  const from = ImageManager.getAllImages();
                  if (Array.isArray(from) && from.length > 0) return from;
                } catch {
                  // ignore
                }
                const globalAll = (window as any).imageManagementGeneratedImages;
                if (Array.isArray(globalAll) && globalAll.length > 0) return globalAll;
                return generatedImages || [];
              })();
              updatePostImages(currentPostId, snapshot);
            } catch {
              // ignore
            }
          } else {
            // ✅ currentPostId가 없으면 제목으로 글 찾아서 URL 저장
            const posts = loadGeneratedPosts();
            const matchingPost = posts.find(p => p.title === title && !p.publishedUrl);
            if (matchingPost) {
              updatePostAfterPublish(matchingPost.id, status.url);
              appendLog(`📎 발행 URL이 저장되었습니다 (제목 매칭): ${status.url}`);

              try {
                const snapshot = (() => {
                  try {
                    const from = ImageManager.getAllImages();
                    if (Array.isArray(from) && from.length > 0) return from;
                  } catch {
                    // ignore
                  }
                  const globalAll = (window as any).imageManagementGeneratedImages;
                  if (Array.isArray(globalAll) && globalAll.length > 0) return globalAll;
                  return generatedImages || [];
                })();
                updatePostImages(matchingPost.id, snapshot);
              } catch {
                // ignore
              }
            }
          }
        }
      }
    }

    if (status.success === false && !status.cancelled) {
      appendLog(`❌ ${status.message || '알 수 없는 오류가 발생했습니다.'}`);
    }
  });
}

// 폼 제출 이벤트
if (form) {
  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    await runAutomation(false);
  });
}

// 실행 버튼 클릭
if (runButton) {
  runButton.addEventListener('click', async () => {
    await runAutomation(false);
  });
}

// 글만 발행하기 버튼
if (publishOnlyButton) {
  publishOnlyButton.addEventListener('click', async () => {
    await runAutomation(true);
  });
}

// 취소 버튼
if (cancelButton) {
  cancelButton.addEventListener('click', async () => {
    await cancelAutomation();
  });
}

// 발행 모드 변경 시 스케줄 날짜 표시/숨김
if (publishModeSelect && scheduleDateContainer) {
  publishModeSelect.addEventListener('change', () => {
    const mode = publishModeSelect.value;
    if (mode === 'schedule') {
      scheduleDateContainer.style.display = 'block';
      if (scheduleDateInput) {
        const now = new Date();
        const minDate = new Date(now.getTime() + 60000); // 1분 후
        const year = minDate.getFullYear();
        const month = String(minDate.getMonth() + 1).padStart(2, '0');
        const day = String(minDate.getDate()).padStart(2, '0');
        const hours = String(minDate.getHours()).padStart(2, '0');
        const minutes = String(minDate.getMinutes()).padStart(2, '0');
        scheduleDateInput.min = `${year}-${month}-${day}T${hours}:${minutes}`;
        if (!scheduleDateInput.value) {
          scheduleDateInput.value = `${year}-${month}-${day}T${hours}:${minutes}`;
        }
      }
    } else {
      scheduleDateContainer.style.display = 'none';
    }
  });

  // 초기 상태 설정
  if (publishModeSelect.value === 'schedule') {
    scheduleDateContainer.style.display = 'block';
  } else {
    scheduleDateContainer.style.display = 'none';
  }
}

// ============================================
// 탭 전환 기능
// ============================================

const tabButtons = Array.from(document.querySelectorAll<HTMLButtonElement>('.tab-button'));
const tabPanels = Array.from(document.querySelectorAll<HTMLDivElement>('.tab-panel'));

tabButtons.forEach(button => {
  button.addEventListener('click', () => {
    const targetTab = button.getAttribute('data-tab');
    if (!targetTab) return;

    // 모든 탭 비활성화
    tabButtons.forEach(btn => {
      btn.classList.remove('active');
      btn.setAttribute('aria-selected', 'false');
    });

    tabPanels.forEach(panel => {
      panel.classList.remove('active');
      (panel as HTMLElement).style.display = 'none';
    });

    // 선택한 탭 활성화
    button.classList.add('active');
    button.setAttribute('aria-selected', 'true');

    const targetPanel = document.getElementById(`tab-${targetTab}`) as HTMLDivElement;
    if (targetPanel) {
      targetPanel.classList.add('active');
      targetPanel.style.display = 'block';
    }
  });
});

// ============================================
// 모달 닫기 기능 (배경 클릭)
// ============================================

[licenseModal, settingsModal, externalLinksModal].forEach(modal => {
  if (modal) {
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        modal.setAttribute('aria-hidden', 'true');
        modal.style.display = 'none';
      }
    });
  }
});

// 라이선스 모달 닫기 버튼
const closeLicenseButtons = Array.from(document.querySelectorAll<HTMLButtonElement>('[data-close-license]'));
closeLicenseButtons.forEach(btn => {
  btn.addEventListener('click', () => {
    if (licenseModal) {
      licenseModal.setAttribute('aria-hidden', 'true');
      licenseModal.style.display = 'none';
    }
  });
});

// ============================================
// 구조화 콘텐츠 미리보기 및 소제목 선택 UI
// ============================================
function displayStructuredContentPreview(content: StructuredContent): void {
  const previewContainer = document.getElementById('structured-content-preview') as HTMLDivElement;
  const headingsList = document.getElementById('structured-headings-list') as HTMLDivElement;
  const imageGenerationSection = document.getElementById('heading-image-generation-section') as HTMLDivElement;

  if (!previewContainer || !headingsList) return;

  // 소제목 목록 생성 (✅ HTML 이스케이프 적용)
  if (content.headings && content.headings.length > 0) {
    headingsList.innerHTML = content.headings.map((heading, index) => {
      const safeTitle = escapeHtml(heading.title || '');
      const safeSummary = escapeHtml(heading.summary || '');
      const safeImagePrompt = escapeHtml(heading.imagePrompt || heading.title || '');
      return `
        <label style="display: flex; align-items: flex-start; gap: 0.5rem; padding: 0.75rem; border-radius: 0.5rem; cursor: pointer; transition: all var(--transition-fast); border: 1px solid var(--border-light); background: var(--bg-primary);">
          <input type="checkbox" class="structured-heading-checkbox" data-heading-index="${index}" checked style="margin-top: 0.25rem;">
          <div style="flex: 1;">
            <div style="font-weight: 600; margin-bottom: 0.25rem; color: var(--text-strong);">${safeTitle}</div>
            <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.25rem;">${safeSummary}</div>
            <div style="font-size: 0.75rem; color: var(--text-light);">이미지 프롬프트: ${safeImagePrompt}</div>
          </div>
        </label>
      `;
    }).join('');

    // 체크박스 호버 효과
    headingsList.querySelectorAll('label').forEach(label => {
      label.addEventListener('mouseenter', () => {
        label.style.background = 'var(--bg-hover)';
        label.style.borderColor = 'var(--primary)';
      });
      label.addEventListener('mouseleave', () => {
        label.style.background = 'var(--bg-primary)';
        label.style.borderColor = 'var(--border-light)';
      });
    });

    // 이미지 생성 섹션 표시
    if (imageGenerationSection) {
      imageGenerationSection.style.display = 'block';
    }

    previewContainer.style.display = 'block';
  } else {
    previewContainer.style.display = 'none';
  }
}

// ============================================
// 자동 생성 기능 (URL 기반)
// ============================================

let currentRssUrl = '';
let autoGenerateTimeout: NodeJS.Timeout | null = null;

async function autoGenerateFromUrl(urls: string): Promise<void> {
  if (!urls.trim() || urls === currentRssUrl) return;

  currentRssUrl = urls.trim();

  if (autoGenerateTimeout) {
    clearTimeout(autoGenerateTimeout);
  }

  autoGenerateTimeout = setTimeout(async () => {
    try {
      // ✅ 새 URL 분석 전 이전 콘텐츠 자동 초기화 (제목 버그 방지)
      if (currentStructuredContent) {
        console.log('[AutoGenerate] 이전 콘텐츠를 초기화합니다...');
        currentStructuredContent = null;
        (window as any).currentStructuredContent = null;
        generatedImages = [];
        (window as any).imageManagementGeneratedImages = null;
      }

      appendLog(`🔍 URL 기반 자동 생성을 시작합니다 (${urls})`);

      const targetAgeSelect = document.getElementById('target-age') as HTMLSelectElement;
      const targetAge = (targetAgeSelect?.value as '20s' | '30s' | '40s' | '50s' | 'all') || 'all';

      const customPrompt = (document.getElementById('unified-custom-prompt') as HTMLTextAreaElement)?.value?.trim();


      const apiClient = EnhancedApiClient.getInstance();

      // ✅ contentMode 수집 (custom 모드 지원)
      const contentModeSelect = document.getElementById('unified-content-mode') as HTMLSelectElement;
      const contentMode = (contentModeSelect?.value || 'seo') as 'seo' | 'homefeed' | 'affiliate' | 'custom';

      console.log(`[URL 생성] contentMode: ${contentMode}, customPrompt: ${customPrompt ? `${customPrompt.substring(0, 50)}...` : '없음'}`);

      const apiResponse = await apiClient.call(
        'generateStructuredContent',
        [{
          assembly: {
            rssUrl: urls,
            targetAge: targetAge as '20s' | '30s' | '40s' | '50s' | 'all',
            generator: 'gemini',
            contentMode: contentMode, // ✅ custom 모드 전달
            customPrompt: customPrompt || undefined,
          } as { rssUrl: string; targetAge: '20s' | '30s' | '40s' | '50s' | 'all'; generator: 'gemini'; contentMode?: string; customPrompt?: string },
        }],
        {
          retryCount: 3,
          retryDelay: 2000,
          timeout: 600000
        }
      );

      const result = apiResponse.data || { success: false, message: apiResponse.error };

      if (isPaywallPayload(result)) {
        activatePaywall(result);
        return;
      }

      if (result.success && result.content) {
        currentStructuredContent = result.content;

        const titleInput = document.getElementById('post-title') as HTMLInputElement;
        const contentTextarea = document.getElementById('post-content') as HTMLTextAreaElement;
        const hashtagsInput = document.getElementById('hashtags-input') as HTMLInputElement;

        if (titleInput) {
          titleInput.value = result.content.selectedTitle || '';
        }

        if (contentTextarea) {
          contentTextarea.value = result.content.bodyPlain || '';
        }

        if (hashtagsInput && result.content.hashtags && result.content.hashtags.length > 0) {
          hashtagsInput.value = result.content.hashtags.join(', ');
        }

        // 구조화 콘텐츠 미리보기 표시
        displayStructuredContentPreview(result.content);

        updateRiskIndicators(result.content);
        appendLog('✅ 자동 생성이 완료되었습니다!');
      } else {
        appendLog(`❌ 자동 생성 실패: ${result.message || '알 수 없는 오류'}`);
      }
    } catch (error) {
      appendLog(`❌ 자동 생성 오류: ${(error as Error).message}`);
    }
  }, 1000); // 1초 디바운스
}

// URL 입력 필드 변경 감지 및 추가 버튼
const urlFieldsContainer = document.getElementById('url-fields-container') as HTMLDivElement;
const addUrlFieldBtn = document.getElementById('add-url-field-btn') as HTMLButtonElement;
let urlFieldCount = 1;

function addUrlField(): void {
  if (!urlFieldsContainer) return;

  const urlFieldItem = document.createElement('div');
  urlFieldItem.className = 'url-field-item';
  urlFieldItem.innerHTML = `
    <input 
      type="url" 
      class="url-field-input" 
      name="rssUrl[]" 
      placeholder="https://example.com/article1 또는 https://blog.naver.com/..."
      data-url-index="${urlFieldCount}"
    />
    <button type="button" class="url-field-remove" aria-label="삭제">×</button>
  `;

  urlFieldsContainer.appendChild(urlFieldItem);
  urlFieldCount++;

  // 삭제 버튼 이벤트 추가 및 표시/숨김
  const removeBtn = urlFieldItem.querySelector('.url-field-remove') as HTMLButtonElement;
  if (removeBtn) {
    // 항목이 여러 개일 때만 삭제 버튼 표시
    const allItems = urlFieldsContainer.querySelectorAll('.url-field-item');
    if (allItems.length > 1) {
      removeBtn.style.display = 'inline-block';
    }

    removeBtn.addEventListener('click', () => {
      const allItems = urlFieldsContainer.querySelectorAll('.url-field-item');
      if (allItems.length > 1) {
        urlFieldItem.remove();
        // 남은 항목들의 삭제 버튼 표시 상태 업데이트
        const remainingItems = urlFieldsContainer.querySelectorAll('.url-field-item');
        remainingItems.forEach((item, index) => {
          const btn = item.querySelector('.url-field-remove') as HTMLButtonElement;
          if (btn) {
            btn.style.display = remainingItems.length > 1 ? 'inline-block' : 'none';
          }
        });
      }
    });
  }

  // 기존 항목들의 삭제 버튼 표시 상태 업데이트
  const allItems = urlFieldsContainer.querySelectorAll('.url-field-item');
  allItems.forEach((item) => {
    const btn = item.querySelector('.url-field-remove') as HTMLButtonElement;
    if (btn) {
      btn.style.display = allItems.length > 1 ? 'inline-block' : 'none';
    }
  });

  // URL 입력 이벤트 추가
  const urlInput = urlFieldItem.querySelector('.url-field-input') as HTMLInputElement;
  if (urlInput) {
    urlInput.addEventListener('input', () => {
      const urls = getUrlsAsString();
      if (urls) {
        autoGenerateFromUrl(urls);
      }
    });
  }
}

if (addUrlFieldBtn) {
  addUrlFieldBtn.addEventListener('click', addUrlField);
}

if (urlFieldsContainer) {
  urlFieldsContainer.addEventListener('input', (e) => {
    const target = e.target as HTMLInputElement;
    if (target.classList.contains('url-field-input')) {
      const urls = getUrlsAsString();
      if (urls) {
        autoGenerateFromUrl(urls);
      }
    }
  });
}

// 스케줄 관리 초기화 (비동기 함수이므로 즉시 호출)
initScheduleManagement();

// 접기/펼치기 토글 기능 (동적으로 추가된 요소도 처리 가능하도록 이벤트 위임)
document.addEventListener('click', (e) => {
  const target = e.target as HTMLElement;
  if (target.classList.contains('collapse-toggle')) {
    const targetId = target.getAttribute('data-target');
    if (!targetId) return;

    const content = document.getElementById(targetId);
    if (!content) return;

    const isCollapsed = content.classList.contains('collapsed');
    if (isCollapsed) {
      content.classList.remove('collapsed');
      target.textContent = '▼';
    } else {
      content.classList.add('collapsed');
      target.textContent = '▶';
    }
  }
});

/**
 * ⚡ API 연결 사전 준비 (Warm-up)
 * - DNS 해석 캐싱
 * - TLS 세션 캐싱
 * - 첫 콘텐츠 생성 시 연결 시간 대폭 단축
 */
async function warmupApiConnections(hasGemini: boolean): Promise<void> {
  console.log('[Warmup] API 연결 사전 준비 시작...');

  const warmupUrls: string[] = [];

  if (hasGemini) {
    warmupUrls.push('https://generativelanguage.googleapis.com');
  }

  // 병렬로 모든 API 서버에 연결 테스트
  const warmupPromises = warmupUrls.map(async (url) => {
    try {
      const startTime = Date.now();
      // HEAD 요청으로 빠르게 연결만 테스트 (응답 본문 없음)
      await fetch(url, {
        method: 'HEAD',
        mode: 'no-cors', // CORS 오류 방지
        cache: 'no-store'
      });
      const elapsed = Date.now() - startTime;
      console.log(`[Warmup] ✅ ${url} 연결 완료 (${elapsed}ms)`);
      return { url, success: true, elapsed };
    } catch (error) {
      // 오류가 나도 무시 (warm-up은 선택적)
      console.log(`[Warmup] ⚠️ ${url} 연결 실패 (무시됨):`, (error as Error).message);
      return { url, success: false, elapsed: 0 };
    }
  });

  try {
    const results = await Promise.allSettled(warmupPromises);
    const successCount = results.filter(r => r.status === 'fulfilled' && (r.value as any).success).length;
    console.log(`[Warmup] API 연결 사전 준비 완료: ${successCount}/${warmupUrls.length}개 서버 연결됨`);

    // 연결 성공한 서버가 있으면 사용자에게 알림 (로그만)
    if (successCount > 0) {
      console.log('[Warmup] 💡 첫 콘텐츠 생성이 더 빨라집니다!');
    }
  } catch (e) {
    // 전체 실패해도 무시
    console.log('[Warmup] warm-up 완료 (일부 실패)');
  }
}

type PaywallResponse = {
  success: false;
  code: 'PAYWALL';
  message?: string;
  quota?: any;
};

let paywallActive = false;
let paywallQuotaSnapshot: any = null;
let paywallOriginalApi: any = null;
let paywallMessageSnapshot: string | null = null;

const isPaywallPayload = (v: any): v is PaywallResponse =>
  !!v && typeof v === 'object' && (v as any).code === 'PAYWALL';

const PAYWALL_PRICE_IMAGE_SRC = '가격표.jpg';
const PAYWALL_OPEN_CHAT_URL = 'https://open.kakao.com/o/sPcaslwh';

function showPriceImageModal(): void {
  let priceModal = document.getElementById('price-image-modal') as HTMLDivElement | null;
  if (!priceModal) {
    priceModal = document.createElement('div');
    priceModal.id = 'price-image-modal';
    priceModal.style.position = 'fixed';
    priceModal.style.left = '0';
    priceModal.style.top = '0';
    priceModal.style.right = '0';
    priceModal.style.bottom = '0';
    priceModal.style.background = 'rgba(0,0,0,0.9)';
    priceModal.style.zIndex = '100020';
    priceModal.style.display = 'none';
    priceModal.style.alignItems = 'center';
    priceModal.style.justifyContent = 'center';
    priceModal.style.padding = '20px';
    priceModal.style.cursor = 'pointer';

    const img = document.createElement('img');
    img.src = PAYWALL_PRICE_IMAGE_SRC;
    img.alt = '가격표';
    img.style.maxWidth = '90vw';
    img.style.maxHeight = '85vh';
    img.style.borderRadius = '16px';
    img.style.boxShadow = '0 20px 60px rgba(0,0,0,0.5)';
    img.style.border = '3px solid rgba(212, 175, 55, 0.5)';

    const closeHint = document.createElement('div');
    closeHint.textContent = '화면을 클릭하면 닫힙니다';
    closeHint.style.position = 'absolute';
    closeHint.style.bottom = '20px';
    closeHint.style.left = '50%';
    closeHint.style.transform = 'translateX(-50%)';
    closeHint.style.color = 'rgba(255,255,255,0.6)';
    closeHint.style.fontSize = '14px';

    priceModal.appendChild(img);
    priceModal.appendChild(closeHint);
    document.body.appendChild(priceModal);

    priceModal.addEventListener('click', () => {
      priceModal!.style.display = 'none';
    });
  }
  priceModal.style.display = 'flex';
}

function ensurePaywallDom(): {
  overlay: HTMLDivElement;
  payButton: HTMLButtonElement;
  modalBackdrop: HTMLDivElement;
  modal: HTMLDivElement;
  openLink: HTMLAnchorElement;
  quotaText: HTMLDivElement;
} {
  let overlay = document.getElementById('global-paywall-overlay') as HTMLDivElement | null;
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'global-paywall-overlay';
    overlay.style.position = 'fixed';
    overlay.style.left = '0';
    overlay.style.top = '0';
    overlay.style.right = '0';
    overlay.style.bottom = '0';
    overlay.style.background = 'rgba(0,0,0,0.55)';
    overlay.style.backdropFilter = 'blur(2px)';
    overlay.style.zIndex = '99990';
    overlay.style.display = 'none';
    overlay.style.pointerEvents = 'auto';
    document.body.appendChild(overlay);
  }

  let payButton = document.getElementById('global-paywall-pay-button') as HTMLButtonElement | null;
  if (!payButton) {
    payButton = document.createElement('button');
    payButton.id = 'global-paywall-pay-button';
    payButton.textContent = '🚀 프로 버전 문의';
    payButton.style.position = 'fixed';
    payButton.style.top = '14px';
    payButton.style.left = '50%';
    payButton.style.transform = 'translateX(-50%)';
    payButton.style.zIndex = '100000';
    payButton.style.padding = '12px 22px';
    payButton.style.borderRadius = '12px';
    payButton.style.border = '2px solid rgba(212, 175, 55, 0.8)';
    payButton.style.background = 'linear-gradient(135deg, #D4AF37 0%, #FFD700 50%, #F4D03F 100%)';
    payButton.style.color = '#0F0F0F';
    payButton.style.fontWeight = '800';
    payButton.style.fontSize = '14px';
    payButton.style.cursor = 'pointer';
    payButton.style.boxShadow = '0 10px 40px rgba(0,0,0,0.55), 0 0 20px rgba(212, 175, 55, 0.3)';
    payButton.style.display = 'none';
    payButton.style.transition = 'all 0.3s ease';
    payButton.onmouseover = () => { payButton!.style.transform = 'translateX(-50%) scale(1.05)'; };
    payButton.onmouseout = () => { payButton!.style.transform = 'translateX(-50%) scale(1)'; };
    document.body.appendChild(payButton);
  }

  let modalBackdrop = document.getElementById('global-paywall-modal-backdrop') as HTMLDivElement | null;
  let modal = document.getElementById('global-paywall-modal') as HTMLDivElement | null;
  let openLink = document.getElementById('global-paywall-open-chat-link') as HTMLAnchorElement | null;
  let quotaText = document.getElementById('global-paywall-quota-text') as HTMLDivElement | null;

  if (!modalBackdrop) {
    modalBackdrop = document.createElement('div');
    modalBackdrop.id = 'global-paywall-modal-backdrop';
    modalBackdrop.style.position = 'fixed';
    modalBackdrop.style.left = '0';
    modalBackdrop.style.top = '0';
    modalBackdrop.style.right = '0';
    modalBackdrop.style.bottom = '0';
    modalBackdrop.style.background = 'rgba(0,0,0,0.9)';
    modalBackdrop.style.zIndex = '100010';
    modalBackdrop.style.display = 'none';
    modalBackdrop.style.alignItems = 'center';
    modalBackdrop.style.justifyContent = 'center';
    modalBackdrop.style.padding = '24px';
    document.body.appendChild(modalBackdrop);

    modal = document.createElement('div');
    modal.id = 'global-paywall-modal';
    modal.style.width = 'min(480px, 95vw)';
    modal.style.maxHeight = '90vh';
    modal.style.overflow = 'auto';
    modal.style.background = 'linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%)';
    modal.style.border = '2px solid rgba(239, 68, 68, 0.5)';
    modal.style.borderRadius = '20px';
    modal.style.boxShadow = '0 30px 80px rgba(0,0,0,0.8), 0 0 60px rgba(239, 68, 68, 0.15)';
    modal.style.padding = '32px';
    modal.style.textAlign = 'center';

    // ⚠️ 경고 제목 (빨간색/노란색)
    const titleRow = document.createElement('div');
    titleRow.style.marginBottom = '24px';

    const warningIcon = document.createElement('span');
    warningIcon.textContent = '⚠️';
    warningIcon.style.fontSize = '32px';
    warningIcon.style.display = 'block';
    warningIcon.style.marginBottom = '12px';

    const title = document.createElement('div');
    title.textContent = '작업이 일시 중단되었습니다!';
    title.style.color = '#fbbf24'; // 노란색 경고
    title.style.fontWeight = '900';
    title.style.fontSize = '22px';
    title.style.letterSpacing = '0.3px';
    title.style.textShadow = '0 0 20px rgba(251, 191, 36, 0.3)';

    titleRow.appendChild(warningIcon);
    titleRow.appendChild(title);

    // 본문 - 설득 문구
    quotaText = document.createElement('div');
    quotaText.id = 'global-paywall-quota-text';
    quotaText.style.padding = '24px';
    quotaText.style.background = 'rgba(251, 191, 36, 0.08)';
    quotaText.style.border = '1px solid rgba(251, 191, 36, 0.2)';
    quotaText.style.borderRadius = '14px';
    quotaText.style.color = 'rgba(255,255,255,0.95)';
    quotaText.style.fontSize = '16px';
    quotaText.style.lineHeight = '1.9';
    quotaText.style.fontWeight = '500';
    quotaText.style.marginBottom = '28px';
    quotaText.innerHTML = `
      <div style="font-size:17px;font-weight:600;color:#fff;margin-bottom:16px;">
        오늘 무료 사용량을 모두 쓰셨습니다.
      </div>
      <div style="color:rgba(255,255,255,0.9);font-size:15px;">
        <span style="color:#ef4444;font-weight:700;">지금 멈추면 블로그 지수 상승도 멈춥니다.</span>
      </div>
      <div style="margin-top:20px;padding-top:16px;border-top:1px solid rgba(255,255,255,0.1);font-size:16px;color:#22c55e;font-weight:700;">
        흐름 끊기지 않고 계속 수익을 내시겠습니까?
      </div>
    `;

    // 버튼 컨테이너
    const btnContainer = document.createElement('div');
    btnContainer.style.display = 'flex';
    btnContainer.style.flexDirection = 'column';
    btnContainer.style.gap = '16px';
    btnContainer.style.width = '100%';

    // 🚀 메인 CTA 버튼 (초록색, 크고 눈에 띄게)
    openLink = document.createElement('a') as HTMLAnchorElement;
    openLink.id = 'global-paywall-open-chat-link';
    openLink.href = PAYWALL_OPEN_CHAT_URL;
    openLink.textContent = '🚀 무제한으로 봉인 해제하기';
    openLink.target = '_blank';
    openLink.rel = 'noreferrer';
    openLink.style.display = 'block';
    openLink.style.padding = '20px';
    openLink.style.textAlign = 'center';
    openLink.style.borderRadius = '14px';
    openLink.style.background = 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)';
    openLink.style.color = '#fff';
    openLink.style.fontWeight = '900';
    openLink.style.fontSize = '18px';
    openLink.style.textDecoration = 'none';
    openLink.style.boxShadow = '0 8px 30px rgba(34, 197, 94, 0.4)';
    openLink.style.transition = 'all 0.2s ease';
    openLink.onmouseover = () => {
      openLink!.style.transform = 'translateY(-3px)';
      openLink!.style.boxShadow = '0 12px 40px rgba(34, 197, 94, 0.5)';
    };
    openLink.onmouseout = () => {
      openLink!.style.transform = 'translateY(0)';
      openLink!.style.boxShadow = '0 8px 30px rgba(34, 197, 94, 0.4)';
    };
    openLink.addEventListener('click', (e) => {
      e.preventDefault();
      try {
        if ((window as any).api?.openExternalUrl) {
          (window as any).api.openExternalUrl(PAYWALL_OPEN_CHAT_URL);
        } else {
          window.open(PAYWALL_OPEN_CHAT_URL, '_blank');
        }
      } catch {
        window.open(PAYWALL_OPEN_CHAT_URL, '_blank');
      }
    });

    // 닫기 버튼 (회색, 배경 없이 글씨만, 죄책감 유발 문구)
    const closeBtn = document.createElement('button');
    closeBtn.textContent = '네, 성장을 멈출게요';
    closeBtn.style.padding = '12px';
    closeBtn.style.borderRadius = '8px';
    closeBtn.style.background = 'transparent';
    closeBtn.style.border = 'none';
    closeBtn.style.color = 'rgba(255,255,255,0.35)';
    closeBtn.style.fontSize = '13px';
    closeBtn.style.fontWeight = '500';
    closeBtn.style.cursor = 'pointer';
    closeBtn.style.transition = 'all 0.2s';
    closeBtn.onmouseover = () => { closeBtn.style.color = 'rgba(255,255,255,0.5)'; };
    closeBtn.onmouseout = () => { closeBtn.style.color = 'rgba(255,255,255,0.35)'; };

    btnContainer.appendChild(openLink);
    btnContainer.appendChild(closeBtn);

    modal.appendChild(titleRow);
    modal.appendChild(quotaText);
    modal.appendChild(btnContainer);
    modalBackdrop.appendChild(modal);

    const hideModal = () => {
      modalBackdrop!.style.display = 'none';
    };
    closeBtn.addEventListener('click', hideModal);
    modalBackdrop.addEventListener('click', (e) => {
      if (e.target === modalBackdrop) {
        hideModal();
      }
    });
  }

  return {
    overlay: overlay!,
    payButton: payButton!,
    modalBackdrop: modalBackdrop!,
    modal: modal!,
    openLink: openLink!,
    quotaText: quotaText!,
  };
}

function setUiBlockedByPaywall(blocked: boolean): void {
  const { overlay, payButton, modalBackdrop } = ensurePaywallDom();
  overlay.style.display = blocked ? 'block' : 'none';
  payButton.style.display = blocked ? 'block' : 'none';

  // ✅ 글로벌 버튼 클릭 가로채기 - 클릭하면 모달 표시
  if (blocked) {
    // 모든 버튼 클릭을 가로채는 이벤트 리스너 추가
    if (!(document as any)._paywallClickHandler) {
      (document as any)._paywallClickHandler = (e: MouseEvent) => {
        const target = e.target as HTMLElement;

        // 페이월 모달 내부 요소는 제외
        if (modalBackdrop && modalBackdrop.contains(target)) return;
        if (target.id === 'global-paywall-pay-button') return;
        if (target.closest('#global-paywall-modal-backdrop')) return;

        // 버튼, 링크, 클릭 가능한 요소 체크
        const clickable = target.closest('button, a, [role="button"], .btn, input[type="submit"], input[type="button"]');
        if (clickable) {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();

          // 페이월 모달 표시
          modalBackdrop.style.display = 'flex';
          return false;
        }
      };
      document.addEventListener('click', (document as any)._paywallClickHandler, true);
    }
  } else {
    // 페이월 해제 시 이벤트 리스너 제거
    if ((document as any)._paywallClickHandler) {
      document.removeEventListener('click', (document as any)._paywallClickHandler, true);
      (document as any)._paywallClickHandler = null;
    }
  }

  // UI 시각적 힌트 (희미하게 표시)
  const nodes = Array.from(document.querySelectorAll<HTMLElement>('button, input, select, textarea, a'));
  for (const el of nodes) {
    if (el.id === 'global-paywall-pay-button') continue;
    if (modalBackdrop && modalBackdrop.contains(el)) continue;

    if (blocked) {
      el.style.opacity = '0.6';
      el.style.filter = 'grayscale(0.2)';
    } else {
      el.style.opacity = '';
      el.style.filter = '';
    }
  }
}

function activatePaywall(payload?: PaywallResponse | any): void {
  if (paywallActive) {
    if (payload?.quota) {
      paywallQuotaSnapshot = payload.quota;
    }
    if (typeof payload?.message === 'string' && payload.message.trim()) {
      paywallMessageSnapshot = String(payload.message || '').trim();
    }
    return;
  }
  paywallActive = true;
  if (payload?.quota) {
    paywallQuotaSnapshot = payload.quota;
  }
  if (typeof payload?.message === 'string' && payload.message.trim()) {
    paywallMessageSnapshot = String(payload.message || '').trim();
  }

  const { payButton, modalBackdrop, quotaText } = ensurePaywallDom();
  setUiBlockedByPaywall(true);

  const quota = paywallQuotaSnapshot;
  const esc = (v: any): string =>
    String(v ?? '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');

  // ✅ 새로운 설득 문구
  quotaText.innerHTML = `
    <div style="font-size:17px;font-weight:600;color:#fff;margin-bottom:16px;">
      오늘 무료 사용량을 모두 쓰셨습니다.
    </div>
    <div style="color:rgba(255,255,255,0.9);font-size:15px;">
      <span style="color:#ef4444;font-weight:700;">지금 멈추면 블로그 지수 상승도 멈춥니다.</span>
    </div>
    <div style="margin-top:20px;padding-top:16px;border-top:1px solid rgba(255,255,255,0.1);font-size:16px;color:#22c55e;font-weight:700;">
      흐름 끊기지 않고 계속 수익을 내시겠습니까?
    </div>
  `;

  payButton.onclick = () => {
    modalBackdrop.style.display = 'flex';
  };

  modalBackdrop.style.display = 'flex';
}

function wrapApiForPaywall(): void {
  if (paywallOriginalApi) return;
  const api: any = (window as any).api;
  if (!api) return;
  paywallOriginalApi = api;

  const wrapped: any = {};
  for (const key of Object.keys(api)) {
    const v = api[key];
    if (typeof v === 'function') {
      wrapped[key] = async (...args: any[]) => {
        const res = await v(...args);
        if (res && typeof res === 'object' && (res as any).code === 'PAYWALL') {
          activatePaywall(res as PaywallResponse);
        }
        return res;
      };
    } else {
      wrapped[key] = v;
    }
  }

  (window as any).api = wrapped;
}

async function initPaywallSystem(): Promise<void> {
  try {
    wrapApiForPaywall();
    if (typeof (window as any).api?.getQuotaStatus === 'function') {
      const status = await (window as any).api.getQuotaStatus();
      if (status?.success && status?.isFree && status?.quota?.isPaywalled) {
        activatePaywall({ success: false, code: 'PAYWALL', quota: status.quota } as any);
      }
    }
  } catch {
  }
}

// ✅ 쇼핑커넥트 CTA 자동 설정 초기화
function initShoppingConnectCTA(): void {
  const affiliateLinkInput = document.getElementById('shopping-connect-affiliate-link') as HTMLInputElement | null;
  const ctaTextInput = document.getElementById('unified-cta-text') as HTMLInputElement | null;
  const ctaLinkInput = document.getElementById('unified-cta-link') as HTMLInputElement | null;

  if (!affiliateLinkInput) return;

  // 후킹 문구 리스트 (구매를 유도하는 문구들)
  const hookingTexts = [
    '🔥 지금 최저가로 구매하기!',
    '💰 오늘만 이 가격! 놓치지 마세요!',
    '⭐ 한정 수량! 품절 전에 구매하세요!',
    '🛒 1분이면 끝! 바로 구매하기',
    '✨ 후회 없는 선택! 지금 확인하세요',
    '🎁 특별 할인 진행 중! 클릭하세요',
  ];

  affiliateLinkInput.addEventListener('input', () => {
    const affiliateLink = affiliateLinkInput.value.trim();

    if (affiliateLink) {
      // ✅ [2026-01-21 FIX] 새 제휴링크 입력 시 기존 캐시 데이터 초기화 (이전 제품 이미지 잔류 방지)
      // currentStructuredContent의 이미지 캐시 초기화
      const sc: any = (window as any).currentStructuredContent;
      if (sc) {
        if (sc.images && sc.images.length > 0) {
          console.log('[ShoppingConnect] 🧹 새 제휴링크 입력 → 기존 이미지 캐시 초기화');
          sc.images = [];
        }
        if (sc.collectedImages && sc.collectedImages.length > 0) {
          sc.collectedImages = [];
        }
        // 제품 정보도 초기화
        if (sc.productInfo) {
          sc.productInfo = null;
        }
      }

      // 이미지 관리 탭의 캐시도 초기화
      if ((window as any).imageManagementGeneratedImages && (window as any).imageManagementGeneratedImages.length > 0) {
        console.log('[ShoppingConnect] 🧹 이미지 관리 탭 캐시 초기화');
        (window as any).imageManagementGeneratedImages = [];
      }

      // CTA 링크 자동 설정
      if (ctaLinkInput && !ctaLinkInput.value.trim()) {
        ctaLinkInput.value = affiliateLink;
      }

      // CTA 텍스트 자동 설정 (랜덤 후킹 문구)
      if (ctaTextInput && !ctaTextInput.value.trim()) {
        const randomHook = hookingTexts[Math.floor(Math.random() * hookingTexts.length)];
        ctaTextInput.value = randomHook;
      }

      console.log('[ShoppingConnect] 🛒 제휴 링크 입력 → CTA 자동 설정됨');
    }
  });

  // 쇼핑커넥트 모드 활성화 시에도 CTA 자동 설정
  const shoppingConnectSettings = document.getElementById('shopping-connect-settings');
  if (shoppingConnectSettings) {
    const observer = new MutationObserver(() => {
      if (shoppingConnectSettings.style.display !== 'none' && affiliateLinkInput.value.trim()) {
        // 쇼핑커넥트 모드 활성화 시 CTA 자동 설정
        if (ctaLinkInput && !ctaLinkInput.value.trim()) {
          ctaLinkInput.value = affiliateLinkInput.value.trim();
        }
        if (ctaTextInput && !ctaTextInput.value.trim()) {
          const randomHook = hookingTexts[Math.floor(Math.random() * hookingTexts.length)];
          ctaTextInput.value = randomHook;
        }
      }
    });
    observer.observe(shoppingConnectSettings, { attributes: true, attributeFilter: ['style'] });
  }
}


// ✅ [2026-01-19] 쇼핑커넥트 배너 탭 전용 이벤트 리스너 (index.html의 subtab-shopping-banner)
let shoppingBannerTabInitialized = false;
function initShoppingBannerTab(): void {
  console.log('[ShoppingBanner] initShoppingBannerTab 호출됨, initialized:', shoppingBannerTabInitialized);

  if (shoppingBannerTabInitialized) {
    console.log('[ShoppingBanner] 이미 초기화됨, 미리보기만 업데이트');
    // 이미 초기화되었어도 미리보기는 업데이트
    const previewEl = document.getElementById('shopping-banner-preview') as HTMLElement;
    const mainTextEl = document.getElementById('shopping-banner-main-text') as HTMLElement;
    if (previewEl && mainTextEl) {
      console.log('[ShoppingBanner] 요소 확인됨, 정상 동작');
    }
    return;
  }
  shoppingBannerTabInitialized = true;

  const hookInput = document.getElementById('shopping-banner-hook') as HTMLInputElement;
  const previewEl = document.getElementById('shopping-banner-preview') as HTMLElement;
  const mainTextEl = document.getElementById('shopping-banner-main-text') as HTMLElement;
  const clickTextEl = document.getElementById('shopping-banner-click-text') as HTMLElement;
  const color1Input = document.getElementById('shopping-banner-color1') as HTMLInputElement;
  const sizeSelect = document.getElementById('shopping-banner-size') as HTMLSelectElement;
  const fontSlider = document.getElementById('shopping-banner-font-size') as HTMLInputElement;
  const fontValueEl = document.getElementById('shopping-banner-font-value') as HTMLElement;
  const showClickCheckbox = document.getElementById('shopping-banner-show-click') as HTMLInputElement;
  const resetBtn = document.getElementById('shopping-banner-reset-btn');
  const saveBtn = document.getElementById('shopping-banner-save-btn');

  // ✅ 디버그: 요소 찾기 결과 출력
  console.log('[ShoppingBanner] 요소 확인:', {
    hookInput: !!hookInput,
    previewEl: !!previewEl,
    mainTextEl: !!mainTextEl,
    color1Input: !!color1Input,
    sizeSelect: !!sizeSelect,
    fontSlider: !!fontSlider,
    resetBtn: !!resetBtn,
    saveBtn: !!saveBtn
  });

  if (!previewEl || !mainTextEl) {
    console.warn('[ShoppingBanner] ⚠️ 필수 요소를 찾을 수 없음! subtab-shopping-banner 패널이 DOM에 없을 수 있음');
    shoppingBannerTabInitialized = false; // 재시도 가능하도록 플래그 리셋
    return;
  }

  // ✅ 실시간 미리보기 업데이트 함수
  function updateShoppingBannerPreview() {
    if (!previewEl || !mainTextEl) return;

    const text = hookInput?.value || '[공식] 최저가 보러가기 →';
    const bgColor = color1Input?.value || '#03C75A';
    const width = sizeSelect?.value || '600';
    const fontSize = fontSlider?.value || '26';
    const showClick = showClickCheckbox?.checked !== false;

    previewEl.style.background = bgColor;
    previewEl.style.width = `${width}px`;
    mainTextEl.textContent = text;
    mainTextEl.style.fontSize = `${fontSize}px`;

    if (clickTextEl) {
      clickTextEl.style.display = showClick ? 'block' : 'none';
    }

    if (fontValueEl) fontValueEl.textContent = fontSize;
  }

  // ✅ 이벤트 리스너 바인딩
  hookInput?.addEventListener('input', updateShoppingBannerPreview);
  color1Input?.addEventListener('input', updateShoppingBannerPreview);
  sizeSelect?.addEventListener('change', updateShoppingBannerPreview);
  fontSlider?.addEventListener('input', updateShoppingBannerPreview);
  showClickCheckbox?.addEventListener('change', updateShoppingBannerPreview);

  // 프리셋 버튼 클릭
  document.querySelectorAll('.shopping-banner-preset').forEach(btn => {
    btn.addEventListener('click', () => {
      const hook = (btn as HTMLElement).dataset.hook || '';
      if (hookInput) hookInput.value = hook;
      updateShoppingBannerPreview();
    });
  });

  // 색상 프리셋 버튼
  document.querySelectorAll('.shopping-banner-color-preset').forEach(btn => {
    btn.addEventListener('click', () => {
      const color = (btn as HTMLElement).dataset.color || '#03C75A';
      if (color1Input) color1Input.value = color;
      updateShoppingBannerPreview();
    });
  });

  // 초기화 버튼
  resetBtn?.addEventListener('click', () => {
    if (hookInput) hookInput.value = '[공식] 최저가 보러가기 →';
    if (color1Input) color1Input.value = '#03C75A';
    if (sizeSelect) sizeSelect.value = '600';
    if (fontSlider) fontSlider.value = '26';
    if (showClickCheckbox) showClickCheckbox.checked = true;
    updateShoppingBannerPreview();
    // ✅ [2026-01-21] 저장된 설정 및 배너 경로 초기화
    localStorage.removeItem('shoppingBannerSettings');
    (window as any).customBannerPath = undefined; // 배너 경로도 초기화
    toastManager.success('🔄 배너 설정이 초기화되었습니다.');
  });

  // ✅ [2026-01-21] localStorage에서 저장된 설정 및 배너 경로 복원
  const savedSettings = localStorage.getItem('shoppingBannerSettings');
  if (savedSettings) {
    try {
      const settings = JSON.parse(savedSettings);
      if (hookInput && settings.text) hookInput.value = settings.text;
      if (color1Input && settings.bgColor) color1Input.value = settings.bgColor;
      if (sizeSelect && settings.width) sizeSelect.value = settings.width;
      if (fontSlider && settings.fontSize) fontSlider.value = settings.fontSize;
      if (showClickCheckbox && settings.showClick !== undefined) showClickCheckbox.checked = settings.showClick;
      updateShoppingBannerPreview();

      // ✅ [2026-01-21] 저장된 배너 경로 복원 (앱 재시작 후에도 커스텀 배너 사용)
      if (settings.bannerPath) {
        (window as any).customBannerPath = settings.bannerPath;
        console.log('[ShoppingBanner] 커스텀 배너 경로 복원:', settings.bannerPath);
      }

      appendLog('✅ 저장된 쇼핑커넥트 배너 설정을 불러왔습니다.');
    } catch (e) {
      console.warn('배너 설정 복원 실패:', e);
    }
  }

  // 저장 버튼 - 실제 배너 이미지 생성 + ✅ [2026-01-19] 설정을 localStorage에도 저장
  saveBtn?.addEventListener('click', async () => {
    const btn = saveBtn as HTMLButtonElement;
    try {
      btn.disabled = true;
      btn.innerHTML = '<span>⏳</span> 생성 중...';

      const bannerText = hookInput?.value || '[공식] 최저가 보러가기 →';
      const bannerBgColor = color1Input?.value || '#03C75A';
      const bannerWidth = sizeSelect?.value || '600';
      const bannerFontSize = fontSlider?.value || '26';
      const bannerShowClick = showClickCheckbox?.checked !== false;

      const result = await (window as any).api.generateCustomBanner({
        text: bannerText,
        colorKey: 'custom',
        sizeKey: 'standard',
        animationKey: 'shimmer',
        customBgColor: bannerBgColor,
      });

      if (result?.success) {
        (window as any).customBannerPath = result.path;

        // ✅ [2026-01-21] 설정과 배너 경로를 localStorage에 저장 (앱 재시작 후에도 유지)
        const settingsToSave = {
          text: bannerText,
          bgColor: bannerBgColor,
          width: bannerWidth,
          fontSize: bannerFontSize,
          showClick: bannerShowClick,
          bannerPath: result.path, // ✅ [2026-01-21] 커스텀 배너 경로 저장
          savedAt: new Date().toISOString()
        };
        localStorage.setItem('shoppingBannerSettings', JSON.stringify(settingsToSave));

        toastManager.success('✅ 배너가 저장되었습니다! 쇼핑커넥트 발행 시 자동 적용됩니다.');
      } else {
        throw new Error(result?.message || '저장 실패');
      }
    } catch (e) {
      toastManager.error(`배너 저장 실패: ${(e as Error).message}`);
    } finally {
      btn.disabled = false;
      btn.innerHTML = '<span>💾</span> 설정 저장';
    }
  });

  // ✅ [2026-01-19] 장단점 표 미리보기 이벤트 리스너
  const prosconsPreviewBtn = document.getElementById('proscons-preview-btn');
  prosconsPreviewBtn?.addEventListener('click', async () => {
    const btn = prosconsPreviewBtn as HTMLButtonElement;
    const container = document.getElementById('proscons-preview-container');
    const area = document.getElementById('proscons-preview-area');
    const status = document.getElementById('proscons-preview-status');

    const prosInput = document.getElementById('proscons-pros-input') as HTMLTextAreaElement;
    const consInput = document.getElementById('proscons-cons-input') as HTMLTextAreaElement;
    const productNameInput = document.getElementById('proscons-product-name') as HTMLInputElement;

    if (!container || !area) return;

    try {
      container.style.display = 'block';
      btn.disabled = true;
      btn.innerHTML = '<span>⏳</span> 생성 중...';
      if (status) status.textContent = '📊 장단점 표 생성 중...';

      // 줄바꿈으로 분리하여 배열로 변환
      const pros = (prosInput?.value || '').split('\n').filter(s => s.trim());
      const cons = (consInput?.value || '').split('\n').filter(s => s.trim());
      const productName = productNameInput?.value || '상품 리뷰';

      const result = await (window as any).api.generateProsConsTable({
        productName,
        pros,
        cons,
      });

      if (result?.success && result.path) {
        const timestamp = Date.now();
        area.innerHTML = `<img src="file://${result.path.replace(/\\\\/g, '/')}?t=${timestamp}" style="max-width:100%; border-radius:8px;" alt="장단점 표">`;
        if (status) status.textContent = '✅ 장단점 표 생성 완료!';
        toastManager.success('📊 장단점 표가 생성되었습니다!');
      } else {
        throw new Error(result?.message || '생성 실패');
      }
    } catch (e) {
      if (status) status.textContent = `❌ ${(e as Error).message}`;
      toastManager.error(`장단점 표 생성 실패: ${(e as Error).message}`);
    } finally {
      btn.disabled = false;
      btn.innerHTML = '<span>👁️</span> 미리보기 생성';
    }
  });

  // 초기 미리보기 업데이트
  updateShoppingBannerPreview();
  console.log('[ShoppingBannerTab] 이벤트 리스너 초기화 완료');
}

function initPurchaseInquiryButton(): void {
  const btn = document.getElementById('purchase-inquiry-btn') as HTMLButtonElement | null;
  if (!btn) return;

  btn.addEventListener('click', () => {
    window.api.openExternalUrl('https://open.kakao.com/o/sPcaslwh');
  });
}

// 메인 초기화 함수 (DOMContentLoaded와 상관없이 한 번만 실행)
async function initializeApplication(): Promise<void> {
  if ((window as any)._appInitialized) {
    console.log('[Init] 애플리케이션이 이미 초기화되어 중복 실행 방지');
    return;
  }
  (window as any)._appInitialized = true;

  console.log('[Init] 애플리케이션 초기화 시작');

  await initPaywallSystem();

  // DOM 캐시 초기화
  UnifiedDOMCache.init();

  appendLog('📝 자동화 시스템이 준비되었습니다.');

  // ✅ API 키 자동 로드 및 확인
  await autoLoadApiKeys(); // API 키 자동 로드 (한 번만 실행)

  // ✅ 저장된 설정 확인 로그
  try {
    const currentConfig = await window.api.getConfig();
    if (currentConfig) {
      // ✅ [2026-01-26 FIX] 전역 config 캐시 (getGenerator()에서 perplexity 감지용)
      (window as any).appConfig = currentConfig;
      const hasGemini = !!currentConfig.geminiApiKey;

      if (hasGemini) {
        appendLog('✅ 저장된 API 키가 로드되었습니다. 바로 사용 가능합니다!');

        // ✅ API 연결 사전 준비 (warm-up) - 백그라운드에서 DNS 및 TLS 캐싱
        // 첫 콘텐츠 생성 시 연결 시간을 줄여줌
        setTimeout(() => {
          warmupApiConnections(hasGemini);
        }, 2000); // 앱 로드 2초 후 시작
      }
    }
  } catch (e) {
    // 무시
  }

  initUnifiedTab();
  initImageLibrary();
  initThumbnailGenerator();
  initLicenseModal();
  initSettingsModal();
  try {
    initGeminiModelSync();
  } catch {
    // ignore
  }
  initCredentialsSave();
  initTitleGeneration();
  initHeadingImageGeneration();
  initApiGuideModal();
  initUserGuideModal();
  initContentHeadingImageGeneration();
  initCharCountDisplay();
  initImageManagementTab();
  initDashboard();
  initTabSwitching();
  initLicenseBadge(); // 라이선스 배지 초기화
  initCustomerServiceButton(); // 고객센터 버튼 초기화
  initPurchaseInquiryButton(); // 구매 문의하기 버튼 초기화
  initGlobalRefreshButton(); // 전체 초기화 버튼 초기화
  initUnifiedImageEventHandlers(); // ✅ 통합 이미지 이벤트 핸들러 초기화
  initShoppingConnectCTA(); // ✅ 쇼핑커넥트 CTA 자동 설정 초기화


  // ✅ 임시 저장 데이터 복구 확인
  setTimeout(() => {
    restoreAutosavedContent();
  }, 1000);

  console.log('[Init] 애플리케이션 초기화 완료');
}

// DOMContentLoaded 시 초기화 (한 번만 실행)
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    initializeApplication();
  });
} else {
  // 이미 로드된 경우 즉시 실행
  initializeApplication();
}

// ============================================
// 콘텐츠 작성 탭의 소제목 이미지 생성 기능 초기화
// ============================================
function initContentHeadingImageGeneration(): void {
  const contentGenerateImagesBtn = document.getElementById('generate-content-images-btn') as HTMLButtonElement;
  const contentImageProvider = document.getElementById('content-image-provider') as HTMLSelectElement;
  const contentGeneratedImagesPreview = document.getElementById('content-generated-images-preview') as HTMLDivElement;
  const contentGeneratedImagesGrid = document.getElementById('content-generated-images-grid') as HTMLDivElement;

  if (contentGenerateImagesBtn && contentImageProvider) {
    contentGenerateImagesBtn.addEventListener('click', async () => {
      const selectedCheckboxes = document.querySelectorAll('.structured-heading-checkbox:checked');
      if (selectedCheckboxes.length === 0) {
        alert('이미지를 생성할 소제목을 최소 1개 이상 선택해주세요.');
        return;
      }

      if (!currentStructuredContent || !currentStructuredContent.headings) {
        alert('생성된 구조화 콘텐츠가 없습니다.');
        return;
      }

      contentGenerateImagesBtn.disabled = true;
      contentGenerateImagesBtn.textContent = '이미지 생성 중...';
      appendLog(`🎨 ${selectedCheckboxes.length}개 소제목의 이미지 생성 시작...`);

      try {
        const selectedHeadingTitles = Array.from(selectedCheckboxes).map(checkbox =>
          (checkbox as HTMLInputElement).getAttribute('data-heading-title') || ''
        ).filter(title => title.length > 0);

        const selectedHeadings = currentStructuredContent.headings.filter(h =>
          selectedHeadingTitles.includes(h.title)
        );

        const provider = contentImageProvider.value as 'dalle' | 'pexels';

        const result = await window.api.generateImages({
          provider,
          items: selectedHeadings.map((h: any) => {
            const title = String(h.title || h.text || (typeof h === 'string' ? h : '')).trim();
            const prompt = String(h.imagePrompt || h.prompt || title || 'Abstract Image').trim();
            return {
              heading: title || '이미지',
              prompt: prompt
            };
          }),
          postTitle: currentStructuredContent?.selectedTitle,
          postId: currentPostId || undefined, // ✅ 글 ID 전달
          // ✅ 쇼핑커넥트 모드: 수집된 이미지 전달
          isShoppingConnect: true, // ✅ 쇼핑커넥트 강제 활성화
          collectedImages: (() => {
            const collected = currentStructuredContent?.collectedImages || [];
            console.log(`[Renderer] 🛒 쇼핑커넥트 이미지 전달: isShoppingConnect=${isShoppingConnectModeActive()}, collectedImages=${collected.length}개`);
            if (collected.length > 0) {
              console.log(`[Renderer]   첫번째 이미지: ${collected[0]?.substring?.(0, 80) || collected[0]}`);
            }
            return collected;
          })(),
        } as any);

        if (result.success && result.images && result.images.length > 0) {
          // 생성된 이미지 목록에 추가
          result.images.forEach(img => {
            // 중복 제거: 같은 heading이면 기존 것 제거
            generatedImages = generatedImages.filter(g => g.heading !== img.heading);
            generatedImages.push({
              heading: img.heading,
              filePath: img.filePath,
              previewDataUrl: img.previewDataUrl,
              provider: img.provider,
            });
          });

          // 이미지 그리드 표시 (✅ HTML 이스케이프 적용)
          if (contentGeneratedImagesGrid) {
            contentGeneratedImagesGrid.innerHTML = result.images.filter(img => img).map(img => {
              const safeHeading = escapeHtml(img.heading || '');
              const safeFilePath = escapeHtml(img.filePath || '');
              const imageRaw = img.previewDataUrl || img.filePath || (img as any).url || '';
              const imageUrl = toFileUrlMaybe(String(imageRaw || '').trim());
              return `
                <div class="image-item" data-image-id="${safeFilePath}">
                  <img src="${imageUrl}" alt="${safeHeading}" loading="lazy" style="width: 100%; height: 200px; object-fit: cover; border-radius: var(--radius-md);">
                  <div style="padding: 0.5rem; font-size: 0.875rem; font-weight: 600;">${safeHeading}</div>
                </div>
              `;
            }).join('');
          }

          if (contentGeneratedImagesPreview) {
            contentGeneratedImagesPreview.style.display = 'block';
          }

          appendLog(`✅ ${result.images.length}개의 이미지가 생성되었습니다.`);
          alert(`✅ ${result.images.length}개의 이미지가 생성되었습니다!`);
        } else {
          appendLog(`❌ 이미지 생성 실패: ${result.message || '알 수 없는 오류'}`);
          alert(`❌ 이미지 생성 실패: ${result.message || '알 수 없는 오류'}`);
        }
      } catch (error) {
        appendLog(`❌ 이미지 생성 오류: ${(error as Error).message}`);
        alert(`❌ 오류: ${(error as Error).message}`);
      } finally {
        contentGenerateImagesBtn.disabled = false;
        contentGenerateImagesBtn.textContent = '선택한 소제목 이미지 생성하기';
      }
    });
  }
}

// ============================================
// 이미지 라이브러리 초기화
// ============================================
async function initImageLibrary(): Promise<void> {
  // 저작권 경고 확인
  const acceptCopyrightBtn = document.getElementById('accept-copyright-warning') as HTMLButtonElement;
  const libraryContent = document.getElementById('library-content') as HTMLDivElement;
  const copyrightWarning = document.querySelector('.copyright-warning') as HTMLDivElement;

  if (acceptCopyrightBtn && libraryContent && copyrightWarning) {
    // 이미 확인했는지 로컬 스토리지에서 확인 (기본적으로 허용)
    const copyrightAccepted = localStorage.getItem('copyright-warning-accepted');
    if (copyrightAccepted === 'true') {
      copyrightWarning.style.display = 'none';
      libraryContent.style.display = 'block';
    } else {
      // 처음 방문 시 자동으로 확인 처리 (사용자 편의를 위해)
      localStorage.setItem('copyright-warning-accepted', 'true');
      copyrightWarning.style.display = 'none';
      libraryContent.style.display = 'block';
      toastManager.info('저작권 경고를 확인했습니다. 이미지 라이브러리를 사용할 수 있습니다.');
    }

    acceptCopyrightBtn.addEventListener('click', () => {
      // 로컬 스토리지에 저장
      localStorage.setItem('copyright-warning-accepted', 'true');

      // UI 업데이트
      copyrightWarning.style.display = 'none';
      libraryContent.style.display = 'block';

      // 성공 토스트
      toastManager.success('저작권 경고를 확인했습니다. 이미지 라이브러리를 사용할 수 있습니다.');
    });
  }

  const collectImagesBtn = document.getElementById('collect-images-btn') as HTMLButtonElement;
  const imageCategoryFilter = document.getElementById('image-category-filter') as HTMLSelectElement;
  const imageSearchKeywords = document.getElementById('image-search-keywords') as HTMLInputElement;
  const libraryImagesGrid = document.getElementById('library-images-grid') as HTMLDivElement;

  // 카테고리 로드
  if (imageCategoryFilter) {
    try {
      const categories = await window.api.getLibraryCategories();
      imageCategoryFilter.innerHTML = '<option value="">전체</option>' +
        categories.map(cat => `<option value="${cat}">${cat}</option>`).join('');

      imageCategoryFilter.addEventListener('change', async () => {
        await loadLibraryImages(imageCategoryFilter.value);
      });
    } catch (error) {
      console.error('카테고리 로드 실패:', error);
    }
  }

  // 고화질 토글 설정
  const highQualityToggle = document.getElementById('library-high-quality-toggle') as HTMLInputElement;
  if (highQualityToggle) {
    // 저장된 설정 불러오기
    const savedSetting = localStorage.getItem('library-use-high-quality');
    highQualityToggle.checked = savedSetting === 'true';

    // 토글 이벤트
    highQualityToggle.addEventListener('change', () => {
      localStorage.setItem('library-use-high-quality', highQualityToggle.checked.toString());

      // 이미지 다시 로드
      const currentCategory = imageCategoryFilter?.value;
      loadLibraryImages(currentCategory);

      toastManager.info(highQualityToggle.checked ? '고화질 모드로 전환되었습니다.' : '미리보기 모드로 전환되었습니다.');
    });
  }

  // 이미지 수집 버튼
  if (collectImagesBtn && imageSearchKeywords) {
    collectImagesBtn.addEventListener('click', async () => {
      const keywords = imageSearchKeywords.value.trim();
      if (!keywords) {
        alert('키워드를 입력해주세요.');
        return;
      }

      collectImagesBtn.disabled = true;
      collectImagesBtn.textContent = '수집 중...';

      // 선택된 크롤링 소스 확인
      const selectedSources: string[] = [];
      document.querySelectorAll('.library-source-checkbox:checked').forEach(checkbox => {
        selectedSources.push((checkbox as HTMLInputElement).value);
      });

      // 기본적으로 크롤링 소스 사용, 없으면 경고
      if (selectedSources.length === 0) {
        alert('⚠️ 수집할 소스를 하나 이상 선택해주세요.\n\n📡 뉴스 크롤링 또는 블로그 크롤링을 선택하세요.');
        collectImagesBtn.disabled = false;
        collectImagesBtn.textContent = '이미지 수집';
        return;
      }

      try {
        // 선택된 소스들을 사용해서 이미지 수집
        const result = await window.api.collectImagesByTitle(keywords, selectedSources);
        if (result.success) {
          alert(`✅ ${result.count}개의 이미지가 수집되었습니다.\n\n📊 수집된 이미지들은 라이브러리에 자동으로 추가됩니다.`);
          await loadLibraryImages();

          // 카테고리 새로고침
          const categories = await window.api.getLibraryCategories();
          if (imageCategoryFilter) {
            imageCategoryFilter.innerHTML = '<option value="">전체</option>' +
              categories.map(cat => `<option value="${cat}">${cat}</option>`).join('');
          }
        } else {
          alert(`❌ 이미지 수집 실패: ${result.message || '알 수 없는 오류'}`);
        }
      } catch (error) {
        alert(`❌ 오류: ${(error as Error).message}`);
      } finally {
        collectImagesBtn.disabled = false;
        collectImagesBtn.textContent = '이미지 수집';
      }
    });
  }

  // 이미지 그리드 초기 로드
  await loadLibraryImages();
}

async function loadLibraryImages(category?: string): Promise<void> {
  const libraryImagesGrid = document.getElementById('library-images-grid') as HTMLDivElement;
  if (!libraryImagesGrid) return;

  try {
    const titleInput = document.getElementById('post-title') as HTMLInputElement;
    const keywords = titleInput?.value.trim() ? [titleInput.value.trim()] : undefined;
    const images = await window.api.getLibraryImages(category, keywords);

    if (images.length === 0) {
      libraryImagesGrid.innerHTML = '<p class="text-center text-muted" style="grid-column: 1 / -1; padding: 2rem;">수집된 이미지가 없습니다.</p>';
      return;
    }

    // 고해상도 이미지 사용 옵션 확인
    const useHighQuality = localStorage.getItem('library-use-high-quality') === 'true';

    libraryImagesGrid.innerHTML = images.map(img => `
      <div class="image-item" data-image-id="${img.id}" style="position: relative;">
        <img src="${useHighQuality ? (img.url || img.previewDataUrl) : (img.previewDataUrl || img.url)}"
             alt="${img.sourceTitle || ''}"
             loading="lazy"
             style="width: 100%; height: 150px; object-fit: cover; border-radius: 8px;">
        <div class="image-quality-indicator" style="position: absolute; top: 8px; right: 8px; background: rgba(0,0,0,0.7); color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.75rem;">
          ${useHighQuality ? '고화질' : '미리보기'}
        </div>
        <div class="image-item-overlay">
          <button type="button" class="use-image-btn" data-image-id="${img.id}" title="이 이미지를 사용하여 블로그에 삽입">사용하기</button>
          <button type="button" class="save-image-btn" data-image-path="${img.filePath}" title="이 이미지를 로컬에 저장">로컬 저장</button>
          <button type="button" class="delete-image-btn" data-image-id="${img.id}" title="이 이미지를 라이브러리에서 삭제">삭제</button>
        </div>
      </div>
    `).join('');

    // 호버 이벤트는 CSS로 처리됨 (.image-item:hover .image-item-overlay)

    // 버튼 이벤트
    libraryImagesGrid.querySelectorAll('.use-image-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const imageId = (btn as HTMLButtonElement).getAttribute('data-image-id');
        if (imageId) {
          useLibraryImage(imageId);
        }
      });
    });

    libraryImagesGrid.querySelectorAll('.save-image-btn').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const filePath = (btn as HTMLButtonElement).getAttribute('data-image-path');
        if (filePath) {
          try {
            const success = await window.api.saveImageToLocal(filePath, `image-${Date.now()}.jpg`);
            if (success) {
              alert('✅ 이미지가 로컬에 저장되었습니다.');
            } else {
              alert('❌ 이미지 저장에 실패했습니다.');
            }
          } catch (error) {
            alert(`❌ 오류: ${(error as Error).message}`);
          }
        }
      });
    });

    libraryImagesGrid.querySelectorAll('.delete-image-btn').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const imageId = (btn as HTMLButtonElement).getAttribute('data-image-id');
        if (imageId && confirm('이미지를 삭제하시겠습니까?')) {
          try {
            const success = await window.api.deleteLibraryImage(imageId);
            if (success) {
              await loadLibraryImages(category);
            }
          } catch (error) {
            alert(`❌ 삭제 실패: ${(error as Error).message}`);
          }
        }
      });
    });
  } catch (error) {
    console.error('이미지 로드 실패:', error);
    libraryImagesGrid.innerHTML = '<p class="text-center text-muted" style="grid-column: 1 / -1; padding: 2rem;">이미지를 불러오는 중 오류가 발생했습니다.</p>';
  }
}

async function useLibraryImage(imageId: string): Promise<void> {
  try {
    const images = await window.api.getLibraryImages();
    const image = images.find(img => img.id === imageId);
    if (!image) {
      alert('이미지를 찾을 수 없습니다.');
      return;
    }

    // 이미지 선택 모달 열기
    const libraryImageModal = document.getElementById('library-image-modal') as HTMLDivElement;
    const libraryModalImagePreview = document.getElementById('library-modal-image-preview') as HTMLImageElement;
    const useLibraryImageBtn = document.getElementById('use-library-image-btn') as HTMLButtonElement;
    const saveLibraryImageLocalBtn = document.getElementById('save-library-image-local-btn') as HTMLButtonElement;
    const deleteLibraryImageBtn = document.getElementById('delete-library-image-btn') as HTMLButtonElement;

    if (libraryImageModal && libraryModalImagePreview) {
      libraryModalImagePreview.src = image.previewDataUrl || image.url;

      // 이미지 사용 버튼
      if (useLibraryImageBtn) {
        useLibraryImageBtn.onclick = () => {
          // 이미지 사용 로직 (나중에 구현)
          alert(`이미지 "${image.sourceTitle || imageId}"를 사용합니다.`);
          libraryImageModal.setAttribute('aria-hidden', 'true');
          libraryImageModal.style.display = 'none';
        };
      }

      // 로컬 저장 버튼
      if (saveLibraryImageLocalBtn) {
        saveLibraryImageLocalBtn.onclick = async () => {
          try {
            const success = await window.api.saveImageToLocal(image.filePath, `image-${Date.now()}.jpg`);
            if (success) {
              alert('✅ 이미지가 로컬에 저장되었습니다.');
            } else {
              alert('❌ 이미지 저장에 실패했습니다.');
            }
          } catch (error) {
            alert(`❌ 오류: ${(error as Error).message}`);
          }
        };
      }

      // 삭제 버튼
      if (deleteLibraryImageBtn) {
        deleteLibraryImageBtn.onclick = async () => {
          if (confirm('이미지를 삭제하시겠습니까?')) {
            try {
              const success = await window.api.deleteLibraryImage(imageId);
              if (success) {
                alert('✅ 이미지가 삭제되었습니다.');
                libraryImageModal.setAttribute('aria-hidden', 'true');
                libraryImageModal.style.display = 'none';
                await loadLibraryImages();
              }
            } catch (error) {
              alert(`❌ 삭제 실패: ${(error as Error).message}`);
            }
          }
        };
      }

      libraryImageModal.setAttribute('aria-hidden', 'false');
      libraryImageModal.style.display = 'flex';
    }
  } catch (error) {
    alert(`❌ 오류: ${(error as Error).message}`);
  }
}

// 라이브러리 이미지 모달 닫기 (전역 초기화)
const libraryImageModalForClose = document.getElementById('library-image-modal') as HTMLDivElement;
const closeLibraryImageButtons = Array.from(document.querySelectorAll<HTMLButtonElement>('[data-close-library-image]'));
if (libraryImageModalForClose) {
  closeLibraryImageButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      libraryImageModalForClose.setAttribute('aria-hidden', 'true');
      libraryImageModalForClose.style.display = 'none';
    });
  });

  libraryImageModalForClose.addEventListener('click', (e) => {
    if (e.target === libraryImageModalForClose) {
      libraryImageModalForClose.setAttribute('aria-hidden', 'true');
      libraryImageModalForClose.style.display = 'none';
    }
  });
}

// ============================================
// 썸네일 생성기 초기화 - ✅ 대폭 개선
// ============================================

// 썸네일 생성기 전역 상태
let thumbnailBackgroundImage: string | null = null;
let thumbnailBackgroundDataUrl: string | null = null;

function resolveFirstHeadingTitleForThumbnail(): string {
  // ✅ 글 제목을 우선 사용 (사용자 요청에 따라 수정)
  try {
    // 1. 생성된 제목 필드에서 가져오기
    const generatedTitleEl = document.getElementById('unified-generated-title') as HTMLInputElement | null;
    const generatedTitle = String(generatedTitleEl?.value || '').trim();
    if (generatedTitle) return generatedTitle;
  } catch {
    // ignore
  }

  try {
    // 2. 통합 제목 필드에서 가져오기
    const unifiedTitleEl = document.getElementById('unified-title') as HTMLInputElement | null;
    const unifiedTitle = String(unifiedTitleEl?.value || '').trim();
    if (unifiedTitle) return unifiedTitle;
  } catch {
    // ignore
  }

  try {
    // 3. currentStructuredContent에서 제목 가져오기
    const sc: any = (window as any).currentStructuredContent;
    const selectedTitle = String(sc?.selectedTitle || '').trim();
    if (selectedTitle) return selectedTitle;
  } catch {
    // ignore
  }

  // ✅ 제목이 없으면 1번 소제목 폴백
  try {
    const sc: any = (window as any).currentStructuredContent;
    const fromStructured = String(sc?.headings?.[0]?.title || '').trim();
    if (fromStructured) return fromStructured;
  } catch {
    // ignore
  }

  try {
    const domTitle = (document.querySelector(
      '#prompts-container .prompt-item[data-index="1"] .heading-title-text'
    ) as HTMLElement | null)?.textContent;
    const fromDom = String(domTitle || '').trim();
    if (fromDom) return fromDom;
  } catch {
    // ignore
  }

  try {
    const h0: any = (ImageManager as any)?.headings?.[0];
    const fromManager = typeof h0 === 'string' ? String(h0).trim() : String(h0?.title || '').trim();
    if (fromManager) return fromManager;
  } catch {
    // ignore
  }

  return '제목';
}


function initThumbnailGenerator(): void {
  const thumbnailPreview = document.getElementById('thumbnail-preview') as HTMLElement | null;
  const thumbnailText = document.getElementById('thumbnail-text') as HTMLInputElement;
  const thumbnailFontSize = document.getElementById('thumbnail-font-size') as HTMLInputElement;
  const thumbnailTextColor = document.getElementById('thumbnail-text-color') as HTMLInputElement;
  const thumbnailBgColor = document.getElementById('thumbnail-bg-color') as HTMLInputElement;
  const thumbnailBorderColor = document.getElementById('thumbnail-border-color') as HTMLInputElement;
  const thumbnailBorderWidth = document.getElementById('thumbnail-border-width') as HTMLInputElement;

  const autoGeneratePromptBtn = document.getElementById('auto-generate-prompt-btn') as HTMLButtonElement;
  const generateAiBackgroundBtn = document.getElementById('generate-ai-background-btn') as HTMLButtonElement;
  const loadExternalImageBtn = document.getElementById('load-external-image-btn') as HTMLButtonElement;
  const removeBackgroundImageBtn = document.getElementById('remove-background-image-btn') as HTMLButtonElement;
  const saveThumbnailBtn = document.getElementById('save-thumbnail-btn') as HTMLButtonElement;
  const useThumbnailBtn = document.getElementById('use-thumbnail-btn') as HTMLButtonElement;
  const aiPromptKeywords = document.getElementById('ai-prompt-keywords') as HTMLInputElement;
  const aiImagePrompt = document.getElementById('ai-image-prompt') as HTMLTextAreaElement;
  const aiPromptResultGroup = document.getElementById('ai-prompt-result-group') as HTMLDivElement;
  const aiImageProvider = document.getElementById('ai-image-provider') as HTMLSelectElement;

  // 프롬프트 자동 생성
  if (autoGeneratePromptBtn && aiPromptKeywords) {
    autoGeneratePromptBtn.addEventListener('click', async () => {
      const keywords = aiPromptKeywords.value.trim();
      if (!keywords) {
        alert('키워드를 입력해주세요.');
        return;
      }

      autoGeneratePromptBtn.disabled = true;
      autoGeneratePromptBtn.textContent = '생성 중...';

      try {
        const prompt = `Create a detailed English image generation prompt for a blog thumbnail image. The image should be visually appealing, professional, and suitable for a blog post about: ${keywords}. Include specific details about composition, lighting, colors, and style. Make it photorealistic and high quality.`;
        const result = await window.api.generateContent(prompt);
        if (result.success && result.content) {
          aiImagePrompt.value = result.content;
          if (aiPromptResultGroup) aiPromptResultGroup.style.display = 'block';
        } else {
          alert('프롬프트 생성에 실패했습니다.');
        }
      } catch (error) {
        alert(`오류: ${(error as Error).message}`);
      } finally {
        autoGeneratePromptBtn.disabled = false;
        autoGeneratePromptBtn.textContent = 'AI 프롬프트 자동 생성';
      }
    });
  }

  // ✅ 썸네일 미리보기 업데이트 (배경 이미지 지원)
  function updateThumbnailPreview(): void {
    if (!thumbnailPreview) return;

    const text = thumbnailText?.value || '';
    const fontSize = parseInt(thumbnailFontSize?.value || '32');
    const textColor = thumbnailTextColor?.value || '#ffffff';
    const bgColor = thumbnailBgColor?.value || '#1a1a2e';
    const borderColor = thumbnailBorderColor?.value || '#4a90d9';
    const borderWidth = parseInt(thumbnailBorderWidth?.value || '3');

    // 텍스트 줄바꿈 처리
    const lines = text.split('\n').filter(line => line.trim());
    const lineHeight = fontSize * 1.3;
    const startY = 200 - ((lines.length - 1) * lineHeight) / 2;

    let textElements = '';
    lines.forEach((line, index) => {
      const y = startY + (index * lineHeight);
      // 텍스트 그림자 효과
      textElements += `
        <text x="302" y="${y + 2}" text-anchor="middle" font-size="${fontSize}" fill="rgba(0,0,0,0.5)" font-weight="bold" font-family="'Noto Sans KR', sans-serif">${escapeHtml(line)}</text>
        <text x="300" y="${y}" text-anchor="middle" font-size="${fontSize}" fill="${textColor}" font-weight="bold" font-family="'Noto Sans KR', sans-serif">${escapeHtml(line)}</text>
      `;
    });

    // 배경 이미지가 있으면 사용, 없으면 단색 배경
    let backgroundElement = '';
    if (thumbnailBackgroundDataUrl) {
      backgroundElement = `
        <defs>
          <pattern id="bg-pattern" patternUnits="userSpaceOnUse" width="600" height="400">
            <image href="${thumbnailBackgroundDataUrl}" x="0" y="0" width="600" height="400" preserveAspectRatio="xMidYMid slice"/>
          </pattern>
        </defs>
        <rect width="600" height="400" fill="url(#bg-pattern)"/>
        <rect width="600" height="400" fill="rgba(0,0,0,0.3)"/>
      `;
    } else {
      backgroundElement = `<rect width="600" height="400" fill="${bgColor}"/>`;
    }

    (thumbnailPreview as HTMLElement).innerHTML = `
      ${backgroundElement}
      <rect x="${borderWidth / 2}" y="${borderWidth / 2}" width="${600 - borderWidth}" height="${400 - borderWidth}" fill="none" stroke="${borderColor}" stroke-width="${borderWidth}" rx="8"/>
      ${textElements}
    `;
  }

  // 모든 입력 필드에 이벤트 리스너 추가
  [thumbnailText, thumbnailFontSize, thumbnailTextColor, thumbnailBgColor, thumbnailBorderColor, thumbnailBorderWidth].forEach(el => {
    if (el) {
      el.addEventListener('input', updateThumbnailPreview);
    }
  });

  // 초기 미리보기
  updateThumbnailPreview();

  // ✅ AI 이미지 생성 버튼 - 실제 구현
  if (generateAiBackgroundBtn && aiImagePrompt && aiImageProvider) {
    generateAiBackgroundBtn.addEventListener('click', async () => {
      const prompt = aiImagePrompt.value.trim();
      if (!prompt) {
        alert('프롬프트를 입력하거나 자동 생성해주세요.');
        return;
      }

      generateAiBackgroundBtn.disabled = true;
      generateAiBackgroundBtn.textContent = '🎨 AI 이미지 생성 중...';

      try {
        const provider = aiImageProvider.value || 'gemini';

        // ✅ 실제 AI 이미지 생성 호출
        const result = await generateImagesWithCostSafety({
          provider: provider,
          items: [{ heading: '썸네일 배경', prompt: prompt, isThumbnail: false }]
        });

        if (result.success && result.images && result.images.length > 0) {
          const image = result.images[0];
          thumbnailBackgroundDataUrl = image.previewDataUrl || null;
          thumbnailBackgroundImage = image.filePath || null;

          updateThumbnailPreview();

          if (removeBackgroundImageBtn) removeBackgroundImageBtn.style.display = 'inline-block';
          alert('✅ AI 배경 이미지가 생성되었습니다!');
        } else {
          alert(`❌ 이미지 생성 실패: ${result.message || '알 수 없는 오류'}`);
        }
      } catch (error) {
        alert(`❌ 오류: ${(error as Error).message}`);
      } finally {
        generateAiBackgroundBtn.disabled = false;
        generateAiBackgroundBtn.textContent = '🎨 AI 배경 이미지 생성';
      }
    });
  }

  // ✅ 외부 이미지 가져오기 버튼 - 실제 구현
  if (loadExternalImageBtn) {
    if (loadExternalImageBtn.getAttribute('data-listener-added') !== 'true') {
      loadExternalImageBtn.setAttribute('data-listener-added', 'true');
      loadExternalImageBtn.addEventListener('click', async () => {
        try {
          const result = await window.api.selectLocalImageFile();
          if (result.success && result.filePath) {
            // 파일을 Data URL로 변환 (getLibraryImageData 사용)
            const dataUrl = await window.api.getLibraryImageData(result.filePath);
            if (dataUrl) {
              thumbnailBackgroundDataUrl = dataUrl;
              thumbnailBackgroundImage = result.filePath;

              updateThumbnailPreview();

              if (removeBackgroundImageBtn) removeBackgroundImageBtn.style.display = 'inline-block';
              alert('✅ 배경 이미지가 설정되었습니다!');
            } else {
              alert('❌ 이미지 로드 실패: 파일을 읽을 수 없습니다.');
            }
          }
        } catch (error) {
          alert(`❌ 오류: ${(error as Error).message}`);
        }
      });
    }
  }

  // 배경 이미지 제거 버튼
  if (removeBackgroundImageBtn) {
    removeBackgroundImageBtn.addEventListener('click', () => {
      if (confirm('배경 이미지를 제거하시겠습니까?')) {
        thumbnailBackgroundDataUrl = null;
        thumbnailBackgroundImage = null;
        removeBackgroundImageBtn.style.display = 'none';
        updateThumbnailPreview();
        alert('✅ 배경 이미지가 제거되었습니다.');
      }
    });
  }

  // ✅ 저장 버튼 - Canvas를 사용하여 PNG로 저장
  if (saveThumbnailBtn) {
    saveThumbnailBtn.addEventListener('click', async () => {
      if (!thumbnailPreview) return;

      saveThumbnailBtn.disabled = true;
      saveThumbnailBtn.textContent = '저장 중...';

      try {
        // SVG를 Canvas로 변환하여 PNG 생성
        const svgData = new XMLSerializer().serializeToString(thumbnailPreview);
        const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
        const svgUrl = URL.createObjectURL(svgBlob);

        const img = new Image();
        img.onload = async () => {
          const canvas = document.createElement('canvas');
          canvas.width = 600;
          canvas.height = 400;
          const ctx = canvas.getContext('2d');

          if (ctx) {
            ctx.drawImage(img, 0, 0);

            // Canvas를 PNG Data URL로 변환
            const pngDataUrl = canvas.toDataURL('image/png');

            // Data URL을 Uint8Array로 변환
            const base64Data = pngDataUrl.split(',')[1];
            const binaryString = atob(base64Data);
            const uint8Array = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              uint8Array[i] = binaryString.charCodeAt(i);
            }

            // PNG로 저장
            const result = await window.api.saveThumbnailToLocal(
              { type: 'image/png', data: Array.from(uint8Array) },
              'png'
            );

            if (result.success && result.filePath) {
              alert(`✅ 썸네일이 저장되었습니다:\n${result.filePath}`);
            } else {
              alert(`❌ 저장 실패: ${result.message || '알 수 없는 오류'}`);
            }
          }

          URL.revokeObjectURL(svgUrl);
          saveThumbnailBtn.disabled = false;
          saveThumbnailBtn.textContent = '💾 로컬에 저장';
        };

        img.onerror = () => {
          URL.revokeObjectURL(svgUrl);
          alert('❌ 이미지 변환에 실패했습니다.');
          saveThumbnailBtn.disabled = false;
          saveThumbnailBtn.textContent = '💾 로컬에 저장';
        };

        img.src = svgUrl;
      } catch (error) {
        alert(`❌ 오류: ${(error as Error).message}`);
        saveThumbnailBtn.disabled = false;
        saveThumbnailBtn.textContent = '💾 로컬에 저장';
      }
    });
  }

  // ✅ 사용 버튼 - 1번 이미지(썸네일)로 적용
  if (useThumbnailBtn) {
    useThumbnailBtn.addEventListener('click', async () => {
      if (!thumbnailPreview) {
        alert('먼저 썸네일을 생성해주세요.');
        return;
      }

      useThumbnailBtn.disabled = true;
      useThumbnailBtn.textContent = '적용 중...';

      try {
        // SVG를 Canvas로 변환하여 PNG Data URL 생성
        const svgData = new XMLSerializer().serializeToString(thumbnailPreview);
        const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
        const svgUrl = URL.createObjectURL(svgBlob);

        const img = new Image();
        img.onload = async () => {
          const canvas = document.createElement('canvas');
          canvas.width = 600;
          canvas.height = 400;
          const ctx = canvas.getContext('2d');

          if (ctx) {
            ctx.drawImage(img, 0, 0);
            const pngDataUrl = canvas.toDataURL('image/png');

            // ✅ 발행/그리드/프롬프트 전부에 반영되도록 로컬 파일로 저장
            const base64Data = pngDataUrl.split(',')[1];
            const binaryString = atob(base64Data);
            const uint8Array = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              uint8Array[i] = binaryString.charCodeAt(i);
            }

            let savedFilePath = '';
            try {
              const saveRes = await window.api.saveThumbnailToLocal(
                { type: 'image/png', data: Array.from(uint8Array) },
                'png'
              );
              if (saveRes?.success && saveRes.filePath) {
                savedFilePath = String(saveRes.filePath || '').trim();
              }
            } catch {
              // ignore
            }

            // ✅ 1번 이미지(썸네일) 미리보기에 적용
            const firstPromptItem = document.querySelector('.prompt-item[data-index="1"]');
            if (firstPromptItem) {
              const imageContainer = firstPromptItem.querySelector('.generated-image') as HTMLDivElement;
              if (imageContainer) {
                imageContainer.innerHTML = `
                  <img src="${pngDataUrl}" alt="썸네일" style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px;">
                  <div style="position: absolute; bottom: 4px; right: 4px; background: rgba(0,0,0,0.7); color: #4ade80; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem;">
                    ✅ 썸네일 적용됨
                  </div>
                `;
                imageContainer.style.position = 'relative';

                ensurePromptCardRemoveButtons();
                ensurePromptCardRemoveHandler();
              }

              // 전역 이미지 배열에도 저장
              const structuredContent = (window as any).currentStructuredContent as any;
              if (structuredContent?.headings && Array.isArray(structuredContent.headings)) {
                try {
                  ImageManager.setHeadings(structuredContent.headings);
                } catch {
                  // ignore
                }
              }

              const firstHeadingTitle = resolveFirstHeadingTitleForThumbnail();

              ImageManager.setImage(firstHeadingTitle, {
                ...(ImageManager.getImage(firstHeadingTitle) || {}),
                heading: firstHeadingTitle,
                previewDataUrl: pngDataUrl,
                url: pngDataUrl,
                filePath: savedFilePath || pngDataUrl,
                provider: 'thumbnail-generator',
                headingIndex: 0
              });

              // ✅ 전체 이미지 목록(예비 포함)은 imageManagementGeneratedImages로 유지
              const allImagesAfter = ImageManager.getAllImages();
              (window as any).imageManagementGeneratedImages = allImagesAfter;

              // ✅ generatedImages는 소제목 1장씩(순서 유지)로 유지
              ImageManager.syncGeneratedImagesArray();
              const perHeadingImages = generatedImages;
              (window as any).generatedImages = perHeadingImages;

              displayGeneratedImages(perHeadingImages);
              updatePromptItemsWithImages(perHeadingImages);
              const sc2: any = (window as any).currentStructuredContent;
              if (sc2?.headings) {
                updateUnifiedImagePreview(sc2.headings, perHeadingImages);
              }
              ImageManager.syncAllPreviews();

              alert('✅ 썸네일이 1번 이미지로 적용되었습니다!\n\n발행 시 이 이미지가 대표 이미지(썸네일)로 사용됩니다.');
            } else {
              // 프롬프트 아이템이 없으면 이미지 그리드에 적용 시도
              const imageGrid = document.getElementById('generated-images-grid');
              if (imageGrid) {
                const firstImageCard = imageGrid.querySelector('.image-card');
                if (firstImageCard) {
                  const imgEl = firstImageCard.querySelector('img');
                  if (imgEl) {
                    imgEl.src = pngDataUrl;
                    alert('✅ 썸네일이 1번 이미지로 적용되었습니다!');
                  }
                }
              } else {
                alert('⚠️ 먼저 글을 생성하여 소제목과 이미지를 만들어주세요.\n\n그 후 썸네일 생성기에서 만든 이미지를 1번 이미지로 적용할 수 있습니다.');
              }
            }
          }

          URL.revokeObjectURL(svgUrl);
          useThumbnailBtn.disabled = false;
          useThumbnailBtn.textContent = '✅ 1번 이미지로 사용';
        };

        img.onerror = () => {
          URL.revokeObjectURL(svgUrl);
          alert('❌ 이미지 변환에 실패했습니다.');
          useThumbnailBtn.disabled = false;
          useThumbnailBtn.textContent = '✅ 1번 이미지로 사용';
        };

        img.src = svgUrl;
      } catch (error) {
        alert(`❌ 오류: ${(error as Error).message}`);
        useThumbnailBtn.disabled = false;
        useThumbnailBtn.textContent = '✅ 1번 이미지로 사용';
      }
    });
  }
}

// ============================================
// 라이선스 서버 연결 테스트
// ============================================

// ✅ 향상된 fetch 래퍼 (재시도 로직 강화)
async function enhancedFetch(url: string, options: RequestInit = {}, retries: number = 7): Promise<Response> {
  let lastError: Error | null = null;

  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      console.log(`[Fetch] ${url} 요청 시도 ${attempt + 1}/${retries + 1}`);

      // ✅ 타임아웃 설정 (90초로 증가)
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 90000);

      const response = await fetch(url, {
        ...options,
        signal: controller.signal,
        // ✅ 추가 헤더로 연결 안정성 향상
        headers: {
          ...options.headers,
          'Connection': 'keep-alive',
          'Keep-Alive': 'timeout=90, max=100'
        }
      });

      clearTimeout(timeoutId);

      // ✅ 5xx 서버 오류는 재시도, 4xx 클라이언트 오류는 즉시 반환
      if (!response.ok) {
        const isServerError = response.status >= 500 && response.status < 600;
        const isRateLimit = response.status === 429;

        if ((isServerError || isRateLimit) && attempt < retries) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
      }

      // The instruction refers to a function `generateFullAutoContent` and variables `content`, `generatedImages`, `imageManagementGeneratedImages`
      // which are not present in the provided code document.
      // Therefore, the requested change cannot be applied as the context is missing.
      // Assuming the user wants to insert this block after the `if (!response.ok)` block,
      // but before the `return response;` or `catch` block, if this `enhancedFetch`
      // function is conceptually where `generateFullAutoContent` would be.
      // However, without the actual `generateFullAutoContent` function,
      // I cannot place it accurately.
      // I will place it here as a placeholder, but it's likely incorrect
      // given the context of `enhancedFetch` vs `generateFullAutoContent`.
      // This is a best guess based on the surrounding code provided in the instruction's `Code Edit` snippet.
      // The `Code Edit` snippet shows `console.log('[FullAuto] 구조화 콘텐츠 생성 완료');`
      // which is not in the current document. I will assume the user wants to add this line too.

      console.log('[FullAuto] 구조화 콘텐츠 생성 완료');

      // ✅ [Shopping Connect] 수집된 이미지가 있으면 전역 이미지 배열에 추가 (참조 이미지로 사용)
      // NOTE: `content`, `generatedImages`, `imageManagementGeneratedImages` are not defined in this scope.
      // This code block is placed here based on the user's instruction and provided context,
      // but it requires the surrounding `generateFullAutoContent` function and its variables.
      // This placement is a best effort given the missing context.
      // if (content.collectedImages && content.collectedImages.length > 0) {
      //   console.log(`[FullAuto] 수집된 이미지 ${content.collectedImages.length}장을 참조 이미지로 등록합니다.`);

      //   // 중복 방지하며 추가
      //   const existingUrls = new Set([...generatedImages, ...imageManagementGeneratedImages]);
      //   const newImages = content.collectedImages.filter(url => !existingUrls.has(url));

      //   if (newImages.length > 0) {
      //     generatedImages.push(...newImages);
      //     imageManagementGeneratedImages.push(...newImages);
      //     // UI 업데이트 필요 시 trigger (여기서는 데이터만 추가)
      //   }
      // }


      console.log(`[Fetch] ${url} 요청 성공`);
      return response;

    } catch (error: any) {
      lastError = error;
      console.warn(`[Fetch] ${url} 시도 ${attempt + 1} 실패:`, error.message);

      if (attempt < retries) {
        // ✅ 지수 백오프 + 지터 (랜덤 지연 추가로 동시 요청 충돌 방지)
        const baseDelay = 2000 * Math.pow(2, Math.min(attempt, 4)); // 최대 32초
        const jitter = Math.random() * 1000; // 0~1초 랜덤 지연
        const delay = baseDelay + jitter;

        console.log(`[Fetch] ${Math.round(delay)}ms 후 재시도...`);
        appendLog(`⚠️ 서버 연결 재시도 중... (${attempt + 1}/${retries}) - ${Math.round(delay / 1000)}초 대기`);
        toastManager.warning(`⚠️ 서버 연결 재시도 중... (${attempt + 1}/${retries})`, 2000);
        await new Promise(resolve => setTimeout(resolve, delay));
      } else {
        appendLog(`❌ 네트워크 오류: 모든 재시도 실패 (${retries + 1}회 시도)`);
        throw lastError || new Error('모든 재시도 실패');
      }
    }
  }

  throw lastError || new Error('모든 재시도 실패');
}


// ============================================
// 빠른 실행 툴바 초기화
// ============================================

// 탭 전환 함수
function switchToTab(tabName: string): void {
  // 모든 탭 버튼에서 active 제거
  const tabButtons = document.querySelectorAll('.tab-button');
  tabButtons.forEach(btn => {
    btn.classList.remove('active');
    btn.setAttribute('aria-selected', 'false');
  });

  // 모든 탭 패널 숨김
  const tabPanels = document.querySelectorAll('.tab-panel');
  tabPanels.forEach(panel => {
    panel.classList.remove('active');
  });

  // 지정된 탭 활성화
  const targetButton = document.querySelector(`[data-tab="${tabName}"]`) as HTMLElement;
  const targetPanel = document.getElementById(`tab-${tabName}`) as HTMLElement;

  if (targetButton && targetPanel) {
    targetButton.classList.add('active');
    targetButton.setAttribute('aria-selected', 'true');
    targetPanel.classList.add('active');
  }
}


// 즐겨찾기 컨텐츠 생성
function generateFavoritesContent(): string {
  const favorites = getFavoriteSettings();

  if (favorites.length === 0) {
    return `
      <div style="text-align: center; padding: 3rem; color: #6b7280;">
        <div style="font-size: 3rem; margin-bottom: 1rem;">⭐</div>
        <h3>즐겨찾기가 없습니다</h3>
        <p>자주 사용하는 설정을 즐겨찾기에 추가해보세요.</p>
      </div>
    `;
  }

  return `
    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1.5rem; padding: 0;">
      ${favorites.map((fav, index) => `
        <div class="unified-item" data-index="${index}" data-type="favorites" onclick="selectUnifiedItem(this)" ondblclick="applyUnifiedItem('favorites', ${index})" style="
          border: 2px solid #e5e7eb; border-radius: 12px; padding: 1.5rem;
          cursor: pointer; transition: all 0.2s; background: white;
        ">
          <div style="display: flex; align-items: start; gap: 1rem;">
            <div style="width: 40px; height: 40px; border-radius: 8px; background: linear-gradient(135deg, #f59e0b, #d97706); display: flex; align-items: center; justify-content: center; color: white; font-size: 1.2rem;">
              ⭐
            </div>
            <div style="flex: 1;">
              <h4 style="margin: 0 0 0.5rem 0; font-size: 1rem; font-weight: 600; color: #1f2937;">${fav.name}</h4>
              <p style="margin: 0 0 0.5rem 0; font-size: 0.8rem; color: #6b7280;">${fav.description}</p>
              <div style="display: flex; align-items: center; gap: 1rem; font-size: 0.75rem; color: #9ca3af;">
                <span>🎯 ${fav.category || '일반'}</span>
                <span>📊 ${fav.usageCount || 0}회 사용</span>
              </div>
            </div>
          </div>
        </div>
      `).join('')}
    </div>
  `;
}

// 템플릿 컨텐츠 생성
function generateTemplatesContent(): string {
  const templates = getEnhancedTemplates();

  return `
    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 1.5rem; padding: 0;">
      ${templates.map((template, index) => `
        <div class="unified-item" data-index="${index}" data-type="templates" onclick="selectUnifiedItem(this)" ondblclick="applyUnifiedItem('templates', ${index})" style="
          border: 2px solid #e5e7eb; border-radius: 12px; padding: 1.5rem;
          cursor: pointer; transition: all 0.2s; background: white; position: relative;
        ">
          <div style="position: absolute; top: 1rem; right: 1rem;">
            <span style="background: ${template.color}; color: white; padding: 0.25rem 0.5rem; border-radius: 12px; font-size: 0.7rem; font-weight: 600;">${template.category}</span>
          </div>
          <div style="display: flex; align-items: start; gap: 1rem;">
            <div style="width: 50px; height: 50px; border-radius: 10px; background: ${template.bgColor}; display: flex; align-items: center; justify-content: center; color: white; font-size: 1.5rem;">
              ${template.icon}
            </div>
            <div style="flex: 1;">
              <h4 style="margin: 0 0 0.5rem 0; font-size: 1.1rem; font-weight: 600; color: #1f2937;">${template.name}</h4>
              <p style="margin: 0 0 0.75rem 0; font-size: 0.85rem; color: #6b7280; line-height: 1.4;">${template.description}</p>
              <div style="display: flex; align-items: center; gap: 1rem; font-size: 0.75rem; color: #9ca3af;">
                <span>📊 ${template.wordCount}자</span>
                <span>⭐ ${template.popularity}/5.0</span>
                <span>👥 ${template.usageCount}회 사용</span>
              </div>
              <div style="margin-top: 0.75rem; display: flex; flex-wrap: wrap; gap: 0.25rem;">
                ${template.tags.map(tag => `<span style="background: #f3f4f6; color: #374151; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.7rem;">${tag}</span>`).join('')}
              </div>
            </div>
          </div>
        </div>
      `).join('')}
    </div>
  `;
}

// 향상된 템플릿 데이터
function getEnhancedTemplates(): Array<{
  name: string;
  description: string;
  category: string;
  icon: string;
  color: string;
  bgColor: string;
  wordCount: number;
  popularity: number;
  usageCount: number;
  tags: string[];
}> {
  return [
    {
      name: '📰 뉴스 스타일',
      description: '최신 뉴스나 트렌드 정보를 전문적으로 전달하는 형식입니다. 객관적이고 신뢰할 수 있는 콘텐츠를 생성합니다.',
      category: '정보',
      icon: '📰',
      color: '#3b82f6',
      bgColor: 'linear-gradient(135deg, #3b82f6, #1d4ed8)',
      wordCount: 1200,
      popularity: 4.8,
      usageCount: 1247,
      tags: ['뉴스', '트렌드', '정보', '전문성']
    },
    {
      name: '⭐ 제품 리뷰',
      description: '제품이나 서비스의 장단점을 분석하고 사용자 경험을 공유하는 리뷰 형식입니다.',
      category: '리뷰',
      icon: '⭐',
      color: '#f59e0b',
      bgColor: 'linear-gradient(135deg, #f59e0b, #d97706)',
      wordCount: 800,
      popularity: 4.6,
      usageCount: 892,
      tags: ['리뷰', '제품', '서비스', '분석']
    },
    {
      name: '📚 사용법 가이드',
      description: '단계별로 설명하는 사용법이나 튜토리얼 형식입니다. 초보자도 쉽게 따라할 수 있도록 구성됩니다.',
      category: '교육',
      icon: '📚',
      color: '#10b981',
      bgColor: 'linear-gradient(135deg, #10b981, #059669)',
      wordCount: 1500,
      popularity: 4.7,
      usageCount: 756,
      tags: ['가이드', '튜토리얼', '교육', '단계별']
    },
    {
      name: '📖 스토리텔링',
      description: '이야기 형식으로 콘텐츠를 전달하는 형식입니다. 독자의 공감을 불러일으키는 감성적인 접근을 합니다.',
      category: '스토리',
      icon: '📖',
      color: '#8b5cf6',
      bgColor: 'linear-gradient(135deg, #8b5cf6, #7c3aed)',
      wordCount: 1000,
      popularity: 4.5,
      usageCount: 634,
      tags: ['스토리', '이야기', '감성', '공감']
    },
    {
      name: '💡 꿀팁 공유',
      description: '실용적이고 도움이 되는 생활 꿀팁이나 노하우를 공유하는 형식입니다.',
      category: '라이프',
      icon: '💡',
      color: '#06b6d4',
      bgColor: 'linear-gradient(135deg, #06b6d4, #0891b2)',
      wordCount: 600,
      popularity: 4.4,
      usageCount: 523,
      tags: ['꿀팁', '라이프', '실용', '노하우']
    },
    {
      name: '🔬 전문 분석',
      description: '데이터와 사실에 기반한 전문적인 분석 콘텐츠입니다. 신뢰할 수 있는 정보를 제공합니다.',
      category: '분석',
      icon: '🔬',
      color: '#ef4444',
      bgColor: 'linear-gradient(135deg, #ef4444, #dc2626)',
      wordCount: 1800,
      popularity: 4.9,
      usageCount: 445,
      tags: ['분석', '데이터', '전문성', '신뢰성']
    },
    {
      name: '🎯 비교 분석',
      description: '여러 옵션을 비교하고 장단점을 분석하는 형식입니다. 선택에 도움이 되는 정보를 제공합니다.',
      category: '비교',
      icon: '🎯',
      color: '#f97316',
      bgColor: 'linear-gradient(135deg, #f97316, #ea580c)',
      wordCount: 1400,
      popularity: 4.6,
      usageCount: 398,
      tags: ['비교', '분석', '선택', '장단점']
    },
    {
      name: '🌟 성공 사례',
      description: '실제 성공 사례를 공유하고 교훈을 전달하는 형식입니다. 동기부여 콘텐츠에 적합합니다.',
      category: '동기부여',
      icon: '🌟',
      color: '#ec4899',
      bgColor: 'linear-gradient(135deg, #ec4899, #db2777)',
      wordCount: 900,
      popularity: 4.3,
      usageCount: 312,
      tags: ['성공', '사례', '동기부여', '교훈']
    },
    {
      name: '🤝 인터뷰 형식',
      description: 'Q&A 형식의 인터뷰 콘텐츠입니다. 전문가의 의견을 자연스럽게 전달합니다.',
      category: '인터뷰',
      icon: '🤝',
      color: '#84cc16',
      bgColor: 'linear-gradient(135deg, #84cc16, #65a30d)',
      wordCount: 1100,
      popularity: 4.2,
      usageCount: 267,
      tags: ['인터뷰', 'Q&A', '전문가', '의견']
    },
    {
      name: '📈 트렌드 분석',
      description: '시장 트렌드와 미래 전망을 분석하는 콘텐츠입니다. 인사이트를 제공합니다.',
      category: '트렌드',
      icon: '📈',
      color: '#6366f1',
      bgColor: 'linear-gradient(135deg, #6366f1, #4f46e5)',
      wordCount: 1300,
      popularity: 4.7,
      usageCount: 589,
      tags: ['트렌드', '분석', '미래', '인사이트']
    }
  ];
}

// 아이템 선택
function selectUnifiedItem(element: HTMLElement): void {
  // 기존 선택 해제
  document.querySelectorAll('.unified-item').forEach(item => {
    (item as HTMLElement).style.borderColor = '#e5e7eb';
    (item as HTMLElement).style.boxShadow = 'none';
  });

  // 새로 선택
  element.style.borderColor = '#3b82f6';
  element.style.boxShadow = '0 0 0 3px rgba(59, 130, 246, 0.1)';

  // 적용 버튼 표시
  const applyBtn = document.getElementById('apply-btn');
  if (applyBtn) {
    applyBtn.style.display = 'block';
  }
}

// 아이템 적용
function applyUnifiedItem(type: string, index: number): void {
  console.log(`${type} 아이템 적용:`, index);
  // 빠른 실행 기능이 제거되었으므로 빈 함수로 유지
  closeUnifiedModal();
}

// 선택된 아이템 적용
function applySelectedItem(): void {
  const selectedItem = document.querySelector('.unified-item[style*="border-color: rgb(59, 130, 246)"]') as HTMLElement;
  if (selectedItem) {
    const type = selectedItem.dataset.type;
    const index = parseInt(selectedItem.dataset.index || '0');
    applyUnifiedItem(type || '', index);
  }
}

// 검색 필터링
function filterUnifiedContent(): void {
  const searchInput = document.getElementById('unified-search') as HTMLInputElement;
  const query = searchInput.value.toLowerCase();
  const items = document.querySelectorAll('.unified-item');

  items.forEach(item => {
    const text = item.textContent?.toLowerCase() || '';
    (item as HTMLElement).style.display = text.includes(query) ? 'block' : 'none';
  });
}

// 정렬
function sortUnifiedContent(): void {
  // 정렬 로직 구현 (필요시)
  console.log('정렬 기능은 추후 구현 예정');
}

// 모달 닫기
function closeUnifiedModal(): void {
  const modal = document.getElementById('unified-modal');
  if (modal) {
    document.removeEventListener('keydown', handleModalKeydown);
    modal.remove();
  }
}

// 키보드 이벤트 핸들러
function handleModalKeydown(e: KeyboardEvent): void {
  if (e.key === 'Escape') {
    closeUnifiedModal();
  }
}

// ✅ 전역 키보드 단축키 지원
function initKeyboardShortcuts(): void {
  document.addEventListener('keydown', (e) => {
    // Ctrl/Cmd + K: 검색 포커스
    if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
      e.preventDefault();
      const searchInput = document.getElementById('posts-search-input') as HTMLInputElement;
      if (searchInput) {
        searchInput.focus();
        searchInput.select();
      }
    }

    // Ctrl/Cmd + S: 저장 (자동 저장 트리거)
    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
      const target = e.target as HTMLElement;
      // 입력 필드에 포커스가 있을 때만 저장
      if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
        e.preventDefault();
        appendLog('💾 수동 저장이 트리거되었습니다. (자동 저장은 30초마다 실행됩니다)');
      }
    }

    // Ctrl/Cmd + N: 새 글 생성 (필드 초기화)
    if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
      const target = e.target as HTMLElement;
      if (target.tagName !== 'INPUT' && target.tagName !== 'TEXTAREA') {
        e.preventDefault();
        if (confirm('모든 필드를 초기화하고 새 글을 작성하시겠습니까?')) {
          resetAllFields();
          appendLog('🆕 새 글 작성을 위해 필드가 초기화되었습니다.');
        }
      }
    }

    // Ctrl/Cmd + F: 검색 (기본 브라우저 검색 방지)
    if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
      const target = e.target as HTMLElement;
      if (target.tagName !== 'INPUT' && target.tagName !== 'TEXTAREA') {
        e.preventDefault();
        const searchInput = document.getElementById('posts-search-input') as HTMLInputElement;
        if (searchInput) {
          searchInput.focus();
          searchInput.select();
        }
      }
    }

    // ESC: 모달 닫기
    if (e.key === 'Escape') {
      const modals = document.querySelectorAll('[style*="z-index: 10000"], [style*="z-index: 10001"]');
      modals.forEach(modal => {
        if (modal instanceof HTMLElement && modal.style.display !== 'none') {
          modal.remove();
        }
      });
    }
  });
}




// 즐겨찾기 설정 가져오기
function getFavoriteSettings(): Array<{ name: string; description: string; category: string; usageCount: number }> {
  // 실제로는 config에서 가져와야 함
  return [
    { name: '블로그 포스팅 기본', description: '일반적인 블로그 글 작성 설정', category: '블로그', usageCount: 25 },
    { name: 'SEO 최적화 모드', description: '검색엔진 최적화에 특화된 설정', category: 'SEO', usageCount: 18 },
    { name: '트렌드 분석 모드', description: '시장 트렌드 분석에 적합한 설정', category: '분석', usageCount: 12 }
  ];
}

function getAvailableTemplates(): Array<{ name: string; description: string }> {
  return [
    { name: '뉴스 스타일', description: '최신 뉴스 형식의 콘텐츠' },
    { name: '리뷰 스타일', description: '제품 리뷰 형식' },
    { name: '사용법 가이드', description: '단계별 사용법 설명' },
    { name: '스토리텔링', description: '이야기 형식의 콘텐츠' }
  ];
}

// ✅ 연속발행 모드 카테고리 분석 초기화
function initContinuousCategorySync(): void {
  console.log('[Continuous] 카테고리 동기화 초기화 완료 (모달 방식 사용)');
}

// ✅ 다중계정 발행 모드 카테고리 분석 초기화 (공통 모달 방식 사용)
function initMultiAccountCategorySync(): void {
  console.log('[Multi-Account] 카테고리 동기화 초기화 완료 (모달 방식 사용)');
}


// ============================================
// 카테고리 선택 모달 초기화
// ============================================
// ✅ 실제 네이버 블로그 카테고리 분석 및 동기화 루틴
function initRealCategorySync(): void {
  const analyzeBtn = document.getElementById('analyze-blog-categories-btn') as HTMLButtonElement;
  const dropdownContainer = document.getElementById('real-category-dropdown-container');
  const categorySelect = document.getElementById('real-blog-category-select') as HTMLSelectElement;

  if (!analyzeBtn || !dropdownContainer || !categorySelect) return;

  analyzeBtn.addEventListener('click', async () => {
    try {
      analyzeBtn.disabled = true;
      const originalHtml = analyzeBtn.innerHTML;
      analyzeBtn.innerHTML = '<span style="font-size: 1.2rem;">⏳</span><span>분석 중...</span>';

      const config = await (window as any).api.getConfig();
      const naverId = (document.getElementById('naver-id') as HTMLInputElement)?.value?.trim() || config.savedNaverId;
      const naverPassword = (document.getElementById('naver-password') as HTMLInputElement)?.value?.trim() || config.savedNaverPassword;

      if (!naverId || !naverPassword) {
        alert('⚠️ 네이버 아이디와 비밀번호를 먼저 입력하거나 저장해주세요.');
        analyzeBtn.disabled = false;
        analyzeBtn.innerHTML = originalHtml;
        return;
      }

      appendLog(`🔎 네이버 카테고리 분석 시작 (${naverId})...`);

      const response = await (window as any).api.fetchBlogCategories({
        naverId,
        naverPassword
      });

      if (response && response.success && response.categories && response.categories.length > 0) {
        // 기존 옵션 제거 (첫 번째 제외)
        while (categorySelect.options.length > 1) {
          categorySelect.remove(1);
        }

        response.categories.forEach((cat: { id: string; name: string }) => {
          const option = document.createElement('option');
          option.value = cat.name;
          option.textContent = cat.name;
          categorySelect.appendChild(option);
        });

        dropdownContainer.style.display = 'block';
        appendLog(`✅ ${response.categories.length}개의 카테고리를 성공적으로 가져왔습니다.`);
        if ((window as any).toastManager) {
          (window as any).toastManager.success(`✅ ${response.categories.length}개의 카테고리를 가져왔습니다.`);
        }
      } else {
        const errorMsg = response.message || '카테고리 정보를 가져오지 못했습니다.';
        alert(`⚠️ ${errorMsg}\n계정 정보를 확인하거나 잠시 후 다시 시도해주세요.`);
        appendLog(`❌ 카테고리 분석 실패: ${errorMsg}`);
      }
    } catch (error) {
      console.error('Category Sync Error:', error);
      alert(`⚠️ 오류 발생: ${(error as any).message}`);
      appendLog(`❌ 카테고리 분석 중 오류: ${(error as any).message}`);
    } finally {
      analyzeBtn.disabled = false;
      analyzeBtn.innerHTML = '<span style="font-size: 1.2rem;">🔍</span><span>블로그 실제 카테고리 분석하기</span>';
    }
  });

  // 카테고리 선택 시 로그 출력
  categorySelect.addEventListener('change', () => {
    if (categorySelect.value) {
      appendLog(`📂 발행 카테고리 설정됨: "${categorySelect.value}"`);
    }
  });
}

function initCategoryModal(): void {
  const openBtn = document.getElementById('open-category-modal-btn');
  // ✅ 다중계정용 버튼 추가
  const maOpenBtn = document.getElementById('ma-open-category-modal-btn');
  // ✅ 연속발행용 버튼 추가
  const continuousOpenBtn = document.getElementById('continuous-open-category-modal-btn');

  const modal = document.getElementById('category-selection-modal');
  const closeBtn = document.getElementById('close-category-modal');
  const cancelBtn = document.getElementById('cancel-category-modal');
  const confirmBtn = document.getElementById('confirm-category-modal');

  // ✅ 모달이 body 직속이 아닌 경우 body로 이동 (중첩 문제 해결)
  if (modal && modal.parentElement !== document.body) {
    console.log('[CategoryModal] 모달이 body 직속이 아님 - body로 이동');
    console.log('[CategoryModal] 현재 부모:', modal.parentElement?.id || modal.parentElement?.tagName);
    document.body.appendChild(modal);
    console.log('[CategoryModal] 모달을 body로 이동 완료');
  }

  // ✅ 추가 버튼들 (계정 설정 및 연속발행용)
  const maSettingOpenBtn = document.getElementById('ma-setting-open-category-btn');
  const continuousCategoryBtn = document.getElementById('continuous-category-btn');

  // 스마트 자동발행용 UI 요소
  const categorySelect = document.getElementById('unified-article-type') as HTMLSelectElement;
  const selectedCategoryText = document.getElementById('selected-category-text');
  const selectedCategoriesDisplay = document.getElementById('selected-categories-display');
  const selectedCategoryName = document.getElementById('selected-category-name');

  // ✅ 다중계정용 UI 요소
  const maCategoryInput = document.getElementById('ma-content-category') as HTMLInputElement;
  const maCategoryBtnText = document.getElementById('ma-selected-category-text');
  const maCategoryDisplay = document.getElementById('ma-selected-categories-display');
  const maCategoryName = document.getElementById('ma-selected-category-name');
  const maAffiliateBtn = document.getElementById('ma-affiliate-mode-btn'); // 쇼핑커넥트 모드 버튼
  const maOpenBtnEl = maOpenBtn as HTMLElement;

  // 어떤 모드에서 열었는지 추적 ('smart-publish' | 'multi-account' | 'continuous' | 'ma-setting')
  let currentMode = 'smart-publish';

  const categoryNames: Record<string, string> = {
    'general': '💭 일상·생각',
    'literature': '📚 문학·책',
    'movie': '🎬 영화',
    'art_design': '🎨 미술·디자인',
    'performance': '🎭 공연·전시',
    'music': '🎵 음악',
    'drama': '📺 드라마',
    'celebrity': '⭐ 스타·연예인',
    'cartoon': '🎌 만화·애니',
    'broadcast': '📡 방송',
    'tips': '💡 생활 꿀팁',
    'parenting': '👶 육아·결혼',
    'pet': '🐶 반려동물',
    'good_writing': '🖼️ 좋은글·이미지',
    'fashion': '👗 패션·미용',
    'interior': '🏠 인테리어·DIY',
    'food_recipe': '🍳 요리·레시피',
    'shopping_review': '📦 상품리뷰',
    'gardening': '🌱 원예·재배',
    'game': '🎮 게임',
    'sports': '⚽ 스포츠',
    'photo': '📷 사진',
    'car': '🚗 자동차',
    'hobby': '🎯 취미',
    'travel_domestic': '🗺️ 국내여행',
    'travel_world': '✈️ 세계여행',
    'tasty_restaurant': '🍽️ 맛집',
    'it_computer': '💻 IT·컴퓨터',
    'society_politics': '📰 사회·정치',
    'health': '🏥 건강·의학',
    'business_economy': '💼 비즈니스·경제',
    'language': '🌍 어학·외국어',
    'education_scholarship': '🎓 교육·학문',
    'realestate': '🏢 부동산',
    'self_dev': '📈 자기계발'
  };
  (window as any).categoryNames = categoryNames;

  // ✅ 모달 열림 직후 클릭으로 인한 즉시 닫힘 방지 플래그
  let justOpened = false;

  // 공통 열기 로직 (hoisted by using function declaration or moving up)
  function openModal(mode: 'smart-publish' | 'multi-account' | 'continuous' | 'ma-setting' | 'continuous-settings' | 'edit-queue') {
    if (!modal) {
      console.error('[CategoryModal] Modal element not found');
      return;
    }
    currentMode = mode;
    // setAttribute를 사용해서 스타일을 강제로 설정 (!important 포함)
    const modalStyle = 'display: flex !important; position: fixed !important; top: 0 !important; left: 0 !important; width: 100vw !important; height: 100vh !important; background: rgba(0, 0, 0, 0.8) !important; z-index: 999999 !important; align-items: center !important; justify-content: center !important;';
    modal.setAttribute('style', modalStyle);
    console.log('[CategoryModal] Style attribute set:', modal.getAttribute('style'));

    let targetValue = '';
    if (mode === 'smart-publish') targetValue = categorySelect?.value || '';
    else if (mode === 'multi-account') targetValue = maCategoryInput?.value || '';
    else if (mode === 'continuous') {
      const contInput = document.getElementById('continuous-category-select') as HTMLInputElement;
      targetValue = contInput?.value || '';
    } else if (mode === 'continuous-settings') {
      const modalCategoryInput = document.getElementById('continuous-modal-category-select') as HTMLInputElement;
      targetValue = modalCategoryInput?.value || '';
    } else if (mode === 'edit-queue') {
      const editCategoryInput = document.getElementById('edit-queue-category') as HTMLInputElement;
      targetValue = editCategoryInput?.value || '';
    } else if (mode === 'ma-setting') {
      const settingInput = document.getElementById('ma-setting-category') as HTMLInputElement;
      targetValue = settingInput?.value || '';
    }

    if (targetValue) {
      const radio = modal.querySelector(`input[name="category-radio"][value="${targetValue}"]`) as HTMLInputElement;
      if (radio) radio.checked = true;
    }

    // 디버그: 모달 상태 확인
    console.log(`[CategoryModal] Modal opened in ${mode} mode, target: ${targetValue}`);
    console.log('[CategoryModal] Modal element:', modal);
    console.log('[CategoryModal] Modal display:', modal.style.display);
    console.log('[CategoryModal] Modal zIndex:', modal.style.zIndex);
    console.log('[CategoryModal] Modal computed display:', window.getComputedStyle(modal).display);
    console.log('[CategoryModal] Modal offsetParent:', modal.offsetParent);
    console.log('[CategoryModal] Modal getBoundingClientRect:', modal.getBoundingClientRect());

    // ✅ 이벤트 버블링으로 인한 즉시 닫힘 방지
    justOpened = true;
    setTimeout(() => {
      justOpened = false;
    }, 100);
  }

  // ✅ 전역 함수로 노출하여 HTML의 onclick에서도 접근 가능하도록 함
  (window as any).openUnifiedCategoryModal = () => {
    console.log('[CategoryModal] Global openUnifiedCategoryModal called');
    openModal('smart-publish');
  };

  // 모달 동기화 함수 노출
  (window as any).syncModalWithSmartPublish = () => {
    const targetValue = categorySelect?.value || '';
    if (targetValue && modal) {
      const radio = modal.querySelector(`input[name="category-radio"][value="${targetValue}"]`) as HTMLInputElement;
      if (radio) radio.checked = true;
    }
  };

  // ✅ 설정창용 모달 열기 함수 노출
  (window as any).openCategoryModalInSettingMode = () => {
    openModal('ma-setting');
  };

  // ✅ 연속 발행 모드용 모달 열기 함수 노출
  (window as any).openCategoryModalInContinuousMode = (mode?: string) => {
    openModal((mode as any) || 'continuous');
  };

  if (!openBtn || !modal) {
    console.warn('[CategoryModal] 카테고리 모달 초기화 필수 요소(btn/modal)가 부족하여 일부 초기화만 진행');
    return;
  }


  openBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    openModal('smart-publish');
  });
  if (maOpenBtn) maOpenBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    openModal('multi-account');
  });
  if (maSettingOpenBtn) maSettingOpenBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    openModal('ma-setting');
  });
  if (continuousOpenBtn) continuousOpenBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    openModal('continuous');
  });
  if (continuousCategoryBtn) continuousCategoryBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    openModal('continuous');
  });

  // 모달 닫기 함수
  const closeModal = () => {
    console.log('[CategoryModal] closeModal called - closing modal');
    console.trace('[CategoryModal] Close stack trace:');
    modal.style.display = 'none';
  };

  // 닫기 버튼
  if (closeBtn) {
    closeBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      closeModal();
    });
  }

  // 취소 버튼
  if (cancelBtn) {
    cancelBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      closeModal();
    });
  }

  // 배경 클릭 시 닫기 - 이벤트가 모달 배경에서 직접 발생한 경우에만
  modal.addEventListener('click', (e) => {
    console.log('[CategoryModal] Modal click detected, target:', e.target, 'modal:', modal);
    console.log('[CategoryModal] e.target === modal:', e.target === modal);
    console.log('[CategoryModal] justOpened:', justOpened);
    // ✅ 열린 직후에는 닫기 무시 (이벤트 버블링 방지)
    if (justOpened) {
      console.log('[CategoryModal] Ignoring click - modal just opened');
      return;
    }
    if (e.target === modal) {
      closeModal();
    }
  });

  // 라디오 버튼 호버 효과
  const categoryItems = modal.querySelectorAll('.category-checkbox-item');
  categoryItems.forEach(item => {
    item.addEventListener('mouseenter', () => {
      (item as HTMLElement).style.background = 'rgba(59, 130, 246, 0.1)';
    });
    item.addEventListener('mouseleave', () => {
      const radio = item.querySelector('input[type="radio"]') as HTMLInputElement;
      if (!radio?.checked) {
        (item as HTMLElement).style.background = 'transparent';
      }
    });
  });

  // ✅ 리뷰형 선택 가능한 카테고리 목록 (신규 고유 ID 대응)
  const reviewableCategories = [
    'fashion', 'interior', 'shopping_review', 'car', 'game', 'hobby',
    'pet', 'food_recipe', 'it_computer', 'travel_domestic', 'travel_world',
    'literature', 'movie', 'drama', 'cartoon', 'art_design', 'performance',
    'music', 'photo', 'parenting'
  ];

  // ✅ 글 유형 선택 UI 표시/숨김
  const contentTypeSelector = document.getElementById('content-type-selector');
  const selectedCategoryForType = document.getElementById('selected-category-for-type');

  // 카테고리 라디오 버튼 클릭 시 글 유형 선택 UI 표시
  const categoryRadios = modal.querySelectorAll('input[name="category-radio"]');
  categoryRadios.forEach(radio => {
    radio.addEventListener('change', (e) => {
      const target = e.target as HTMLInputElement;
      const value = target.value;
      const label = target.parentElement?.querySelector('span')?.textContent || categoryNames[value] || value;

      if (reviewableCategories.includes(value) && contentTypeSelector) {
        contentTypeSelector.style.display = 'block';
        if (selectedCategoryForType) {
          selectedCategoryForType.textContent = label;
        }
      } else if (contentTypeSelector) {
        contentTypeSelector.style.display = 'none';

        // ✅ 리뷰형 선택이 남아있지 않도록 info로 강제
        const infoRadio = modal.querySelector('input[name="content-type-radio"][value="info"]') as HTMLInputElement;
        if (infoRadio) infoRadio.checked = true;
      }
    });
  });

  // 선택 완료 버튼
  if (confirmBtn) {
    confirmBtn.addEventListener('click', () => {
      const selectedRadio = modal.querySelector('input[name="category-radio"]:checked') as HTMLInputElement;

      if (!selectedRadio) {
        alert('⚠️ 카테고리를 선택해주세요.');
        return;
      }

      let value = selectedRadio.value;
      const label = selectedRadio.parentElement?.querySelector('span')?.textContent || categoryNames[value] || value;

      if (currentMode === 'smart-publish') {
        // ---- [스마트 자동발행 로직] ----

        // ✅ 글 유형 선택 확인 (리뷰형/정보형)
        const contentTypeRadio = modal.querySelector('input[name="content-type-radio"]:checked') as HTMLInputElement;
        const contentType = reviewableCategories.includes(value) ? (contentTypeRadio?.value || 'info') : 'info';
        const isReviewType = contentType === 'review';

        // ✅ 리뷰형 선택 시 카테고리를 리뷰 버전으로 변경
        if (isReviewType && reviewableCategories.includes(value)) {
          // 리뷰형 선택 시 특정 카테고리로 매핑 (네이버 로직 대응)
          if (value === 'it_computer' || value === 'shopping_review') {
            // 이미 리뷰 성격의 카테고리면 유지
          } else if (['game', 'photo', 'art_design', 'music', 'it_computer'].includes(value)) {
            value = 'it_computer'; // 소품/IT류 리뷰는 IT·컴퓨터로
          } else {
            value = 'shopping_review'; // 나머지는 상품리뷰로
          }
        }

        // hidden select 업데이트
        if (categorySelect) {
          console.log('[CategoryModal] Setting unified-article-type.value to:', selectedRadio.value);
          categorySelect.value = selectedRadio.value; // 원본 값 저장 (표시용)
          categorySelect.setAttribute('data-user-selected', 'true');
          categorySelect.dispatchEvent(new Event('change'));
          console.log('[CategoryModal] Final unified-article-type.value:', categorySelect.value);
        }

        // ✅ 글 유형 저장 (전역 변수)
        (window as any).selectedContentType = contentType;

        // 버튼 텍스트 업데이트
        const typeLabel = isReviewType ? ' (리뷰형)' : '';
        if (selectedCategoryText) {
          selectedCategoryText.textContent = label + typeLabel;
        }

        // 선택된 카테고리 표시
        if (selectedCategoriesDisplay && selectedCategoryName) {
          selectedCategoriesDisplay.style.display = 'block';
          selectedCategoryName.textContent = label + typeLabel;
        }

        // 버튼 스타일 변경
        if (isReviewType) {
          openBtn.style.background = 'linear-gradient(135deg, #8b5cf6, #7c3aed)';
        } else {
          openBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
        }

        appendLog(`✅ 카테고리 선택됨: ${label}${typeLabel}`);

        // ✅ 글 유형 선택 UI 숨기기
        if (contentTypeSelector) {
          contentTypeSelector.style.display = 'none';
        }

      } else if (currentMode === 'multi-account') {
        // ---- [다중계정 로직] ----

        // 다중계정은 단순하게 선택된 원본 카테고리 값을 사용합니다.
        if (maCategoryInput) {
          maCategoryInput.value = value;
        }

        if (maCategoryBtnText) {
          maCategoryBtnText.textContent = label;
        }

        if (maCategoryDisplay && maCategoryName) {
          maCategoryDisplay.style.display = 'block';
          maCategoryName.textContent = label;
        }

        // ✅ 쇼핑커넥트 버튼 표시 로직
        // 원본 선택값이 리뷰 가능한 카테고리라면 쇼핑커넥트 모드 버튼을 보여줍니다.
        if (maAffiliateBtn) {
          if (reviewableCategories.includes(value)) {
            maAffiliateBtn.style.display = 'flex';
            maAffiliateBtn.animate([
              { transform: 'scale(0.8)', opacity: 0 },
              { transform: 'scale(1)', opacity: 1 }
            ], { duration: 300, easing: 'ease-out' });
          } else {
            maAffiliateBtn.style.display = 'none';

            // 만약 현재 쇼핑커넥트 모드가 선택되어 있었다면 SEO 모드로 강제 변경
            const modeInput = document.getElementById('ma-content-mode') as HTMLInputElement;
            if (modeInput?.value === 'affiliate') {
              modeInput.value = 'seo';
              document.querySelector('.ma-content-mode-btn[data-mode="seo"]')?.classList.add('selected');
              document.querySelector('.ma-content-mode-btn[data-mode="affiliate"]')?.classList.remove('selected');
            }
          }
        }

        // 버튼 색상 변경 (녹색 고정)
        if (maOpenBtnEl) {
          maOpenBtnEl.style.background = 'linear-gradient(135deg, #10b981, #059669)';
        }

        appendLog(`📂 [다중계정] 카테고리 선택됨: ${label}`);
      } else if (currentMode === 'continuous') {
        // ---- [연속발행 로직] ----
        const continuousCategoryInput = document.getElementById('continuous-category-select') as HTMLInputElement;
        const continuousCategoryBtnText = document.getElementById('continuous-category-text');
        const continuousCategoryBtn = document.getElementById('continuous-category-btn');

        if (continuousCategoryInput) {
          continuousCategoryInput.value = value;
        }

        if (continuousCategoryBtnText) {
          continuousCategoryBtnText.textContent = `📂 ${label}`;
        }

        // 버튼 스타일 변경
        if (continuousCategoryBtn) {
          continuousCategoryBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
          continuousCategoryBtn.style.borderColor = '#10b981';
          continuousCategoryBtn.style.color = 'white';
        }

        appendLog(`📂 [연속발행] 카테고리 선택됨: ${label}`);
        // ✅ 쇼핑커넥트 옵션 표시 여부 업데이트
        if (typeof (window as any).updateAffiliateOptionVisibility === 'function') {
          (window as any).updateAffiliateOptionVisibility(value, 'continuous-modal-content-mode');
        }
      } else if (currentMode === 'continuous-settings') {
        // ---- [연속발행 상세 설정 로직] ----
        const modalCategoryInput = document.getElementById('continuous-modal-category-select') as HTMLInputElement;
        const modalCategoryText = document.getElementById('continuous-modal-category-text');

        // 메인 UI 요소 (동기화 대상)
        const mainCategoryInput = document.getElementById('continuous-category-select') as HTMLInputElement;
        const mainCategoryText = document.getElementById('continuous-category-text');

        if (modalCategoryInput) modalCategoryInput.value = value;
        if (modalCategoryText) modalCategoryText.textContent = label;
        if (mainCategoryInput) mainCategoryInput.value = value;
        if (mainCategoryText) mainCategoryText.textContent = `📂 ${label}`;

        appendLog(`📂 [연속발행 설정] 카테고리 선택됨: ${label}`);
        if (typeof (window as any).updateAffiliateOptionVisibility === 'function') {
          (window as any).updateAffiliateOptionVisibility(value, 'continuous-modal-content-mode');
        }
      } else if (currentMode === 'ma-setting') {
        // ---- [다중계정 설정창 로직] ----
        const settingCategoryInput = document.getElementById('ma-setting-category') as HTMLInputElement;
        const settingCategoryText = document.getElementById('ma-setting-category-text');

        if (settingCategoryInput) {
          settingCategoryInput.value = value;
        }

        if (settingCategoryText) {
          settingCategoryText.textContent = label;
        }

        appendLog(`📂 [다중계정 설정] 카테고리 선택됨: ${label}`);
        // ✅ 쇼핑커넥트 옵션 표시 여부 업데이트
        if (typeof (window as any).updateAffiliateOptionVisibility === 'function') {
          (window as any).updateAffiliateOptionVisibility(value, 'ma-setting-content-mode');
        }
      } else if (currentMode === 'edit-queue') {
        // ---- [큐 항목 수정 로직] ----
        if (typeof (window as any).openCategoryModalForEditQueue === 'function') {
          (window as any).openCategoryModalForEditQueue(value, label);
        }
        appendLog(`📂 [큐 수정] 카테고리 선택됨: ${label}`);
      }

      closeModal();
    });
  }

  console.log('[CategoryModal] 카테고리 모달 초기화 완료');
}

// ============================================
// 통합 탭 초기화
// ============================================
async function initUnifiedTab(): Promise<void> {
  console.log('[Unified] 통합 탭 초기화 시작');

  // URL 필드 관리 초기화
  try {
    initUnifiedUrlFields();
    console.log('[Unified] URL 필드 관리 초기화 완료');

    // ✅ 실시간 미리보기 동기화 초기화
    initUnifiedRealtimeSync();
  } catch (error) {
    console.error('[Unified] URL 필드 관리 초기화 실패:', error);
  }

  // ✅ [Fix] 반자동 편집 필드 변경 시 currentStructuredContent 동기화 (입력 리스너 등록)
  // 영상 생성 후 UI 리프레시 시 사용자가 직접 입력한 내용이 사라지는 문제 해결
  const semiAutoTitle = document.getElementById('unified-generated-title') as HTMLInputElement;
  const semiAutoContent = document.getElementById('unified-generated-content') as HTMLTextAreaElement;
  const semiAutoHashtags = document.getElementById('unified-generated-hashtags') as HTMLInputElement;

  if (semiAutoTitle) {
    semiAutoTitle.addEventListener('input', () => {
      const sc = (window as any).currentStructuredContent;
      if (sc) {
        sc.title = semiAutoTitle.value;
        sc.selectedTitle = semiAutoTitle.value;
      }
    });
  }

  if (semiAutoContent) {
    semiAutoContent.addEventListener('input', () => {
      const sc = (window as any).currentStructuredContent;
      if (sc) {
        sc.bodyPlain = semiAutoContent.value;
        sc.content = semiAutoContent.value;
      }
    });
  }

  if (semiAutoHashtags) {
    semiAutoHashtags.addEventListener('input', () => {
      const sc = (window as any).currentStructuredContent;
      if (sc) {
        // 입력된 해시태그 문자열을 그대로 저장 (fillSemiAutoFields에서 string도 처리함)
        sc.hashtags = semiAutoHashtags.value;
      }
    });
  }

  // ✅ 카테고리 선택 모달 초기화
  initCategoryModal();
  initRealCategorySync();
  initContinuousCategorySync(); // ✅ 연속발행 모드용 카테고리 분석 초기화
  initMultiAccountCategorySync(); // ✅ 다중계정 발행 모드용 카테고리 분석 초기화

  // ✅ 페러프레이징 버튼 이벤트
  const paraphraseBtn = document.getElementById('paraphrase-mode-btn');
  if (paraphraseBtn) {
    paraphraseBtn.addEventListener('click', async () => {
      await paraphraseContent();
    });
  }

  // ✅ 생성된 글 목록 새로고침 버튼
  const refreshPostsBtn = document.getElementById('refresh-posts-list-btn');
  if (refreshPostsBtn) {
    refreshPostsBtn.addEventListener('click', () => {
      refreshGeneratedPostsList();
    });
  }

  // ✅ 내보내기, 가져오기, 통계 버튼 이벤트 리스너 (초기화 시 한 번만 연결)
  const exportBtn = document.getElementById('export-posts-btn');
  if (exportBtn && !exportBtn.hasAttribute('data-listener-added')) {
    exportBtn.setAttribute('data-listener-added', 'true');
    exportBtn.addEventListener('click', () => {
      exportAllPosts();
    });
  }

  const importBtn = document.getElementById('import-posts-btn');
  if (importBtn && !importBtn.hasAttribute('data-listener-added')) {
    importBtn.setAttribute('data-listener-added', 'true');
    importBtn.addEventListener('click', () => {
      importPosts();
    });
  }

  const statsBtn = document.getElementById('posts-stats-btn');
  if (statsBtn && !statsBtn.hasAttribute('data-listener-added')) {
    statsBtn.setAttribute('data-listener-added', 'true');
    statsBtn.addEventListener('click', () => {
      showPostsStatsDashboard();
    });
  }

  const selectAllBtn = document.getElementById('posts-select-all-btn');
  if (selectAllBtn && !selectAllBtn.hasAttribute('data-listener-added')) {
    selectAllBtn.setAttribute('data-listener-added', 'true');
    selectAllBtn.addEventListener('click', () => {
      toggleSelectAllPosts();
    });
  }

  const batchDeleteBtn = document.getElementById('posts-batch-delete-btn');
  if (batchDeleteBtn && !batchDeleteBtn.hasAttribute('data-listener-added')) {
    batchDeleteBtn.setAttribute('data-listener-added', 'true');
    batchDeleteBtn.addEventListener('click', () => {
      batchDeletePosts();
    });
  }

  const viewToggleBtn = document.getElementById('posts-view-toggle-btn');
  if (viewToggleBtn && !viewToggleBtn.hasAttribute('data-listener-added')) {
    viewToggleBtn.setAttribute('data-listener-added', 'true');
    viewToggleBtn.addEventListener('click', () => {
      togglePostsView();
    });
  }

  const refreshBtn = document.getElementById('refresh-posts-list-btn');
  if (refreshBtn && !refreshBtn.hasAttribute('data-listener-added')) {
    refreshBtn.setAttribute('data-listener-added', 'true');
    refreshBtn.addEventListener('click', () => {
      refreshGeneratedPostsList();
    });
  }

  // 초기 로드 시 목록 표시
  refreshGeneratedPostsList();

  // ✅ 로그 및 진행상황 초기화 버튼 이벤트 리스너
  const unifiedResetLogBtn = document.getElementById('unified-reset-log-btn');
  const unifiedResetProgressBtn = document.getElementById('unified-reset-progress-btn');
  const imagesResetLogBtn = document.getElementById('images-reset-log-btn');
  const imagesResetProgressBtn = document.getElementById('images-reset-progress-btn');

  if (unifiedResetLogBtn) {
    unifiedResetLogBtn.addEventListener('click', () => {
      resetLogAndProgress('unified-log-output');
    });
  }

  if (unifiedResetProgressBtn) {
    unifiedResetProgressBtn.addEventListener('click', () => {
      resetLogAndProgress(undefined, 'unified-progress-container');
    });
  }

  if (imagesResetLogBtn) {
    imagesResetLogBtn.addEventListener('click', () => {
      resetLogAndProgress('images-log-output');
    });
  }

  if (imagesResetProgressBtn) {
    imagesResetProgressBtn.addEventListener('click', () => {
      resetLogAndProgress(undefined, 'images-progress-container');
    });
  }

  // 발행 모드 선택
  try {
    initUnifiedModeSelection();
    console.log('[Unified] 발행 모드 선택 초기화 완료');
  } catch (error) {
    console.error('[Unified] 발행 모드 선택 초기화 실패:', error);
  }

  // 이미지 소스 선택
  try {
    initUnifiedImageSourceSelection();
    console.log('[Unified] 이미지 소스 선택 초기화 완료');
  } catch (error) {
    console.error('[Unified] 이미지 소스 선택 초기화 실패:', error);
  }

  // ✅ 1번 이미지 텍스트 옵션 체크박스 동적 추가 (풀오토/반자동)
  try {
    addThumbnailTextOptionUI();
    console.log('[Unified] 1번 이미지 텍스트 옵션 UI 추가 완료');
  } catch (error) {
    console.error('[Unified] 1번 이미지 텍스트 옵션 UI 추가 실패:', error);
  }

  // 발행 모드 관련 코드 제거 (발행설정의 풀오토/반자동으로 대체)

  // ✅ URL에서 키워드 추출 버튼
  const extractKeywordsBtn = document.getElementById('extract-keywords-btn') as HTMLButtonElement;
  if (extractKeywordsBtn && !extractKeywordsBtn.hasAttribute('data-listener-added')) {
    extractKeywordsBtn.setAttribute('data-listener-added', 'true');
    console.log('[Unified] extract-keywords-btn 이벤트 리스너 등록');

    extractKeywordsBtn.addEventListener('click', async () => {
      console.log('[Unified] 키워드 추출 버튼 클릭됨');

      // URL 필드에서 첫 번째 URL 가져오기 (클래스명 수정: unified-url-field -> unified-url-input)
      const urlFields = document.querySelectorAll('.unified-url-input') as NodeListOf<HTMLInputElement>;
      const firstUrl = urlFields[0]?.value.trim();

      if (!firstUrl) {
        toastManager.warning('📝 URL을 먼저 입력해주세요.');
        return;
      }

      // URL 유효성 검사
      try {
        new URL(firstUrl);
      } catch {
        alert('❌ 올바른 URL 형식이 아닙니다.\n\n예: https://example.com/article');
        return;
      }

      const originalText = extractKeywordsBtn.textContent;
      extractKeywordsBtn.disabled = true;

      // ✅ 로딩 애니메이션 시작
      const loadingSteps = [
        '🔄 URL 접속 중...',
        '📥 콘텐츠 수집 중...',
        '🤖 AI 분석 중...',
        '🎯 키워드 추출 중...'
      ];
      let stepIndex = 0;
      const loadingInterval = setInterval(() => {
        extractKeywordsBtn.innerHTML = `<span style="display: inline-flex; align-items: center; gap: 0.25rem;">${loadingSteps[stepIndex]}</span>`;
        stepIndex = (stepIndex + 1) % loadingSteps.length;
      }, 1500);

      extractKeywordsBtn.innerHTML = `<span style="display: inline-flex; align-items: center; gap: 0.25rem;">${loadingSteps[0]}</span>`;

      appendLog('🎯 URL에서 키워드 추출 시작...');
      appendLog(`📎 URL: ${firstUrl}`);

      try {
        // 1. generateStructuredContent API를 사용하여 URL 크롤링 및 키워드 추출
        appendLog('📥 URL 크롤링 및 AI 키워드 분석 중... (약 10~30초 소요)');

        const generator = (document.getElementById('unified-generator') as HTMLSelectElement)?.value || 'gemini';

        const keywordPrompt = `다음 URL의 콘텐츠를 분석하여 핵심 키워드와 제목을 추출해주세요.
- 원본 글의 주제와 핵심 내용을 가장 잘 나타내는 제목을 한 줄로 추출합니다.
- 추출된 제목에는 "블로그 상위노출", "진짜 이유", "핵심 팁" 같은 지침성 단어나 예시 문구를 포함하지 마세요.

URL: ${firstUrl}

[추출 요청]
1. 핵심 키워드 1개 (메인 키워드)
2. 서브 키워드 3~5개 (연관 키워드)
3. 롱테일 키워드 2~3개 (세부 키워드)
4. 원본 글 제목

[출력 형식 - 반드시 이 형식으로만 출력]
제목: [원본 글 제목]
핵심: [핵심키워드]
서브: [키워드1], [키워드2], [키워드3]
롱테일: [롱테일1], [롱테일2]

키워드와 제목만 간결하게 출력하세요.`;

        // generateStructuredContent API 사용
        const apiClient = EnhancedApiClient.getInstance();
        const apiResponse = await apiClient.call(
          'generateStructuredContent',
          [{
            assembly: {
              generator: generator as 'gemini' | 'openai' | 'claude',
              rssUrl: firstUrl,
              targetAge: 'all',
              minChars: 500,
              articleType: 'general',
              customPrompt: keywordPrompt
            }
          }],
          {
            retryCount: 3,
            retryDelay: 2000,
            timeout: 600000 // ✅ 10분 타임아웃 (크롤링 + Gemini 폴백 시간 고려)
          }
        );

        if (!apiResponse.success) {
          throw new Error(apiResponse.error || '키워드 추출에 실패했습니다.');
        }

        appendLog('✅ URL 분석 완료!');

        // 결과에서 키워드 추출
        const result = apiResponse.data;
        let mainKeyword = '';
        let subKeywords: string[] = [];
        let longTailKeywords: string[] = [];
        let originalTitle = '';

        // structuredContent에서 정보 추출
        if (result?.content) {
          const content = result.content;

          // 제목 추출
          originalTitle = content.selectedTitle || content.title || '';

          // 해시태그에서 키워드 추출
          if (content.hashtags && content.hashtags.length > 0) {
            mainKeyword = content.hashtags[0].replace('#', '');
            subKeywords = content.hashtags.slice(1, 5).map((h: string) => h.replace('#', ''));
          }

          // 소제목에서 추가 키워드 추출
          if (content.headings && content.headings.length > 0) {
            const headingKeywords = content.headings
              .slice(0, 3)
              .map((h: any) => h.title || h)
              .filter((t: string) => t && t.length < 20);
            longTailKeywords = headingKeywords;
          }
        }

        // 4. 키워드 필드에 자동 입력
        const keywordsInput = document.getElementById('unified-keywords') as HTMLInputElement;
        if (keywordsInput) {
          const allKeywords = [mainKeyword, ...subKeywords].filter(k => k).join(', ');
          keywordsInput.value = allKeywords;
          appendLog(`📝 키워드 필드에 자동 입력됨: ${allKeywords}`);
        }

        // 5. 결과 표시
        appendLog('\n🎯 ===== 키워드 추출 결과 =====');
        appendLog(`📰 원본 제목: ${originalTitle || '(추출 실패)'}`);
        appendLog(`🔑 핵심 키워드: ${mainKeyword || '(추출 실패)'}`);
        appendLog(`📌 서브 키워드: ${subKeywords.join(', ') || '(추출 실패)'}`);
        appendLog(`🔍 롱테일 키워드: ${longTailKeywords.join(', ') || '(추출 실패)'}`);
        appendLog('================================\n');

        // 6. 토스트 메시지
        toastManager.success(`✅ 키워드 추출 완료!\n핵심: ${mainKeyword}`);

        // 7. 제목 필드가 비어있으면 제목 제안 (지침/예시 문구 유출 방지 로직 포함)
        const titleInput = document.getElementById('unified-title') as HTMLInputElement;
        if (titleInput && !titleInput.value.trim() && originalTitle) {
          // ✅ 지침성 단어나 시스템 예시가 포함된 가짜 제목 필터링
          const lowerTitle = originalTitle.toLowerCase();
          const riskPatterns = [
            '상위노출', '실패하는 진짜 이유', '핵심 팁', '꿀팁 대방출', '꼭 확인해야 할',
            '끝판왕 제목', '알고보니', '경악한 이유', '진실 공개', '몰랐던 진실',
            '홈판 노출', '제목 공식', '노출 방법', '클릭률', '블로그 노출', '필수 체크'
          ];

          const isHallucinated = riskPatterns.some(p => lowerTitle.includes(p.toLowerCase()));

          if (isHallucinated) {
            appendLog(`⚠️ 추출된 제목에서 지침성 문구 감지됨 (무시): ${originalTitle}`);
          } else {
            titleInput.value = originalTitle;
            appendLog(`📝 제목 필드에 원본 제목 입력됨: ${originalTitle}`);
          }
        }

      } catch (error) {
        console.error('[KeywordExtract] 오류:', error);
        appendLog(`❌ 키워드 추출 실패: ${(error as Error).message}`);
        toastManager.error(`키워드 추출 실패: ${(error as Error).message}`);
      } finally {
        // ✅ 로딩 애니메이션 정리
        clearInterval(loadingInterval);
        extractKeywordsBtn.disabled = false;
        extractKeywordsBtn.textContent = originalText || '🎯 키워드 추출';
      }
    });
  }

  // URL로 AI 글 생성하기 버튼
  const generateFromUrlBtn = document.getElementById('generate-from-url-btn') as HTMLButtonElement;
  if (generateFromUrlBtn && !generateFromUrlBtn.hasAttribute('data-listener-added')) {
    generateFromUrlBtn.setAttribute('data-listener-added', 'true');
    console.log('[Unified] generate-from-url-btn 이벤트 리스너 등록');

    generateFromUrlBtn.addEventListener('click', async () => {
      console.log('[Unified] generate-from-url-btn 클릭됨');
      appendLog('🔄 URL로 AI 글 생성 버튼 클릭됨');

      try {
        // ✅ 글 생성 전 필수 선택 강제
        if (!ensurePreGenerationSelectionsOrWarn()) {
          return;
        }

        // ✅ [2026-01-16] 카테고리 검증은 ensurePreGenerationSelectionsOrWarn()에서 이미 수행됨
        // 중복 검증 제거하여 버그 방지

        const urls = getUnifiedUrls();
        console.log('[Unified] 수집된 URLs:', urls);

        if (urls.length === 0) {
          alert('⚠️ 유효한 URL을 입력해주세요.');
          appendLog('⚠️ 유효한 URL이 없습니다.');
          return;
        }

        // 버튼 비활성화 및 상태 표시
        generateFromUrlBtn.disabled = true;
        generateFromUrlBtn.textContent = '🔄 글 생성 중...';

        appendLog(`🔄 ${urls.length}개 URL 중 첫 번째 URL로 콘텐츠 생성 시작...`);
        appendLog(`   URL: ${urls[0]}`);

        // 여러 URL 중 첫 번째로 콘텐츠 생성
        const toneStyle = UnifiedDOMCache.getToneStyle();
        await generateContentFromUrl(urls[0], undefined, toneStyle);

        // ✅ 반자동 미리보기 섹션 강제 표시
        if (currentStructuredContent) {
          console.log('[Unified] URL 생성 완료 -> 반자동 필드 채우기 실행', currentStructuredContent);
          fillSemiAutoFields(currentStructuredContent);
          const semiAutoElem = document.getElementById('unified-semi-auto-section');
          if (semiAutoElem) semiAutoElem.style.display = 'block';
        } else {
          console.error('[Unified] URL 생성 완료되었으나 currentStructuredContent가 없음');
        }

        appendLog(`✅ ${urls.length}개 URL 중 첫 번째 URL로 콘텐츠 생성 완료`);

        // ✅ [2026-01-16] 쿼터/라이선스 UI 갱신
        if (typeof (window as any).updateFreeQuota === 'function') {
          void (window as any).updateFreeQuota();
        }


        // 성공 알림은 generateContentFromUrl 내부에서 이미 표시됨
      } catch (error) {
        console.error('[Unified] URL 기반 글 생성 오류:', error);
        const errorMessage = (error as Error).message || '알 수 없는 오류가 발생했습니다.';
        alert(`❌ 글 생성 중 오류가 발생했습니다.\n\n오류: ${errorMessage}\n\n콘솔을 확인해주세요.`);
        appendLog(`❌ URL 기반 글 생성 실패: ${errorMessage}`);
      } finally {
        // 버튼 상태 복원
        if (generateFromUrlBtn) {
          generateFromUrlBtn.disabled = false;
          generateFromUrlBtn.textContent = '🔄 URL로 AI 글 생성하기';
        }
      }
    });
  } else if (generateFromUrlBtn) {
    console.log('[Unified] generate-from-url-btn 이벤트 리스너 이미 등록됨');
  } else {
    console.warn('[Unified] generate-from-url-btn 요소를 찾을 수 없음!');
  }

  // 키워드,제목으로 AI 글 생성하기 버튼
  const generateManualBtn = document.getElementById('generate-manual-btn') as HTMLButtonElement;
  if (generateManualBtn && !generateManualBtn.hasAttribute('data-listener-added')) {
    generateManualBtn.setAttribute('data-listener-added', 'true');
    console.log('[Unified] generate-manual-btn 이벤트 리스너 등록');

    generateManualBtn.addEventListener('click', async () => {
      console.log('[Unified] generate-manual-btn 클릭됨');
      appendLog('🔄 키워드/제목으로 AI 글 생성 버튼 클릭됨');

      try {
        // ✅ 글 생성 전 필수 선택 강제
        if (!ensurePreGenerationSelectionsOrWarn()) {
          return;
        }

        // ✅ [2026-01-16] 카테고리 검증은 ensurePreGenerationSelectionsOrWarn()에서 이미 수행됨
        // 중복 검증 제거하여 버그 방지

        // 제목 필드가 제거되어 키워드만 사용 (제목은 AI가 자동 생성)
        const title = ''; // UI에서 제목 필드 제거됨
        const keywords = (document.getElementById('unified-keywords') as HTMLInputElement)?.value?.trim();

        if (!keywords) {
          alert('⚠️ 키워드를 입력해주세요. AI가 키워드를 기반으로 제목과 글을 자동 생성합니다.');
          return;
        }

        // 버튼 비활성화 및 상태 표시
        generateManualBtn.disabled = true;
        generateManualBtn.textContent = '🔄 글 생성 중...';

        appendLog(`🔄 키워드 기반 콘텐츠 생성 시작...`);
        appendLog(`   키워드: ${keywords}`);

        await generateContentFromKeywords(title, keywords);

        // ✅ 반자동 미리보기 섹션 강제 표시
        if (currentStructuredContent) {
          console.log('[Unified] 키워드 생성 완료 -> 반자동 필드 채우기 실행', currentStructuredContent);
          fillSemiAutoFields(currentStructuredContent);
          const semiAutoElem = document.getElementById('unified-semi-auto-section');
          if (semiAutoElem) semiAutoElem.style.display = 'block';
        } else {
          console.error('[Unified] 키워드 생성 완료되었으나 currentStructuredContent가 없음');
        }

        // ✅ [2026-01-16] 쿼터/라이선스 UI 갱신 (키워드 생성 완료 시)
        if (typeof (window as any).updateFreeQuota === 'function') {
          void (window as any).updateFreeQuota();
        }

        // 성공 알림은 generateContentFromKeywords 내부에서 이미 표시됨
      } catch (error) {
        console.error('[Unified] 키워드 기반 글 생성 오류:', error);
        const errorMessage = (error as Error).message || '알 수 없는 오류가 발생했습니다.';

        // ✅ 오류 유형별 친절한 해결 가이드 제공
        let solutionGuide = '';

        if (errorMessage.includes('API 키') || errorMessage.includes('GEMINI_API_KEY') || errorMessage.includes('설정되지 않')) {
          solutionGuide = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔑 API 키 문제 해결 방법
━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1️⃣ 환경설정(⚙️) 버튼 클릭
2️⃣ Gemini API 키 입력란 확인
3️⃣ API 키가 비어있으면:
   • Google AI Studio 접속
   • https://aistudio.google.com
   • "Get API Key" 클릭하여 키 생성
4️⃣ 키 입력 후 "저장" 버튼 클릭
5️⃣ 다시 시도하기

💡 API 키는 "AIza"로 시작합니다
`;
        } else if (errorMessage.includes('타임아웃') || errorMessage.includes('timeout') || errorMessage.includes('시간 초과')) {
          solutionGuide = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⏱️ 응답 지연 해결 방법
━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1️⃣ 인터넷 연결 확인
2️⃣ VPN 사용 중이면 끄기
3️⃣ 다른 프로그램 종료
4️⃣ 30초 대기 후 다시 시도

💡 네트워크가 느리면 시간이 걸릴 수 있어요
💡 "네트워크 진단" 버튼으로 확인해보세요
`;
        } else if (errorMessage.includes('네트워크') || errorMessage.includes('network') || errorMessage.includes('연결')) {
          solutionGuide = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🌐 네트워크 문제 해결 방법
━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1️⃣ WiFi 또는 인터넷 연결 확인
2️⃣ 방화벽에서 앱 허용 확인
3️⃣ VPN 끄기 (사용 중인 경우)
4️⃣ 회사/학교 네트워크면 모바일 핫스팟 사용
5️⃣ 앱 재시작 후 다시 시도

💡 환경설정의 "네트워크 진단" 버튼 활용!
`;
        } else {
          solutionGuide = `
━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔧 일반 해결 방법
━━━━━━━━━━━━━━━━━━━━━━━━━━━━

1️⃣ 앱 완전히 종료 후 재시작
2️⃣ 환경설정에서 API 키 다시 저장
3️⃣ 컴퓨터 재부팅 후 시도
4️⃣ 환경설정 → "네트워크 진단" 실행

💡 문제가 지속되면 개발자에게 문의해주세요
`;
        }

        alert(`❌ 글 생성 중 오류가 발생했습니다.\n\n오류: ${errorMessage}\n${solutionGuide}`);
        appendLog(`❌ 키워드 기반 글 생성 실패: ${errorMessage}`);
      } finally {
        // 버튼 상태 복원
        if (generateManualBtn) {
          generateManualBtn.disabled = false;
          generateManualBtn.textContent = '🔄 키워드,제목으로 AI 글 생성하기';
        }
      }
    });
  } else if (generateManualBtn) {
    console.log('[Unified] generate-manual-btn 이벤트 리스너 이미 등록됨');
  } else {
    console.warn('[Unified] generate-manual-btn 요소를 찾을 수 없음!');
  }

  // 풀오토 발행 버튼
  const fullAutoPublishBtn = document.getElementById('full-auto-publish-btn') as HTMLButtonElement;
  if (fullAutoPublishBtn) {
    fullAutoPublishBtn.addEventListener('click', async () => {
      try {
        // ✅ 중지 플래그 초기화
        (window as any).stopFullAutoPublish = false;

        // 발행 시작 알림 표시
        showPublishStartNotification('풀오토 발행을 시작합니다!');

        // 진행률 표시 초기화
        initializePublishProgress();

        // ✅ 중지 버튼 표시 및 발행 버튼 비활성화
        showStopButton();
        fullAutoPublishBtn.disabled = true;
        fullAutoPublishBtn.innerHTML = '<span style="font-size: 2rem;">⏳</span><span>실행 중...</span><span style="font-size: 0.75rem; opacity: 0.9;">잠시만 기다려주세요</span>';
        automationRunning = true;

        await handleFullAutoPublish();

        // ✅ [2026-01-16] 쿼터/라이선스 UI 갱신 (풀오토 발행 완료 시)
        if (typeof (window as any).updateFreeQuota === 'function') {
          void (window as any).updateFreeQuota();
        }
      } catch (error) {
        console.error('[Unified] 풀오토 발행 오류:', error);
        alert(`풀오토 발행 중 오류가 발생했습니다: ${(error as Error).message}`);
      } finally {
        // ✅ 중지 버튼 숨기기 및 발행 버튼 복원
        hideStopButton();
        enableFullAutoPublishButton();
        fullAutoPublishBtn.innerHTML = '<span style="font-size: 2rem;">⚡</span><span>풀오토 발행</span><span style="font-size: 0.75rem; opacity: 0.9;">콘텐츠 생성 → 이미지 생성 → 발행 (한 번에)</span>';
        automationRunning = false;
      }
    });
  }

  // 반자동 발행 버튼
  const semiAutoPublishBtn = document.getElementById('semi-auto-publish-btn') as HTMLButtonElement;
  if (semiAutoPublishBtn) {
    semiAutoPublishBtn.addEventListener('click', async () => {
      try {
        // ✅ 중지 플래그 초기화
        (window as any).stopFullAutoPublish = false;

        // 발행 시작 알림 표시
        showPublishStartNotification('반자동 발행을 시작합니다!');

        // 진행률 표시 초기화
        initializePublishProgress();

        // ✅ 중지 버튼 표시 및 발행 버튼 비활성화
        showStopButton();
        semiAutoPublishBtn.disabled = true;
        semiAutoPublishBtn.innerHTML = '<span style="font-size: 2rem;">⏳</span><span>실행 중...</span><span style="font-size: 0.75rem; opacity: 0.9;">잠시만 기다려주세요</span>';
        automationRunning = true;

        await handleSemiAutoPublish();
      } catch (error) {
        console.error('[Unified] 반자동 발행 오류:', error);
        alert(`반자동 발행 중 오류가 발생했습니다: ${(error as Error).message}`);
      } finally {
        // ✅ 중지 버튼 숨기기 및 발행 버튼 복원
        hideStopButton();
        enableSemiAutoPublishButton();
        semiAutoPublishBtn.innerHTML = '<span style="font-size: 2rem;">🔧</span><span>반자동 발행</span><span style="font-size: 0.75rem; opacity: 0.9;">수동 수정 후 발행</span>';

        // ✅ 반자동 발행 완료 후에도 풀오토 발행 버튼이 계속 비활성화로 남지 않도록 복구
        const fullAutoBtn = document.getElementById('full-auto-publish-btn') as HTMLButtonElement | null;
        if (fullAutoBtn) {
          enableFullAutoPublishButton();
          fullAutoBtn.innerHTML = '<span style="font-size: 2rem;">⚡</span><span>풀오토 발행</span><span style="font-size: 0.75rem; opacity: 0.9;">콘텐츠 생성 → 이미지 생성 → 발행 (한 번에)</span>';
        }

        automationRunning = false;
      }
    });
  }

  // ✅ 계정 탭 전환 (1개 계정 / 다중계정)
  const singleAccountTab = document.getElementById('single-account-tab') as HTMLButtonElement;
  const multiAccountTab = document.getElementById('multi-account-tab') as HTMLButtonElement;
  const singleAccountContent = document.getElementById('single-account-content');
  const multiAccountContent = document.getElementById('multi-account-content');

  // 현재 선택된 탭 모드 저장
  let currentAccountMode: 'single' | 'multi' = 'single';
  // 인라인 다중계정 선택 목록
  let inlineSelectedAccountIds: string[] = [];

  function updateTabStyles() {
    if (currentAccountMode === 'single') {
      singleAccountTab.style.background = 'linear-gradient(135deg, #10b981, #059669)';
      singleAccountTab.style.color = 'white';
      multiAccountTab.style.background = 'var(--bg-tertiary)';
      multiAccountTab.style.color = 'var(--text-muted)';
      if (singleAccountContent) singleAccountContent.style.display = 'block';
      if (multiAccountContent) multiAccountContent.style.display = 'none';
    } else {
      multiAccountTab.style.background = 'linear-gradient(135deg, #8b5cf6, #7c3aed)';
      multiAccountTab.style.color = 'white';
      singleAccountTab.style.background = 'var(--bg-tertiary)';
      singleAccountTab.style.color = 'var(--text-muted)';
      if (singleAccountContent) singleAccountContent.style.display = 'none';
      if (multiAccountContent) multiAccountContent.style.display = 'block';
      renderInlineAccountList();

      // ✅ 다중계정 탭 전환 시에도 1번 이미지 텍스트 옵션 UI를 다시 시도
      try {
        addThumbnailTextOptionUI();
      } catch {
        // ignore
      }
    }
  }

  singleAccountTab?.addEventListener('click', () => {
    currentAccountMode = 'single';
    updateTabStyles();
  });

  multiAccountTab?.addEventListener('click', () => {
    currentAccountMode = 'multi';
    updateTabStyles();
  });

  // 인라인 계정 목록 렌더링
  async function renderInlineAccountList() {
    const container = document.getElementById('ma-accounts-inline');
    const noAccountsMsg = document.getElementById('ma-no-accounts-inline');
    if (!container) return;

    try {
      const result = await window.api.getAllBlogAccounts();
      if (!result.success || !result.accounts || result.accounts.length === 0) {
        container.innerHTML = '';
        if (noAccountsMsg) {
          noAccountsMsg.style.display = 'block';
          container.appendChild(noAccountsMsg);
        }
        return;
      }

      const accounts = result.accounts;
      if (noAccountsMsg) noAccountsMsg.style.display = 'none';

      container.innerHTML = accounts.map((account: any) => {
        const isSelected = inlineSelectedAccountIds.includes(account.id);
        return `
          <div class="ma-inline-account" data-account-id="${account.id}" style="
            display: flex; align-items: center; gap: 0.75rem; padding: 0.6rem 0.75rem;
            background: ${isSelected ? 'rgba(139, 92, 246, 0.15)' : 'transparent'};
            border: 1px solid ${isSelected ? 'rgba(139, 92, 246, 0.4)' : 'rgba(255,255,255,0.1)'};
            border-radius: 8px; margin-bottom: 0.5rem; cursor: pointer; transition: all 0.2s;
          ">
            <input type="checkbox" class="ma-inline-checkbox" data-account-id="${account.id}" ${isSelected ? 'checked' : ''} style="width: 18px; height: 18px; cursor: pointer;">
            <div style="flex: 1; min-width: 0;">
              <div style="font-weight: 600; color: var(--text-strong); font-size: 0.9rem;">👤 ${account.name}</div>
              <div style="font-size: 0.75rem; color: var(--text-muted);">ID: ${account.blogId || account.name}</div>
            </div>
            <div style="display: flex; gap: 0.35rem; flex-shrink: 0;" onclick="event.stopPropagation();">
              <button type="button" class="ma-inline-edit-btn" data-account-id="${account.id}" style="padding: 0.3rem 0.5rem; background: rgba(59, 130, 246, 0.2); color: #3b82f6; border: 1px solid #3b82f6; border-radius: 5px; font-size: 0.7rem; cursor: pointer;" title="편집">⚙️</button>
              <button type="button" class="ma-inline-delete-btn" data-account-id="${account.id}" style="padding: 0.3rem 0.5rem; background: rgba(239, 68, 68, 0.2); color: #ef4444; border: 1px solid #ef4444; border-radius: 5px; font-size: 0.7rem; cursor: pointer;" title="삭제">🗑️</button>
            </div>
          </div>
        `;
      }).join('');

      // 체크박스 이벤트
      container.querySelectorAll('.ma-inline-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
          const target = e.target as HTMLInputElement;
          const accountId = target.dataset.accountId;
          if (!accountId) return;

          if (target.checked) {
            if (!inlineSelectedAccountIds.includes(accountId)) {
              inlineSelectedAccountIds.push(accountId);
            }
          } else {
            inlineSelectedAccountIds = inlineSelectedAccountIds.filter(id => id !== accountId);
          }
          updateInlineSelectedCount();
          renderInlineAccountList();
        });
      });

      // 카드 클릭으로도 선택 가능
      container.querySelectorAll('.ma-inline-account').forEach(card => {
        card.addEventListener('click', (e) => {
          const target = e.target as HTMLElement;
          if (target.tagName === 'INPUT' || target.tagName === 'BUTTON' || target.closest('button')) return;
          const accountId = (card as HTMLElement).dataset.accountId;
          if (!accountId) return;

          if (inlineSelectedAccountIds.includes(accountId)) {
            inlineSelectedAccountIds = inlineSelectedAccountIds.filter(id => id !== accountId);
          } else {
            inlineSelectedAccountIds.push(accountId);
          }
          updateInlineSelectedCount();
          renderInlineAccountList();
        });
      });

      // ✅ 편집 버튼 이벤트
      container.querySelectorAll('.ma-inline-edit-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          e.stopPropagation();
          const accountId = (e.target as HTMLElement).dataset.accountId;
          if (accountId && typeof (window as any).openAccountEditModal === 'function') {
            (window as any).openAccountEditModal(accountId);
          }
        });
      });

      // ✅ 삭제 버튼 이벤트
      container.querySelectorAll('.ma-inline-delete-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          e.stopPropagation();
          const accountId = (e.target as HTMLElement).dataset.accountId;
          if (!accountId) return;

          if (!confirm('정말로 이 계정을 삭제하시겠습니까?')) return;

          try {
            const result = await window.api.removeBlogAccount(accountId);
            if (result.success) {
              toastManager.success('계정이 삭제되었습니다.');
              inlineSelectedAccountIds = inlineSelectedAccountIds.filter(id => id !== accountId);
              // 모든 계정 목록 새로고침
              if (typeof (window as any).refreshAllAccountLists === 'function') {
                await (window as any).refreshAllAccountLists();
              } else {
                await renderInlineAccountList();
              }
            } else {
              toastManager.error(result.message || '계정 삭제 실패');
            }
          } catch (error) {
            console.error('[InlineAccountList] 삭제 오류:', error);
            toastManager.error('삭제 중 오류가 발생했습니다.');
          }
        });
      });

    } catch (error) {
      console.error('[InlineAccountList] 오류:', error);
    }
  }

  function updateInlineSelectedCount() {
    const countEl = document.getElementById('ma-selected-count-inline');
    if (countEl) {
      countEl.textContent = `${inlineSelectedAccountIds.length}개`;
    }
  }

  // ✅ 발행 대기열 시스템
  interface PublishQueueItem {
    id: string;
    accountId: string;
    accountName: string;
    title: string;
    structuredContent: any;
    generatedImages: any[];
    formData: any;
    createdAt: string;
  }

  let publishQueue: PublishQueueItem[] = [];

  // 대기열 UI 업데이트
  function updateQueueUI() {
    const queueList = document.getElementById('publish-queue-list');
    const queueCount = document.getElementById('queue-count');
    const queueEmptyMsg = document.getElementById('queue-empty-msg');
    const batchPublishBtn = document.getElementById('batch-publish-btn') as HTMLButtonElement;

    if (queueCount) queueCount.textContent = String(publishQueue.length);

    if (batchPublishBtn) {
      batchPublishBtn.textContent = `🚀 일괄 발행 (${publishQueue.length}개)`;
      batchPublishBtn.disabled = publishQueue.length === 0;
      batchPublishBtn.style.opacity = publishQueue.length === 0 ? '0.5' : '1';
    }

    if (!queueList) return;

    if (publishQueue.length === 0) {
      queueList.innerHTML = `
        <div id="queue-empty-msg" style="text-align: center; padding: 2rem; color: var(--text-muted);">
          <div style="font-size: 2rem; margin-bottom: 0.5rem;">📭</div>
          <div>대기열이 비어있습니다</div>
          <div style="font-size: 0.8rem; margin-top: 0.25rem;">글과 이미지를 세팅한 후 계정을 선택하고 "대기열에 추가"를 클릭하세요</div>
        </div>
      `;
      return;
    }

    queueList.innerHTML = publishQueue.map((item, index) => {
      // 이미지 썸네일 생성 (최대 3개)
      const images = item.generatedImages || [];
      const thumbnailsHtml = images.slice(0, 3).map((img: any) => {
        const imgRaw = img.previewDataUrl || img.dataUrl || img.url || img.filePath || '';
        const imgSrc = toFileUrlMaybe(String(imgRaw || '').trim());
        if (!imgSrc) return '';
        return `<img src="${imgSrc}" style="width: 40px; height: 40px; object-fit: cover; border-radius: 6px; border: 1px solid rgba(139, 92, 246, 0.3);" onerror="this.style.display='none'">`;
      }).join('');
      const moreCount = images.length > 3 ? `<div style="width: 40px; height: 40px; background: rgba(139, 92, 246, 0.3); border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: 0.7rem; color: #8b5cf6;">+${images.length - 3}</div>` : '';

      return `
      <div class="queue-item" data-queue-id="${item.id}" style="
        display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem;
        background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3);
        border-radius: 8px; margin: 0.5rem; transition: all 0.2s;
      ">
        <div style="font-size: 1.5rem; color: #8b5cf6; font-weight: 700;">${index + 1}</div>
        <div style="flex: 1; min-width: 0;">
          <div style="font-weight: 600; color: var(--text-strong); font-size: 0.9rem; display: flex; align-items: center; gap: 0.5rem;">
            <span style="color: #f59e0b;">👤</span> <span>${item.accountName}</span>
          </div>
          <div style="font-size: 0.8rem; color: var(--text-muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-top: 0.25rem;">
            📝 ${item.title || '제목 없음'}
          </div>
          <div style="display: flex; gap: 0.25rem; margin-top: 0.5rem; align-items: center;">
            ${thumbnailsHtml || '<span style="font-size: 0.7rem; color: var(--text-muted);">🖼️ 이미지 없음</span>'}
            ${moreCount}
            ${images.length > 0 ? `<span style="font-size: 0.7rem; color: var(--text-muted); margin-left: 0.5rem;">(${images.length}개)</span>` : ''}
          </div>
        </div>
        <div style="display: flex; gap: 0.5rem;">
          <button type="button" class="queue-edit-btn" data-queue-id="${item.id}" style="
            padding: 0.4rem 0.6rem; background: rgba(59, 130, 246, 0.2); color: #3b82f6;
            border: 1px solid #3b82f6; border-radius: 6px; font-size: 0.75rem; cursor: pointer;
          ">✏️ 수정</button>
          <button type="button" class="queue-delete-btn" data-queue-id="${item.id}" style="
            padding: 0.4rem 0.6rem; background: rgba(239, 68, 68, 0.2); color: #ef4444;
            border: 1px solid #ef4444; border-radius: 6px; font-size: 0.75rem; cursor: pointer;
          ">🗑️</button>
        </div>
      </div>
    `;
    }).join('');

    // 수정 버튼 이벤트
    queueList.querySelectorAll('.queue-edit-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const queueId = (e.target as HTMLElement).dataset.queueId;
        if (queueId) loadQueueItemForEdit(queueId);
      });
    });

    // 삭제 버튼 이벤트
    queueList.querySelectorAll('.queue-delete-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const queueId = (e.target as HTMLElement).dataset.queueId;
        if (queueId) removeFromQueue(queueId);
      });
    });
  }

  // 현재 세팅 수집
  function collectCurrentSettings(): { structuredContent: any; generatedImages: any[]; formData: any; title: string } | null {
    const structuredContent = (window as any).currentStructuredContent;
    // ✅ generatedImages와 imageManagementGeneratedImages 둘 다 확인
    let currentImages = (window as any).generatedImages || [];
    if (currentImages.length === 0) {
      currentImages = (window as any).imageManagementGeneratedImages || [];
    }

    // ✅ 이미지 깊은 복사 (참조 공유 방지)
    const generatedImages = currentImages.map((img: any) => {
      if (!img) return null;
      return {
        ...img,
        url: img.url || '',
        filePath: img.filePath || '',
        previewDataUrl: img.previewDataUrl || img.url || img.filePath || '',
        heading: img.heading || '',
        prompt: img.prompt || '',
        provider: img.provider || '',
        isThumbnail: img.isThumbnail || false,
        headingIndex: img.headingIndex ?? -1,
      };
    }).filter((img: any) => img !== null);

    if (!structuredContent || !structuredContent.selectedTitle) {
      return null;
    }

    // ✅ [Fix] 우선순위 변경: DOM 입력값(수정된 값) > 기존 structuredContent 값
    // 사용자가 수정한 제목/본문을 반영하기 위함
    const domTitle = (document.getElementById('unified-generated-title') as HTMLInputElement)?.value?.trim();
    const title = domTitle || structuredContent.selectedTitle || '';

    const domContent = (document.getElementById('unified-generated-content') as HTMLTextAreaElement)?.value?.trim();

    // 구조화된 콘텐츠에도 반영 (대기열/저장 시 사용됨)
    if (domTitle) {
      structuredContent.selectedTitle = domTitle;
      // titleCandidates 등에도 반영하고 싶지만 복잡하므로 일단 selectedTitle만 업데이트
    }
    if (domContent) {
      structuredContent.content = domContent;
      structuredContent.bodyPlain = domContent;
    }

    const imageSource = document.querySelector('.unified-img-source-btn.selected')?.getAttribute('data-source') || 'gemini';
    const skipImages = (document.getElementById('unified-skip-images') as HTMLInputElement)?.checked || false;
    const skipCta = (document.getElementById('unified-skip-cta') as HTMLInputElement)?.checked || false;
    const ctasUi = readUnifiedCtasFromUi();
    const ctaText = ctasUi[0]?.text || (document.getElementById('unified-cta-text') as HTMLInputElement)?.value || '';
    const ctaLink = ctasUi[0]?.link || (document.getElementById('unified-cta-link') as HTMLInputElement)?.value || '';
    const ctaPosition = ((document.getElementById('unified-cta-position') as HTMLSelectElement)?.value as 'top' | 'middle' | 'bottom') || 'bottom';
    const includeThumbnailText =
      (document.getElementById('full-auto-thumbnail-text') as HTMLInputElement | null)?.checked ||
      (document.getElementById('semi-auto-thumbnail-text') as HTMLInputElement | null)?.checked ||
      false;

    const formData = {
      mode: 'full-auto',
      generator: (document.getElementById('unified-generator') as HTMLSelectElement)?.value || 'gemini',
      imageSource,
      skipImages,
      skipCta,
      ctaText,
      ctaLink,
      ctas: skipCta ? [] : ctasUi,
      ctaPosition,
      includeThumbnailText,
      publishMode: 'publish',
      structuredContent,
    };

    return { structuredContent, generatedImages, formData, title };
  }

  // 대기열에 추가
  async function addToQueue() {
    if (inlineSelectedAccountIds.length === 0) {
      toastManager.warning('발행할 계정을 먼저 선택해주세요.');
      return;
    }

    const settings = collectCurrentSettings();
    if (!settings) {
      toastManager.warning('먼저 글을 생성하고 이미지를 세팅해주세요.');
      return;
    }

    // 선택된 각 계정에 대해 대기열 항목 생성
    const allAccounts = await window.api.getAllBlogAccounts();
    let addedCount = 0;

    // 수정 중인 아이디가 있는 경우 해당 아이디를 가진 항목을 업데이트
    const editingId = (window as any).currentEditingQueueId;
    let isUpdate = false;

    for (const accountId of inlineSelectedAccountIds) {
      const account = allAccounts.accounts?.find((a: any) => a.id === accountId);
      if (!account) continue;

      // 만약 수정 중이고, 현재 루프의 계정이 수정 중인 항목의 계정과 같다면 업데이트
      // (단, 다중 계정 선택 시에는 1개만 업데이트되고 나머지는 추가됨 - 이는 의도된 동작일 수 있음)

      let targetId = `queue-${Date.now()}-${accountId}-${Math.random().toString(36).substr(2, 5)}`;

      if (editingId) {
        const editingItem = publishQueue.find(i => i.id === editingId);
        if (editingItem && editingItem.accountId === accountId) {
          targetId = editingId;
          isUpdate = true;
        }
      }

      // 새 항목 추가 (동일 계정이라도 다른 글이면 추가될 수 있도록 덮어쓰기 로직 제거)
      const queueItem: PublishQueueItem = {
        id: targetId,
        accountId,
        accountName: account.name,
        title: settings.title,
        structuredContent: JSON.parse(JSON.stringify(settings.structuredContent)),
        generatedImages: JSON.parse(JSON.stringify(settings.generatedImages)),
        formData: JSON.parse(JSON.stringify(settings.formData)),
        createdAt: new Date().toISOString(),
      };

      if (isUpdate && editingId) {
        // 기존 항목 교체
        const idx = publishQueue.findIndex(i => i.id === editingId);
        if (idx !== -1) {
          publishQueue[idx] = queueItem;
          appendLog(`♻️ ${account.name} 계정의 대기열 항목이 업데이트되었습니다.`);
        } else {
          publishQueue.push(queueItem);
        }
      } else {
        publishQueue.push(queueItem);
      }
      addedCount++;
    }

    // 수정 모드 종료
    (window as any).currentEditingQueueId = null;

    updateQueueUI();

    if (addedCount > 0) {
      if (isUpdate) {
        toastManager.success(`대기열 항목이 수정되었습니다.`);
      } else {
        toastManager.success(`${addedCount}개 계정이 대기열에 추가되었습니다. 화면이 초기화됩니다.`);
      }
      appendLog(`✅ ${addedCount}개 계정이 발행 대기열에 ${isUpdate ? '업데이트' : '추가'}되었습니다.`);

      // ✅ 자동 초기화 - 다음 글 작성을 위해
      resetCurrentSettings();
    } else {
      toastManager.info('선택된 계정의 대기열이 업데이트되었습니다.');
    }

    // 선택 해제
    inlineSelectedAccountIds = [];
    updateInlineSelectedCount();
    renderInlineAccountList();
  }

  // ✅ [New] 통합 탭 실시간 동기화 이벤트 리스너 등록
  function initUnifiedRealtimeSync(): void {
    const titleInput = document.getElementById('unified-generated-title');
    const contentArea = document.getElementById('unified-generated-content');
    const hashtagsInput = document.getElementById('unified-generated-hashtags');

    const inputs = [titleInput, contentArea, hashtagsInput];
    inputs.forEach(input => {
      if (input) {
        input.addEventListener('input', () => {
          syncIntegratedPreviewFromInputs();
        });
      }
    });
    console.log('[Init] 통합 미리보기 실시간 동기화 리스너 등록 완료');
  }

  // ✅ 현재 세팅 초기화 함수
  function resetCurrentSettings() {
    // 글로벌 변수 초기화
    (window as any).currentStructuredContent = null;
    (window as any).generatedImages = [];
    (window as any).imageManagementGeneratedImages = [];
    (window as any).currentEditingQueueId = null; // 수정 모드 안전 초기화
    generatedImages = [];

    // ✅ ImageManager 초기화
    ImageManager.clear();

    // 메인 탭 입력 필드 초기화
    const titleInput = document.getElementById('unified-generated-title') as HTMLInputElement;
    const contentArea = document.getElementById('unified-generated-content') as HTMLTextAreaElement;
    const hashtagsInput = document.getElementById('unified-generated-hashtags') as HTMLInputElement;
    const urlInput = document.querySelector('.unified-url-input') as HTMLInputElement;
    const keywordsInput = document.getElementById('unified-keywords') as HTMLInputElement;
    const mainTitleInput = document.getElementById('unified-title') as HTMLInputElement;

    if (titleInput) titleInput.value = '';
    if (contentArea) contentArea.value = '';
    if (hashtagsInput) hashtagsInput.value = '';
    if (urlInput) urlInput.value = '';
    if (keywordsInput) keywordsInput.value = '';
    if (mainTitleInput) mainTitleInput.value = '';

    // ✅ 생성된 콘텐츠 미리보기 초기화 (unified-preview-*)
    const previewTitle = document.getElementById('unified-preview-title');
    if (previewTitle) previewTitle.textContent = '제목이 여기에 표시됩니다';

    const previewBody = document.getElementById('unified-preview-body');
    if (previewBody) previewBody.innerHTML = '<p style="color: var(--text-muted);">본문이 여기에 표시됩니다</p>';

    const previewHashtags = document.getElementById('unified-preview-hashtags');
    if (previewHashtags) previewHashtags.textContent = '';

    // 이미지 미리보기 초기화
    const imagePreviewContainer = document.getElementById('unified-image-preview');
    if (imagePreviewContainer) {
      imagePreviewContainer.innerHTML = `
        <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
          <div style="font-size: 2rem; margin-bottom: 0.5rem;">🖼️</div>
          <div>이미지가 생성되면 여기에 표시됩니다</div>
        </div>
      `;
    }

    // 이미지 관리 탭 미리보기 초기화
    const imageManagementPreview = document.getElementById('image-preview-container');
    if (imageManagementPreview) {
      imageManagementPreview.innerHTML = `
        <div style="text-align: center; padding: 3rem; color: var(--text-muted);">
          <div style="font-size: 3rem; margin-bottom: 1rem;">🖼️</div>
          <div style="font-size: 1.1rem;">먼저 메인 탭에서 글을 생성해주세요</div>
          <div style="font-size: 0.9rem; margin-top: 0.5rem;">소제목별 이미지 프롬프트가 여기에 표시됩니다</div>
        </div>
      `;
    }

    // ✅ 영어 프롬프트 미리보기 초기화
    const promptsContainer = document.getElementById('prompts-container');
    if (promptsContainer) {
      promptsContainer.innerHTML = '';
      promptsContainer.style.display = 'none';
    }

    // ✅ 생성된 이미지 그리드 초기화
    const generatedImagesGrid = document.getElementById('generated-images-grid');
    if (generatedImagesGrid) {
      generatedImagesGrid.style.display = 'flex';
      generatedImagesGrid.style.alignItems = 'center';
      generatedImagesGrid.style.justifyContent = 'center';
      generatedImagesGrid.innerHTML = `
        <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
          <div style="font-size: 3rem; margin-bottom: 1rem;">🖼️</div>
          <div style="font-size: 1rem; margin-bottom: 0.5rem;">이미지가 없습니다</div>
          <div style="font-size: 0.85rem;">이미지 소스를 선택하고 "이미지 생성하기"를 클릭하거나<br>"폴더에서 불러오기"로 이미지를 추가하세요</div>
        </div>
      `;
    }

    // ✅ 소제목 분석 결과 초기화
    const headingsAnalysis = document.getElementById('headings-analysis');
    if (headingsAnalysis) {
      headingsAnalysis.innerHTML = `
        <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
          <div style="font-size: 2rem; margin-bottom: 0.5rem;">📝</div>
          <div>소제목이 분석되면 여기에 표시됩니다</div>
        </div>
      `;
    }

    appendLog('🔄 화면이 초기화되었습니다. 다음 글을 작성해주세요.');
  }

  // 대기열에서 제거
  function removeFromQueue(queueId: string) {
    const item = publishQueue.find(i => i.id === queueId);
    if (item) {
      publishQueue = publishQueue.filter(i => i.id !== queueId);
      updateQueueUI();
      toastManager.info(`${item.accountName} 계정이 대기열에서 제거되었습니다.`);
      appendLog(`🗑️ ${item.accountName} 계정이 대기열에서 제거되었습니다.`);
    }
  }

  // 대기열 전체 삭제
  function clearQueue() {
    if (publishQueue.length === 0) return;
    if (!confirm(`대기열의 ${publishQueue.length}개 항목을 모두 삭제하시겠습니까?`)) return;

    publishQueue = [];
    updateQueueUI();
    toastManager.info('대기열이 비워졌습니다.');
    appendLog('🗑️ 발행 대기열이 비워졌습니다.');
  }

  // 대기열 항목 수정을 위해 불러오기
  function loadQueueItemForEdit(queueId: string) {
    const item = publishQueue.find(i => i.id === queueId);
    if (!item) return;

    // ✅ 수정 중인 아이디 추적
    (window as any).currentEditingQueueId = queueId;

    // 현재 세팅을 대기열 항목의 세팅으로 복원
    const restoredContent = JSON.parse(JSON.stringify(item.structuredContent));
    const restoredImages = JSON.parse(JSON.stringify(item.generatedImages));

    // ✅ 글로벌 변수 복원
    (window as any).currentStructuredContent = restoredContent;
    (window as any).generatedImages = restoredImages;
    (window as any).imageManagementGeneratedImages = restoredImages;

    try {
      hydrateImageManagerFromImages(restoredContent, restoredImages);
    } catch {
      // ignore
    }

    // UI 업데이트 - 입력 필드
    const titleInput = document.getElementById('unified-generated-title') as HTMLInputElement;
    const contentArea = document.getElementById('unified-generated-content') as HTMLTextAreaElement;
    const hashtagsInput = document.getElementById('unified-generated-hashtags') as HTMLInputElement;

    if (titleInput) titleInput.value = restoredContent.selectedTitle || '';
    if (contentArea) contentArea.value = restoredContent.bodyPlain || restoredContent.content || '';
    if (hashtagsInput) hashtagsInput.value = (restoredContent.hashtags || []).join(', ');

    // ✅ 생성된 콘텐츠 미리보기 업데이트 (unified-preview-*)
    updateUnifiedPreview(restoredContent);

    // ✅ 이미지 미리보기 업데이트
    if (restoredContent.headings && restoredImages) {
      // 메인 탭 이미지 미리보기
      updateUnifiedImagePreview(restoredContent.headings, restoredImages);

      // ✅ 이미지 관리 탭 - 생성된 이미지 미리보기
      displayGeneratedImages(restoredImages);

      // ✅ 이미지 관리 탭 - 영어 프롬프트 미리보기 업데이트
      setTimeout(() => {
        updatePromptItemsWithImages(restoredImages);
      }, 200);
    }

    // 해당 계정 선택
    inlineSelectedAccountIds = [item.accountId];
    updateInlineSelectedCount();
    renderInlineAccountList();

    toastManager.info(`${item.accountName} 계정의 세팅을 불러왔습니다. 수정 후 "대기열에 추가"를 클릭하세요.`);
    appendLog(`📝 ${item.accountName} 계정의 세팅을 불러왔습니다. (이미지 ${restoredImages.length}개)`);

    // 메인 탭으로 스크롤
    document.getElementById('unified-generated-title')?.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }

  // 일괄 발행
  async function executeBatchPublish() {
    if (publishQueue.length === 0) {
      toastManager.warning('발행할 항목이 없습니다.');
      return;
    }

    let accountSettingsMap: Record<string, any> = {};
    try {
      const all = await window.api.getAllBlogAccounts();
      if (all.success && all.accounts) {
        accountSettingsMap = Object.fromEntries(all.accounts.map((a: any) => [a.id, a.settings || {}]));
      }
    } catch {
      accountSettingsMap = {};
    }

    const intervalSeconds = parseInt((document.getElementById('ma-interval-inline') as HTMLInputElement)?.value || '30');

    if (!confirm(`${publishQueue.length}개 계정에 순차적으로 발행합니다. 계속하시겠습니까?`)) return;

    appendLog(`🚀 일괄 발행 시작: ${publishQueue.length}개 계정`);

    // ✅ 중지 플래그 초기화 및 중지 버튼 표시
    (window as any).stopBatchPublish = false;
    showStopButton();

    const batchPublishBtn = document.getElementById('batch-publish-btn') as HTMLButtonElement;
    if (batchPublishBtn) {
      batchPublishBtn.disabled = true;
      batchPublishBtn.textContent = '🔄 발행 중...';
    }

    let successCount = 0;
    let failCount = 0;
    const successIds: string[] = [];

    try {
      for (let i = 0; i < publishQueue.length; i++) {
        // ✅ 중지 버튼 클릭 확인
        if ((window as any).stopBatchPublish || (window as any).stopFullAutoPublish) {
          appendLog('⏹️ 일괄 발행이 사용자에 의해 중지되었습니다.');
          toastManager.warning('일괄 발행이 중지되었습니다.');
          break;
        }

        const item = publishQueue[i];

        try {
          appendLog(`📝 [${i + 1}/${publishQueue.length}] ${item.accountName} 계정 발행 시작...`);

          (window as any).currentPublishingAccountSettings = accountSettingsMap[item.accountId] || {};

          // 계정 자격 증명 가져오기
          const credResult = await window.api.getAccountCredentials(item.accountId);
          if (!credResult.success || !credResult.credentials) {
            appendLog(`❌ [${i + 1}/${publishQueue.length}] ${item.accountName}: 자격 증명을 가져올 수 없습니다.`);
            failCount++;
            continue;
          }

          // ✅ 중지 플래그 재확인 (자격 증명 가져온 후)
          if ((window as any).stopBatchPublish || (window as any).stopFullAutoPublish) {
            appendLog('⏹️ 일괄 발행이 사용자에 의해 중지되었습니다.');
            toastManager.warning('일괄 발행이 중지되었습니다.');
            break;
          }

          // 발행 실행
          const publishFormData = {
            ...item.formData,
            structuredContent: item.structuredContent,
          };

          // 현재 세팅을 이 항목의 세팅으로 설정
          (window as any).currentStructuredContent = item.structuredContent;
          (window as any).generatedImages = item.generatedImages;
          (window as any).imageManagementGeneratedImages = item.generatedImages;

          // ✅ 전역 generatedImages 변수도 업데이트
          generatedImages = item.generatedImages || [];

          try {
            hydrateImageManagerFromImages(item.structuredContent, item.generatedImages || []);
          } catch {
            // ignore
          }

          // 네이버 ID/PW 설정
          const naverIdInput = document.getElementById('naver-id') as HTMLInputElement;
          const naverPwInput = document.getElementById('naver-password') as HTMLInputElement;
          if (naverIdInput) naverIdInput.value = credResult.credentials.naverId;
          if (naverPwInput) naverPwInput.value = credResult.credentials.naverPassword;

          // ✅ 반자동 발행 실행 및 결과 추적
          appendLog(`🌐 브라우저를 열고 발행을 시작합니다...`);

          // ✅ 발행 결과를 추적하기 위한 Promise
          let publishSuccess = false;
          let publishError: string | null = null;
          let resultReceived = false; // 중복 방지 플래그

          const publishPromise = new Promise<boolean>((resolve) => {
            const statusHandler = (status: { success: boolean; message?: string; cancelled?: boolean }) => {
              if (resultReceived) return; // 이미 처리됨
              resultReceived = true;

              if (status.cancelled) {
                publishError = '발행이 사용자에 의해 취소되었습니다.';
                resolve(false);
              } else if (status.success) {
                resolve(true);
              } else {
                publishError = status.message || '발행 실패';
                resolve(false);
              }
            };
            (window.api as any).on('automation:status', statusHandler);

            // 타임아웃: 5분 후에도 응답이 없으면 실패로 처리
            setTimeout(() => {
              if (!resultReceived) {
                resultReceived = true;
                publishError = '발행 시간 초과';
                resolve(false);
              }
            }, 5 * 60 * 1000);
          });

          // 발행 시작
          handleSemiAutoPublish();

          // 발행 결과 대기
          publishSuccess = await publishPromise;

          if (publishSuccess) {
            appendLog(`✅ [${i + 1}/${publishQueue.length}] ${item.accountName}: 발행 성공!`);
            successCount++;
            successIds.push(item.id);
          } else {
            appendLog(`❌ [${i + 1}/${publishQueue.length}] ${item.accountName}: ${publishError || '발행 실패'}`);
            failCount++;
          }

          // 다음 계정 발행 전 대기 (마지막 계정 제외)
          if (i < publishQueue.length - 1 && publishSuccess) {
            appendLog(`⏳ ${intervalSeconds}초 대기 중... (다음 발행까지)`);
            await new Promise(resolve => setTimeout(resolve, intervalSeconds * 1000));
          }

        } catch (error) {
          appendLog(`❌ [${i + 1}/${publishQueue.length}] ${item.accountName}: ${(error as Error).message}`);
          failCount++;
        }
      }
    } finally {
      (window as any).currentPublishingAccountSettings = null;
    }

    appendLog(`🏁 일괄 발행 완료: 성공 ${successCount}개, 실패 ${failCount}개`);
    toastManager.success(`일괄 발행 완료: 성공 ${successCount}개, 실패 ${failCount}개`);

    // 성공한 항목 대기열에서 제거 (전체 삭제 대신 필터링)
    if (successIds.length > 0) {
      publishQueue = publishQueue.filter(item => !successIds.includes(item.id));
      updateQueueUI();
    }

    if (batchPublishBtn) {
      batchPublishBtn.disabled = publishQueue.length === 0;
      batchPublishBtn.textContent = `🚀 일괄 발행 (${publishQueue.length}개)`;
      batchPublishBtn.style.opacity = publishQueue.length === 0 ? '0.5' : '1';
    }

    // ✅ 중지 버튼 숨기기
    hideStopButton();
  }

  // 이벤트 리스너 등록
  document.getElementById('add-to-queue-btn')?.addEventListener('click', addToQueue);
  document.getElementById('clear-queue-btn')?.addEventListener('click', clearQueue);
  document.getElementById('batch-publish-btn')?.addEventListener('click', executeBatchPublish);

  // 초기 UI 업데이트
  updateQueueUI();

  // 전체 선택/해제
  document.getElementById('ma-select-all-inline')?.addEventListener('click', async () => {
    const result = await window.api.getAllBlogAccounts();
    if (result.success && result.accounts) {
      inlineSelectedAccountIds = result.accounts.map((a: any) => a.id);
      updateInlineSelectedCount();
      renderInlineAccountList();
    }
  });

  document.getElementById('ma-deselect-all-inline')?.addEventListener('click', () => {
    inlineSelectedAccountIds = [];
    updateInlineSelectedCount();
    renderInlineAccountList();
  });

  // 계정 추가 버튼 (풀오토 다중계정 발행과 동일하게 연동)
  document.getElementById('ma-add-account-inline')?.addEventListener('click', () => {
    // ✅ 풀오토 다중계정 발행의 계정 추가와 동일한 함수 호출 (window 통해 접근)
    if (typeof (window as any).openAccountEditModal === 'function') {
      (window as any).openAccountEditModal();
    } else {
      // 폴백: 기존 모달 열기
      const multiAccountModal = document.getElementById('multi-account-modal');
      if (multiAccountModal) {
        multiAccountModal.style.display = 'flex';
        multiAccountModal.setAttribute('aria-hidden', 'false');
      }
    }
  });

  // 현재 계정 모드 및 선택된 계정 정보 반환 함수 (발행 시 사용)
  (window as any).getAccountMode = () => currentAccountMode;
  (window as any).getInlineSelectedAccounts = () => inlineSelectedAccountIds;
  (window as any).getInlineInterval = () => parseInt((document.getElementById('ma-interval-inline') as HTMLInputElement)?.value || '30');

  // ✅ 인라인 계정 목록 렌더링 함수 글로벌 노출 (계정 동기화용)
  (window as any).renderInlineAccountList = renderInlineAccountList;

  // ✅ CTA 버튼 이벤트 핸들러
  const generateCtaBtn = document.getElementById('generate-cta-btn') as HTMLButtonElement;
  const previewCtaBtn = document.getElementById('preview-cta-btn') as HTMLButtonElement;
  const ctaTextInput = document.getElementById('unified-cta-text') as HTMLInputElement;
  const ctaLinkInput = document.getElementById('unified-cta-link') as HTMLInputElement;
  const ctaPreview = document.getElementById('cta-preview') as HTMLDivElement;
  const ctaPreviewText = document.getElementById('cta-preview-text') as HTMLDivElement;

  // ✅ 다중 CTA UI
  const ctaItemsContainer = document.getElementById('unified-cta-items-container') as HTMLDivElement | null;
  const addCtaBtn = document.getElementById('unified-add-cta-btn') as HTMLButtonElement | null;

  const appendCtaRow = (preset?: { text?: string; link?: string }) => {
    if (!ctaItemsContainer) return;
    const row = document.createElement('div');
    row.className = 'unified-cta-item';
    row.style.cssText = 'display:flex; gap:0.5rem; align-items:center;';
    const presetText = String(preset?.text || '').trim();
    const presetLink = String(preset?.link || '').trim();
    row.innerHTML = `
      <input type="text" class="unified-cta-text" placeholder="CTA 텍스트" style="flex:1; padding: 0.75rem; border: 1px solid var(--border-light); border-radius: var(--radius-sm); font-size: 0.9rem; background: var(--bg-primary);" value="${escapeHtml(presetText)}">
      <input type="url" class="unified-cta-link" placeholder="링크 URL" style="flex:1; padding: 0.75rem; border: 1px solid var(--border-light); border-radius: var(--radius-sm); font-size: 0.9rem; background: var(--bg-primary);" value="${escapeHtml(presetLink)}">
      <button type="button" class="unified-cta-remove" style="padding:0.5rem 0.75rem; background: rgba(239,68,68,0.15); color:#ef4444; border: 1px solid rgba(239,68,68,0.35); border-radius: 8px; cursor:pointer;">✕</button>
    `;
    ctaItemsContainer.appendChild(row);
  };

  const ensureAtLeastOneCtaRow = () => {
    if (!ctaItemsContainer) return;
    const existing = ctaItemsContainer.querySelectorAll('.unified-cta-item');
    if (existing.length === 0) {
      appendCtaRow({ text: ctaTextInput?.value || '', link: ctaLinkInput?.value || '' });
    }
  };

  if (ctaItemsContainer) {
    // legacy 단일 입력은 숨김(호환용으로 값은 유지)
    try {
      const legacyTextWrap = ctaTextInput?.closest('div') as HTMLElement | null;
      const legacyLinkWrap = ctaLinkInput?.closest('div') as HTMLElement | null;
      if (legacyTextWrap) legacyTextWrap.style.display = 'none';
      if (legacyLinkWrap) legacyLinkWrap.style.display = 'none';
    } catch {
      // ignore
    }

    ensureAtLeastOneCtaRow();

    if (addCtaBtn && !addCtaBtn.hasAttribute('data-listener-added')) {
      addCtaBtn.setAttribute('data-listener-added', 'true');
      addCtaBtn.addEventListener('click', () => {
        appendCtaRow();
      });
    }

    if (!ctaItemsContainer.hasAttribute('data-cta-delegation')) {
      ctaItemsContainer.setAttribute('data-cta-delegation', 'true');
      ctaItemsContainer.addEventListener('click', (e) => {
        const target = e.target as HTMLElement | null;
        if (!target) return;
        if (target.classList.contains('unified-cta-remove')) {
          const row = target.closest('.unified-cta-item') as HTMLElement | null;
          if (row) row.remove();
          ensureAtLeastOneCtaRow();
        }
      });
    }
  }

  // ✅ CTA 위치/미리보기/AI 생성 UI 숨김 (요청사항)
  try {
    const ctaPositionSelect = document.getElementById('unified-cta-position') as HTMLSelectElement | null;
    if (ctaPositionSelect) {
      const wrapper = ctaPositionSelect.closest('.form-group') as HTMLElement | null;
      if (wrapper) wrapper.style.display = '';
      else ctaPositionSelect.style.display = '';
    }
  } catch {
    // ignore
  }
  try {
    if (generateCtaBtn) generateCtaBtn.style.display = 'none';
    if (previewCtaBtn) previewCtaBtn.style.display = 'none';
    if (ctaPreview) ctaPreview.style.display = 'none';
    if (ctaPreviewText) ctaPreviewText.innerHTML = '';
  } catch {
    // ignore
  }

  // AI로 CTA 생성 버튼
  if (generateCtaBtn) {
    generateCtaBtn.addEventListener('click', async () => {
      try {
        generateCtaBtn.disabled = true;
        generateCtaBtn.textContent = '생성 중...';

        // 현재 콘텐츠에서 CTA 텍스트 생성
        const title = (document.getElementById('unified-generated-title') as HTMLInputElement)?.value ||
          (document.getElementById('unified-title') as HTMLInputElement)?.value || '';

        const ctaSuggestions = [
          '더 알아보기', '자세히 보기', '지금 확인하기', '바로 가기',
          '구매하기', '신청하기', '무료 체험하기', '상담 받기',
          '후기 더보기', '다른 글 보기', '이전 글 보기'
        ];

        // 제목에 따라 적절한 CTA 선택
        let suggestedCta = ctaSuggestions[Math.floor(Math.random() * ctaSuggestions.length)];

        if (title.includes('리뷰') || title.includes('후기')) {
          suggestedCta = '구매하기';
        } else if (title.includes('여행') || title.includes('맛집')) {
          suggestedCta = '예약하기';
        } else if (title.includes('재테크') || title.includes('투자')) {
          suggestedCta = '더 알아보기';
        }

        if (ctaTextInput) {
          ctaTextInput.value = suggestedCta;
        }

        appendLog(`✅ CTA 버튼 텍스트가 생성되었습니다: "${suggestedCta}"`);

      } catch (error) {
        appendLog(`❌ CTA 생성 실패: ${(error as Error).message}`);
      } finally {
        generateCtaBtn.disabled = false;
        generateCtaBtn.textContent = 'AI로 생성';
      }
    });
  }

  // CTA 미리보기 버튼
  if (previewCtaBtn) {
    previewCtaBtn.addEventListener('click', () => {
      const ctaText = ctaTextInput?.value?.trim() || '더 알아보기';
      const ctaLink = ctaLinkInput?.value?.trim() || '#';

      if (ctaPreview && ctaPreviewText) {
        ctaPreview.style.display = 'block';
        ctaPreviewText.innerHTML = `
          <div style="text-align: center; margin: 1rem 0;">
            <hr style="border: none; border-top: 1px solid var(--border-light); margin: 1rem 0;">
            <a href="${ctaLink}" target="_blank" style="display: inline-block; padding: 0.75rem 2rem; background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; text-decoration: none; border-radius: 8px; font-weight: 600; box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);">
              ${ctaText}
            </a>
            <hr style="border: none; border-top: 1px solid var(--border-light); margin: 1rem 0;">
          </div>
        `;
      }
    });
  }

  // ✅ 이전 작성글 엮기 기능
  const selectPreviousPostBtn = document.getElementById('select-previous-post-btn') as HTMLButtonElement;
  const linkPreviousPostCheckbox = document.getElementById('unified-link-previous-post') as HTMLInputElement;

  if (selectPreviousPostBtn) {
    selectPreviousPostBtn.addEventListener('click', () => {
      // 저장된 글 목록 가져오기
      const posts = loadGeneratedPosts();

      if (posts.length === 0) {
        alert('📝 저장된 글이 없습니다.\n\n먼저 글을 생성하고 발행해주세요.');
        return;
      }

      // 글 선택 모달 표시
      const currentCategory = String((document.getElementById('unified-article-type') as HTMLSelectElement | null)?.value || '').trim();
      showPostSelectionModal(posts, (selectedPost) => {
        if (selectedPost) {
          // 선택된 글 정보 저장
          (window as any).selectedPreviousPost = selectedPost;
          if (linkPreviousPostCheckbox) {
            linkPreviousPostCheckbox.checked = true;
          }

          // ✅ CTA URL에 자동으로 주소 채우기
          const ctaLinkInput = document.getElementById('unified-cta-link') as HTMLInputElement;
          const ctaTextInput = document.getElementById('unified-cta-text') as HTMLInputElement;
          const ctaItemsContainer = document.getElementById('unified-cta-items-container') as HTMLDivElement | null;
          const selectedPostInfo = document.getElementById('selected-previous-post-info') as HTMLDivElement;
          const selectedPostTitle = document.getElementById('selected-post-title') as HTMLDivElement;

          // ✅ CTA 텍스트는 항상 입력 (발행 여부와 관계없이)
          if (ctaTextInput && selectedPost.title) {
            ctaTextInput.value = `📖 ${selectedPost.title}`;
          }

          // ✅ 다중 CTA 컨테이너가 있으면 첫 번째 CTA row에 반영
          if (ctaItemsContainer && selectedPost.title) {
            const firstRow = ctaItemsContainer.querySelector('.unified-cta-item') as HTMLElement | null;
            if (firstRow) {
              const textEl = firstRow.querySelector('.unified-cta-text') as HTMLInputElement | null;
              if (textEl) textEl.value = `📖 ${selectedPost.title}`;
              if (selectedPost.publishedUrl) {
                const linkEl = firstRow.querySelector('.unified-cta-link') as HTMLInputElement | null;
                if (linkEl) linkEl.value = selectedPost.publishedUrl;
              }
            }
          }

          // ✅ 선택된 글 정보 표시
          if (selectedPostInfo && selectedPostTitle) {
            selectedPostInfo.style.display = 'block';
            selectedPostTitle.textContent = selectedPost.title;
          }

          if (selectedPost.publishedUrl) {
            // 발행된 글이면 URL도 자동 입력
            if (ctaLinkInput) {
              ctaLinkInput.value = selectedPost.publishedUrl;
            }
            appendLog(`✅ 이전 글 선택됨: "${selectedPost.title}" (CTA 자동 입력됨)`);
            toastManager.success(`✅ "${selectedPost.title}" 선택됨!`);
          } else {
            // 미발행 글이면 제목만 입력됨 안내
            appendLog(`⚠️ 이전 글 선택됨: "${selectedPost.title}" (미발행 - URL 없음)`);
            toastManager.warning(`⚠️ 미발행 글 선택됨 - URL 없음`);
          }
        }
      }, { defaultCategory: currentCategory || undefined });
    });
  }

  // ✅ (숨김 상태 관리용) unified-link-previous-post 체크 시에도 이전글 선택 모달 자동 오픈
  if (linkPreviousPostCheckbox && !linkPreviousPostCheckbox.hasAttribute('data-listener-added')) {
    linkPreviousPostCheckbox.setAttribute('data-listener-added', 'true');
    linkPreviousPostCheckbox.addEventListener('change', () => {
      try {
        if (linkPreviousPostCheckbox.checked && selectPreviousPostBtn && !selectPreviousPostBtn.disabled) {
          selectPreviousPostBtn.click();
        }
      } catch {
        // ignore
      }
    });
  }

  // ✅ 이전글 선택 해제 버튼
  const clearPreviousPostBtn = document.getElementById('clear-previous-post-btn');
  if (clearPreviousPostBtn) {
    clearPreviousPostBtn.addEventListener('click', () => {
      // 선택 해제
      (window as any).selectedPreviousPost = null;
      if (linkPreviousPostCheckbox) {
        linkPreviousPostCheckbox.checked = false;
      }

      // CTA 필드 초기화
      const ctaLinkInput = document.getElementById('unified-cta-link') as HTMLInputElement;
      const ctaTextInput = document.getElementById('unified-cta-text') as HTMLInputElement;
      const selectedPostInfo = document.getElementById('selected-previous-post-info') as HTMLDivElement;

      if (ctaTextInput) ctaTextInput.value = '';
      if (ctaLinkInput) ctaLinkInput.value = '';
      if (selectedPostInfo) selectedPostInfo.style.display = 'none';

      appendLog(`🔓 이전글 연결 해제됨`);
      toastManager.info(`이전글 연결이 해제되었습니다.`);
    });
  }

  // ✅ CTA 없이 발행 체크박스 - 체크 시 CTA 필드 및 이전글 엮기 비활성화
  const skipCtaCheckbox = document.getElementById('unified-skip-cta') as HTMLInputElement;
  if (skipCtaCheckbox) {
    skipCtaCheckbox.addEventListener('change', () => {
      const ctaTextInput = document.getElementById('unified-cta-text') as HTMLInputElement;
      const ctaLinkInput = document.getElementById('unified-cta-link') as HTMLInputElement;
      const selectPreviousPostBtn = document.getElementById('select-previous-post-btn') as HTMLButtonElement;
      const selectedPostInfo = document.getElementById('selected-previous-post-info') as HTMLDivElement;
      const ctaPositionSelect = document.getElementById('unified-cta-position') as HTMLSelectElement;

      if (skipCtaCheckbox.checked) {
        // CTA 없이 발행 체크됨 - 모든 CTA 관련 필드 비활성화 및 초기화
        if (ctaTextInput) {
          ctaTextInput.value = '';
          ctaTextInput.disabled = true;
          ctaTextInput.style.opacity = '0.5';
        }
        if (ctaLinkInput) {
          ctaLinkInput.value = '';
          ctaLinkInput.disabled = true;
          ctaLinkInput.style.opacity = '0.5';
        }
        if (selectPreviousPostBtn) {
          selectPreviousPostBtn.disabled = true;
          selectPreviousPostBtn.style.opacity = '0.5';
        }
        if (selectedPostInfo) {
          selectedPostInfo.style.display = 'none';
        }
        if (ctaPositionSelect) {
          ctaPositionSelect.disabled = true;
          ctaPositionSelect.style.opacity = '0.5';
        }
        // 이전글 엮기 체크 해제
        if (linkPreviousPostCheckbox) {
          linkPreviousPostCheckbox.checked = false;
        }
        (window as any).selectedPreviousPost = null;

        appendLog(`🚫 CTA 없이 발행 모드 활성화`);
      } else {
        // CTA 없이 발행 해제됨 - 모든 CTA 관련 필드 활성화
        if (ctaTextInput) {
          ctaTextInput.disabled = false;
          ctaTextInput.style.opacity = '1';
        }
        if (ctaLinkInput) {
          ctaLinkInput.disabled = false;
          ctaLinkInput.style.opacity = '1';
        }
        if (selectPreviousPostBtn) {
          selectPreviousPostBtn.disabled = false;
          selectPreviousPostBtn.style.opacity = '1';
        }
        if (ctaPositionSelect) {
          ctaPositionSelect.disabled = false;
          ctaPositionSelect.style.opacity = '1';
        }

        appendLog(`✅ CTA 발행 모드 활성화`);
      }
    });
  }

  // ✅ 중지 버튼 초기화
  initStopButton();

  console.log('[Unified] 통합 탭 초기화 완료');
}

// ✅ 중지 버튼 초기화 및 이벤트 핸들러
function initStopButton(): void {
  const stopBtn = document.getElementById('unified-stop-btn');


  if (stopBtn && !stopBtn.hasAttribute('data-listener-added')) {
    stopBtn.setAttribute('data-listener-added', 'true');
    stopBtn.addEventListener('click', async () => {
      console.log('[Stop] 중지 버튼 클릭');

      try {
        // ✅ 풀오토 발행 중지 플래그 반영
        (window as any).stopFullAutoPublish = true;

        // 진행 중인 자동화 중지
        if (automationRunning) {
          await window.api.cancelAutomation();
          appendLog('⏹️ 발행/수집/생성이 중지되었습니다.');
        }

        // ✅ 다중계정 발행도 즉시 중지 (백그라운드 브라우저 모두 종료)
        try {
          await window.api.multiAccountCancel();
        } catch (e) {
          // 다중계정 발행이 없을 수도 있음 - 무시
        }

        // 연속 발행 모드 중지
        if (isContinuousMode) {
          stopContinuousMode();
        }

        // 상태 초기화
        automationRunning = false;
        hideStopButton();

        // 버튼 상태 복원
        const fullAutoBtn = document.getElementById('full-auto-publish-btn') as HTMLButtonElement;
        const semiAutoBtn = document.getElementById('semi-auto-publish-btn') as HTMLButtonElement;

        if (fullAutoBtn) {
          enableFullAutoPublishButton();
          fullAutoBtn.innerHTML = '<span style="font-size: 2rem;">⚡</span><span>풀오토 발행</span><span style="font-size: 0.75rem; opacity: 0.9;">콘텐츠 생성 → 이미지 생성 → 발행 (한 번에)</span>';
        }

        if (semiAutoBtn) {
          enableSemiAutoPublishButton();
          semiAutoBtn.innerHTML = '<span style="font-size: 2rem;">🔧</span><span>반자동 발행</span><span style="font-size: 0.75rem; opacity: 0.9;">수동 수정 후 발행</span>';
        }

        toastManager.info('⏹️ 작업이 중지되었습니다.');
      } catch (error) {
        console.error('[Stop] 중지 실패:', error);
        appendLog(`❌ 중지 실패: ${(error as Error).message}`);
      }
    });
  }
}

// ✅ 중지 버튼 표시 (발행 버튼 숨기고 중지 버튼 표시)
function showStopButton(): void {
  const stopBtn = document.getElementById('unified-stop-btn');
  const publishBtn = document.getElementById('unified-publish-btn');
  const publishModeDesc = document.getElementById('publish-mode-desc');

  if (stopBtn) {
    stopBtn.style.display = 'flex';
  }
  if (publishBtn) {
    publishBtn.style.display = 'none';
  }
  if (publishModeDesc) {
    publishModeDesc.textContent = '⏳ 작업 진행 중... 중지하려면 버튼을 클릭하세요';
  }
}

// ✅ 중지 버튼 숨기기 (발행 버튼 표시하고 중지 버튼 숨김)
function hideStopButton(): void {
  const stopBtn = document.getElementById('unified-stop-btn');
  const publishBtn = document.getElementById('unified-publish-btn');

  if (stopBtn) {
    stopBtn.style.display = 'none';
  }
  if (publishBtn) {
    publishBtn.style.display = 'flex';
  }

  // 버튼 스타일 리셋
  const publishModeSelect = document.getElementById('publish-mode-select') as HTMLSelectElement;
  const publishModeDesc = document.getElementById('publish-mode-desc');
  if (publishModeSelect && publishModeDesc) {
    const mode = publishModeSelect.value;
    if (mode === 'full-auto') {
      publishModeDesc.innerHTML = '💡 URL/키워드 입력 → AI 글 생성 → 이미지 생성 → 발행 (한 번에)';
    } else {
      publishModeDesc.innerHTML = '💡 AI 글 생성 → 미리보기 확인/수정 → 수동 발행';
    }
  }
}


// 전역 함수로 등록
(window as any).showStopButton = showStopButton;
(window as any).hideStopButton = hideStopButton;

// ✅ 글 선택 모달 표시
function showPostSelectionModal(
  posts: any[],
  onSelect: (post: any) => void,
  options?: { defaultCategory?: string }
): void {
  // 기존 모달 제거
  const existingModal = document.getElementById('post-selection-modal');
  if (existingModal) {
    existingModal.remove();
  }

  const modal = document.createElement('div');
  modal.id = 'post-selection-modal';
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2147483646;
  `;

  const content = document.createElement('div');
  content.style.cssText = `
    background: var(--bg-primary);
    border-radius: var(--radius-lg);
    padding: 1.5rem;
    width: 90%;
    max-width: 600px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
  `;

  const normalizeKey = (v: unknown): string => {
    const s = String(v || '').trim();
    return s ? s : 'uncategorized';
  };

  let activeCategory = String(options?.defaultCategory || '').trim();
  const allCategoryKey = '__all__';
  if (!activeCategory) activeCategory = allCategoryKey;

  const categories = Array.from(
    new Set(
      (posts || []).map((p) => normalizeKey((p as any)?.category))
    )
  );
  categories.sort((a, b) => {
    if (a === 'uncategorized' && b !== 'uncategorized') return 1;
    if (b === 'uncategorized' && a !== 'uncategorized') return -1;
    return getGeneratedPostCategoryLabel(a).localeCompare(getGeneratedPostCategoryLabel(b), 'ko');
  });

  const computeList = (categoryKey: string) => {
    const filtered = (posts || []).filter((p) => {
      if (categoryKey === allCategoryKey) return true;
      return normalizeKey((p as any)?.category) === normalizeKey(categoryKey);
    });
    const published = filtered.filter((p) => p.publishedUrl);
    const unpublished = filtered.filter((p) => !p.publishedUrl);
    const sorted = [...published, ...unpublished].slice(0, 40);
    return { filtered, published, unpublished, sorted };
  };

  const initial = computeList(activeCategory);

  content.innerHTML = `
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
      <h3 style="margin: 0; font-size: 1.25rem; color: var(--text-strong);">📝 이전 작성글 선택</h3>
      <button id="close-post-modal" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text-muted);">&times;</button>
    </div>
    <p style="color: var(--text-muted); margin-bottom: 0.5rem; font-size: 0.9rem;">엮을 글을 선택하세요. 선택한 글의 링크가 CTA에 자동으로 입력됩니다.</p>
    <div style="display:flex; gap: 0.5rem; align-items:center; margin-bottom: 0.75rem; flex-wrap: wrap;">
      <div style="font-size: 0.8rem; color: var(--text-muted); font-weight: 700;">카테고리</div>
      <select id="post-category-filter" style="flex: 1; min-width: 180px; padding: 0.45rem 0.6rem; border-radius: 8px; border: 1px solid var(--border-medium); background: var(--bg-secondary); color: var(--text-strong);">
        <option value="${allCategoryKey}">전체</option>
        ${categories
      .map((k) => `<option value="${escapeHtml(k)}">${escapeHtml(getGeneratedPostCategoryLabel(k))}</option>`)
      .join('')}
      </select>
    </div>
    <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
      <span id="post-selection-published-badge" style="padding: 0.25rem 0.5rem; background: rgba(16, 185, 129, 0.15); color: #10b981; border-radius: 4px; font-size: 0.8rem; font-weight: 600;">✅ 발행됨 ${initial.published.length}개</span>
      <span id="post-selection-unpublished-badge" style="padding: 0.25rem 0.5rem; background: rgba(156, 163, 175, 0.15); color: var(--text-muted); border-radius: 4px; font-size: 0.8rem;">⏳ 미발행 ${initial.unpublished.length}개</span>
    </div>
    <div id="post-list" style="display: flex; flex-direction: column; gap: 0.5rem;">
      ${initial.sorted.map((post, idx) => `
        <div class="post-item" data-post-index="${posts.indexOf(post)}" style="padding: 1rem; background: ${post.publishedUrl ? 'linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.05))' : 'var(--bg-secondary)'}; border-radius: var(--radius-md); cursor: pointer; transition: all 0.2s; border: 2px solid ${post.publishedUrl ? 'rgba(16, 185, 129, 0.4)' : 'var(--border-light)'};">
          <div style="display: flex; align-items: flex-start; gap: 0.75rem;">
            <span style="font-size: 1.5rem; line-height: 1;">${post.publishedUrl ? '✅' : '⏳'}</span>
            <div style="flex: 1; min-width: 0;">
              <div style="font-weight: 600; color: var(--text-strong); margin-bottom: 0.25rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${post.title || '제목 없음'}</div>
              <div style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.25rem;">
                ${post.createdAt ? new Date(post.createdAt).toLocaleDateString('ko-KR') : '날짜 없음'}
                ${post.publishedAt ? ' • 발행: ' + new Date(post.publishedAt).toLocaleDateString('ko-KR') : ''}
              </div>
              <div style="display:flex; gap: 0.4rem; align-items:center; margin-bottom: 0.35rem; flex-wrap: wrap;">
                <span style="font-size: 0.75rem; padding: 0.2rem 0.5rem; border-radius: 999px; background: rgba(59,130,246,0.15); color: var(--text-strong); font-weight: 800;">${escapeHtml(getGeneratedPostCategoryLabel(normalizeKey((post as any)?.category)))}</span>
                <span style="font-size: 0.75rem; padding: 0.2rem 0.5rem; border-radius: 999px; background: rgba(148,163,184,0.15); color: var(--text-muted); font-weight: 800;">🖼️ ${(post.images?.length || 0)}개</span>
              </div>
              ${post.publishedUrl ? `
                <div style="font-size: 0.75rem; color: #10b981; background: rgba(16, 185, 129, 0.1); padding: 0.25rem 0.5rem; border-radius: 4px; display: inline-block;">
                  🔗 ${post.publishedUrl.length > 50 ? post.publishedUrl.substring(0, 50) + '...' : post.publishedUrl}
                </div>
              ` : `
                <div style="font-size: 0.75rem; color: #f59e0b; background: rgba(245, 158, 11, 0.1); padding: 0.25rem 0.5rem; border-radius: 4px; display: inline-block;">
                  ⚠️ 미발행 - URL 없음
                </div>
              `}
            </div>
          </div>
        </div>
      `).join('')}
    </div>
  `;

  modal.appendChild(content);
  document.body.appendChild(modal);

  // ✅ 다른 모달보다 항상 위로 오도록(마지막에 붙이기 + 포커스)
  try {
    document.body.appendChild(modal);
    (modal as any).tabIndex = -1;
    (modal as any).focus?.();
  } catch {
    // ignore
  }

  // 이벤트 리스너
  const closeBtn = content.querySelector('#close-post-modal');
  if (closeBtn) {
    closeBtn.addEventListener('click', () => modal.remove());
  }

  modal.addEventListener('click', (e) => {
    if (e.target === modal) modal.remove();
  });

  const bindItems = () => {
    const postItems = content.querySelectorAll('.post-item');
    postItems.forEach((item) => {
      item.addEventListener('click', () => {
        const postIndex = parseInt(item.getAttribute('data-post-index') || '0');
        const selectedPost = posts[postIndex];
        modal.remove();
        onSelect(selectedPost);
      });

      item.addEventListener('mouseenter', () => {
        (item as HTMLElement).style.borderColor = 'var(--primary)';
        (item as HTMLElement).style.background = 'var(--bg-tertiary)';
      });

      item.addEventListener('mouseleave', () => {
        const postIndex = parseInt(item.getAttribute('data-post-index') || '0');
        const hasUrl = posts[postIndex]?.publishedUrl;
        (item as HTMLElement).style.borderColor = hasUrl ? 'rgba(16, 185, 129, 0.3)' : 'transparent';
        (item as HTMLElement).style.background = 'var(--bg-secondary)';
      });
    });
  };

  bindItems();

  const categorySelect = content.querySelector('#post-category-filter') as HTMLSelectElement | null;
  if (categorySelect) {
    categorySelect.value = activeCategory;
    categorySelect.addEventListener('change', () => {
      activeCategory = String(categorySelect.value || '').trim() || allCategoryKey;
      const res = computeList(activeCategory);
      const publishedBadge = content.querySelector('#post-selection-published-badge') as HTMLElement | null;
      const unpublishedBadge = content.querySelector('#post-selection-unpublished-badge') as HTMLElement | null;
      if (publishedBadge) publishedBadge.textContent = `✅ 발행됨 ${res.published.length}개`;
      if (unpublishedBadge) unpublishedBadge.textContent = `⏳ 미발행 ${res.unpublished.length}개`;

      const list = content.querySelector('#post-list') as HTMLElement | null;
      if (list) {
        list.innerHTML = res.sorted.map((post) => {
          const cat = getGeneratedPostCategoryLabel(normalizeKey((post as any)?.category));
          const imgCount = (post.images?.length || 0);
          return `
            <div class="post-item" data-post-index="${posts.indexOf(post)}" style="padding: 1rem; background: ${post.publishedUrl ? 'linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.05))' : 'var(--bg-secondary)'}; border-radius: var(--radius-md); cursor: pointer; transition: all 0.2s; border: 2px solid ${post.publishedUrl ? 'rgba(16, 185, 129, 0.4)' : 'var(--border-light)'};">
              <div style="display: flex; align-items: flex-start; gap: 0.75rem;">
                <span style="font-size: 1.5rem; line-height: 1;">${post.publishedUrl ? '✅' : '⏳'}</span>
                <div style="flex: 1; min-width: 0;">
                  <div style="font-weight: 600; color: var(--text-strong); margin-bottom: 0.25rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${escapeHtml(post.title || '제목 없음')}</div>
                  <div style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0.25rem;">${post.createdAt ? new Date(post.createdAt).toLocaleDateString('ko-KR') : '날짜 없음'}${post.publishedAt ? ' • 발행: ' + new Date(post.publishedAt).toLocaleDateString('ko-KR') : ''}</div>
                  <div style="display:flex; gap: 0.4rem; align-items:center; margin-bottom: 0.35rem; flex-wrap: wrap;">
                    <span style="font-size: 0.75rem; padding: 0.2rem 0.5rem; border-radius: 999px; background: rgba(59,130,246,0.15); color: var(--text-strong); font-weight: 800;">${escapeHtml(cat)}</span>
                    <span style="font-size: 0.75rem; padding: 0.2rem 0.5rem; border-radius: 999px; background: rgba(148,163,184,0.15); color: var(--text-muted); font-weight: 800;">🖼️ ${imgCount}개</span>
                  </div>
                  ${post.publishedUrl ? `<div style="font-size: 0.75rem; color: #10b981; background: rgba(16, 185, 129, 0.1); padding: 0.25rem 0.5rem; border-radius: 4px; display: inline-block;">🔗 ${escapeHtml(post.publishedUrl.length > 50 ? post.publishedUrl.substring(0, 50) + '...' : post.publishedUrl)}</div>` : `<div style="font-size: 0.75rem; color: #f59e0b; background: rgba(245, 158, 11, 0.1); padding: 0.25rem 0.5rem; border-radius: 4px; display: inline-block;">⚠️ 미발행 - URL 없음</div>`}
                </div>
              </div>
            </div>
          `;
        }).join('');
      }
      bindItems();
    });
  }
}

// 발행 모드 선택 초기화
function initUnifiedModeSelection(): void {
  // 기존 버튼 모드 선택
  const modeBtns = document.querySelectorAll('.unified-mode-btn');

  modeBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const mode = (btn as HTMLElement).getAttribute('data-mode');

      // 기존 선택 해제
      modeBtns.forEach(b => {
        b.classList.remove('selected');
        (b as HTMLElement).style.background = 'var(--bg-tertiary)';
        (b as HTMLElement).style.color = 'var(--text-strong)';
        (b as HTMLElement).style.borderColor = 'transparent';
        (b as HTMLElement).style.boxShadow = 'none';
      });

      // 새로 선택
      btn.classList.add('selected');
      (btn as HTMLElement).style.background = 'var(--primary)';
      (btn as HTMLElement).style.color = 'white';
      (btn as HTMLElement).style.borderColor = 'var(--primary)';

      // 모드 설명 업데이트
      updateModeDescription(mode);

      // 반자동 모드 섹션 토글
      toggleSemiAutoSection(mode === 'semi-auto');
    });
  });

  // ✅ 발행 방식 버튼 클릭 이벤트
  document.querySelectorAll('.publish-mode-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const mode = (btn as HTMLElement).dataset.mode || 'publish';
      const hiddenInput = document.getElementById('unified-publish-mode') as HTMLInputElement;
      if (hiddenInput) hiddenInput.value = mode;

      // 버튼 스타일 업데이트
      document.querySelectorAll('.publish-mode-btn').forEach(b => {
        (b as HTMLElement).classList.remove('selected');
        (b as HTMLElement).style.background = 'var(--bg-tertiary)';
        (b as HTMLElement).style.color = 'var(--text-muted)';
        (b as HTMLElement).style.border = '1px solid var(--border-medium)';
      });
      (btn as HTMLElement).classList.add('selected');
      (btn as HTMLElement).style.background = 'linear-gradient(135deg, #10b981, #059669)';
      (btn as HTMLElement).style.color = 'white';
      (btn as HTMLElement).style.border = 'none';

      // 예약 발행 컨테이너 표시/숨김
      const scheduleContainer = document.getElementById('unified-schedule-container');
      if (scheduleContainer) {
        if (mode === 'schedule') {
          scheduleContainer.style.display = 'block';
          // 최소 예약 시간 설정
          const scheduleInput = document.getElementById('unified-schedule-date') as HTMLInputElement;
          if (scheduleInput) {
            const now = new Date();
            const minDate = new Date(now.getTime() + 60000);
            const formattedDateTime = `${minDate.getFullYear()}-${String(minDate.getMonth() + 1).padStart(2, '0')}-${String(minDate.getDate()).padStart(2, '0')}T${String(minDate.getHours()).padStart(2, '0')}:${String(minDate.getMinutes()).padStart(2, '0')}`;
            scheduleInput.min = formattedDateTime;
            scheduleInput.value = formattedDateTime;
            setTimeout(() => {
              scheduleInput.focus();
              scheduleInput.showPicker?.();
            }, 100);
          }
        } else {
          scheduleContainer.style.display = 'none';
        }
      }
    });
  });

  // ✅ 글 톤/스타일 버튼 클릭 이벤트
  document.querySelectorAll('.tone-style-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const tone = (btn as HTMLElement).dataset.tone || 'friendly';
      const hiddenInput = document.getElementById('unified-tone-style') as HTMLInputElement;
      if (hiddenInput) {
        hiddenInput.value = tone;
        hiddenInput.setAttribute('data-user-selected', 'true');
      }

      // 버튼 스타일 업데이트
      document.querySelectorAll('.tone-style-btn').forEach(b => {
        (b as HTMLElement).classList.remove('selected');
        (b as HTMLElement).style.background = 'var(--bg-tertiary)';
        (b as HTMLElement).style.color = 'var(--text-muted)';
        (b as HTMLElement).style.border = '1px solid var(--border-medium)';
      });
      (btn as HTMLElement).classList.add('selected');
      (btn as HTMLElement).style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
      (btn as HTMLElement).style.color = 'white';
      (btn as HTMLElement).style.border = 'none';
    });
  });

  // ✅ 콘텐츠 모드 선택 버튼 클릭 이벤트 (SEO / 홈판 / 제휴마케팅 / 사용자정의)
  document.querySelectorAll('.content-mode-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const mode = (btn as HTMLElement).dataset.mode || 'seo';
      const hiddenInput = document.getElementById('unified-content-mode') as HTMLInputElement;
      if (hiddenInput) {
        hiddenInput.value = mode;
        hiddenInput.setAttribute('data-user-selected', 'true');
      }

      const descriptionEl = document.getElementById('content-mode-description');
      const homefeedDescEl = document.getElementById('content-mode-description-homefeed');
      const affiliateDescEl = document.getElementById('content-mode-description-affiliate');
      const customDescEl = document.getElementById('content-mode-description-custom');
      const customPromptArea = document.getElementById('custom-prompt-area');

      // 버튼 스타일 업데이트
      document.querySelectorAll('.content-mode-btn').forEach(b => {
        (b as HTMLElement).classList.remove('selected');
        (b as HTMLElement).style.background = 'var(--bg-tertiary)';
        (b as HTMLElement).style.color = 'var(--text-muted)';
        (b as HTMLElement).style.border = '2px solid var(--border-medium)';
      });
      (btn as HTMLElement).classList.add('selected');

      // 모드별 색상/그래디언트 정의
      if (mode === 'seo') {
        (btn as HTMLElement).style.background = 'linear-gradient(135deg, #10b981, #059669)';
      } else if (mode === 'homefeed') {
        (btn as HTMLElement).style.background = 'linear-gradient(135deg, #8b5cf6, #7c3aed)';
      } else if (mode === 'affiliate') {
        (btn as HTMLElement).style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
      } else if (mode === 'custom') {
        (btn as HTMLElement).style.background = 'linear-gradient(135deg, #6366f1, #4f46e5)';
      }

      (btn as HTMLElement).style.color = 'white';
      (btn as HTMLElement).style.border = 'none';

      // 설명 토글
      if (descriptionEl) descriptionEl.style.display = mode === 'seo' ? 'block' : 'none';
      if (homefeedDescEl) homefeedDescEl.style.display = mode === 'homefeed' ? 'block' : 'none';
      if (affiliateDescEl) affiliateDescEl.style.display = mode === 'affiliate' ? 'block' : 'none';
      if (customDescEl) customDescEl.style.display = mode === 'custom' ? 'block' : 'none';

      // 사용자정의 프롬프트 영역: custom 모드에서만 표시
      if (customPromptArea) {
        customPromptArea.style.display = mode === 'custom' ? 'block' : 'none';
      }
    });
  });


  // 통합 탭 발행 방식 선택 (select 요소 - 레거시 지원)
  const publishModeSelect = document.getElementById('unified-publish-mode') as HTMLSelectElement;
  if (publishModeSelect && publishModeSelect.tagName === 'SELECT') {
    publishModeSelect.addEventListener('change', () => {
      const mode = publishModeSelect.value;
      const scheduleContainer = document.getElementById('unified-schedule-container');

      if (scheduleContainer) {
        if (mode === 'schedule') {
          scheduleContainer.style.display = 'block';
          // 최소 예약 시간 설정 (현재 시간 + 1분)
          const scheduleInput = document.getElementById('unified-schedule-date') as HTMLInputElement;
          const scheduleConfirmBtn = document.getElementById('unified-schedule-confirm-btn') as HTMLButtonElement;

          if (scheduleInput) {
            const now = new Date();
            const minDate = new Date(now.getTime() + 60000); // 1분 후
            const year = minDate.getFullYear();
            const month = String(minDate.getMonth() + 1).padStart(2, '0');
            const day = String(minDate.getDate()).padStart(2, '0');
            const hours = String(minDate.getHours()).padStart(2, '0');
            const minutes = String(minDate.getMinutes()).padStart(2, '0');
            const formattedDateTime = `${year}-${month}-${day}T${hours}:${minutes}`;
            scheduleInput.min = formattedDateTime;
            scheduleInput.value = formattedDateTime;

            // 입력 필드에 포커스하여 달력 바로 표시
            setTimeout(() => {
              scheduleInput.focus();
              scheduleInput.showPicker?.(); // showPicker API 지원 시 달력 바로 표시
            }, 100);
          }

          // 확인 버튼 표시
          if (scheduleConfirmBtn) {
            scheduleConfirmBtn.style.display = 'block';
          }

          // 날짜/시간 변경 시 확인 버튼 활성화
          if (scheduleInput) {
            scheduleInput.addEventListener('change', () => {
              if (scheduleConfirmBtn && scheduleInput.value) {
                scheduleConfirmBtn.disabled = false;
                scheduleConfirmBtn.style.opacity = '1';
              }
            });
          }
        } else {
          scheduleContainer.style.display = 'none';
          const scheduleConfirmBtn = document.getElementById('unified-schedule-confirm-btn') as HTMLButtonElement;
          if (scheduleConfirmBtn) {
            scheduleConfirmBtn.style.display = 'none';
          }
        }
      }
    });
  }

  // ✅ 예약 시간 입력 시 미리보기 및 확인 버튼 활성화
  const scheduleInput = document.getElementById('unified-schedule-date') as HTMLInputElement;
  const schedulePreview = document.getElementById('schedule-preview');

  if (scheduleInput) {
    // ✅ change 이벤트: 날짜/시간 선택 완료 시 (달력이 자동으로 닫힘)
    scheduleInput.addEventListener('change', () => {
      const scheduleConfirmBtn = document.getElementById('unified-schedule-confirm-btn') as HTMLButtonElement;

      if (scheduleInput.value) {
        const selectedDate = new Date(scheduleInput.value);
        const formattedDate = selectedDate.toLocaleString('ko-KR', {
          year: 'numeric',
          month: 'long',
          day: 'numeric',
          weekday: 'short',
          hour: '2-digit',
          minute: '2-digit',
        });

        // 미리보기 표시
        if (schedulePreview) {
          schedulePreview.textContent = `📅 ${formattedDate}`;
          schedulePreview.style.display = 'block';
        }

        // 확인 버튼 활성화 (강조 효과 추가)
        if (scheduleConfirmBtn) {
          scheduleConfirmBtn.disabled = false;
          scheduleConfirmBtn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
          scheduleConfirmBtn.style.cursor = 'pointer';
          scheduleConfirmBtn.style.boxShadow = '0 6px 20px rgba(16, 185, 129, 0.5)';
          scheduleConfirmBtn.style.transform = 'scale(1.02)';
          scheduleConfirmBtn.innerHTML = `
            <span style="display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
              <span style="font-size: 1.2rem;">✅</span>
              <span>예약 설정 확인</span>
            </span>
          `;

          // 애니메이션 효과 후 원래대로
          setTimeout(() => {
            scheduleConfirmBtn.style.transform = 'scale(1)';
          }, 300);
        }

        // 달력 자동 닫기 (blur 이벤트 트리거)
        scheduleInput.blur();

        appendLog(`📅 예약 시간 선택됨: ${formattedDate}`);
        toastManager.success('✅ 예약 시간이 선택되었습니다! 확인 버튼을 눌러주세요.');
      } else {
        // 값이 없으면 비활성화
        if (schedulePreview) {
          schedulePreview.style.display = 'none';
        }
        if (scheduleConfirmBtn) {
          scheduleConfirmBtn.disabled = true;
          scheduleConfirmBtn.style.background = 'linear-gradient(135deg, #9ca3af, #6b7280)';
          scheduleConfirmBtn.style.cursor = 'not-allowed';
          scheduleConfirmBtn.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.2)';
          scheduleConfirmBtn.innerHTML = `
            <span style="display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
              <span style="font-size: 1.2rem;">⏰</span>
              <span>날짜와 시간을 먼저 선택하세요</span>
            </span>
          `;
        }
      }
    });

    // ✅ 예약발행 모드 선택 시 달력 자동 열기
    const publishModeSelect = document.getElementById('unified-publish-mode') as HTMLSelectElement;
    if (publishModeSelect) {
      publishModeSelect.addEventListener('change', () => {
        if (publishModeSelect.value === 'schedule') {
          // 약간의 딜레이 후 달력 열기 (UI 렌더링 대기)
          setTimeout(() => {
            scheduleInput.showPicker?.();
          }, 100);
        }
      });
    }
  }

  // 예약 시간 확인 버튼 이벤트
  const scheduleConfirmBtn = document.getElementById('unified-schedule-confirm-btn') as HTMLButtonElement;
  if (scheduleConfirmBtn) {
    scheduleConfirmBtn.addEventListener('click', () => {
      const scheduleInput = document.getElementById('unified-schedule-date') as HTMLInputElement;
      const publishModeSelect = document.getElementById('unified-publish-mode') as HTMLSelectElement;
      const successMessage = document.getElementById('schedule-success-message');

      if (scheduleInput && scheduleInput.value) {
        const selectedDate = new Date(scheduleInput.value);
        const now = new Date();

        if (selectedDate <= now) {
          toastManager.error('⚠️ 예약 시간은 현재 시간 이후로 설정해주세요.');
          return;
        }

        // ✅ datetime-local 형식(2025-01-15T14:30)을 YYYY-MM-DD HH:mm 형식으로 변환
        const datetimeValue = scheduleInput.value; // 2025-01-15T14:30
        const formattedScheduleDate = datetimeValue.replace('T', ' '); // 2025-01-15 14:30

        // ✅ 변환된 날짜를 data 속성에 저장 (발행 시 사용)
        scheduleInput.dataset.formattedDate = formattedScheduleDate;

        const formattedDate = selectedDate.toLocaleString('ko-KR', {
          year: 'numeric',
          month: 'long',
          day: 'numeric',
          weekday: 'short',
          hour: '2-digit',
          minute: '2-digit',
        });

        // ✅ 발행 모드를 'schedule'로 확실하게 설정
        if (publishModeSelect) {
          publishModeSelect.value = 'schedule';
        }

        // ✅ 성공 메시지 표시
        if (successMessage) {
          successMessage.style.display = 'block';
          successMessage.innerHTML = `
            <div style="display: flex; align-items: center; justify-content: center; gap: 0.75rem;">
              <span style="font-size: 2rem;">✅</span>
              <div>
                <div style="font-size: 1.1rem; margin-bottom: 0.25rem;">예약이 설정되었습니다!</div>
                <div style="font-size: 0.9rem; opacity: 0.9;">${formattedDate}에 자동으로 발행됩니다.</div>
              </div>
            </div>
          `;

          // 3초 후 자동 숨김
          setTimeout(() => {
            if (successMessage) {
              successMessage.style.display = 'none';
            }
          }, 5000);
        }

        toastManager.success(`✅ 예약 설정 완료: ${formattedDate}`);
        appendLog(`✅ 예약 발행 시간 설정: ${formattedDate}`);
      } else {
        toastManager.error('⚠️ 예약 시간을 선택해주세요.');
      }
    });
  }
}

// 모드 설명 업데이트
function updateModeDescription(mode: string | null): void {
  const fullAutoDesc = document.getElementById('mode-description-full-auto');
  const semiAutoDesc = document.getElementById('mode-description-semi-auto');

  if (fullAutoDesc && semiAutoDesc) {
    if (mode === 'full-auto') {
      fullAutoDesc.style.display = 'block';
      semiAutoDesc.style.display = 'none';
    } else {
      fullAutoDesc.style.display = 'none';
      semiAutoDesc.style.display = 'block';
    }
  }
}

// 반자동 모드 섹션 토글
function toggleSemiAutoSection(show: boolean): void {
  const semiAutoSection = document.getElementById('unified-semi-auto-section');
  if (semiAutoSection) {
    semiAutoSection.style.display = show ? 'block' : 'none';
  }

  // ✅ 반자동 섹션이 보여질 때, 수정 영역이 비어 있으면 currentStructuredContent로 자동 복원
  if (show) {
    try {
      const structuredContent = (window as any).currentStructuredContent;
      fillSemiAutoFields(structuredContent);
    } catch {
      // ignore
    }
  }
}



// 발행 시작 알림 표시
function showPublishStartNotification(message: string): void {
  // 기존 알림 제거
  const existingNotification = document.getElementById('publish-start-notification');
  if (existingNotification) {
    existingNotification.remove();
  }

  // 새로운 알림 생성
  const notification = document.createElement('div');
  notification.id = 'publish-start-notification';
  notification.style.cssText = `
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: linear-gradient(135deg, #10b981, #059669);
    color: white;
    padding: 2rem 3rem;
    border-radius: 16px;
    box-shadow: 0 20px 40px rgba(16, 185, 129, 0.4);
    z-index: 10000;
    text-align: center;
    font-size: 1.2rem;
    font-weight: 600;
    animation: slideIn 0.3s ease-out;
    border: 3px solid rgba(255, 255, 255, 0.3);
  `;

  notification.innerHTML = `
    <div style="font-size: 2rem; margin-bottom: 0.5rem;">🚀</div>
    <div>${message}</div>
    <div style="margin-top: 1rem; font-size: 0.9rem; opacity: 0.9;">잠시만 기다려주세요...</div>
  `;

  // 애니메이션 스타일 추가
  const style = document.createElement('style');
  style.textContent = `
    @keyframes slideIn {
      from { transform: translate(-50%, -60%); opacity: 0; }
      to { transform: translate(-50%, -50%); opacity: 1; }
    }
  `;
  document.head.appendChild(style);

  document.body.appendChild(notification);

  // 3초 후 자동 제거
  setTimeout(() => {
    if (notification.parentNode) {
      notification.style.animation = 'slideOut 0.3s ease-in';
      setTimeout(() => {
        notification.remove();
        style.remove();
      }, 300);
    }
  }, 3000);

  // 추가 애니메이션
  style.textContent += `
    @keyframes slideOut {
      from { transform: translate(-50%, -50%); opacity: 1; }
      to { transform: translate(-50%, -40%); opacity: 0; }
    }
  `;
}

// 진행률 표시 초기화
function initializePublishProgress(): void {
  // 기존 진행률 컨테이너 제거
  const existingProgress = document.getElementById('publish-progress-container');
  if (existingProgress) {
    existingProgress.remove();
  }

  // 새로운 진행률 컨테이너 생성
  const progressContainer = document.createElement('div');
  progressContainer.id = 'publish-progress-container';
  progressContainer.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    width: 350px;
    background: var(--bg-primary);
    border: 2px solid var(--primary);
    border-radius: 12px;
    padding: 1.5rem;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    z-index: 9999;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  `;

  progressContainer.innerHTML = `
    <div style="display: flex; align-items: center; margin-bottom: 1rem;">
      <div style="font-size: 1.5rem; margin-right: 0.5rem;">📊</div>
      <div style="font-weight: 600; color: var(--text-strong);">발행 진행률</div>
    </div>

    <div style="margin-bottom: 1rem;">
      <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
        <span id="progress-text" style="color: var(--text-muted); font-size: 0.9rem;">준비 중...</span>
        <span id="progress-percent" style="color: var(--text-gold); font-weight: 600;">0%</span>
      </div>
      <div style="width: 100%; height: 8px; background: var(--bg-tertiary); border-radius: 4px; overflow: hidden;">
        <div id="progress-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, var(--primary), var(--accent)); border-radius: 4px; transition: width 0.3s ease;"></div>
      </div>
    </div>

    <div id="progress-details" style="color: var(--text-muted); font-size: 0.85rem; line-height: 1.4;">
      발행을 준비하고 있습니다...
    </div>

    <button id="close-progress-btn" style="
      position: absolute;
      top: 10px;
      right: 10px;
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 1.2rem;
      cursor: pointer;
      padding: 0.2rem;
      border-radius: 50%;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    " onmouseover="this.style.background='rgba(239, 68, 68, 0.1)'" onmouseout="this.style.background='none'" title="닫기">×</button>
  `;

  document.body.appendChild(progressContainer);

  // 닫기 버튼 이벤트
  const closeBtn = progressContainer.querySelector('#close-progress-btn') as HTMLButtonElement;
  if (closeBtn) {
    closeBtn.addEventListener('click', () => {
      progressContainer.remove();
    });
  }
}

// ✅ 오류 로그 상세화 - 전역 에러 핸들러
interface ErrorLog {
  timestamp: string;
  type: 'error' | 'unhandledRejection' | 'api' | 'automation';
  message: string;
  stack?: string;
  context?: any;
  userAgent: string;
  url: string;
}

const ERROR_LOG_KEY = 'naver_blog_error_logs';
const MAX_ERROR_LOGS = 50; // 최대 50개 로그 저장

function logError(error: Error | string, type: ErrorLog['type'] = 'error', context?: any): void {
  const errorLog: ErrorLog = {
    timestamp: new Date().toISOString(),
    type,
    message: typeof error === 'string' ? error : error.message,
    stack: typeof error === 'string' ? undefined : error.stack,
    context,
    userAgent: navigator.userAgent,
    url: window.location.href
  };

  try {
    // 기존 로그 불러오기
    const existingLogs = localStorage.getItem(ERROR_LOG_KEY);
    const logs: ErrorLog[] = existingLogs ? JSON.parse(existingLogs) : [];

    // 새 로그 추가
    logs.unshift(errorLog);

    // 최대 개수 제한
    if (logs.length > MAX_ERROR_LOGS) {
      logs.splice(MAX_ERROR_LOGS);
    }

    // 저장
    localStorage.setItem(ERROR_LOG_KEY, JSON.stringify(logs));

    // 콘솔에도 상세 로그 출력
    console.error(`[${type.toUpperCase()}] ${errorLog.timestamp}`, {
      message: errorLog.message,
      stack: errorLog.stack,
      context: errorLog.context
    });
  } catch (e) {
    console.error('[ErrorLog] 오류 로그 저장 실패:', e);
  }
}

// ✅ 크래시 복구 기능
let crashRecoveryAttempts = 0;
const MAX_CRASH_RECOVERY_ATTEMPTS = 3;

function handleCrash(error: any, context: string): void {
  logError(error, 'error', { context, crashRecoveryAttempts });

  // 자동 저장 실행
  const structuredContent = (window as any).currentStructuredContent;
  if (structuredContent) {
    const mode = document.querySelector('.unified-mode-btn.selected')?.getAttribute('data-mode') as 'full-auto' | 'semi-auto' || 'full-auto';
    autosaveContent({
      timestamp: Date.now(),
      mode,
      structuredContent,
      generatedImages: (window as any).imageManagementGeneratedImages || []
    });
    appendLog('💾 크래시 감지: 작업 내용을 긴급 저장했습니다.');
  }

  // 복구 시도 제한
  if (crashRecoveryAttempts < MAX_CRASH_RECOVERY_ATTEMPTS) {
    crashRecoveryAttempts++;
    appendLog(`🔄 크래시 복구 시도 중... (${crashRecoveryAttempts}/${MAX_CRASH_RECOVERY_ATTEMPTS})`);

    // 3초 후 복구 시도
    setTimeout(() => {
      appendLog('✅ 애플리케이션이 복구되었습니다. 작업을 계속하세요.');
      crashRecoveryAttempts = 0; // 복구 성공 시 카운터 리셋
    }, 3000);
  } else {
    appendLog('❌ 크래시 복구 한도 초과. 애플리케이션을 재시작해주세요.');
    alert('⚠️ 심각한 오류가 발생했습니다.\n\n작업 내용은 자동 저장되었습니다.\n애플리케이션을 재시작한 후 복구하세요.');
  }
}

// 전역 에러 핸들러 등록
window.addEventListener('error', (event) => {
  logError(event.error || event.message, 'error', {
    filename: event.filename,
    lineno: event.lineno,
    colno: event.colno
  });

  // 크래시 복구 처리
  handleCrash(event.error || event.message, 'window.error');

  // 기본 동작 방지 (콘솔에만 로그)
  event.preventDefault();
});

window.addEventListener('unhandledrejection', (event) => {
  // 상세 오류 정보 로깅
  const errorDetails = {
    reason: event.reason,
    message: event.reason?.message || 'Unknown error',
    stack: event.reason?.stack || 'No stack trace',
    timestamp: new Date().toISOString()
  };

  console.error('[UNHANDLED_REJECTION] 처리되지 않은 프로미스 오류:', errorDetails);
  appendLog(`⚠️ 처리되지 않은 오류: ${errorDetails.message}`);

  logError(event.reason, 'unhandledRejection', {
    promise: event.promise,
    details: errorDetails
  });

  // 크래시 복구 처리
  handleCrash(event.reason, 'unhandledRejection');

  // 기본 동작 방지
  event.preventDefault();
});

// 오류 로그 내보내기 함수
function exportErrorLogs(): void {
  try {
    const logs = localStorage.getItem(ERROR_LOG_KEY);
    if (!logs) {
      alert('저장된 오류 로그가 없습니다.');
      return;
    }

    const blob = new Blob([logs], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `error_logs_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
    a.click();
    URL.revokeObjectURL(url);

    alert('오류 로그가 다운로드되었습니다.');
  } catch (e) {
    console.error('[ErrorLog] 로그 내보내기 실패:', e);
    alert('오류 로그 내보내기에 실패했습니다.');
  }
}

// 오류 로그 초기화 함수
function clearErrorLogs(): void {
  if (confirm('모든 오류 로그를 삭제하시겠습니까?')) {
    localStorage.removeItem(ERROR_LOG_KEY);
    alert('오류 로그가 삭제되었습니다.');
  }
}

// ✅ 예상 완료 시간 계산 헬퍼
let progressStartTime: number | null = null;

function calculateEstimatedTime(currentPercent: number): string {
  if (!progressStartTime || currentPercent <= 0) return '';

  const elapsed = Date.now() - progressStartTime;
  const remaining = (elapsed / currentPercent) * (100 - currentPercent);

  if (remaining < 60000) {
    return `약 ${Math.ceil(remaining / 1000)}초 남음`;
  } else {
    return `약 ${Math.ceil(remaining / 60000)}분 남음`;
  }
}

// ✅ 발행 완료 후 필드 초기화
function resetAllFields(): void {
  try {
    // 풀오토 모드 필드 초기화
    const urlInputs = document.querySelectorAll('.unified-url-input') as NodeListOf<HTMLInputElement>;
    urlInputs.forEach(input => input.value = '');

    const keywordsInput = document.getElementById('unified-keywords') as HTMLInputElement;
    if (keywordsInput) keywordsInput.value = '';

    const titleInput = document.getElementById('unified-title') as HTMLInputElement;
    if (titleInput) titleInput.value = '';

    // ✅ 연속발행(continuous) 입력값도 초기화 (최근 작성 키워드가 남는 현상 방지)
    const continuousKeywordInput = document.getElementById('continuous-keyword-input') as HTMLInputElement | null;
    if (continuousKeywordInput) continuousKeywordInput.value = '';
    const continuousKeywordTitleInput = document.getElementById('continuous-keyword-title-input') as HTMLInputElement | null;
    if (continuousKeywordTitleInput) continuousKeywordTitleInput.value = '';

    const continuousUrlInput = document.getElementById('continuous-url-input') as HTMLInputElement | null;
    if (continuousUrlInput) continuousUrlInput.value = '';
    const continuousUrlKeywordInput = document.getElementById('continuous-url-keyword-input') as HTMLInputElement | null;
    if (continuousUrlKeywordInput) continuousUrlKeywordInput.value = '';
    const continuousUrlTitleInput = document.getElementById('continuous-url-title-input') as HTMLInputElement | null;
    if (continuousUrlTitleInput) continuousUrlTitleInput.value = '';

    // 개별 키워드 필드 방식(continuous-keyword-fields-container)
    const continuousKeywordFieldInputs = document.querySelectorAll('.continuous-keyword-field-input') as NodeListOf<HTMLInputElement>;
    continuousKeywordFieldInputs.forEach((input) => (input.value = ''));

    // 반자동 모드 필드 초기화
    const manualTitleInput = document.getElementById('unified-manual-title') as HTMLInputElement;
    if (manualTitleInput) manualTitleInput.value = '';

    const manualContentTextarea = document.getElementById('unified-manual-content') as HTMLTextAreaElement;
    if (manualContentTextarea) manualContentTextarea.value = '';

    const manualHashtagsInput = document.getElementById('unified-manual-hashtags') as HTMLInputElement;
    if (manualHashtagsInput) manualHashtagsInput.value = '';

    // 생성된 제목/해시태그 필드 초기화
    const generatedTitleInput = document.getElementById('unified-generated-title') as HTMLInputElement;
    if (generatedTitleInput) {
      generatedTitleInput.value = '';
      generatedTitleInput.readOnly = false;
    }

    const generatedHashtagsInput = document.getElementById('unified-generated-hashtags') as HTMLInputElement;
    if (generatedHashtagsInput) {
      generatedHashtagsInput.value = '';
      generatedHashtagsInput.readOnly = false;
    }

    // ✅ 생성된 본문 필드 초기화 (unified-generated-content)
    const generatedContentTextarea = document.getElementById('unified-generated-content') as HTMLTextAreaElement;
    if (generatedContentTextarea) {
      generatedContentTextarea.value = '';
      generatedContentTextarea.readOnly = false;
    }

    // ✅ 본문 필드 초기화 (unified-body)
    const unifiedBodyTextarea = document.getElementById('unified-body') as HTMLTextAreaElement;
    if (unifiedBodyTextarea) {
      unifiedBodyTextarea.value = '';
      unifiedBodyTextarea.readOnly = false;
    }

    // ✅ 발행 모드를 "즉시 발행"으로 초기화
    const publishModeSelect = document.getElementById('unified-publish-mode') as HTMLSelectElement;
    if (publishModeSelect) {
      publishModeSelect.value = 'publish';

      // 예약 발행 컨테이너 숨기기
      const scheduleContainer = document.getElementById('unified-schedule-container');
      if (scheduleContainer) {
        scheduleContainer.style.display = 'none';
      }

      // 예약 날짜 초기화
      const scheduleDateInput = document.getElementById('unified-schedule-date') as HTMLInputElement;
      if (scheduleDateInput) {
        scheduleDateInput.value = '';
        scheduleDateInput.removeAttribute('data-formatted-date');
      }
    }

    // 미리보기 초기화
    const previewSection = document.getElementById('unified-preview-section');
    if (previewSection) {
      previewSection.style.display = 'none';
    }

    const previewTitle = document.getElementById('unified-preview-title');
    if (previewTitle) previewTitle.textContent = '제목이 여기에 표시됩니다';

    const previewBody = document.getElementById('unified-preview-body');
    if (previewBody) previewBody.innerHTML = '<p style="color: var(--text-muted);">본문이 여기에 표시됩니다</p>';

    const previewHashtags = document.getElementById('unified-preview-hashtags');
    if (previewHashtags) previewHashtags.textContent = '';

    // ✅ [2026-01-22] 쇼핑커넥트 관련 UI 필드 초기화 (캐시 방지)
    const affiliateLinkInput = document.getElementById('shopping-connect-affiliate-link') as HTMLInputElement;
    if (affiliateLinkInput) affiliateLinkInput.value = '';

    const batchLinkInput = document.getElementById('batch-link-input') as HTMLInputElement;
    if (batchLinkInput) batchLinkInput.value = '';

    const autoBannerCheckbox = document.getElementById('shopping-connect-auto-banner') as HTMLInputElement;
    if (autoBannerCheckbox) autoBannerCheckbox.checked = false;

    const useVideoCheckbox = document.getElementById('shopping-connect-use-video') as HTMLInputElement;
    if (useVideoCheckbox) useVideoCheckbox.checked = false;

    // CTA 필드 초기화
    const ctaItemsContainer = document.getElementById('unified-cta-items-container');
    if (ctaItemsContainer) ctaItemsContainer.innerHTML = '';

    // 이전글 선택 필드 초기화
    const previousPostTitleInput = document.getElementById('previous-post-title') as HTMLInputElement;
    if (previousPostTitleInput) previousPostTitleInput.value = '';
    const previousPostUrlInput = document.getElementById('previous-post-url') as HTMLInputElement;
    if (previousPostUrlInput) previousPostUrlInput.value = '';

    // 이미지 관리 탭 초기화
    const imageTitleInput = document.getElementById('image-title') as HTMLInputElement;
    if (imageTitleInput) imageTitleInput.value = '';

    const promptsContainer = document.getElementById('prompts-container');
    if (promptsContainer) promptsContainer.innerHTML = '';

    const generatedImagesSection = document.getElementById('generated-images-section');
    if (generatedImagesSection) generatedImagesSection.style.display = 'none';

    // 전역 변수 초기화 (발행 후 캐시 완전 제거)
    (window as any).currentStructuredContent = null;
    (window as any).imageManagementGeneratedImages = null;
    currentPostId = null; // ✅ 글 ID도 초기화
    // ✅ [2026-01-22] 추가 캐시 초기화 - 모든 발행 모드에서 완전 초기화
    (window as any).customBannerPath = null; // 커스텀 배너 경로
    (window as any).generatedImages = null; // 생성된 이미지
    (window as any).previousPostUrl = null; // 이전글 URL (수동 설정 시)
    (window as any).previousPostTitle = null; // 이전글 제목 (수동 설정 시)
    (window as any).affiliateLinkData = null; // 제휴 링크 데이터
    (window as any).crawledProductInfo = null; // 크롤링된 제품 정보
    (window as any).collectedImages = null; // 수집된 이미지

    // ✅ [Fix] 생성된 콘텐츠 미리보기 체크박스 초기화
    const previewCheckbox = document.getElementById('full-auto-enable-preview') as HTMLInputElement;
    if (previewCheckbox) previewCheckbox.checked = true; // 기본값: 체크됨

    // ✅ [Fix] 글 생성 후 풀오토 사용불가 상태 초기화
    (window as any).hasGeneratedContent = false;
    if (typeof (window as any).updatePublishButtonVisibility === 'function') {
      (window as any).updatePublishButtonVisibility();
    }

    appendLog('🔄 모든 필드가 초기화되었습니다. 새로운 글을 작성할 수 있습니다.');
    console.log('[Reset] 모든 필드 초기화 완료');
  } catch (error) {
    console.error('[Reset] 필드 초기화 실패:', error);
  }
}

// ✅ [New] 편집 필드와 통합 미리보기 실시간 동기화 함수
function syncIntegratedPreviewFromInputs(): void {
  const titleInput = document.getElementById('unified-generated-title') as HTMLInputElement;
  const contentArea = document.getElementById('unified-generated-content') as HTMLTextAreaElement;
  const hashtagsInput = document.getElementById('unified-generated-hashtags') as HTMLInputElement;

  const previewTitle = document.getElementById('unified-preview-title');
  const previewBody = document.getElementById('unified-preview-body');
  const previewHashtags = document.getElementById('unified-preview-hashtags');

  // 1. 미리보기 업데이트
  if (previewTitle && titleInput) {
    previewTitle.textContent = titleInput.value || '제목이 여기에 표시됩니다';
  }

  if (previewBody && contentArea) {
    const text = contentArea.value || '';
    if (!text) {
      previewBody.innerHTML = '<p style="color: var(--text-muted);">본문이 여기에 표시됩니다</p>';
    } else {
      // 🌈 [New] 하이라이트 색상 (Yellow, Blue, Red 계열 파스텔톤)
      const highlightColors = [
        '#fff9c4', // Yellow
        '#bbdefb', // Blue
        '#ffcdd2', // Red
        '#f0f4c3', // Lime
        '#d1c4e9'  // Purple
      ];

      // 본문을 <p> 태그와 <br>로 변환하여 미리보기 구성
      const paragraphs = text.split(/\n{2,}/);
      previewBody.innerHTML = paragraphs.map(p => {
        // 1. HTML Escape (보안)
        const lines = p.split('\n').map(line => {
          let safeLine = escapeHtml(line);

          // 2. **Bold** -> Highlight 변환
          safeLine = safeLine.replace(/\*\*([^*]+)\*\*/g, (match, content) => {
            const randomColor = highlightColors[Math.floor(Math.random() * highlightColors.length)];
            return `<span style="background-color: ${randomColor}; padding: 2px 4px; border-radius: 4px; font-weight: 600; box-decoration-break: clone; -webkit-box-decoration-break: clone;">${content}</span>`;
          });

          return safeLine;
        }).join('<br>');

        return `<p style="margin-bottom: 1.25rem; line-height: 1.8;">${lines}</p>`;
      }).join('');
    }
  }

  if (previewHashtags && hashtagsInput) {
    previewHashtags.textContent = hashtagsInput.value || '';
  }

  // 2. 전역 상태값(currentStructuredContent) 동기화 - 발행 시 사용됨
  if ((window as any).currentStructuredContent) {
    const sc = (window as any).currentStructuredContent;
    sc.selectedTitle = titleInput?.value || '';
    sc.bodyPlain = contentArea?.value || '';
    sc.hashtags = hashtagsInput?.value.split(/\s+/).filter(h => h.startsWith('#')) || [];
  }
}

// ✅ 임시 저장 기능 - 안정성 향상
const AUTOSAVE_KEY = 'naver_blog_autosave';
const AUTOSAVE_INTERVAL = 30000; // 30초마다 자동 저장
let autosaveTimer: NodeJS.Timeout | null = null;

// ✅ 자동 백업 기능
const BACKUP_KEY_PREFIX = 'naver_blog_backup_';
const BACKUP_INTERVAL = 300000; // 5분마다 백업
const MAX_BACKUPS = 10; // 최대 10개 백업 유지
let backupTimer: NodeJS.Timeout | null = null;

interface AutosaveData {
  timestamp: number;
  mode: 'full-auto' | 'semi-auto';
  structuredContent?: any;
  formData?: any;
  generatedImages?: any[];
}

// 임시 저장 (✅ [2026-01-23 FIX] 용량 초과 처리 추가)
function autosaveContent(data: AutosaveData): void {
  try {
    const saveData = {
      ...data,
      timestamp: Date.now()
    };

    // ✅ 저장 전 데이터 크기 검사 (5MB 제한)
    let jsonString = JSON.stringify(saveData);
    const MAX_SIZE = 4 * 1024 * 1024; // 4MB (여유 두고 설정)

    // 용량 초과 시 이미지 데이터 제외
    if (jsonString.length > MAX_SIZE) {
      console.warn('[Autosave] 데이터 용량 초과, 이미지 제외하고 저장...');

      // 이미지 데이터 제외한 버전 생성
      const slimData = {
        ...saveData,
        generatedImages: (saveData.generatedImages || []).map((img: any) => ({
          heading: img.heading,
          filePath: img.filePath || img.savedToLocal, // 파일 경로만 유지
          provider: img.provider,
          // previewDataUrl과 base64 데이터는 제외
        }))
      };
      jsonString = JSON.stringify(slimData);

      // 그래도 크면 이미지 완전 제거
      if (jsonString.length > MAX_SIZE) {
        const minimalData = {
          ...saveData,
          generatedImages: []
        };
        jsonString = JSON.stringify(minimalData);
        console.warn('[Autosave] 이미지 완전 제거하여 저장');
      }
    }

    localStorage.setItem(AUTOSAVE_KEY, jsonString);
    console.log('[Autosave] 콘텐츠 임시 저장 완료:', new Date().toLocaleTimeString(), `(${Math.round(jsonString.length / 1024)}KB)`);
  } catch (error: any) {
    // ✅ 용량 초과 에러 특별 처리
    if (error?.name === 'QuotaExceededError' || error?.message?.includes('quota')) {
      console.warn('[Autosave] localStorage 용량 초과, 이미지 없이 재시도...');
      try {
        const minimalData = {
          ...data,
          timestamp: Date.now(),
          generatedImages: [] // 이미지 완전 제거
        };
        localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(minimalData));
        console.log('[Autosave] 이미지 제외하고 저장 성공');
      } catch (retryError) {
        console.error('[Autosave] 최소 데이터도 저장 실패:', retryError);
      }
    } else {
      console.error('[Autosave] 임시 저장 실패:', error);
    }
  }
}

// 임시 저장 데이터 불러오기
function loadAutosavedContent(): AutosaveData | null {
  try {
    const saved = localStorage.getItem(AUTOSAVE_KEY);
    if (!saved) return null;

    const data = JSON.parse(saved) as AutosaveData;
    // 24시간 이내 데이터만 복구
    if (Date.now() - data.timestamp < 24 * 60 * 60 * 1000) {
      return data;
    }
    // 오래된 데이터는 삭제
    localStorage.removeItem(AUTOSAVE_KEY);
    return null;
  } catch (error) {
    console.error('[Autosave] 임시 저장 데이터 로드 실패:', error);
    return null;
  }
}

// 임시 저장 데이터 삭제
function clearAutosavedContent(): void {
  localStorage.removeItem(AUTOSAVE_KEY);
  console.log('[Autosave] 임시 저장 데이터 삭제');
}

// ✅ 백업 생성 (✅ [2026-01-23 FIX] 용량 초과 처리 추가)
function createBackup(): void {
  try {
    const structuredContent = (window as any).currentStructuredContent;
    const generatedImages = (window as any).imageManagementGeneratedImages;

    if (!structuredContent) return;

    const mode = document.querySelector('.unified-mode-btn.selected')?.getAttribute('data-mode') as 'full-auto' | 'semi-auto' || 'full-auto';

    // ✅ 이미지는 파일 경로만 저장 (base64 제외)
    const slimImages = (generatedImages || []).map((img: any) => ({
      heading: img.heading,
      filePath: img.filePath || img.savedToLocal,
      provider: img.provider,
    }));

    const backupData: AutosaveData = {
      timestamp: Date.now(),
      mode,
      structuredContent,
      generatedImages: slimImages
    };

    const backupKey = `${BACKUP_KEY_PREFIX}${Date.now()}`;

    // ✅ 용량 검사 후 저장
    let jsonString = JSON.stringify(backupData);
    const MAX_SIZE = 2 * 1024 * 1024; // 2MB (백업당)

    if (jsonString.length > MAX_SIZE) {
      console.warn('[Backup] 백업 데이터 용량 초과, 이미지 제거');
      const minimalData = { ...backupData, generatedImages: [] };
      jsonString = JSON.stringify(minimalData);
    }

    localStorage.setItem(backupKey, jsonString);

    // 오래된 백업 삭제
    cleanupOldBackups();

    console.log('[Backup] 백업 생성 완료:', new Date().toLocaleTimeString(), `(${Math.round(jsonString.length / 1024)}KB)`);
    appendLog(`💾 백업 생성 완료 (${new Date().toLocaleTimeString()})`);
  } catch (error: any) {
    // ✅ 용량 초과 시 이미지 없이 재시도
    if (error?.name === 'QuotaExceededError' || error?.message?.includes('quota')) {
      console.warn('[Backup] localStorage 용량 초과, 백업 건너뜀');
      cleanupOldBackups(); // 오래된 백업 정리
    } else {
      console.error('[Backup] 백업 생성 실패:', error);
    }
  }
}

// 오래된 백업 삭제
function cleanupOldBackups(): void {
  try {
    const backupKeys: string[] = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith(BACKUP_KEY_PREFIX)) {
        backupKeys.push(key);
      }
    }

    // 타임스탬프 기준 정렬 (최신순)
    backupKeys.sort((a, b) => {
      const timeA = parseInt(a.replace(BACKUP_KEY_PREFIX, ''));
      const timeB = parseInt(b.replace(BACKUP_KEY_PREFIX, ''));
      return timeB - timeA;
    });

    // 최대 개수 초과 시 오래된 것 삭제
    if (backupKeys.length > MAX_BACKUPS) {
      for (let i = MAX_BACKUPS; i < backupKeys.length; i++) {
        localStorage.removeItem(backupKeys[i]);
        console.log('[Backup] 오래된 백업 삭제:', backupKeys[i]);
      }
    }
  } catch (error) {
    console.error('[Backup] 백업 정리 실패:', error);
  }
}

// 백업 목록 조회
function listBackups(): AutosaveData[] {
  const backups: AutosaveData[] = [];
  try {
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && key.startsWith(BACKUP_KEY_PREFIX)) {
        const data = localStorage.getItem(key);
        if (data) {
          backups.push(JSON.parse(data));
        }
      }
    }

    // 타임스탬프 기준 정렬 (최신순)
    backups.sort((a, b) => b.timestamp - a.timestamp);
  } catch (error) {
    console.error('[Backup] 백업 목록 조회 실패:', error);
  }
  return backups;
}

// 백업에서 복구
function restoreFromBackup(timestamp: number): void {
  try {
    const backupKey = `${BACKUP_KEY_PREFIX}${timestamp}`;
    const data = localStorage.getItem(backupKey);

    if (!data) {
      alert('백업을 찾을 수 없습니다.');
      return;
    }

    const backup: AutosaveData = JSON.parse(data);

    // 모드 전환
    const modeBtn = document.querySelector(`.unified-mode-btn[data-mode="${backup.mode}"]`) as HTMLButtonElement;
    if (modeBtn) {
      modeBtn.click();
    }

    // 콘텐츠 복구
    if (backup.structuredContent) {
      (window as any).currentStructuredContent = backup.structuredContent;
      fillSemiAutoFields(backup.structuredContent);
      updateUnifiedPreview(backup.structuredContent);
    }

    // 이미지 복구 (✅ prompt 필드 보장)
    if (backup.generatedImages && backup.generatedImages.length > 0) {
      const imagesWithPrompt = backup.generatedImages.map((img: any, index: number) => ({
        ...img,
        prompt: img.prompt || img.heading || `이미지 ${index + 1}`,
        url: img.url || img.filePath || img.previewDataUrl,
      }));
      (window as any).imageManagementGeneratedImages = imagesWithPrompt;
      generatedImages = imagesWithPrompt;
      displayGeneratedImages(imagesWithPrompt);
    }

    const backupDate = new Date(backup.timestamp);
    alert(`✅ 백업이 복구되었습니다!\n\n백업 시간: ${backupDate.toLocaleString()}`);
    appendLog(`✅ 백업 복구 완료 (${backupDate.toLocaleString()})`);
  } catch (error) {
    console.error('[Backup] 백업 복구 실패:', error);
    alert('백업 복구에 실패했습니다.');
  }
}

// 자동 백업 시작
function startAutoBackup(): void {
  if (backupTimer) {
    clearInterval(backupTimer);
  }

  backupTimer = setInterval(() => {
    createBackup();
  }, BACKUP_INTERVAL);

  console.log('[Backup] 자동 백업 시작 (5분 간격)');
  appendLog('💾 자동 백업 시작 (5분 간격)');
}

// 자동 백업 중지
function stopAutoBackup(): void {
  if (backupTimer) {
    clearInterval(backupTimer);
    backupTimer = null;
    console.log('[Backup] 자동 백업 중지');
  }
}

// 자동 저장 시작
function startAutosave(): void {
  if (autosaveTimer) {
    clearInterval(autosaveTimer);
  }

  autosaveTimer = setInterval(() => {
    const structuredContent = (window as any).currentStructuredContent;
    const generatedImages = (window as any).imageManagementGeneratedImages;

    if (structuredContent) {
      const mode = document.querySelector('.unified-mode-btn.selected')?.getAttribute('data-mode') as 'full-auto' | 'semi-auto' || 'full-auto';
      autosaveContent({
        timestamp: Date.now(),
        mode,
        structuredContent,
        generatedImages: generatedImages || []
      });
    }
  }, AUTOSAVE_INTERVAL);

  console.log('[Autosave] 자동 저장 시작 (30초 간격)');
}

// 자동 저장 중지
function stopAutosave(): void {
  if (autosaveTimer) {
    clearInterval(autosaveTimer);
    autosaveTimer = null;
    console.log('[Autosave] 자동 저장 중지');
  }
}

// 임시 저장 데이터 복구
function restoreAutosavedContent(): void {
  const saved = loadAutosavedContent();
  if (!saved) return;

  const timeSince = Math.floor((Date.now() - saved.timestamp) / 1000 / 60); // 분 단위
  const message = `${timeSince}분 전에 저장된 작업이 있습니다.\n\n복구하시겠습니까?`;

  if (confirm(message)) {
    appendLog(`🔄 임시 저장 데이터 복구 중... (${timeSince}분 전)`);

    // 모드 전환
    const modeBtn = document.querySelector(`.unified-mode-btn[data-mode="${saved.mode}"]`) as HTMLButtonElement;
    if (modeBtn) {
      modeBtn.click();
    }

    // 콘텐츠 복구
    if (saved.structuredContent) {
      (window as any).currentStructuredContent = saved.structuredContent;

      // ✅ [Fix] 반자동 편집 섹션 강제 표시 및 데이터 채우기 (백업 복원 시)
      setTimeout(() => {
        fillSemiAutoFields(saved.structuredContent);
        // 섹션 강제 표시
        const semiAutoSection = document.getElementById('unified-semi-auto-section');
        if (semiAutoSection) {
          semiAutoSection.style.display = 'block';
          semiAutoSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }, 300);

      updateUnifiedPreview(saved.structuredContent);
      appendLog('✅ 콘텐츠 및 반자동 편집창 복구 완료');
    }

    // 이미지 복구 (✅ prompt 필드 보장)
    if (saved.generatedImages && saved.generatedImages.length > 0) {
      const imagesWithPrompt = saved.generatedImages.map((img: any, index: number) => ({
        ...img,
        prompt: img.prompt || img.heading || `이미지 ${index + 1}`,
        url: img.url || img.filePath || img.previewDataUrl,
      }));
      (window as any).imageManagementGeneratedImages = imagesWithPrompt;
      generatedImages = imagesWithPrompt;
      displayGeneratedImages(imagesWithPrompt);
      appendLog(`✅ 이미지 ${imagesWithPrompt.length}개 복구 완료`);

      try {
        hydrateImageManagerFromImages(saved.structuredContent, imagesWithPrompt);
      } catch {
        // ignore
      }
    }

    // ✅ 복구 완료 후 자동 소제목 분석
    if (saved.structuredContent?.headings?.length > 0) {
      setTimeout(async () => {
        try {
          appendLog('🔍 자동 소제목 분석 시작...');
          await autoAnalyzeHeadings(saved.structuredContent);
          appendLog('✅ 소제목 분석 완료!');
        } catch (error) {
          appendLog(`⚠️ 소제목 자동 분석 실패: ${(error as Error).message}`);
        }
      }, 500);
    }

    // ✅ CTA 자동 생성
    if (saved.structuredContent) {
      autoGenerateCTA(saved.structuredContent);
    }

    alert('✅ 작업이 복구되었습니다!');
  } else {
    clearAutosavedContent();
  }
}

// 통합 진행률 표시 함수
// 이미지 관리 탭 진행률 표시 함수
function showImagesProgress(percent: number, text: string, details?: string): void {
  console.log(`[ImagesProgress] ${percent}%: ${text}`);

  // 시작 시간 기록
  if (percent === 0 || !progressStartTime) {
    progressStartTime = Date.now();
  }

  // images-progress-container 업데이트
  const imagesContainer = document.getElementById('images-progress-container');
  if (imagesContainer) {
    imagesContainer.style.display = 'block';

    const progressBar = document.getElementById('images-progress-bar');
    const progressPercent = document.getElementById('images-progress-percent');
    const progressText = document.getElementById('images-progress-text');
    const progressDetail = document.getElementById('images-progress-detail');

    if (progressBar) {
      progressBar.style.width = `${percent}%`;
    }

    if (progressPercent) {
      const estimatedTime = calculateEstimatedTime(percent);
      progressPercent.textContent = estimatedTime ? `${percent}% (${estimatedTime})` : `${percent}%`;
    }

    if (progressText) {
      progressText.textContent = text;
    }

    if (progressDetail && details) {
      progressDetail.textContent = details;
    }
  }

  // 완료 시 시작 시간 초기화
  if (percent >= 100) {
    progressStartTime = null;
  }
}

function showUnifiedProgress(percent: number, text: string, details?: string): void {
  console.log(`[Progress] ${percent}%: ${text}`);

  // 시작 시간 기록
  if (percent === 0 || !progressStartTime) {
    progressStartTime = Date.now();
  }

  // unified-progress-container 업데이트
  const unifiedContainer = document.getElementById('unified-progress-container');
  if (unifiedContainer) {
    unifiedContainer.style.display = 'block';

    const progressBar = document.getElementById('unified-progress-bar');
    const progressPercent = document.getElementById('unified-progress-percent');
    const progressText = document.getElementById('unified-progress-text');
    const progressDetail = document.getElementById('unified-progress-detail');

    if (progressBar) {
      progressBar.style.width = `${percent}%`;
    }

    // ✅ 이미지 관리 탭 진행률도 동기화
    showImagesProgress(percent, text, details);
    if (progressPercent) {
      const estimatedTime = calculateEstimatedTime(percent);
      progressPercent.textContent = estimatedTime ? `${percent}% (${estimatedTime})` : `${percent}%`;
    }
    if (progressText) {
      progressText.textContent = text;
    }
    if (progressDetail && details) {
      progressDetail.textContent = details;
    }
  }

  // publish-progress-container도 업데이트 (호환성)
  const publishContainer = document.getElementById('publish-progress-container');
  if (publishContainer) {
    const progressBar = publishContainer.querySelector('#progress-bar') as HTMLElement;
    const progressPercent = publishContainer.querySelector('#progress-percent') as HTMLElement;
    const progressText = publishContainer.querySelector('#progress-text') as HTMLElement;
    const progressDetails = publishContainer.querySelector('#progress-details') as HTMLElement;

    if (progressBar) progressBar.style.width = `${percent}%`;
    if (progressPercent) progressPercent.textContent = `${percent}%`;
    if (progressText) progressText.textContent = text;
    if (progressDetails && details) progressDetails.textContent = details;
  }

  // 완료 시 시작 시간 초기화
  if (percent >= 100) {
    progressStartTime = null;
  }
}

function hideUnifiedProgress(): void {
  const unifiedContainer = document.getElementById('unified-progress-container');
  if (unifiedContainer) {
    unifiedContainer.style.display = 'none';
  }
}

// ✅ 로그 및 진행상황 초기화 함수
function resetLogAndProgress(logOutputId?: string, progressContainerId?: string): void {
  // 로그 초기화
  const logOutputs: HTMLElement[] = [];

  if (logOutputId) {
    const specificOutput = document.getElementById(logOutputId);
    if (specificOutput) logOutputs.push(specificOutput);
  } else {
    // 모든 로그 출력 요소 초기화
    const unifiedLog = document.getElementById('unified-log-output');
    const imagesLog = document.getElementById('images-log-output');
    const defaultLog = document.getElementById('log-output');

    if (unifiedLog) logOutputs.push(unifiedLog);
    if (imagesLog) logOutputs.push(imagesLog);
    if (defaultLog) logOutputs.push(defaultLog);
  }

  logOutputs.forEach(logOutput => {
    if (logOutput) {
      logOutput.innerHTML = '';
      logOutput.textContent = '';
    }
  });

  // 진행상황 초기화
  const progressContainers: HTMLElement[] = [];

  if (progressContainerId) {
    const specificContainer = document.getElementById(progressContainerId);
    if (specificContainer) progressContainers.push(specificContainer);
  } else {
    // 모든 진행률 컨테이너 초기화
    const unifiedProgress = document.getElementById('unified-progress-container');
    const imagesProgress = document.getElementById('images-progress-container');
    const publishProgress = document.getElementById('publish-progress-container');

    if (unifiedProgress) progressContainers.push(unifiedProgress);
    if (imagesProgress) progressContainers.push(imagesProgress);
    if (publishProgress) progressContainers.push(publishProgress);
  }

  progressContainers.forEach(container => {
    if (container) {
      // 진행률 바 초기화
      const progressBar = container.querySelector('[id$="-progress-bar"], #progress-bar') as HTMLElement;
      if (progressBar) progressBar.style.width = '0%';

      // 진행률 퍼센트 초기화
      const progressPercent = container.querySelector('[id$="-progress-percent"], #progress-percent') as HTMLElement;
      if (progressPercent) progressPercent.textContent = '0%';

      // 진행률 텍스트 초기화
      const progressText = container.querySelector('[id$="-progress-text"], #progress-text') as HTMLElement;
      if (progressText) progressText.textContent = '준비 중...';

      // 진행률 상세 초기화
      const progressDetail = container.querySelector('[id$="-progress-detail"], #progress-details') as HTMLElement;
      if (progressDetail) progressDetail.textContent = '';

      // 컨테이너 숨기기
      container.style.display = 'none';
    }
  });

  // 진행 시작 시간 초기화
  progressStartTime = null;

  // 로그 관련 변수 초기화
  if (typeof (appendLog as any).lastMessage !== 'undefined') {
    (appendLog as any).lastMessage = null;
    (appendLog as any).lastTime = null;
  }

  console.log('[Reset] 로그 및 진행상황이 초기화되었습니다.');
  appendLog('🔄 로그 및 진행상황이 초기화되었습니다.', logOutputId);
}

// 통합 탭 URL 필드 관리
function initUnifiedUrlFields(): void {
  const addBtn = document.getElementById('unified-add-url-field-btn') as HTMLButtonElement;
  const container = document.getElementById('unified-url-fields-container') as HTMLDivElement;
  if (addBtn && container) {
    addBtn.addEventListener('click', () => {
      const urlItems = container.querySelectorAll('.url-field-item');
      const newIndex = urlItems.length;

      const newItem = document.createElement('div');
      newItem.className = 'url-field-item';
      newItem.style.cssText = 'display: flex; gap: 0.5rem; align-items: center; margin-bottom: 0.5rem;';
      newItem.innerHTML = `
        <input type="url" class="url-field-input unified-url-input" placeholder="https://example.com/article${newIndex + 1}" style="flex: 1;" data-url-index="${newIndex}">
        <button type="button" class="url-field-remove" style="padding: 0.25rem 0.5rem; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer;" title="삭제">×</button>
      `;

      container.appendChild(newItem);
      updateUnifiedUrlFieldRemoveButtons();

      // 새로 추가된 입력 필드에 포커스
      const newInput = newItem.querySelector('.unified-url-input') as HTMLInputElement;
      if (newInput) {
        setTimeout(() => newInput.focus(), 100);
      }
    });
  } else {
    console.warn('[Unified] URL 필드 초기화 건너뜀: addBtn 또는 container가 없습니다.');
  }

  // 이벤트 위임으로 삭제 버튼 처리
  if (container) {
    container.addEventListener('click', (e) => {
      const target = e.target as HTMLElement;
      if (target.classList.contains('url-field-remove')) {
        const urlItems = container.querySelectorAll('.url-field-item');
        if (urlItems.length > 1) {
          target.closest('.url-field-item')?.remove();
          updateUnifiedUrlFieldRemoveButtons();
        }
      }
    });
  }
}

function updateUnifiedUrlFieldRemoveButtons(): void {
  const container = document.getElementById('unified-url-fields-container') as HTMLDivElement;
  const urlItems = container?.querySelectorAll('.url-field-item');

  if (urlItems) {
    urlItems.forEach((item, index) => {
      const removeBtn = item.querySelector('.url-field-remove') as HTMLButtonElement;
      if (removeBtn) {
        // 첫 번째 항목은 삭제 불가, 나머지는 삭제 가능
        removeBtn.style.display = index === 0 ? 'none' : 'inline-block';
      }
    });
  }
}

function getUnifiedUrls(): string[] {
  const container = document.getElementById('unified-url-fields-container') as HTMLDivElement;
  if (!container) return [];

  const urlInputs = container.querySelectorAll('.unified-url-input') as NodeListOf<HTMLInputElement>;
  return Array.from(urlInputs)
    .map(input => input.value.trim())
    .filter(url => url.length > 0 && /^https?:\/\//i.test(url));
}

// ✅ CTA 자동 생성 함수 (내 블로그 이전 글만 연결 - 외부 사이트 연결 금지!)
function generateAutoCTA(title: string, keywords?: string): { ctaText: string; ctaLink: string } {
  // ✅ 중요: 외부 사이트(쿠팡, 네이버 건강, 정부24 등)로 연결하지 않음!
  // 오직 사용자의 이전 블로그 글만 CTA로 연결

  const isJabBlog = (() => {
    const publishingSettings = (window as any).currentPublishingAccountSettings;
    if (publishingSettings && typeof publishingSettings === 'object') {
      return publishingSettings.isJabBlog === true;
    }
    const mainSettings = (window as any).currentMainAccountSettings;
    if (mainSettings && typeof mainSettings === 'object') {
      return mainSettings.isJabBlog === true;
    }
    return false;
  })();

  const getCurrentCategoryKey = (): string | null => {
    const fromUi = String((document.getElementById('unified-article-type') as HTMLSelectElement | null)?.value || '').trim();
    if (fromUi) return fromUi;
    if (currentPostId) {
      const p = loadGeneratedPost(currentPostId);
      const fromPost = String((p as any)?.category || '').trim();
      if (fromPost) return fromPost;
    }
    return null;
  };

  const pickLatestPublished = (candidates: any[]): any | null => {
    if (!candidates || candidates.length === 0) return null;
    const sorted = [...candidates].sort((a, b) => {
      const at = new Date(a.publishedAt || a.updatedAt || a.createdAt || 0).getTime();
      const bt = new Date(b.publishedAt || b.updatedAt || b.createdAt || 0).getTime();
      return bt - at;
    });
    return sorted[0] || null;
  };

  // 저장된 이전 글 목록에서 발행된 글 찾기
  try {
    const posts = loadGeneratedPosts();
    // publishedUrl이 있는 글만 필터링 (발행된 글)
    const publishedPosts = posts
      .filter(p => p.publishedUrl && p.publishedUrl.length > 0)
      .filter(p => !currentPostId || p.id !== currentPostId);

    if (publishedPosts.length > 0) {
      let candidates = publishedPosts;
      if (!isJabBlog) {
        const categoryKey = getCurrentCategoryKey();
        if (categoryKey) {
          const byCategory = publishedPosts.filter(p => String((p as any)?.category || '').trim() === categoryKey);
          if (byCategory.length > 0) {
            candidates = byCategory;
          }
        }
      }

      const latestPost = pickLatestPublished(candidates) || pickLatestPublished(publishedPosts);
      if (!latestPost) {
        return {
          ctaText: '📖 관련 글 더 보기',
          ctaLink: ''
        };
      }
      return {
        ctaText: `📖 ${latestPost.title}`,
        ctaLink: latestPost.publishedUrl || ''
      };
    }
  } catch (e) {
    console.warn('[CTA] 이전 글 목록 로드 실패:', e);
  }

  // ✅ 이전 글이 없으면 CTA 링크를 비워둠 (외부 사이트로 연결하지 않음!)
  return {
    ctaText: '📖 관련 글 더 보기',
    ctaLink: '' // 빈 링크 - CTA 텍스트만 표시되고 링크는 없음
  };
}

// 풀오토 발행 처리
async function handleFullAutoPublish(): Promise<void> {
  // ✅ 완전 자동 모드 설정
  (window as any).currentAutomationMode = 'full-auto';

  // ✅ 현재 계정 모드 확인 (1개 계정 / 다중계정)
  const accountMode = (window as any).getAccountMode?.() || 'single';

  if (accountMode === 'multi') {
    // 다중계정 모드: 순차 발행
    await handleMultiAccountPublish();
    return;
  }

  // 1개 계정 모드: 기존 로직
  const urls = getUnifiedUrls();
  const title = (document.getElementById('unified-title') as HTMLInputElement)?.value?.trim();
  const keywords = (document.getElementById('unified-keywords') as HTMLInputElement)?.value?.trim();

  // 입력 검증
  if (urls.length === 0 && !title && !keywords) {
    alert('풀오토 발행을 위해서는 URL, 제목, 키워드 중 최소 하나 이상을 입력해주세요.');
    return;
  }

  // ✅ 진행상황 모달 표시
  const modal = getProgressModal();
  modal.show('🚀 풀오토 발행 진행 중', 'AI가 콘텐츠를 생성하고 있습니다...');
  modal.setStep(1, 'active', 'AI 콘텐츠 생성 중...');
  modal.setProgress(5, '콘텐츠 생성 준비 중...');
  modal.addLog('🚀 풀오토 발행 시작');

  appendLog('🚀 풀오토 발행 시작: 콘텐츠 생성 → 이미지 생성 → 자동 발행');

  try {
    if (isFullAutoStopRequested(modal)) {
      appendLog('⏹️ 사용자가 풀오토 발행을 중지했습니다.');
      return;
    }

    // 콘텐츠 생성
    modal.setProgress(10, '콘텐츠 생성 중...');
    const toneStyle = UnifiedDOMCache.getToneStyle();
    if (urls.length > 0) {
      appendLog(`🔄 ${urls.length}개 URL 기반 콘텐츠 생성 (첫 번째 URL 사용)`);
      modal.addLog(`📎 URL: ${urls[0].substring(0, 50)}...`);
      await generateContentFromUrl(urls[0], undefined, toneStyle, true);
    } else {
      appendLog('✏️ 키워드/제목 기반 콘텐츠 생성');
      modal.addLog(`📝 키워드: ${keywords || title}`);
      await generateContentFromKeywords(title, keywords, toneStyle, true); // suppressModal: true
    }

    // 취소 확인
    if (isFullAutoStopRequested(modal)) {
      appendLog('❌ 사용자가 발행을 취소했습니다.');
      return;
    }

    // 생성된 콘텐츠 가져오기
    const structuredContent = (window as any).currentStructuredContent;
    if (!structuredContent) {
      throw new Error('콘텐츠 생성에 실패했습니다.');
    }

    // 풀오토 발행에서도 콘텐츠 미리보기 표시 (대기 시간 제거 - 속도 향상)
    updateUnifiedPreview(structuredContent);

    // ✅ 소제목 개수 확인 로깅
    const headingCount = structuredContent.headings?.length || 0;
    appendLog(`✅ 콘텐츠 생성 완료! ${headingCount}개 소제목으로 이미지 생성 진행...`);

    // ✅ [신규] 글 목록에 자동 저장 (어떤 모드로 발행해도 저장되도록)
    try {
      const savedPostId = saveGeneratedPost(structuredContent, false, { category: UnifiedDOMCache.getRealCategory() });
      if (savedPostId) {
        modal.addLog(`💾 글이 자동 저장되었습니다 (ID: ${savedPostId})`);
        appendLog(`💾 글이 자동 저장되었습니다`);
      }
    } catch (saveErr) {
      console.error('글 저장 실패:', saveErr);
    }

    // ✅ 진행상황 모달 업데이트 - 콘텐츠 생성 완료
    modal.setStep(1, 'completed', '완료');
    modal.setProgress(30, '이미지 생성 준비 중...');
    modal.addLog(`✅ 콘텐츠 생성 완료 (${headingCount}개 소제목)`);

    // 취소 확인
    if (modal.cancelled) {
      appendLog('❌ 사용자가 발행을 취소했습니다.');
      return;
    }

    // 발행 데이터 구성
    const imageSource = UnifiedDOMCache.getImageSource();
    const skipImages = (document.getElementById('unified-skip-images') as HTMLInputElement)?.checked || false;

    const ctasUi = readUnifiedCtasFromUi();
    const skipCtaCheckbox = document.getElementById('unified-skip-cta') as HTMLInputElement;
    const skipCta = skipCtaCheckbox?.checked || false; // ✅ CTA 없이 발행 체크박스
    // ✅ UI에서 발행 방식 읽기 (즉시/임시/예약) - 기존 하드코딩 버그 수정
    const publishModeInput = document.getElementById('unified-publish-mode') as HTMLSelectElement;
    const publishMode = publishModeInput?.value || 'publish';
    console.log(`[FullAutoPublish] 발행 방식: ${publishMode === 'draft' ? '임시저장' : publishMode === 'schedule' ? '예약발행' : '즉시발행'}`);

    const scheduleDate = publishMode === 'schedule' ? (document.getElementById('unified-schedule-date') as HTMLInputElement)?.value : undefined;
    const scheduleType = publishMode === 'schedule' ? ((document.getElementById('unified-schedule-type') as HTMLSelectElement)?.value as 'app-schedule' | 'naver-server' || 'app-schedule') : undefined;

    // ✅ CTA 자동 생성 (skipCta가 false인 경우만)
    let finalCtaText = '';
    let finalCtaLink = '';

    if (!skipCta) {
      const generatedTitle = structuredContent.selectedTitle || title || '';
      const autoCTA = generateAutoCTA(generatedTitle, keywords);

      // 수동 입력된 CTA가 있으면 우선 사용
      const manualCtaText = ctasUi[0]?.text || (document.getElementById('unified-cta-text') as HTMLInputElement)?.value?.trim();
      const manualCtaLink = ctasUi[0]?.link || (document.getElementById('unified-cta-link') as HTMLInputElement)?.value?.trim();

      finalCtaText = manualCtaText || autoCTA.ctaText;
      finalCtaLink = manualCtaLink || autoCTA.ctaLink;

      if (finalCtaLink) {
        appendLog(`✅ CTA 자동 포함: "${finalCtaText}" → ${finalCtaLink.substring(0, 50)}...`);
      } else {
        appendLog(`⚠️ 연결할 이전 글이 없습니다. CTA 링크 없이 발행됩니다.`);
      }
    } else {
      appendLog(`🚫 CTA 없이 발행 옵션이 선택되었습니다.`);
    }

    // ✅ CTA 위치 고정
    const ctaPosition = ((document.getElementById('unified-cta-position') as HTMLSelectElement | null)?.value as 'top' | 'middle' | 'bottom') || 'bottom';

    // ✅ [핵심 수정] 올바른 체크박스 ID에서 읽기 (이전: hidden input을 .checked로 읽어서 항상 false)
    const includeThumbnailText = (document.getElementById('full-auto-thumbnail-text') as HTMLInputElement)?.checked ?? false;

    const formData = {
      mode: 'full-auto',
      generator: (document.getElementById('unified-generator') as HTMLSelectElement)?.value || 'gemini',
      targetAge: 'all',
      toneStyle: (document.getElementById('unified-tone-style') as HTMLInputElement)?.value || 'friendly',
      imageSource,
      skipImages,
      publishMode,
      scheduleDate,
      scheduleType,
      structuredContent,
      urls: urls, // URL 배열 추가
      title: title,
      keywords: keywords,
      // ✅ CTA 설정
      ctaText: finalCtaText,
      ctaLink: finalCtaLink,
      ctas: skipCta ? [] : (ctasUi.length > 0 ? ctasUi : (finalCtaText ? [{ text: finalCtaText, link: finalCtaLink || undefined }] : [])),
      ctaPosition: ctaPosition, // ✅ CTA 위치 추가
      skipCta: skipCta, // ✅ 체크박스 값 반영
      categoryName: UnifiedDOMCache.getRealCategory(),
      useAiImage: (document.getElementById('unified-use-ai-image') as HTMLInputElement)?.checked ?? true,
      includeThumbnailText, // ✅ 옵션 추가
      createProductThumbnail: (document.getElementById('unified-create-product-thumbnail') as HTMLInputElement)?.checked ?? false,
      affiliateLink: (document.getElementById('shopping-connect-affiliate-link') as HTMLInputElement)?.value?.trim() || (document.getElementById('batch-link-input') as HTMLInputElement)?.value?.trim(),
      customBannerPath: (window as any).customBannerPath || undefined, // ✅ [2026-01-18] 커스텀 배너 경로 전달
      // ✅ 쇼핑커넥트 모드 자동 감지: affiliateLink가 있으면 affiliate 모드
      contentMode: ((document.getElementById('shopping-connect-affiliate-link') as HTMLInputElement)?.value?.trim() || (document.getElementById('batch-link-input') as HTMLInputElement)?.value?.trim()) ? 'affiliate' : 'seo',
    };

    // ✅ 진행상황 모달 업데이트 - 이미지 생성 시작
    modal.setStep(2, 'active', skipImages ? '건너뛰기' : '이미지 생성 중...');
    modal.setProgress(40, skipImages ? '이미지 생성 건너뛰기...' : '이미지 생성 중...');

    // ✅ [2026-01-21] 쇼핑커넥트 모드일 때 제휴 링크에서 제품 이미지 자동 수집
    if (formData.contentMode === 'affiliate' && formData.affiliateLink && !skipImages) {
      modal.addLog('🛒 쇼핑커넥트 모드: 제품 이미지 수집 시작...');
      appendLog(`🖼️ 제휴 링크에서 제품 이미지 수집 중: ${formData.affiliateLink.substring(0, 50)}...`);

      try {
        const collectResult = await (window as any).api.collectImagesFromShopping(formData.affiliateLink);

        if (collectResult?.success && collectResult.images && collectResult.images.length > 0) {
          modal.addLog(`✅ 제품 이미지 ${collectResult.images.length}개 수집 완료!`);
          appendLog(`✅ 제품 이미지 ${collectResult.images.length}개 수집 완료`);

          // 수집된 이미지를 전역 변수에 저장 (generateImagesForAutomation에서 사용)
          const collectedImages = collectResult.images.map((imgUrl: string, idx: number) => ({
            url: imgUrl,
            filePath: imgUrl,
            heading: `제품 이미지 ${idx + 1}`,
            provider: 'collected'
          }));

          // 기존 이미지와 병합
          const existing = (window as any).imageManagementGeneratedImages || [];
          (window as any).imageManagementGeneratedImages = [...collectedImages, ...existing];
          console.log('[FullAutoPublish] 제품 이미지 수집 완료:', collectedImages.length);

          // ✅ [2026-01-21 FIX] currentStructuredContent.images에도 저장 (generateImagesWithCostSafety에서 참조)
          if (structuredContent) {
            structuredContent.images = [...collectedImages, ...(structuredContent.images || [])];
            currentStructuredContent = structuredContent;
            (window as any).currentStructuredContent = structuredContent;
            console.log('[FullAutoPublish] structuredContent.images에 수집 이미지 동기화:', structuredContent.images.length);
          }

          // 제품 정보가 있으면 콘텐츠 보완에 활용
          if (collectResult.productInfo) {
            modal.addLog(`📦 제품명: ${collectResult.productInfo.name || '알 수 없음'}`);
          }
        } else {
          modal.addLog('⚠️ 제품 이미지 수집 실패 - AI 이미지로 대체합니다');
          appendLog('⚠️ 제품 이미지 수집 실패 - AI 이미지 생성으로 진행');
        }
      } catch (collectError) {
        console.error('[FullAutoPublish] 제품 이미지 수집 오류:', collectError);
        modal.addLog(`⚠️ 이미지 수집 오류: ${(collectError as Error).message?.substring(0, 50)}`);
        appendLog('⚠️ 제품 이미지 수집 중 오류 발생 - AI 이미지로 대체');
      }
    }

    // ✅ 이미지 생성 및 소분류 매칭
    if (!skipImages) {
      modal.addLog('🎨 이미지 처리 시작...');
      try {
        const collectedImgs = (window as any).imageManagementGeneratedImages || (window as any).generatedImages || [];
        let referenceImagePath = '';

        // 1. 수집된 이미지와 소제목 매칭 (지능형 매칭)
        if (collectedImgs.length > 0 && (structuredContent.headings || []).length > 0) {
          modal.addLog('🤖 수집 이미지를 소제목에 매칭 중...');
          try {
            const matchResult = await (window as any).api.matchImages({
              headings: structuredContent.headings || [],
              collectedImages: collectedImgs
            });
            if (matchResult.success && matchResult.assignments) {
              matchResult.assignments.forEach((assignment: any) => {
                const headIdx = assignment.headingIndex;
                const targetHeading = (structuredContent.headings || [])[headIdx];
                if (targetHeading) {
                  targetHeading.referenceImagePath = assignment.assignedImage.url;
                  modal.addLog(`   🔗 "${targetHeading.title.substring(0, 15)}..." 매칭 완료`);
                }
              });
            }
          } catch (e) {
            console.error('이미지 매칭 실패:', e);
          }

          // 전역 폴백용 첫 번째 이미지
          const first = collectedImgs[0];
          referenceImagePath = first.filePath || first.url;
        }

        let generatedImgs: any[] = [];

        if (formData.useAiImage) {
          // ✅ A. AI 이미지 생성 모드 (기존 로직)
          generatedImgs = await generateImagesForAutomation(
            imageSource,
            structuredContent.headings || [],
            structuredContent.selectedTitle || title,
            {
              stopCheck: () => isFullAutoStopRequested(modal),
              onProgress: (msg) => modal.addLog(msg),
              allowThumbnailText: formData.includeThumbnailText,
              referenceImagePath,
              collectedImages: collectedImgs  // ✅ [2026-01-21 FIX] 수집된 이미지 명시적 전달
            }
          );
        } else if (collectedImgs.length > 0) {
          // ✅ B. 수집 이미지 그대로 사용 모드 (통일된 로직)
          modal.addLog('📷 AI 생성 대신 수집된 이미지를 그대로 사용합니다.');

          // ✅ [수정] 별도 썸네일 없음! 첫 번째 소제목 이미지 = 썸네일
          // includeThumbnailText가 켜져 있으면 첫 번째 이미지에만 텍스트 합성
          (structuredContent.headings || []).forEach((h: any, idx: number) => {
            const path = h.referenceImagePath || (collectedImgs[idx % collectedImgs.length]?.filePath || collectedImgs[idx % collectedImgs.length]?.url);
            if (path) {
              // 첫 번째 이미지이고 텍스트 포함 옵션이 켜져 있으면 AI 생성으로 처리
              if (idx === 0 && formData.includeThumbnailText) {
                // 첫 번째 이미지만 텍스트 합성 필요 - generateImagesForAutomation 호출
                modal.addLog('🎨 첫 번째 이미지에 텍스트 합성 중...');
                (async () => {
                  const thumbResult = await generateImagesForAutomation(
                    imageSource,
                    [h], // 첫 번째 소제목만 전달
                    structuredContent.selectedTitle || title,
                    {
                      stopCheck: () => isFullAutoStopRequested(modal),
                      onProgress: (msg) => modal.addLog(msg),
                      allowThumbnailText: true,
                      referenceImagePath: path
                    }
                  );
                  if (thumbResult && thumbResult.length > 0) {
                    generatedImgs.unshift(thumbResult[0]); // 맨 앞에 추가
                  }
                })();
              } else {
                generatedImgs.push({
                  heading: h.title || h.heading || '',
                  filePath: path,
                  provider: 'manual',
                  savedToLocal: path,
                  isThumbnail: idx === 0 // 첫 번째 이미지는 썸네일로 마킹
                });
              }
            }
          });

          // 비동기 처리 대기
          await new Promise(resolve => setTimeout(resolve, 500));
        }

        if (isFullAutoStopRequested(modal)) {
          appendLog('⏹️ 사용자가 풀오토 발행을 중지했습니다.');
          return;
        }

        // 전역 변수 설정 (executeUnifiedAutomation에서 사용)
        (window as any).generatedImages = generatedImgs;

        // ImageManager 동기화
        if (typeof ImageManager !== 'undefined') {
          ImageManager.clear();
          if (generatedImgs && generatedImgs.length > 0) {
            generatedImgs.forEach((img: any) => {
              const h = img.heading || structuredContent.selectedTitle;
              if (h) ImageManager.addImage(h, img);
            });
            (window as any).imageManagementGeneratedImages = ImageManager.getAllImages();
          }
        }

        if (generatedImgs.length > 0) {
          modal.addLog(`✅ 이미지 처리 완료 (${generatedImgs.length}장)`);

          // ✅ [신규] 생성된 이미지를 structuredContent에 저장하고 글 목록 업데이트
          structuredContent.images = generatedImgs;
          saveGeneratedPost(structuredContent, true); // isUpdate=true로 업데이트
          modal.addLog(`💾 이미지 포함하여 글 목록에 저장 완료`);
        } else {
          modal.addLog('ℹ️ 사용할 수 있는 이미지가 없습니다.');
        }

      } catch (imgErr) {
        console.error('이미지 처리 실패:', imgErr);
        modal.addLog(`⚠️ 이미지 처리 오류: ${(imgErr as Error).message}`);
      }
    } else {
      modal.addLog('⏭️ 이미지 삽입 건너뛰기 (설정)');
    }

    // 자동화 실행 (이미지 생성 + 로그인 + 발행 포함)
    // executeUnifiedAutomation 내부에서 진행상황 업데이트를 위해 modal 전달
    (window as any).currentProgressModal = modal;
    await executeUnifiedAutomation(formData);

    if (isFullAutoStopRequested(modal)) {
      appendLog('⏹️ 사용자가 풀오토 발행을 중지했습니다.');
      modal.showError('⏹️ 발행 중지', '사용자가 발행을 중지했습니다.');
      return;
    }

    // ✅ 발행 성공
    modal.showSuccess('🎉 발행 완료!', '블로그 글이 성공적으로 발행되었습니다.');

  } catch (error) {
    appendLog(`❌ 풀오토 발행 실패: ${(error as Error).message}`);
    // ✅ 진행상황 모달 에러 표시
    modal.showError('❌ 발행 실패', (error as Error).message);
    throw error;
  }
}

// 다중계정 순차 발행 처리
async function handleMultiAccountPublish(): Promise<void> {
  const selectedAccountIds = (window as any).getInlineSelectedAccounts?.() || [];
  const intervalSeconds = (window as any).getInlineInterval?.() || 30;

  (window as any).stopFullAutoPublish = false;

  if (selectedAccountIds.length === 0) {
    alert('발행할 계정을 선택해주세요. (다중계정 탭에서 계정 선택)');
    return;
  }
  // ✅ 다중계정 발행 전 Stability AI/Prodia API 키 및 소스 체크
  const firstSelectedBtn = (document.querySelector('.image-source-btn.selected') || document.querySelector('.unified-img-source-btn.selected')) as HTMLButtonElement;
  const commonImageSource = firstSelectedBtn?.dataset.source || 'nano-banana-pro';

  if (commonImageSource === 'stability' || commonImageSource === 'prodia') {
    const config = await window.api.getConfig();
    if (commonImageSource === 'stability' && !config?.stabilityApiKey) {
      alert('Stability AI API 키가 설정되지 않았습니다. 환경설정에서 API 키를 입력해주세요.');
      return;
    }
    if (commonImageSource === 'prodia' && !config?.prodiaToken) {
      alert('Prodia AI Token이 설정되지 않았습니다. 환경설정에서 Token을 입력해주세요.');
      return;
    }
  }

  // 진행 상태 표시
  const modal = getProgressModal();
  modal.show('다중 계정 순차 발행 중...', `총 ${selectedAccountIds.length}개 계정 진행`);

  appendLog(`🚀 다중계정 순차 발행 시작: ${selectedAccountIds.length}개 계정`);

  // ✅ [2026-01-20] 다중계정 발행 프리셋 썸네일 적용
  const maPreset = applyPresetThumbnailIfExists('ma-semi-auto') || applyPresetThumbnailIfExists('ma-full-auto');
  if (maPreset && maPreset.applied) {
    // 전역 변수에 프리셋 썸네일 저장 (발행 시 사용)
    (window as any).maPresetThumbnail = maPreset.forHeading;
    (window as any).maPresetThumbnailPath = maPreset.forThumbnail;
    appendLog('🎨 미리 세팅된 썸네일이 다중계정 발행에 적용됩니다!');
  }

  // 메인 화면의 현재 세팅 수집
  const mainSettings = {
    title: (document.getElementById('unified-title') as HTMLInputElement)?.value || '',
    keywords: (document.getElementById('unified-keywords') as HTMLInputElement)?.value || '',
    url: (document.querySelector('.unified-url-input') as HTMLInputElement)?.value || '',
    generator: (document.getElementById('unified-generator') as HTMLSelectElement)?.value || 'gemini',
    imageSource: UnifiedDOMCache.getImageSource() || 'nano-banana-pro',
    toneStyle: (document.getElementById('unified-tone-style') as HTMLInputElement)?.value || 'friendly',
    useAiImage: (document.getElementById('unified-use-ai-image') as HTMLInputElement)?.checked ?? true,
    createProductThumbnail: (document.getElementById('unified-create-product-thumbnail') as HTMLInputElement)?.checked ?? false,
    contentMode: (document.getElementById('unified-content-mode') as HTMLInputElement)?.value || 'seo',
    affiliateLink: (document.getElementById('shopping-connect-affiliate-link') as HTMLInputElement)?.value?.trim() || (document.getElementById('batch-link-input') as HTMLInputElement)?.value?.trim() || '',
    customBannerPath: (window as any).customBannerPath || undefined, // ✅ [2026-01-18] 커스텀 배너 경로 전달
    // ✅ UI에서 발행 방식 읽기 (즉시/임시/예약) - 동기화 수정
    publishMode: (document.getElementById('unified-publish-mode') as HTMLSelectElement)?.value || 'publish',
    generatedTitle: (document.getElementById('unified-generated-title') as HTMLInputElement)?.value || '',
    generatedContent: (document.getElementById('unified-generated-content') as HTMLTextAreaElement)?.value || '',
    generatedHashtags: (document.getElementById('unified-generated-hashtags') as HTMLInputElement)?.value || '',
    category: UnifiedDOMCache.getRealCategory() || undefined, // ✅ 카테고리 추가
  };

  const scheduleDate = mainSettings.publishMode === 'schedule' ? (document.getElementById('unified-schedule-date') as HTMLInputElement)?.value : undefined;
  const scheduleType = mainSettings.publishMode === 'schedule' ? ((document.getElementById('unified-schedule-type') as HTMLSelectElement)?.value as 'app-schedule' | 'naver-server' || 'app-schedule') : undefined;

  const ctasUi = readUnifiedCtasFromUi();
  const skipCta = (document.getElementById('unified-skip-cta') as HTMLInputElement)?.checked || false;
  const ctaPosition = ((document.getElementById('unified-cta-position') as HTMLSelectElement | null)?.value as 'top' | 'middle' | 'bottom') || 'bottom';
  const preferredTitle = String(mainSettings.generatedTitle || mainSettings.title || '').trim();

  // 콘텐츠 소스 확인
  if (!mainSettings.title && !mainSettings.keywords && !mainSettings.url && !mainSettings.generatedContent) {
    alert('메인 화면에서 키워드, URL 또는 생성된 콘텐츠를 먼저 설정해주세요.');
    return;
  }

  let successCount = 0;
  let failCount = 0;

  const waitInterruptible = async (seconds: number) => {
    const ms = Math.max(0, Math.floor(seconds * 1000));
    const start = Date.now();
    while (Date.now() - start < ms) {
      if ((window as any).stopFullAutoPublish === true) return false;
      await new Promise((r) => setTimeout(r, 200));
    }
    return true;
  };

  for (let i = 0; i < selectedAccountIds.length; i++) {
    if ((window as any).stopFullAutoPublish === true) {
      appendLog('⏹️ 사용자가 다중계정 발행을 중지했습니다.');
      return;
    }
    const accountId = selectedAccountIds[i];

    try {
      // 계정 정보 가져오기
      const allAccounts = await window.api.getAllBlogAccounts();
      const account = allAccounts.accounts?.find((a: any) => a.id === accountId);

      if (!account) {
        appendLog(`❌ [${i + 1}/${selectedAccountIds.length}] 계정을 찾을 수 없습니다.`);
        failCount++;
        continue;
      }

      appendLog(`📝 [${i + 1}/${selectedAccountIds.length}] ${account.name} 계정 발행 시작...`);

      // 계정 자격 증명 가져오기
      const credResult = await window.api.getAccountCredentials(accountId);
      if (!credResult.success || !credResult.credentials) {
        appendLog(`❌ [${i + 1}/${selectedAccountIds.length}] ${account.name}: 자격 증명을 가져올 수 없습니다.`);
        failCount++;
        continue;
      }

      // 발행 옵션 구성
      // ✅ [2026-01-20] scheduleInterval, scheduleTime 추가 - 순차 예약 지원
      // 다중계정 전용 UI 또는 연속 발행 일괄 예약 설정 UI 참조
      const intervalEl = document.getElementById('unified-schedule-interval') ||
        document.getElementById('continuous-modal-schedule-interval');
      const intervalUnitEl = document.getElementById('unified-schedule-interval-unit') ||
        document.getElementById('continuous-modal-schedule-interval-unit');
      const timeEl = document.getElementById('unified-schedule-time') ||
        document.getElementById('continuous-modal-schedule-time');

      const intervalValue = parseInt((intervalEl as HTMLInputElement)?.value || '1');
      const intervalUnit = parseInt((intervalUnitEl as HTMLSelectElement)?.value || '360');  // 기본 6시간
      const scheduleIntervalValue = intervalValue * intervalUnit;
      const scheduleTimeValue = (timeEl as HTMLInputElement)?.value || '09:00';

      // ✅ [2026-01-20] 랜덤 편차 On/Off 옵션 (체크박스 또는 기본값 true)
      const randomOffsetEl = document.getElementById('unified-schedule-random-offset') ||
        document.getElementById('continuous-modal-schedule-random-offset');
      const useRandomOffset = (randomOffsetEl as HTMLInputElement)?.checked ?? true;  // 기본값: 랜덤 사용

      console.log(`[다중계정] 순차 예약 간격: ${scheduleIntervalValue}분, 시작 시간: ${scheduleTimeValue}, 랜덤: ${useRandomOffset}`);

      const publishOptions = {
        naverId: credResult.credentials.naverId,
        naverPassword: credResult.credentials.naverPassword,
        url: mainSettings.url,
        keywords: mainSettings.keywords,
        title: preferredTitle || undefined,
        generator: mainSettings.generator,
        imageSource: mainSettings.imageSource,
        toneStyle: mainSettings.toneStyle,
        publishMode: mainSettings.publishMode,
        scheduleDate,
        scheduleTime: scheduleTimeValue,  // ✅ 예약 시간
        scheduleInterval: scheduleIntervalValue,  // ✅ 순차 예약 간격 (분)
        scheduleRandomOffset: useRandomOffset,  // ✅ 랜덤 편차 On/Off
        scheduleType,
        category: mainSettings.category, // ✅ 카테고리 전달
        useAiImage: mainSettings.useAiImage,
        createProductThumbnail: mainSettings.createProductThumbnail,
        contentMode: mainSettings.contentMode,
        affiliateLink: mainSettings.affiliateLink,
        // ✅ CTA 설정 (main 프로세스 경로에서도 동일하게 전달)
        skipCta,
        ctaPosition,
        ctas: skipCta ? [] : ctasUi,
        ctaText: skipCta ? '' : (ctasUi[0]?.text || ''),
        ctaLink: skipCta ? '' : (ctasUi[0]?.link || ''),
        preGeneratedContent: mainSettings.generatedContent ? {
          title: preferredTitle,
          content: mainSettings.generatedContent,
          hashtags: mainSettings.generatedHashtags,
        } : null,
        // ✅ [2026-01-20] 프리셋 썸네일 정보 전달
        presetThumbnail: (window as any).maPresetThumbnail || undefined,
        presetThumbnailPath: (window as any).maPresetThumbnailPath || undefined,
      };

      // 발행 실행
      const result = await window.api.multiAccountPublish([accountId], publishOptions);

      if ((window as any).stopFullAutoPublish === true) {
        appendLog('⏹️ 사용자가 다중계정 발행을 중지했습니다.');
        return;
      }

      if (result.success) {
        appendLog(`✅ [${i + 1}/${selectedAccountIds.length}] ${account.name}: 발행 성공!`);
        successCount++;
      } else {
        appendLog(`❌ [${i + 1}/${selectedAccountIds.length}] ${account.name}: ${result.message || '발행 실패'}`);
        failCount++;
      }

      // 다음 계정 발행 전 대기 (마지막 계정 제외)
      if (i < selectedAccountIds.length - 1) {
        appendLog(`⏳ ${intervalSeconds}초 대기 중...`);
        const ok = await waitInterruptible(intervalSeconds);
        if (!ok) {
          appendLog('⏹️ 사용자가 다중계정 발행을 중지했습니다.');
          return;
        }
      }

    } catch (error) {
      appendLog(`❌ [${i + 1}/${selectedAccountIds.length}] 오류: ${(error as Error).message}`);
      failCount++;
    }
  }

  appendLog(`🏁 다중계정 발행 완료: 성공 ${successCount}개, 실패 ${failCount}개`);

  // ✅ 다중계정 발행 완료 UI 업데이트
  modal.setProgress(100, '발행 완료');
  modal.addLog(`✨ 모든 작업이 완료되었습니다! (성공: ${successCount}, 실패: ${failCount})`);

  toastManager.success(`✅ 다중 계정 발행 완료! (성공: ${successCount}, 실패: ${failCount})`);

  // 성공 시 3초 후 모달 자동 닫기
  if (failCount === 0) {
    setTimeout(() => {
      modal.hide();
    }, 3000);
  }
}

// 반자동 발행 처리
async function handleSemiAutoPublish(): Promise<void> {
  // ✅ 반자동 모드 설정
  (window as any).currentAutomationMode = 'semi-auto';

  // 먼저 콘텐츠가 생성되었는지 확인
  let structuredContent = (window as any).currentStructuredContent;

  // ✅ [FIX] 반자동 발행 시 사용자 수정 내용 보존
  // 필드에 이미 내용이 있으면 덮어쓰지 않음 (사용자가 수정했을 수 있음)
  const existingTitle = (document.getElementById('unified-generated-title') as HTMLInputElement)?.value?.trim();
  const existingContent = (document.getElementById('unified-generated-content') as HTMLTextAreaElement)?.value?.trim();

  // 필드가 비어있을 때만 fillSemiAutoFields 호출 (사용자 수정 내용 보존)
  if (!existingTitle && !existingContent && structuredContent) {
    try {
      fillSemiAutoFields(structuredContent);
    } catch {
      // ignore
    }
  }

  // ✅ structuredContent가 없으면 필드에서 직접 생성
  if (!structuredContent) {
    const title = (document.getElementById('unified-generated-title') as HTMLInputElement)?.value?.trim();
    const content = (document.getElementById('unified-generated-content') as HTMLTextAreaElement)?.value?.trim();
    const hashtagsStr = (document.getElementById('unified-generated-hashtags') as HTMLInputElement)?.value?.trim();

    if (!title || !content) {
      alert('먼저 상단에서 AI 글을 생성하거나, 제목과 본문을 직접 입력해주세요.');
      return;
    }

    // 직접 입력한 경우 structuredContent 생성
    structuredContent = {
      selectedTitle: title,
      bodyPlain: content,
      content: content,
      hashtags: hashtagsStr ? hashtagsStr.split(' ').filter(tag => tag.length > 0) : [],
      headings: [],
      toneStyle: (document.getElementById('unified-tone-style') as HTMLInputElement)?.value || 'friendly'
    };

    // 전역 변수에 저장
    (window as any).currentStructuredContent = structuredContent;
    currentStructuredContent = structuredContent;

    // ✅ localStorage에 저장 (postId 생성) - 카테고리도 함께 저장
    const postId = saveGeneratedPost(structuredContent, false, { category: UnifiedDOMCache.getRealCategory() });
    if (postId) {
      currentPostId = postId;
      appendLog(`💾 글이 자동으로 저장되었습니다 (ID: ${postId})`);
    }
  }

  // 수정된 콘텐츠 가져오기
  const title = (document.getElementById('unified-generated-title') as HTMLInputElement)?.value?.trim();
  const content = (document.getElementById('unified-generated-content') as HTMLTextAreaElement)?.value?.trim();
  const hashtagsStr = (document.getElementById('unified-generated-hashtags') as HTMLInputElement)?.value?.trim();

  if (!title || !content) {
    alert('제목과 본문을 모두 입력해주세요.');
    return;
  }

  // 수정된 콘텐츠로 structuredContent 업데이트
  // ✅ 소제목 정보(headings)는 원본에서 보존
  const updatedStructuredContent = {
    ...structuredContent,
    selectedTitle: title,
    bodyPlain: content,
    content: content,
    hashtags: hashtagsStr ? hashtagsStr.split(' ').filter(tag => tag.length > 0) : [],
    // 소제목 정보 보존 (이미지 매칭에 필요)
    headings: structuredContent.headings || []
  };

  // ✅ 업데이트된 콘텐츠 다시 저장
  saveGeneratedPost(updatedStructuredContent, true);

  if (updatedStructuredContent.headings && updatedStructuredContent.headings.length > 0) {
    appendLog(`📑 소제목 ${updatedStructuredContent.headings.length}개가 포함되어 있습니다.`);
  }

  appendLog('🔧 반자동 발행 시작: 수정된 콘텐츠로 발행');

  // ✅ 이미지 가져오기 (우선순위: ImageManager > 전역 변수 generatedImages > window.imageManagementGeneratedImages)
  let imageManagementImages: any[] = [];

  // ✅ 디버깅: 이미지 소스 상태 확인
  console.log('[SemiAuto] ImageManager.imageMap 크기:', ImageManager.imageMap.size);
  console.log('[SemiAuto] ImageManager.getAllImages():', ImageManager.getAllImages());
  console.log('[SemiAuto] 전역 generatedImages:', generatedImages?.length);
  console.log('[SemiAuto] window.imageManagementGeneratedImages:', (window as any).imageManagementGeneratedImages?.length);

  // 1. ImageManager에서 이미지 가져오기 (가장 우선)
  const imageManagerImages = ImageManager.getAllImages();
  if (imageManagerImages && imageManagerImages.length > 0) {
    imageManagementImages = [...imageManagerImages]; // 복사본 사용
    appendLog(`🖼️ ImageManager에서 ${imageManagementImages.length}개의 이미지를 가져왔습니다.`);
    imageManagementImages.forEach((img, i) => {
      console.log(`[SemiAuto] ImageManager 이미지 ${i}:`, img.heading, img.filePath?.substring(0, 50));
    });
  }

  // 2. 전역 변수 generatedImages에서 가져오기
  if (imageManagementImages.length === 0 && generatedImages && generatedImages.length > 0) {
    imageManagementImages = [...generatedImages]; // 복사본 사용
    appendLog(`🖼️ 전역 generatedImages에서 ${imageManagementImages.length}개의 이미지를 가져왔습니다.`);
  }

  // 3. window.imageManagementGeneratedImages에서 가져오기
  if (imageManagementImages.length === 0 && (window as any).imageManagementGeneratedImages && (window as any).imageManagementGeneratedImages.length > 0) {
    imageManagementImages = [...(window as any).imageManagementGeneratedImages]; // 복사본 사용
    appendLog(`🖼️ window.imageManagementGeneratedImages에서 ${imageManagementImages.length}개의 이미지를 가져왔습니다.`);
  }

  if (imageManagementImages.length > 0) {
    appendLog(`✅ 총 ${imageManagementImages.length}개의 이미지를 발행에 사용합니다.`);
    appendLog(`📋 이미지 목록:`);
    imageManagementImages.forEach((img: any, idx: number) => {
      const provider = img.provider || 'unknown';
      const heading = img.heading || '제목 없음';
      const filePath = img.filePath || img.url || 'N/A';
      appendLog(`   [${idx + 1}] ${heading} (${provider}) - ${filePath.substring(0, 60)}...`);
    });

    // ✅ [버그 수정] 이미지를 window.imageManagementGeneratedImages와 ImageManager에 동기화
    // executeBlogPublishing에서 이미지를 찾을 수 있도록 전역 상태에 저장
    (window as any).imageManagementGeneratedImages = [...imageManagementImages];
    generatedImages = [...imageManagementImages];

    // ImageManager에도 동기화 (ImageManager가 비어있는 경우에만)
    const currentManagerImages = ImageManager.getAllImages();
    if (!currentManagerImages || currentManagerImages.length === 0) {
      imageManagementImages.forEach((img: any) => {
        const heading = img.heading || img.title || '';
        if (heading) {
          ImageManager.setImage(heading, img);
        }
      });
      appendLog(`🔗 ImageManager에 ${imageManagementImages.length}개 이미지 동기화 완료`);
    }
  } else {
    appendLog(`⚠️ 이미지가 없습니다. 새로 생성합니다.`);
  }

  // 발행 데이터 구성
  const imageSource = UnifiedDOMCache.getImageSource();
  const skipImages = (document.getElementById('unified-skip-images') as HTMLInputElement)?.checked || false;

  const ctasUi = readUnifiedCtasFromUi();
  const skipCtaCheckbox = document.getElementById('unified-skip-cta') as HTMLInputElement;
  const skipCta = skipCtaCheckbox?.checked || false; // ✅ CTA 없이 발행 체크박스
  const publishMode = (document.getElementById('unified-publish-mode') as HTMLSelectElement)?.value || 'publish';
  const scheduleDate = publishMode === 'schedule' ? getScheduleDateFromInput('unified-schedule-date') : undefined;
  const scheduleType = publishMode === 'schedule' ? ((document.getElementById('unified-schedule-type') as HTMLSelectElement)?.value as 'app-schedule' | 'naver-server' || 'app-schedule') : undefined;

  // ✅ 디버깅: 이미지 관리 이미지 확인
  console.log('[handleSemiAutoPublish] generatedImages:', generatedImages);
  console.log('[handleSemiAutoPublish] imageManagementImages:', imageManagementImages);
  console.log('[handleSemiAutoPublish] imageManagementImages.length:', imageManagementImages.length);

  // ✅ CTA 자동 생성 (skipCta가 false인 경우만)
  let finalCtaText = '';
  let finalCtaLink = '';

  if (!skipCta) {
    const autoCTA = generateAutoCTA(title, '');

    // 수동 입력된 CTA가 있으면 우선 사용
    const manualCtaText = ctasUi[0]?.text || (document.getElementById('unified-cta-text') as HTMLInputElement)?.value?.trim();
    const manualCtaLink = ctasUi[0]?.link || (document.getElementById('unified-cta-link') as HTMLInputElement)?.value?.trim();

    finalCtaText = manualCtaText || autoCTA.ctaText;
    finalCtaLink = manualCtaLink || autoCTA.ctaLink;

    if (finalCtaLink) {
      appendLog(`✅ CTA 자동 포함: "${finalCtaText}" → ${finalCtaLink.substring(0, 50)}...`);
    } else {
      appendLog(`ℹ️ 연결할 이전 글이 없습니다. CTA 텍스트만 포함됩니다.`);
    }
  } else {
    appendLog(`🚫 CTA 없이 발행 옵션이 선택되었습니다.`);
  }

  // ✅ CTA 위치 고정
  const ctaPosition = ((document.getElementById('unified-cta-position') as HTMLSelectElement | null)?.value as 'top' | 'middle' | 'bottom') || 'bottom';

  // ✅ 이미지 객체 정규화: main 프로세스에서 filePath가 없으면 드랍될 수 있어서 여기서 보강
  const normalizedImagesForPublish = (Array.isArray(imageManagementImages) ? imageManagementImages : [])
    .map((img: any) => {
      const filePath = img?.filePath || img?.url || img?.previewDataUrl;
      return {
        ...img,
        filePath,
      };
    })
    .filter((img: any) => Boolean(img?.filePath));

  const formData: any = {
    mode: 'semi-auto',
    generator: (document.getElementById('unified-generator') as HTMLSelectElement)?.value || 'gemini',
    targetAge: 'all',
    toneStyle: (document.getElementById('unified-tone-style') as HTMLInputElement)?.value || 'friendly',
    imageSource,
    skipImages,
    publishMode,
    scheduleDate,
    scheduleType,
    structuredContent: updatedStructuredContent,
    // ✅ 이미지 전달 (호환)
    imageManagementImages: normalizedImagesForPublish,
    generatedImages: normalizedImagesForPublish,
    // ✅ CTA 설정
    ctaText: finalCtaText,
    ctaLink: finalCtaLink,
    ctas: skipCta ? [] : (ctasUi.length > 0 ? ctasUi : (finalCtaText ? [{ text: finalCtaText, link: finalCtaLink || undefined }] : [])),
    ctaPosition: ctaPosition, // ✅ CTA 위치 추가
    skipCta: skipCta, // ✅ 체크박스 값 반영
    categoryName: UnifiedDOMCache.getRealCategory(),
    // ✅ [2026-01-21 FIX] 쇼핑커넥트 모드 지원 추가
    affiliateLink: (document.getElementById('shopping-connect-affiliate-link') as HTMLInputElement)?.value?.trim() || '',
    contentMode: (document.getElementById('unified-content-mode') as HTMLInputElement)?.value || 'seo'
  };

  console.log('[handleSemiAutoPublish] formData.imageManagementImages:', formData.imageManagementImages);
  console.log('[handleSemiAutoPublish] formData.imageManagementImages.length:', formData.imageManagementImages?.length);

  // ✅ 이미지 소스가 stability인데 stabilityApiKey가 없으면 경고 (handleFullAutoPublish 등에서 미리 체크)
  const currentImageSource = formData.imageSource;
  if (currentImageSource === 'stability') {
    const config = await window.api.getConfig();
    if (!config?.stabilityApiKey) {
      alert('Stability AI API 키가 설정되지 않았습니다. 환경설정에서 API 키를 입력해주세요.');
      return;
    }
  } else if (currentImageSource === 'prodia') {
    const config = await window.api.getConfig();
    if (!config?.prodiaToken) {
      alert('Prodia AI Token이 설정되지 않았습니다. 환경설정에서 Token을 입력해주세요.');
      return;
    }
  }

  // 자동화 실행
  await executeUnifiedAutomation(formData);
}

// 통합 이미지 소스 선택
function initUnifiedImageSourceSelection(): void {
  const imgSourceBtns = document.querySelectorAll('.unified-img-source-btn');
  const imgSourceSelect = document.getElementById('unified-image-source') as HTMLSelectElement;

  imgSourceBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const source = (btn as HTMLElement).dataset.source;

      // 기존 선택 해제 및 스타일 초기화
      imgSourceBtns.forEach(b => {
        b.classList.remove('selected');
        (b as HTMLElement).style.boxShadow = 'none';
        (b as HTMLElement).style.borderColor = 'transparent';
        (b as HTMLElement).style.opacity = '0.7';

        // 체크 표시 제거
        const check = b.querySelector('div[style*="top: 0.4rem"]');
        if (check) (check as HTMLElement).style.display = 'none';
      });

      // 새로 선택 및 스타일 적용
      btn.classList.add('selected');
      (btn as HTMLElement).style.opacity = '1';
      (btn as HTMLElement).style.boxShadow = '0 0 0 3px var(--primary-light), 0 4px 12px rgba(0,0,0,0.2)';
      (btn as HTMLElement).style.borderColor = 'var(--primary)';

      // 체크 표시 추가
      const check = btn.querySelector('div[style*="top: 0.4rem"]');
      if (check) (check as HTMLElement).style.display = 'flex';

      // ✅ [Sync] 드롭다운(select) element 동기화
      if (imgSourceSelect && source) {
        imgSourceSelect.value = source;
        console.log(`[Sync] 이미지 소스 버튼 -> 셀렉트 동기화: ${source}`);
      }
    });
  });

  // ✅ [Sync] 드롭다운 변경 시 버튼 UI 업데이트
  if (imgSourceSelect) {
    imgSourceSelect.addEventListener('change', () => {
      const val = imgSourceSelect.value;
      console.log(`[Sync] 이미지 소스 셀렉트 -> 버튼 동기화: ${val}`);
      imgSourceBtns.forEach(btn => {
        if ((btn as HTMLElement).dataset.source === val) {
          // 이미 selected 클래스가 있으면 무시 (무한 루프 방지)
          if (!btn.classList.contains('selected')) {
            (btn as HTMLElement).click();
          }
        }
      });
    });
  }
}

// ✅ 1번 이미지 텍스트 옵션 UI 동적 추가 (풀오토/반자동 발행)
function addThumbnailTextOptionUI(): void {
  // 풀오토 발행 영역에 체크박스 추가 (2026-01-18: 이제 쇼핑커넥트 썸네일은 HTML 렌더링으로 생성되므로 숨김)
  const fullAutoImageSection =
    document
      .querySelector('#full-auto-image-source-section, .full-auto-img-source-btn, .unified-img-source-btn')
      ?.closest('.form-group, .option-group, .field, div[style*="margin"]');
  if (fullAutoImageSection && !document.getElementById('full-auto-thumbnail-text')) {
    const fullAutoCheckboxContainer = document.createElement('div');
    fullAutoCheckboxContainer.id = 'full-auto-thumbnail-text-container';
    fullAutoCheckboxContainer.style.cssText = `
      background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(217, 119, 6, 0.05));
      border: 1px solid rgba(245, 158, 11, 0.3);
      border-radius: 8px;
      padding: 0.75rem;
      margin-top: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    `;
    fullAutoCheckboxContainer.innerHTML = `
      <input type="checkbox" id="full-auto-thumbnail-text" style="width: 18px; height: 18px; cursor: pointer; accent-color: #f59e0b;">
      <label for="full-auto-thumbnail-text" style="cursor: pointer; font-size: 0.85rem; color: var(--text-strong); display: flex; flex-direction: column; gap: 0.15rem;">
        <span style="font-weight: 600;">🖼️ 1번 이미지에 제목 텍스트 포함</span>
        <span style="font-size: 0.75rem; color: var(--text-muted);">⚠️ AI가 한글을 정확히 렌더링하지 못할 수 있습니다</span>
      </label>
    `;
    fullAutoImageSection.appendChild(fullAutoCheckboxContainer);
    console.log('[Unified] 풀오토 1번 이미지 텍스트 옵션 UI 추가됨 (숨김 상태)');

    // ✅ [신규] 썸네일만 생성 체크박스 (일반 모드 전용 - 1번 소제목만 이미지 생성, 나머지는 텍스트만)
    const thumbnailOnlyContainer = document.createElement('div');
    thumbnailOnlyContainer.id = 'full-auto-thumbnail-only-container';
    thumbnailOnlyContainer.style.cssText = `
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(37, 99, 235, 0.05));
      border: 1px solid rgba(59, 130, 246, 0.3);
      border-radius: 8px;
      padding: 0.75rem;
      margin-top: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    `;
    thumbnailOnlyContainer.innerHTML = `
      <input type="checkbox" id="full-auto-thumbnail-only" style="width: 18px; height: 18px; cursor: pointer; accent-color: #3b82f6;">
      <label for="full-auto-thumbnail-only" style="cursor: pointer; font-size: 0.85rem; color: var(--text-strong); display: flex; flex-direction: column; gap: 0.15rem;">
        <span style="font-weight: 600;">📷 썸네일만 생성 (나머지 이미지 생성 안함)</span>
        <span style="font-size: 0.75rem; color: var(--text-muted);">1번 소제목에만 텍스트 포함 이미지, 나머지는 텍스트만</span>
      </label>
    `;
    fullAutoImageSection.appendChild(thumbnailOnlyContainer);
    console.log('[Unified] 풀오토 썸네일만 생성 옵션 UI 추가됨');

    // ✅ [핵심] 쇼핑커넥트 모드 변경 시 체크박스 표시/숨김 업데이트 함수
    const updateCheckboxVisibility = () => {
      const isShoppingConnect = isShoppingConnectModeActive();
      // 쇼핑커넥트 모드: 두 체크박스 숨김 (자동으로 텍스트 포함됨)
      fullAutoCheckboxContainer.style.display = isShoppingConnect ? 'none' : 'flex';
      thumbnailOnlyContainer.style.display = isShoppingConnect ? 'none' : 'flex';
    };

    // 초기 상태 설정
    updateCheckboxVisibility();

    // 콘텐츠 모드 변경 감지
    const contentModeSelect = document.getElementById('unified-content-mode');
    if (contentModeSelect) {
      contentModeSelect.addEventListener('change', updateCheckboxVisibility);
    }

    // 쇼핑커넥트 설정 표시 변경 감지 (MutationObserver)
    const shoppingConnectSettings = document.getElementById('shopping-connect-settings');
    if (shoppingConnectSettings) {
      const observer = new MutationObserver(updateCheckboxVisibility);
      observer.observe(shoppingConnectSettings, { attributes: true, attributeFilter: ['style'] });
    }
  }

  // 반자동 발행 영역에 체크박스 추가
  const semiAutoImageSection = document
    .querySelector('#unified-image-source-section, .unified-img-source-btn')
    ?.closest('.form-group, .option-group, div[style*="margin"]');

  // unified UI에서는 full-auto/반자동이 동일 영역(.unified-img-source-btn) 아래에 있으므로
  // 동일 컨테이너일 경우에는 체크박스를 한 번만 추가한다.
  const isSameHost =
    fullAutoImageSection && semiAutoImageSection && fullAutoImageSection === semiAutoImageSection;

  if (semiAutoImageSection && !isSameHost && !document.getElementById('semi-auto-thumbnail-text')) {
    const semiAutoCheckboxContainer = document.createElement('div');
    semiAutoCheckboxContainer.id = 'semi-auto-thumbnail-text-container';
    semiAutoCheckboxContainer.style.cssText = `
      background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(217, 119, 6, 0.05));
      border: 1px solid rgba(245, 158, 11, 0.3);
      border-radius: 8px;
      padding: 0.75rem;
      margin-top: 0.75rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    `;
    semiAutoCheckboxContainer.innerHTML = `
      <input type="checkbox" id="semi-auto-thumbnail-text" style="width: 18px; height: 18px; cursor: pointer; accent-color: #f59e0b;">
      <label for="semi-auto-thumbnail-text" style="cursor: pointer; font-size: 0.85rem; color: var(--text-strong); display: flex; flex-direction: column; gap: 0.15rem;">
        <span style="font-weight: 600;">🖼️ 1번 이미지에 제목 텍스트 포함</span>
        <span style="font-size: 0.75rem; color: var(--text-muted);">⚠️ AI가 한글을 정확히 렌더링하지 못할 수 있습니다</span>
      </label>
    `;
    semiAutoImageSection.appendChild(semiAutoCheckboxContainer);
    console.log('[Unified] 반자동 1번 이미지 텍스트 옵션 UI 추가됨');
  }

  // ✅ [2026-01-19] 쇼핑커넥트 전용 AI 이미지 생성 체크박스 추가
  addShoppingConnectAiImageOptions();
}

// ✅ [2026-01-19] 쇼핑커넥트 AI 표/배너 이미지 생성 옵션 체크박스 추가
function addShoppingConnectAiImageOptions(): void {
  // 이미 추가되어 있으면 스킵
  if (document.getElementById('ai-table-image-checkbox')) return;

  // 쇼핑커넥트 설정 영역 또는 풀오토 이미지 섹션 찾기
  const targetSection =
    document.getElementById('shopping-connect-settings') ||
    document.querySelector('#full-auto-thumbnail-text-container')?.parentElement ||
    document.querySelector('.unified-img-source-btn')?.closest('.form-group, .option-group, .field, div[style*="margin"]');

  if (!targetSection) {
    console.log('[ShoppingConnect] 체크박스 삽입 위치를 찾을 수 없음 - body에 hidden으로 추가');
    // 위치를 찾지 못하면 body에 숨겨서 추가 (기능은 동작하도록)
    const hiddenContainer = document.createElement('div');
    hiddenContainer.style.display = 'none';
    hiddenContainer.innerHTML = `
      <input type="checkbox" id="ai-table-image-checkbox" checked>
      <input type="checkbox" id="ai-banner-checkbox" checked>
    `;
    document.body.appendChild(hiddenContainer);
    return;
  }

  // 쇼핑커넥트 AI 이미지 옵션 컨테이너 생성
  const aiImageOptionsContainer = document.createElement('div');
  aiImageOptionsContainer.id = 'shopping-connect-ai-image-options';
  aiImageOptionsContainer.style.cssText = `
    display: none;
    grid-template-columns: 1fr 1fr;
    gap: 0.75rem;
    margin-top: 0.75rem;
    padding: 0.75rem;
    background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.05));
    border: 1px solid rgba(16, 185, 129, 0.3);
    border-radius: 8px;
  `;
  aiImageOptionsContainer.innerHTML = `
    <label style="display: flex; align-items: center; gap: 0.5rem; padding: 0.6rem; background: rgba(59, 130, 246, 0.1); border-radius: 8px; cursor: pointer; border: 1px solid rgba(59, 130, 246, 0.2);">
      <input type="checkbox" id="ai-table-image-checkbox" checked style="width: 16px; height: 16px; accent-color: #3b82f6;">
      <span style="color: var(--text-strong); font-size: 0.75rem; font-weight: 600;">📊 장단점 표 AI 이미지</span>
    </label>
    <label style="display: flex; align-items: center; gap: 0.5rem; padding: 0.6rem; background: rgba(16, 185, 129, 0.1); border-radius: 8px; cursor: pointer; border: 1px solid rgba(16, 185, 129, 0.2);">
      <input type="checkbox" id="ai-banner-checkbox" checked style="width: 16px; height: 16px; accent-color: #10b981;">
      <span style="color: var(--text-strong); font-size: 0.75rem; font-weight: 600;">🎯 CTA 배너 AI 생성</span>
    </label>
  `;
  targetSection.appendChild(aiImageOptionsContainer);
  console.log('[ShoppingConnect] AI 표/배너 이미지 옵션 체크박스 추가됨');

  // 쇼핑커넥트 모드일 때만 표시
  const updateVisibility = () => {
    const isShoppingConnect = isShoppingConnectModeActive();
    aiImageOptionsContainer.style.display = isShoppingConnect ? 'grid' : 'none';
  };

  // 초기 상태 설정
  updateVisibility();

  // 콘텐츠 모드 변경 감지
  const contentModeSelect = document.getElementById('unified-content-mode');
  if (contentModeSelect) {
    contentModeSelect.addEventListener('change', updateVisibility);
  }

  // 쇼핑커넥트 설정 영역 표시 변경 감지
  const shoppingConnectSettings = document.getElementById('shopping-connect-settings');
  if (shoppingConnectSettings) {
    const observer = new MutationObserver(updateVisibility);
    observer.observe(shoppingConnectSettings, { attributes: true, attributeFilter: ['style'] });
  }
}

// 통합 폼 데이터 수집
function collectUnifiedFormData(): any {
  const mode = (document.querySelector('input[name="unified-mode"]:checked') as HTMLInputElement)?.value || 'full-auto';

  // 공통 데이터
  const generator = (document.getElementById('unified-generator') as HTMLSelectElement)?.value || 'gemini';
  const targetAge = (document.getElementById('unified-target-age') as HTMLSelectElement)?.value || 'all';
  // ✅ 글 톤 설정 - UI에서 선택한 값 사용
  const toneStyle = (document.getElementById('unified-tone-style') as HTMLInputElement)?.value || 'friendly';
  const imageSource = document.querySelector('.unified-img-source-btn.selected')?.getAttribute('data-source') || 'dalle';
  const skipImages = (document.getElementById('unified-skip-images') as HTMLInputElement)?.checked || false;
  const publishMode = (document.getElementById('unified-publish-mode') as HTMLSelectElement)?.value || 'publish';
  const scheduleDate = publishMode === 'schedule' ? (document.getElementById('unified-schedule-date') as HTMLInputElement)?.value : undefined;
  const scheduleType = publishMode === 'schedule' ? ((document.getElementById('unified-schedule-type') as HTMLSelectElement)?.value as 'app-schedule' | 'naver-server' || 'app-schedule') : undefined;

  // ✅ 썸네일 텍스트 포함 여부 (나노 바나나 프로 전용)
  const includeThumbnailText =
    (document.getElementById('full-auto-thumbnail-text') as HTMLInputElement)?.checked ||
    (document.getElementById('semi-auto-thumbnail-text') as HTMLInputElement)?.checked ||
    (document.getElementById('thumbnail-text-option') as HTMLInputElement)?.checked ||
    (document.getElementById('ma-setting-include-thumbnail-text') as HTMLInputElement)?.checked ||
    false;

  // ✅ [신규] 썸네일만 생성 옵션 (1번 소제목만 이미지, 나머지는 텍스트만)
  const thumbnailOnly =
    (document.getElementById('full-auto-thumbnail-only') as HTMLInputElement)?.checked ||
    (document.getElementById('semi-auto-thumbnail-only') as HTMLInputElement)?.checked ||
    false;

  const baseData = {
    mode,
    generator,
    targetAge,
    toneStyle,
    imageSource,
    skipImages,
    publishMode,
    scheduleDate,
    scheduleType,
    includeThumbnailText, // ✅ 추가
    thumbnailOnly // ✅ [신규] 썸네일만 생성 옵션
  };

  if (mode === 'full-auto') {
    // 풀오토 모드 추가 데이터
    const urls = Array.from(document.querySelectorAll('#unified-url-fields-container .url-field-input'))
      .map(input => (input as HTMLInputElement).value.trim())
      .filter(url => url.length > 0);
    const keywords = (document.getElementById('unified-keywords') as HTMLInputElement)?.value.trim() || '';
    const title = (document.getElementById('unified-title') as HTMLInputElement)?.value.trim() || '';

    return {
      ...baseData,
      urls,
      keywords,
      title,
      isFullAuto: true // ✅ 풀오토 모드 플래그 (인덱스 기반 이미지 매칭용)
    };
  } else {
    // 반자동 모드 추가 데이터
    const title = (document.getElementById('unified-manual-title') as HTMLInputElement)?.value.trim() || '';
    const content = (document.getElementById('unified-manual-content') as HTMLTextAreaElement)?.value.trim() || '';
    const hashtags = (document.getElementById('unified-manual-hashtags') as HTMLInputElement)?.value.trim() || '';

    return {
      ...baseData,
      title,
      content,
      hashtags: hashtags ? hashtags.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0) : []
    };
  }
}

// URL로 AI 글 생성하기
async function generateContentFromUrl(
  url: string,
  keywordsOverride?: string,
  toneOverride?: string,
  suppressModal?: boolean,
  contentModeOverride?: string,
  articleTypeOverride?: string
): Promise<void> {
  // ✅ 기존 콘텐츠 및 이미지 완전 초기화 (이전 글 데이터 충돌 방지)
  appendLog('🔄 기존 콘텐츠를 초기화하고 새로운 콘텐츠를 생성합니다...');
  currentStructuredContent = null;
  (window as any).currentStructuredContent = null;
  generatedImages = [];
  (window as any).generatedImages = []; // ✅ [2026-01-21] 연속 발행용 이미지 변수도 초기화
  (window as any).imageManagementGeneratedImages = [];
  ImageManager.clear(); // ✅ ImageManager 초기화 (이전 글의 이미지 매핑 제거)
  // ✅ 활성 모달 결정 (suppressModal이면 메인 진행 모달 사용, 아니면 개별 모달)
  const activeModal: any = suppressModal ? getProgressModal() : aiProgressModal;

  // ✅ AI 글생성 진행률 모달 표시 (suppressModal이 아닐 때만)
  if (!suppressModal) {
    const contentGenSteps = [
      { percent: 10, step: '📝 키워드 분석 중...' },
      { percent: 25, step: '🔍 경쟁 블로그 분석 중...' },
      { percent: 45, step: '✍️ AI 글 작성 중...' },
      { percent: 70, step: '📄 콘텐츠 구조화 중...' },
      { percent: 85, step: '🔗 내부링크 삽입 중...' },
      { percent: 95, step: '✨ 글 마무리 중...' },
    ];

    aiProgressModal.show('🔄 AI 글 생성 중...', {
      autoAnimate: true,
      icon: '📝',
      initialLog: `URL: ${url.substring(0, 60)}${url.length > 60 ? '...' : ''}`,
      steps: contentGenSteps
    });
  }

  // ✅ 로그는 항상 활성 모달에 기록 (풀오토 시에도 진행상황 보이도록)
  if (activeModal.addLog) activeModal.addLog('🔄 URL 크롤링 시작...');

  // ✅ 진행률 표시 시작
  showUnifiedProgress(0, '🔄 URL 크롤링 시작...', `URL: ${url.substring(0, 50)}...`);
  appendLog('🔄 URL에서 콘텐츠 크롤링 및 AI 글 생성 시작...');

  // ✅ [2026-01-26 FIX] Perplexity 모델 직접 감지 (UI 동기화 문제 우회)
  let generator = UnifiedDOMCache.getGenerator();
  try {
    const config = await window.api.getConfig();
    const selectedModel = config?.primaryGeminiTextModel || config?.geminiModel || '';
    if (selectedModel === 'perplexity-sonar' || String(selectedModel).toLowerCase().startsWith('perplexity')) {
      generator = 'perplexity';
      console.log(`[Unified] ✅ Perplexity 모델 감지됨: ${selectedModel}`);
    }
  } catch (e) {
    console.log('[Unified] Config 로드 실패, 기본 generator 사용:', generator);
  }
  const targetAge = 'all'; // 고정

  // ✅ Override 우선 사용
  const toneStyle = toneOverride || (window as any)._toneOverride || UnifiedDOMCache.getToneStyle();
  const contentMode = contentModeOverride || (document.getElementById('unified-content-mode') as HTMLInputElement)?.value || 'seo';
  const articleType = articleTypeOverride || (document.getElementById('unified-article-type') as HTMLSelectElement)?.value || 'general';

  const minChars = parseInt((document.getElementById('unified-min-chars') as HTMLInputElement)?.value) || 2000;

  const keywordInputEl = document.getElementById('unified-keywords') as HTMLInputElement;
  const keywords = (keywordsOverride ?? keywordInputEl?.value)?.trim() || '';
  if (keywordInputEl && typeof keywordsOverride === 'string') {
    keywordInputEl.value = keywordsOverride;
  }
  const keywordList = keywords ? keywords.split(',').map(k => k.trim()).filter(k => k.length > 0) : [];

  // ✅ 리뷰형/정보형 선택 확인
  const selectedContentType = (window as any).selectedContentType || 'info';
  const isReviewType = selectedContentType === 'review';

  // ✅ articleType을 categoryHint로 매핑 (2축 분리 구조 연동)
  const categoryHintMap: Record<string, string> = {
    'entertainment': '연예',
    'sports': '스포츠',
    'health': '건강',
    'it_review': 'IT',
    'finance': '경제',
    'shopping_review': '쇼핑',
    'travel': '여행',
    'food': '음식',
    'parenting': '육아',
    'lifestyle': '라이프',
    'tips': '생활',
    'general': 'general'
  };
  const categoryHint = categoryHintMap[articleType] || '';

  // ✅ 리뷰형이면 로그 출력
  if (isReviewType) {
    appendLog('📦 리뷰형 글 생성 모드 - 구매전환 유도 글 작성');
  }

  const payload = {
    assembly: {
      generator: generator as 'gemini' | 'openai' | 'claude',
      rssUrl: url,
      keywords: keywordList,
      targetAge: targetAge as '20s' | '30s' | '40s' | '50s' | 'all',
      minChars,
      articleType,
      toneStyle,
      contentMode: contentMode as 'seo' | 'homefeed' | 'affiliate', // ✅ [FIX] 쇼핑커넥트(affiliate) 모드 타입 추가
      categoryHint, // ✅ 카테고리 힌트 전달 (2축 분리 프롬프트)
      isReviewType // ✅ 리뷰형 여부 전달
    }
  };

  try {
    const apiClient = EnhancedApiClient.getInstance();

    // ✅ 진행률 업데이트 - 크롤링 중
    showUnifiedProgress(15, '📡 URL 크롤링 중...', 'URL에서 콘텐츠를 가져오고 있습니다');
    appendLog('📡 URL 크롤링 중...');

    // ✅ 진행률 업데이트 - AI 생성 중
    showUnifiedProgress(30, '🤖 AI 글 생성 중...', `${generator} 엔진으로 콘텐츠 생성 중`);
    appendLog(`🤖 ${generator} 엔진으로 AI 글 생성 중... (${minChars}자 목표)`);
    // activeModal에도 진행 로그 추가
    if (activeModal.addLog) activeModal.addLog(`🤖 ${generator} 엔진으로 콘텐츠 생성 중...`);

    const apiResponse = await apiClient.call(
      'generateStructuredContent',
      [payload],
      {
        retryCount: 5,
        retryDelay: 2000,
        timeout: 600000 // ✅ 10분 타임아웃 (네트워크 느린 환경 대응)
      }
    );

    if (apiResponse?.success && isPaywallPayload(apiResponse.data)) {
      activatePaywall(apiResponse.data);
      return;
    }

    // ✅ 진행률 업데이트 - 응답 처리
    showUnifiedProgress(70, '📝 응답 처리 중...', '생성된 콘텐츠를 분석하고 있습니다');

    if (!apiResponse.success || !apiResponse.data?.success) {
      throw new Error(apiResponse.data?.message || apiResponse.error || '콘텐츠 생성 실패');
    }

    const result = apiResponse.data;
    const structuredContent = result.content;

    try {
      const seed = getReviewHeadingSeed('', keywords, structuredContent);
      applyReviewHeadingPrefix(structuredContent, seed);
    } catch {
    }

    const coreKeyword = (keywords || '').split(',').map((k) => k.trim()).filter(Boolean)[0] || '';
    if (coreKeyword) {
      structuredContent.selectedTitle = applyKeywordPrefixToTitleContinuous(String(structuredContent.selectedTitle || structuredContent.title || ''), coreKeyword);
      if (Array.isArray(structuredContent.titleAlternatives) && structuredContent.titleAlternatives.length > 0) {
        structuredContent.titleAlternatives = structuredContent.titleAlternatives
          .map((t: string) => applyKeywordPrefixToTitleContinuous(String(t || ''), coreKeyword))
          .filter(Boolean);
      }
      if (Array.isArray(structuredContent.titleCandidates) && structuredContent.titleCandidates.length > 0) {
        structuredContent.titleCandidates = structuredContent.titleCandidates.map((c: any) => ({
          ...c,
          text: applyKeywordPrefixToTitleContinuous(String(c?.text || ''), coreKeyword),
        }));
      }
    }

    // ✅ 진행률 업데이트 - 필드 채움
    showUnifiedProgress(80, '✏️ 필드 자동 입력 중...', '제목, 본문, 해시태그 입력');

    // ✅ [2026-01-20 버그수정] 생성된 콘텐츠를 전역 상태에 저장 (필수!)
    // 이 저장이 누락되면 풀오토 발행에서 콘텐츠를 찾을 수 없어 실패함
    currentStructuredContent = structuredContent;
    (window as any).currentStructuredContent = structuredContent;
    console.log('[GenerateContent] currentStructuredContent 저장 완료:', structuredContent?.selectedTitle);

    // 미리보기 업데이트 (소제목 없이)
    updateUnifiedPreview(structuredContent);

    // 필드 자동 채움
    fillSemiAutoFields(structuredContent);

    // ✅ CTA 자동 생성
    showUnifiedProgress(85, '🔗 CTA 자동 생성 중...', '관련 링크 생성');
    autoGenerateCTA(structuredContent);

    // ✅ 진행률 업데이트 - 소제목 분석
    showUnifiedProgress(90, '🔍 소제목 분석 중...', '이미지 배치 준비');
    appendLog('🎨 글 생성 완료! 소제목 분석을 자동으로 시작합니다...');

    // 소제목이 있으면 자동으로 분석 실행
    if (structuredContent && structuredContent.headings && structuredContent.headings.length > 0) {
      try {
        appendLog('🔍 소제목 분석 자동 실행 중...');
        await autoAnalyzeHeadings(structuredContent);
        appendLog('✅ 소제목 분석 완료! 이미지 생성이 준비되었습니다.');
      } catch (error) {
        appendLog(`⚠️ 소제목 자동 분석 실패: ${(error as Error).message}`);
      }
    } else {
      appendLog('⚠️ 소제목이 없어 자동 분석을 건너뜁니다.');
    }

    // ✅ 완료!
    showUnifiedProgress(100, '✅ 글 생성 완료!', `${structuredContent.bodyPlain?.length || 0}자 생성됨`);
    appendLog('✅ URL 기반 콘텐츠 생성 완료');

    // ✅ AI 글생성 진행률 모달 완료 표시
    if (!suppressModal && aiProgressModal.update) {
      aiProgressModal.update(100, '✅ 글 생성 완료!');
    }
    if (activeModal.addLog) activeModal.addLog(`✅ 콘텐츠 생성 완료 (${structuredContent.bodyPlain?.length || 0}자)`);

    // 개별 모달인 경우에만 닫기 (풀오토 모달은 유지해야 함)
    if (!suppressModal && aiProgressModal.hide) {
      setTimeout(() => aiProgressModal.hide(), 1500); // 1.5초 후 모달 자동 닫기
    }

    // ✅ 위험 지표 업데이트 (AI탐지, 법적위험, SEO점수)
    updateRiskIndicators(structuredContent);

    toastManager.success('✅ AI 글 생성이 완료되었습니다!');

    // ✅ URL 글생성 후 풀오토 발행 버튼 비활성화
    disableFullAutoPublishButton('URL 글생성 후에는 반자동 발행만 사용 가능합니다');
  } catch (error) {
    appendLog(`❌ URL 기반 콘텐츠 생성 실패: ${(error as Error).message}`);
    // 에러 로그는 항상 기록
    if (activeModal.addLog) activeModal.addLog(`❌ 오류: ${(error as Error).message}`);

    // 개별 모달인 경우에만 닫기
    if (!suppressModal && aiProgressModal.hide) {
      aiProgressModal.hide();
    }
    throw error;
  }
}

// 키워드,제목으로 AI 글 생성하기
async function normalizeKeywordsForGeneration(title: string, rawKeywords: string): Promise<{ primaryKeyword: string; keywordList: string[]; changed: boolean; reason: string }> {
  const raw = String(rawKeywords || '').trim();
  const normalized = raw
    .replace(/[\n\r]+/g, ',')
    .replace(/[|｜;]+/g, ',')
    .replace(/[#]+/g, ',')
    .replace(/\s+,/g, ',')
    .replace(/,\s+/g, ',');

  const candidates = normalized
    .split(',')
    .map((s) => String(s || '').trim())
    .filter(Boolean);

  const dedupe = (arr: string[]) => {
    const seen = new Set<string>();
    const out: string[] = [];
    for (const v of arr) {
      const key = v.toLowerCase();
      if (seen.has(key)) continue;
      seen.add(key);
      out.push(v);
    }
    return out;
  };

  const heuristicPrimary = (): string => {
    const first = String(candidates[0] || raw || title || '').trim();
    if (!first) return '';
    const words = first.split(/\s+/).filter(Boolean);
    let v = words.length > 10 ? words.slice(0, 10).join(' ') : first;
    if (v.length > 50) v = v.slice(0, 50).trim();
    return v;
  };

  const needsAutoPick = (() => {
    if (!raw) return false;
    if (candidates.length >= 3) return true;
    if (raw.length >= 60) return true;
    if ((raw.match(/,/g) || []).length >= 1 && raw.split(',').some((p) => String(p).trim().length > 25)) return true;
    return false;
  })();

  if (!needsAutoPick || typeof (window.api as any)?.generateContent !== 'function') {
    const primary = heuristicPrimary();
    const list = dedupe([primary, ...candidates.slice(1, 6)].filter(Boolean));
    return { primaryKeyword: primary, keywordList: list, changed: false, reason: primary ? 'heuristic' : 'empty' };
  }

  try {
    const prompt = `You are a Korean SEO blog editor.

[Input]
Title (optional): ${String(title || '').trim()}
Raw keywords (may contain multiple unrelated topics): ${raw}

[Task]
1) Choose ONLY ONE main topic keyword phrase that best represents what the user likely wants.
2) Provide 3-6 supporting keywords that are tightly related to that ONE main topic.
3) Do NOT mix unrelated topics.

[Output]
Return ONLY valid JSON like:
{"primary":"...","keywords":["...","..."]}`;

    const res = await (window.api as any).generateContent(prompt);
    const text = String(res?.content || '').trim();
    if (!res?.success || !text) {
      throw new Error('keyword_normalize_failed');
    }

    const jsonMatch = text.match(/\{[\s\S]*\}/);
    const jsonText = jsonMatch ? jsonMatch[0] : text;
    const parsed = JSON.parse(jsonText);
    const primaryRaw = String(parsed?.primary || '').trim();
    const listRaw = Array.isArray(parsed?.keywords) ? parsed.keywords.map((x: any) => String(x || '').trim()).filter(Boolean) : [];
    const primary = primaryRaw || heuristicPrimary();
    const list = dedupe([primary, ...listRaw].filter(Boolean)).slice(0, 6);
    return { primaryKeyword: primary, keywordList: list, changed: true, reason: 'ai_select' };
  } catch {
    const primary = heuristicPrimary();
    const list = dedupe([primary, ...candidates.slice(1, 6)].filter(Boolean));
    return { primaryKeyword: primary, keywordList: list, changed: true, reason: 'fallback' };
  }
}

async function generateContentFromKeywords(
  title: string,
  keywords: string,
  toneOverride?: string,
  suppressModal?: boolean,
  contentModeOverride?: string,
  articleTypeOverride?: string
): Promise<void> {
  // ✅ 기존 콘텐츠 및 이미지 완전 초기화 (이전 글 데이터 충돌 방지)
  appendLog('🔄 기존 콘텐츠를 초기화하고 새로운 콘텐츠를 생성합니다...');
  currentStructuredContent = null;
  (window as any).currentStructuredContent = null;
  generatedImages = [];
  (window as any).generatedImages = []; // ✅ [2026-01-21] 연속 발행용 이미지 변수도 초기화
  (window as any).imageManagementGeneratedImages = [];
  ImageManager.clear(); // ✅ ImageManager 초기화 (이전 글의 이미지 매핑 제거)
  currentPostId = null; // ✅ 새 글이므로 postId 초기화

  // ✅ 활성 모달 결정 (suppressModal이면 메인 진행 모달 사용, 아니면 개별 모달)
  const activeModal: any = suppressModal ? getProgressModal() : aiProgressModal;

  // ✅ AI 글생성 진행률 모달 표시 (suppressModal이 아닐 때만)
  if (!suppressModal) {
    const contentGenSteps = [
      { percent: 10, step: '📝 키워드 분석 중...' },
      { percent: 25, step: '🔍 경쟁 블로그 분석 중...' },
      { percent: 45, step: '✍️ AI 글 작성 중...' },
      { percent: 70, step: '📄 콘텐츠 구조화 중...' },
      { percent: 85, step: '🔗 내부링크 삽입 중...' },
      { percent: 95, step: '✨ 글 마무리 중...' },
    ];

    aiProgressModal.show('✏️ AI 글 생성 중...', {
      autoAnimate: true,
      icon: '📝',
      initialLog: `키워드: ${keywords.substring(0, 30)}...`,
      steps: contentGenSteps
    });
    // 진행률 표시 시작 (단일 생성 모드일 때만)
    showUnifiedProgress(0, '✏️ 키워드 기반 글 생성 시작...', `제목: ${title?.substring(0, 30) || '자동 생성'}...`);
  }
  appendLog('✏️ 키워드 기반 AI 글 생성 시작...');

  const generator = UnifiedDOMCache.getGenerator();
  const targetAge = 'all'; // 고정

  // ✅ Override 우선 사용
  const toneStyle = toneOverride || (window as any)._toneOverride || UnifiedDOMCache.getToneStyle();
  const contentMode = contentModeOverride || (document.getElementById('unified-content-mode') as HTMLInputElement)?.value || 'seo';
  const articleType = articleTypeOverride || (document.getElementById('unified-article-type') as HTMLSelectElement)?.value || 'general';

  const minChars = parseInt((document.getElementById('unified-min-chars') as HTMLInputElement)?.value) || 2000;

  // ✅ 실시간 정보 수집 체크박스 확인 (반자동 또는 완전 자동 모드에 따라)
  const isFullAuto = (window as any).currentAutomationMode === 'full-auto';
  const realtimeCrawlCheckbox = isFullAuto
    ? (document.getElementById('full-auto-realtime-crawl') as HTMLInputElement)
    : (document.getElementById('semi-auto-realtime-crawl') as HTMLInputElement) || (document.getElementById('unified-realtime-crawl') as HTMLInputElement);
  const useRealtimeCrawl = realtimeCrawlCheckbox?.checked ?? true; // 기본값: 켜짐

  // ✅ 발행 날짜 가져오기 (예약 발행인 경우)
  const publishMode = (document.getElementById('unified-publish-mode') as HTMLSelectElement)?.value || 'publish';
  const scheduleDateInput = document.getElementById('unified-schedule-date') as HTMLInputElement;
  const scheduleDate = publishMode === 'schedule' && scheduleDateInput?.value ? scheduleDateInput.value : undefined;

  let crawledText = ''; // 크롤링된 텍스트

  const normalizedKeywords = await normalizeKeywordsForGeneration(title, keywords);
  if (normalizedKeywords.primaryKeyword) {
    appendLog(`🔎 주제 고정 키워드: ${normalizedKeywords.primaryKeyword}${normalizedKeywords.changed ? ` (자동정제: ${normalizedKeywords.reason})` : ''}`);
  }

  // ✅ 실시간 정보 수집 (체크박스가 켜져 있을 때) - URL 기반과 동등한 품질 보장
  // ✅ 주제 일탈 방지를 위해 대표 키워드(1개)로만 검색
  const searchQuery = normalizedKeywords.primaryKeyword || title;
  if (useRealtimeCrawl && searchQuery) {
    try {
      showUnifiedProgress(5, '🌐 실시간 정보 수집 중...', '네이버 뉴스, 블로그, 카페, 구글 뉴스에서 최신 정보 검색');
      appendLog('🌐 실시간 정보 수집 시작 - URL 기반과 동등한 품질 보장을 위해 다양한 소스 검색 중...');

      // ✅ 더 많은 소스에서 수집하여 URL 기반과 동등한 품질 보장
      // ✅ 항상 오늘 날짜 기준으로 크롤링 (최신 정보만 수집)
      const todayDate = new Date().toISOString().split('T')[0]; // YYYY-MM-DD 형식
      const targetCrawlDate = scheduleDate || todayDate; // 예약 발행 날짜가 있으면 그걸 사용, 없으면 오늘
      const crawlOptions: any = { maxPerSource: 10, targetDate: targetCrawlDate };
      appendLog(`📅 ${scheduleDate ? '발행 날짜' : '오늘 날짜'} 기준 크롤링: ${targetCrawlDate} (최근 30일 이내 자료만 수집)`);
      const crawlResult = await window.api.collectContentFromPlatforms(searchQuery, crawlOptions);

      if (crawlResult.success && crawlResult.collectedText) {
        crawledText = crawlResult.collectedText;
        const charCount = crawledText.length;
        appendLog(`✅ 실시간 정보 수집 완료: ${crawlResult.sourceCount}개 소스에서 ${charCount.toLocaleString()}자 수집`);
        showUnifiedProgress(15, '✅ 실시간 정보 수집 완료', `${crawlResult.sourceCount}개 소스에서 ${charCount.toLocaleString()}자 수집됨`);

        // ✅ 수집량이 충분한지 확인 (URL 기반과 동등한 품질을 위해 최소 2000자 권장)
        if (charCount < 2000) {
          appendLog(`⚠️ 수집된 정보가 적습니다 (${charCount}자). 추가 검색을 시도합니다...`);
          // 제목으로도 추가 검색 시도
          if (title) {
            try {
              const additionalResult = await window.api.collectContentFromPlatforms(title, { maxPerSource: 5 });
              if (additionalResult.success && additionalResult.collectedText) {
                crawledText += '\n\n[추가 수집 정보]\n' + additionalResult.collectedText;
                appendLog(`✅ 추가 정보 수집: ${additionalResult.sourceCount}개 소스에서 ${additionalResult.collectedText.length}자 추가`);
              }
            } catch (e) {
              console.warn('[Crawl] 추가 수집 실패:', e);
            }
          }
        }
      } else {
        appendLog(`⚠️ 실시간 정보 수집 실패: ${crawlResult.message || '관련 글을 찾을 수 없음'}`);
        // ✅ 폴백: 제목으로 다시 시도
        if (title) {
          appendLog('🔄 제목으로 재시도 중...');
          try {
            const fallbackResult = await window.api.collectContentFromPlatforms(title, { maxPerSource: 8 });
            if (fallbackResult.success && fallbackResult.collectedText) {
              crawledText = fallbackResult.collectedText;
              appendLog(`✅ 제목 기반 수집 성공: ${fallbackResult.sourceCount}개 소스에서 ${crawledText.length}자 수집`);
            } else {
              // ✅ 같은 키워드로 재시도 (관련 없는 결과 방지 - 다른 키워드 사용 금지!)
              appendLog('🔄 [재시도] 같은 키워드로 다시 검색합니다 (소스 수 증가)...');
              try {
                const retryResult = await window.api.collectContentFromPlatforms(searchQuery, { maxPerSource: 15 });
                if (retryResult.success && retryResult.collectedText && retryResult.collectedText.length >= 300) {
                  crawledText = retryResult.collectedText;
                  appendLog(`✅ 재시도 성공: ${retryResult.sourceCount}개 소스에서 ${crawledText.length}자 수집`);
                } else {
                  appendLog('⚠️ 재시도도 실패 - 수집된 정보가 부족합니다.');
                  toastManager.warning('⚠️ 실시간 정보 수집 결과가 부족합니다. 정확도가 낮을 수 있습니다.', 5000);
                  // 부족해도 있는 정보로 계속 진행
                  if (retryResult.collectedText) {
                    crawledText = retryResult.collectedText;
                  }
                }
              } catch (retryError) {
                console.warn('[Crawl] 재시도 실패:', retryError);
                appendLog('⚠️ 재시도 중 오류 - 가능한 정보로 계속합니다.');
              }
            }
          } catch (fallbackError) {
            console.warn('[Crawl] 폴백 시도 실패:', fallbackError);
            appendLog('⚠️ 정보 수집 중 오류 발생 - 가능한 정보로 계속합니다.');
          }
        } else {
          // 제목도 없는 경우 - 경고만 표시하고 계속
          appendLog('⚠️ 검색 키워드 부족 - 가능한 정보로 글을 생성합니다.');
          toastManager.warning('⚠️ 실시간 정보가 부족할 수 있습니다.', 3000);
        }
      }
    } catch (crawlError) {
      console.warn('[Crawl] 실시간 정보 수집 오류:', crawlError);
      appendLog('⚠️ 정보 수집 중 오류 발생 - 가능한 정보로 계속합니다.');
      toastManager.warning('⚠️ 일부 정보 수집 실패, 가능한 정보로 계속합니다.', 3000);
    }
  }

  // ✅ 환각 방지 경고 (중단하지 않고 경고만)
  if (useRealtimeCrawl && crawledText.length < 300) {
    appendLog(`⚠️ [경고] 수집된 정보가 적음 (${crawledText.length}자) - 정확도가 낮을 수 있습니다.`);
    toastManager.warning(`⚠️ 수집된 정보가 적습니다 (${crawledText.length}자). 정확도가 낮을 수 있습니다.`, 5000);
  }

  // ✅ URL 기반과 동등한 품질을 위한 payload 구성
  const keywordList = normalizedKeywords.keywordList;

  const referenceDate = (() => {
    const raw = scheduleDate || '';
    if (raw) {
      const d = new Date(raw);
      if (!isNaN(d.getTime())) return d.toISOString().slice(0, 10);
    }
    return new Date().toISOString().slice(0, 10);
  })();

  // ✅ [2026-01-21 FIX] 연도를 동적으로 계산하여 AI가 올바른 연도 사용
  const currentYear = new Date().getFullYear(); // 2026
  const lastYear = currentYear - 1; // 2025
  const twoYearsAgo = currentYear - 2; // 2024

  const recencyDirective = `[최신성 규칙]
- 기준일: ${referenceDate} (현재 ${currentYear}년)
- 작성 내용은 기준일 기준 최신 정보(최근 동향/최근 발표/최근 이슈)를 우선 반영하세요.
- 연말정산/종합소득세 등 세금 관련 내용은 ${lastYear}년 귀속 기준으로 작성하세요. (${currentYear}년 초에 신고하는 것은 ${lastYear}년 소득에 대한 것입니다)
- ${twoYearsAgo}년/${twoYearsAgo - 1}년 등 과거 연도를 언급해야 한다면 반드시 맥락(최근 업데이트/비교/통계 출처 등)을 함께 제시하세요.
- '최근' 또는 '올해'라고 할 때는 ${currentYear}년을 의미합니다.
- 확실하지 않은 과거 수치/사실은 단정하지 말고 일반적인 설명으로 처리하세요.
`;

  // ✅ articleType을 categoryHint로 매핑 (2축 분리 구조 연동)
  const categoryHintMap: Record<string, string> = {
    'entertainment': '연예',
    'sports': '스포츠',
    'health': '건강',
    'it_review': 'IT',
    'finance': '경제',
    'shopping_review': '쇼핑',
    'travel': '여행',
    'food': '음식',
    'parenting': '육아',
    'lifestyle': '라이프',
    'tips': '생활',
    'general': ''
  };
  const categoryHint = categoryHintMap[articleType] || '';

  const payload = {
    assembly: {
      generator: generator as 'gemini' | 'openai' | 'claude',
      keywords: keywordList,
      targetAge: targetAge as '20s' | '30s' | '40s' | '50s' | 'all',
      minChars,
      articleType,
      toneStyle,
      contentMode: contentMode as 'seo' | 'homefeed' | 'affiliate', // ✅ [FIX] 쇼핑커넥트(affiliate) 모드 타입 추가
      categoryHint, // ✅ 카테고리 힌트 전달 (2축 분리 프롬프트)
      title: title || undefined,
      // ✅ 크롤링된 텍스트가 있으면 baseText로 전달 (할루시네이션 방지)
      // URL 기반처럼 실제 정보를 기반으로 생성하여 품질 향상
      baseText: crawledText || undefined,
      // ✅ 더 많은 컨텍스트 전달 (최대 10000자)
      draftText: crawledText
        ? `${recencyDirective}\n[주제 고정 규칙]\n- 이 글의 주제는 반드시 "${normalizedKeywords.primaryKeyword || (title || '').trim()}" 하나로만 유지하세요.\n- 키워드 입력에 다른 이슈/사건/인물/회사명이 섞여 있어도 절대 다른 주제로 넘어가지 마세요.\n- 실시간 수집 정보도 위 주제와 직접 관련된 내용만 사용하세요.\n\n[실시간 수집된 최신 정보 - 아래 내용을 반드시 참고하여 정확한 글 작성]\n\n${crawledText.substring(0, 10000)}`
        : `${recencyDirective}\n[주제 고정 규칙]\n- 이 글의 주제는 반드시 "${normalizedKeywords.primaryKeyword || (title || '').trim()}" 하나로만 유지하세요.\n- 키워드 입력에 다른 이슈/사건/인물/회사명이 섞여 있어도 절대 다른 주제로 넘어가지 마세요.\n`,
      // ✅ 실시간 정보가 있으면 더 정확한 글 생성 지시
      useRealTimeInfo: !!crawledText,
      sourceInfo: crawledText ? `"${searchQuery}"에 대한 실시간 수집 정보 기반` : undefined,
      customPrompt: (document.getElementById('unified-custom-prompt') as HTMLTextAreaElement)?.value?.trim() || undefined
    }
  };

  try {
    const apiClient = EnhancedApiClient.getInstance();

    // ✅ 진행률 업데이트 - AI 생성 준비
    showUnifiedProgress(20, '📝 키워드 분석 중...', keywords?.substring(0, 50) || '키워드 없음');
    appendLog(`📝 키워드 분석: ${keywords || '(없음)'}`);

    // ✅ 진행률 업데이트 - AI 생성 중
    const crawlStatus = crawledText ? ' (실시간 정보 기반)' : '';
    showUnifiedProgress(35, '🤖 AI 글 생성 중...', `${generator} 엔진으로 콘텐츠 생성 중${crawlStatus}`);
    appendLog(`🤖 ${generator} 엔진으로 AI 글 생성 중... (${minChars}자 목표)${crawlStatus}`);

    const apiResponse = await apiClient.call(
      'generateStructuredContent',
      [payload],
      {
        retryCount: 5,
        retryDelay: 2000,
        timeout: 600000 // ✅ 10분 타임아웃 (네트워크 느린 환경 대응)
      }
    );

    if (apiResponse?.success && isPaywallPayload(apiResponse.data)) {
      activatePaywall(apiResponse.data);
      return;
    }

    // ✅ 진행률 업데이트 - 응답 처리
    showUnifiedProgress(70, '📝 응답 처리 중...', '생성된 콘텐츠를 분석하고 있습니다');

    if (!apiResponse.success || !apiResponse.data?.success) {
      throw new Error(apiResponse.data?.message || apiResponse.error || '콘텐츠 생성 실패');
    }

    const result = apiResponse.data;
    const structuredContent = result.content;

    try {
      const seed = getReviewHeadingSeed(title, keywords, structuredContent);
      applyReviewHeadingPrefix(structuredContent, seed);
    } catch {
    }

    // ✅ 진행률 업데이트 - 필드 채움
    showUnifiedProgress(80, '✏️ 필드 자동 입력 중...', '제목, 본문, 해시태그 입력');

    // ✅ [2026-01-20 버그수정] 생성된 콘텐츠를 전역 상태에 저장 (필수!)
    // generateContentFromUrl과 동일한 버그였음 - 풀오토 키워드 발행 실패 원인
    currentStructuredContent = structuredContent;
    (window as any).currentStructuredContent = structuredContent;
    console.log('[GenerateContentKeywords] currentStructuredContent 저장 완료:', structuredContent?.selectedTitle);

    // 미리보기 업데이트 (소제목 없이)
    updateUnifiedPreview(structuredContent);

    // 필드 자동 채움
    fillSemiAutoFields(structuredContent);

    // ✅ CTA 자동 생성
    showUnifiedProgress(85, '🔗 CTA 자동 생성 중...', '관련 링크 생성');
    autoGenerateCTA(structuredContent);

    // ✅ 진행률 업데이트 - 소제목 분석
    showUnifiedProgress(90, '🔍 소제목 분석 중...', '이미지 배치 준비');
    appendLog('🎨 글 생성 완료! 소제목 분석을 자동으로 시작합니다...');

    // 소제목이 있으면 자동으로 분석 실행
    if (structuredContent && structuredContent.headings && structuredContent.headings.length > 0) {
      try {
        appendLog('🔍 소제목 분석 자동 실행 중...');
        await autoAnalyzeHeadings(structuredContent);
        appendLog('✅ 소제목 분석 완료! 이미지 생성이 준비되었습니다.');
      } catch (error) {
        appendLog(`⚠️ 소제목 자동 분석 실패: ${(error as Error).message}`);
      }
    } else {
      appendLog('⚠️ 소제목이 없어 자동 분석을 건너뜁니다.');
    }

    // ✅ 완료!
    showUnifiedProgress(100, '✅ 글 생성 완료!', `${structuredContent.bodyPlain?.length || 0}자 생성됨`);
    appendLog('✅ 키워드 기반 콘텐츠 생성 완료');

    // ✅ 위험 지표 업데이트 (AI탐지, 법적위험, SEO점수)
    updateRiskIndicators(structuredContent);

    // ✅ AI 글생성 진행률 모달 완료 표시
    if (!suppressModal && aiProgressModal.update) {
      aiProgressModal.update(100, '✅ 글 생성 완료!');
    }
    if (activeModal.addLog) activeModal.addLog(`✅ 콘텐츠 생성 완료 (${structuredContent.bodyPlain?.length || 0}자)`);

    // 개별 모달인 경우에만 닫기 (풀오토 모달은 유지해야 함)
    if (!suppressModal && aiProgressModal.hide) {
      setTimeout(() => aiProgressModal.hide(), 1500); // 1.5초 후 모달 자동 닫기
    }

    toastManager.success('✅ AI 글 생성이 완료되었습니다!');

    // ✅ 키워드 글생성 후 풀오토 발행 버튼 비활성화
    disableFullAutoPublishButton('키워드 글생성 후에는 반자동 발행만 사용 가능합니다');
  } catch (error) {
    showUnifiedProgress(0, '❌ 오류 발생', (error as Error).message);
    appendLog(`❌ 키워드 기반 콘텐츠 생성 실패: ${(error as Error).message}`);
    // 에러 로그는 항상 기록
    if (activeModal.addLog) activeModal.addLog(`❌ 오류: ${(error as Error).message}`);

    // 개별 모달인 경우에만 닫기
    if (!suppressModal && aiProgressModal.hide) {
      aiProgressModal.hide();
    }
    throw error;
  }
}

// ✅ 풀오토 발행 버튼 비활성화 함수
function disableFullAutoPublishButton(reason: string): void {
  const fullAutoBtn = document.getElementById('full-auto-publish-btn') as HTMLButtonElement;
  if (fullAutoBtn) {
    fullAutoBtn.disabled = true;
    fullAutoBtn.style.opacity = '0.5';
    fullAutoBtn.style.cursor = 'not-allowed';
    fullAutoBtn.title = reason;
    appendLog(`⚠️ ${reason}`);
  }
}

function enableFullAutoPublishButton(): void {
  const fullAutoBtn = document.getElementById('full-auto-publish-btn') as HTMLButtonElement;
  if (!fullAutoBtn) return;
  fullAutoBtn.disabled = false;
  fullAutoBtn.style.opacity = '1';
  fullAutoBtn.style.cursor = 'pointer';
  fullAutoBtn.title = '';
}

function enableSemiAutoPublishButton(): void {
  const semiAutoBtn = document.getElementById('semi-auto-publish-btn') as HTMLButtonElement;
  if (!semiAutoBtn) return;
  semiAutoBtn.disabled = false;
  semiAutoBtn.style.opacity = '1';
  semiAutoBtn.style.cursor = 'pointer';
  semiAutoBtn.title = '';
}

// ✅ CTA 자동 생성 함수 (내 블로그 이전 글만 연결 - 외부 사이트 연결 금지!)
function autoGenerateCTA(structuredContent: any): void {
  const ctaTextInput = document.getElementById('unified-cta-text') as HTMLInputElement;
  const ctaLinkInput = document.getElementById('unified-cta-link') as HTMLInputElement;

  if (!ctaTextInput || !ctaLinkInput) {
    console.log('[CTA] CTA 입력 필드를 찾을 수 없습니다');
    return;
  }

  try {
    const autoCTA = generateAutoCTA(structuredContent?.selectedTitle || structuredContent?.title || '', '');
    if (autoCTA.ctaLink) {
      ctaTextInput.value = autoCTA.ctaText;
      ctaLinkInput.value = autoCTA.ctaLink;
      appendLog(`🔗 CTA 자동 생성: 내 블로그 이전 글 "${autoCTA.ctaText.replace(/^📖\s*/, '')}"`);
      return;
    }
  } catch (e) {
    console.warn('[CTA] CTA 자동 생성 실패:', e);
  }

  ctaTextInput.value = '';
  ctaLinkInput.value = '';
  appendLog(`ℹ️ 발행된 이전 글이 없어 CTA가 비어있습니다. 글 선택 버튼으로 연결할 글을 선택하세요.`);
}

// ✅ 불러오기/백업 복원 시 CTA 자동 채움
function autoFillCTAFromContent(): void {
  const titleInput = document.getElementById('unified-title') as HTMLInputElement;
  const bodyInput = document.getElementById('unified-body') as HTMLTextAreaElement;

  if (!titleInput || !bodyInput) return;

  const structuredContent = {
    title: titleInput.value,
    bodyPlain: bodyInput.value
  };

  autoGenerateCTA(structuredContent);
}

// 반자동 모드 필드에 콘텐츠 채우기 (통합 및 강화됨)
function fillSemiAutoFields(structuredContent: any): void {
  console.log('[fillSemiAutoFields] Called with:', JSON.stringify(structuredContent).substring(0, 100) + '...');

  // 반자동 모드 섹션 표시
  const semiAutoSection = document.getElementById('unified-semi-auto-section');
  if (semiAutoSection) {
    console.log('[fillSemiAutoFields] Showing unified-semi-auto-section');
    semiAutoSection.style.display = 'block';
    // 부드러운 애니메이션
    semiAutoSection.style.opacity = '0.5';
    setTimeout(() => {
      semiAutoSection.style.opacity = '1';
      semiAutoSection.style.transition = 'opacity 0.3s ease';
    }, 50);

    // 섹션으로 스크롤
    setTimeout(() => {
      semiAutoSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }, 300);
  } else {
    console.warn('[fillSemiAutoFields] unified-semi-auto-section NOT found in DOM!');
  }

  if (!structuredContent) {
    console.error('[fillSemiAutoFields] structuredContent is null or undefined!');
    return;
  }

  // 제목 필드 채움 (수정 가능)
  const titleInput = document.getElementById('unified-generated-title') as HTMLInputElement;
  if (titleInput) {
    const val = structuredContent.selectedTitle || structuredContent.title || '';
    console.log('[fillSemiAutoFields] Updating title:', val);
    titleInput.value = val;
    titleInput.readOnly = false;
    appendLog(`📝 제목: "${val}"`);
  } else {
    console.error('[fillSemiAutoFields] unified-generated-title NOT found!');
  }

  // 본문 필드 채움 (수정 가능)
  const contentTextarea = document.getElementById('unified-generated-content') as HTMLTextAreaElement;
  if (contentTextarea) {
    let body = structuredContent.bodyPlain || structuredContent.content || '';

    // ✅ [핵심 수정] 소제목이 있으면 항상 headings에서 본문 재구성
    // 미리보기(headings)와 편집 필드(bodyPlain)가 다른 내용일 수 있으므로 동기화
    if (structuredContent.headings && structuredContent.headings.length > 0) {
      console.log('[fillSemiAutoFields] ✅ headings에서 본문 재구성 (미리보기와 동기화)');
      const headings = structuredContent.headings;
      const structuredBlocks: string[] = [];

      // 도입부 있으면 추가
      if (structuredContent.introduction) {
        structuredBlocks.push(structuredContent.introduction);
      }

      // 소제목 + 본문 조합
      headings.forEach((h: any) => {
        if (h.title) {
          structuredBlocks.push(h.title);  // ### 없이 제목만
        }
        if (h.content) {
          structuredBlocks.push(h.content);
        } else if (h.summary) {
          structuredBlocks.push(h.summary);
        }
      });

      // 마무리 있으면 추가
      if (structuredContent.conclusion) {
        structuredBlocks.push(structuredContent.conclusion);
      }

      if (structuredBlocks.length > 0) {
        body = structuredBlocks.join('\n\n');
      }
    }

    const normalized = normalizeReadableBodyText(body);
    console.log('[fillSemiAutoFields] Updating content (length):', normalized.length);
    contentTextarea.value = normalized;
    contentTextarea.readOnly = false;
    appendLog(`📄 본문: ${normalized.length}자`);
  } else {
    console.error('[fillSemiAutoFields] unified-generated-content NOT found!');
  }

  // 해시태그 필드 채움 (수정 가능)
  const hashtagsInput = document.getElementById('unified-generated-hashtags') as HTMLInputElement;
  if (hashtagsInput && structuredContent.hashtags) {
    const hashtagsStr = Array.isArray(structuredContent.hashtags)
      ? structuredContent.hashtags.join(' ')
      : structuredContent.hashtags;
    console.log('[fillSemiAutoFields] Updating hashtags:', hashtagsStr);
    hashtagsInput.value = hashtagsStr;
    hashtagsInput.readOnly = false;
    appendLog(`🏷️ 해시태그: ${hashtagsStr}`);
  } else if (!hashtagsInput) {
    console.error('[fillSemiAutoFields] unified-generated-hashtags NOT found!');
  }

  // 소제목 정보 저장
  currentStructuredContent = structuredContent;
  (window as any).currentStructuredContent = structuredContent;


  // ✅ 생성된 글 목록에 저장 (postId 반환)
  const postId = saveGeneratedPost(structuredContent);
  if (postId) {
    currentPostId = postId; // 전역 변수에 저장 (이미지 생성 시 사용)
  }

  // ✅ 이미지 관리 탭 제목 필드도 자동으로 채우기
  const imageTitleInput = document.getElementById('image-title') as HTMLInputElement;
  if (imageTitleInput && structuredContent.selectedTitle) {
    imageTitleInput.value = structuredContent.selectedTitle;
    appendLog(`📝 이미지 관리 탭 제목도 자동 입력: "${structuredContent.selectedTitle}"`);
  }

  // ✅ 자동 저장 및 백업 시작
  startAutosave();
  startAutoBackup();
  appendLog('💾 자동 저장 시작 (30초마다)');
  appendLog('💾 자동 백업 시작 (5분마다)');

  // ✅ 생성된 글 목록 새로고침
  refreshGeneratedPostsList();

  // ✅ [New] 미리보기 즉시 동기화
  syncIntegratedPreviewFromInputs();
}

// ✅ 페러프레이징 모드로 글쓰기
async function paraphraseContent(): Promise<void> {
  const titleInput = document.getElementById('unified-generated-title') as HTMLInputElement;
  const contentTextarea = document.getElementById('unified-generated-content') as HTMLTextAreaElement;
  const hashtagsInput = document.getElementById('unified-generated-hashtags') as HTMLInputElement;

  const title = titleInput?.value.trim() || '';
  const content = contentTextarea?.value.trim() || '';
  const hashtags = hashtagsInput?.value.trim() || '';

  if (!title && !content) {
    alert('제목 또는 본문을 입력해주세요.');
    return;
  }

  try {
    appendLog('✨ 페러프레이징 모드: 글의 퀄리티를 개선하여 새롭게 작성 중...');
    showUnifiedProgress(10, '페러프레이징 시작...', 'AI가 글을 분석하고 개선 중입니다');

    // 기존 콘텐츠 초기화
    if (currentStructuredContent) {
      currentStructuredContent = null;
      (window as any).currentStructuredContent = null;
      generatedImages = [];
    }

    const generator = UnifiedDOMCache.getGenerator();
    const targetAge = 'all';
    const toneStyle = UnifiedDOMCache.getToneStyle();
    const articleType = (document.getElementById('unified-article-type') as HTMLSelectElement)?.value || 'general';
    const minChars = parseInt((document.getElementById('unified-min-chars') as HTMLInputElement)?.value) || 2000;

    // 페러프레이징 프롬프트 구성 (100점 강화 버전)
    let draftText = '';
    if (title) draftText += `제목: ${title}\n\n`;
    if (content) draftText += `본문:\n${content}\n\n`;
    if (hashtags) draftText += `해시태그: ${hashtags}\n\n`;
    draftText += `위 글을 완전히 새롭게 재작성해주세요.

════════════════════════════════════════
🔥 패러프레이징 100점 공식 🔥
════════════════════════════════════════

[핵심 목표]
1. AI 탐지 100% 회피 (사람이 쓴 것처럼)
2. 네이버 상위노출/홈판노출 최적화
3. 원본 의미는 유지하되 표현은 완전히 새롭게

════════════════════════════════════════
📌 문장 변환 필수 규칙 (AI 탐지 회피)
════════════════════════════════════════

[문장 구조 변환]
- 능동태 ↔ 피동태 전환: "나는 ~했다" → "~가 되었다"
- 문장 순서 변경: 결론 → 과정 또는 과정 → 결론
- 복문 → 단문: 긴 문장을 2~3개로 분리
- 단문 → 복문: 짧은 문장들을 자연스럽게 연결

[어휘 변환 - 동의어 적극 활용]
- "좋다" → "괜찮다/만족스럽다/마음에 들다"
- "나쁘다" → "아쉽다/별로다/기대 이하다"
- "많다" → "꽤 된다/여럿이다/상당하다"
- "중요하다" → "핵심이다/빠지면 안 된다/꼭 알아야 한다"

[AI티 제거 필수]
❌ 절대 금지: "물론", "확실히", "분명히", "~것입니다", "~하겠습니다"
❌ 절대 금지: "살펴보겠습니다", "알아보겠습니다", "정리하자면"
✅ 대신 사용: "저도 그랬어요", "솔직히", "근데", "그래서", "아무튼"

[구어체 필수 변환]
- "~입니다" → "~이에요/예요"
- "~합니다" → "~해요"
- "~하였다" → "~했어요"
- 딱딱한 문어체 전면 금지

════════════════════════════════════════
📌 제목 100점 재작성
════════════════════════════════════════

[제목 공식]
[핵심키워드] + [구체적 상황/숫자] + [감정/결과 트리거]

[제목 트리거 필수 포함]
- 감정형: "~에 울컥", "~보고 소름", "~듣고 충격"
- 정보형: "총정리", "완벽 가이드", "~가지 방법"
- 현장감: "실시간", "방금", "댓글 난리"

════════════════════════════════════════
📌 도입부 후킹 100점 재작성
════════════════════════════════════════

[첫 문장 필수 패턴 중 하나]
- "저도 처음엔 이랬어요."
- "이거 보고 진짜 놀랐어요."
- "다들 이거 모르더라고요."
- "솔직히 말하면요."

[도입부 3줄 구성]
1줄: 공감/충격 (15~25자)
2줄: 상황 설명 (20~30자)
3줄: 본문 유도 (20~30자)

════════════════════════════════════════
📌 본문 변환 규칙
════════════════════════════════════════

[소제목 재작성]
- 원본 소제목 의미 유지하되 표현 완전 변경
- 감정/행동 중심 소제목으로 변환
❌ "제품 특징 정리" → ✅ "써보니까 이게 달랐어요"
❌ "장단점 분석" → ✅ "솔직히 좋은 점, 아쉬운 점"

[문단 재구성]
- 문단 순서 섞기 (논리적 흐름 유지하면서)
- 예시/사례 추가 또는 변경
- 숫자/데이터 표현 방식 변경 (50% → 절반, 2배 → 두 배로)

[반응 블록 추가]
📌 실제 반응:
- "~라는 댓글이 많았어요"
- "주변에서도 ~라고 하더라고요"

════════════════════════════════════════
📌 AI 인용 최적화 (네이버 AI 대응)
════════════════════════════════════════

[인용 가능한 문장 3개 이상 포함]
- "핵심은 딱 하나예요. ~"
- "결론부터 말하면, ~"
- "가장 중요한 건 ~이에요."

[구조화된 정보]
- 숫자 리스트 1개 이상 (3가지, 5단계 등)
- 비교/대조 문장 1개 이상

════════════════════════════════════════
⚠️ 최종 체크리스트
════════════════════════════════════════

□ AI 탐지 금지 표현 0개
□ 모든 문장 구어체 "~해요"
□ 제목에 감정/숫자 트리거 포함
□ 도입부 3줄 후킹 패턴 적용
□ 소제목 5개 이상
□ 인용 가능한 팩트 문장 3개 이상
□ 원본과 문장 유사도 30% 이하 (완전히 새롭게)

결과물은 AI가 아닌 사람이 직접 쓴 것처럼 자연스러워야 합니다.`;

    showUnifiedProgress(30, 'AI가 글을 개선 중...', '페러프레이징 및 퀄리티 향상 중');

    const payload = {
      assembly: {
        generator: generator as 'gemini' | 'openai' | 'claude',
        draftText: draftText,
        targetAge: targetAge as '20s' | '30s' | '40s' | '50s' | 'all',
        minChars,
        articleType,
        toneStyle
      }
    };

    const apiClient = EnhancedApiClient.getInstance();
    const apiResponse = await apiClient.call(
      'generateStructuredContent',
      [payload],
      {
        retryCount: 5,
        retryDelay: 2000,
        timeout: 600000 // ✅ 10분 타임아웃
      }
    );

    if (!apiResponse.success || !apiResponse.data?.success) {
      throw new Error(apiResponse.data?.message || apiResponse.error || '페러프레이징 실패');
    }

    showUnifiedProgress(80, '페러프레이징 완료!', '개선된 글을 필드에 채우는 중');

    const result = apiResponse.data;
    const structuredContent = result.content;

    // 필드에 개선된 글 채우기
    if (titleInput && structuredContent.selectedTitle) {
      titleInput.value = structuredContent.selectedTitle;
    }
    if (contentTextarea && structuredContent.bodyPlain) {
      const normalized = normalizeReadableBodyText(structuredContent.bodyPlain);
      structuredContent.bodyPlain = normalized;
      structuredContent.content = normalized;
      contentTextarea.value = normalized;
    }
    if (hashtagsInput && structuredContent.hashtags) {
      hashtagsInput.value = structuredContent.hashtags.join(' ');
    }

    appendLog('✨ 페러프레이징 완료! 필드를 확인해주세요.');

    // 글로벌 상태 업데이트
    currentStructuredContent = structuredContent;
    (window as any).currentStructuredContent = structuredContent;

    // 미리보기 및 목록 업데이트
    updateUnifiedPreview(structuredContent);
    refreshGeneratedPostsList();
  } catch (error: any) {
    console.error('Paraphrase failed:', error);
    appendLog(`❌ 페러프레이징 실패: ${error.message}`);
  } finally {
    hideUnifiedProgress();
  }
}


// ✅ 갤러리 뷰 전환 상태
let isGalleryView = false;

const GENERATED_POSTS_CATEGORY_COLLAPSE_PREFIX = 'generated_posts_category_collapsed:';

function normalizeGeneratedPostCategoryKey(raw: unknown): string {
  const trimmed = String(raw || '').trim();
  if (!trimmed) return 'uncategorized';
  // ✅ [2026-01-23 FIX] normalizeCategory 함수를 사용하여 카테고리명 통일
  const normalized = normalizeCategory(trimmed);
  return normalized || trimmed;
}

const CATEGORY_LABEL_MAP: Record<string, string> = {
  // ✅ [2026-01-23 FIX] CATEGORY_NORMALIZE_MAP의 출력값과 일치하도록 수정
  // key: CATEGORY_NORMALIZE_MAP의 결과값(저장되는 값), value: 화면에 표시될 라벨
  '일반': '일반/생활',
  '스타 연예인': '스타 연예인',
  '사회 정치': '사회/정치',  // ✅ [2026-01-24 FIX] 뉴스 이슈 → 사회 정치로 변경
  '스포츠': '스포츠',
  '건강': '건강/의학',
  '비즈니스 경제': '비즈니스/경제',
  'IT 테크': 'IT/테크',
  '쇼핑 리뷰': '쇼핑/리뷰',
  '육아': '육아/교육',
  '맛집 요리': '맛집/요리',
  '여행': '여행/나들이',
  '리빙 인테리어': '리빙/인테리어',
  '반려동물': '반려동물',
  '패션 뷰티': '패션/뷰티',
  '취미 라이프': '취미/라이프',
  '부동산': '부동산',
  '자동차': '자동차',
  '책 영화': '책/영화/문화',
  '자기계발': '자기계발',
  '공부': '공부/학습',
  '게임': '게임',
  '사진 영상': '사진/영상',
  '예술': '예술/디자인',
  '음악': '음악',
  '생활 꿀팁': '생활꿀팁',
  'uncategorized': '미분류',
  '': '미분류'
};

function getGeneratedPostCategoryLabel(categoryKey: string): string {
  // ✅ [2026-01-23 FIX] 콘텐츠 카테고리 드롭다운과 완전히 동일하게 표시
  // 변환 없이 저장된 값 그대로 반환 (예: "스타 연예인" → "스타 연예인")
  const key = normalizeGeneratedPostCategoryKey(categoryKey);
  if (!key || key === 'uncategorized') return '미분류';
  return key;
}

function isGeneratedPostCategoryCollapsed(categoryKey: string): boolean {
  const key = normalizeGeneratedPostCategoryKey(categoryKey);
  return localStorage.getItem(`${GENERATED_POSTS_CATEGORY_COLLAPSE_PREFIX}${key}`) === '1';
}

function setGeneratedPostCategoryCollapsed(categoryKey: string, collapsed: boolean): void {
  const key = normalizeGeneratedPostCategoryKey(categoryKey);
  localStorage.setItem(`${GENERATED_POSTS_CATEGORY_COLLAPSE_PREFIX}${key}`, collapsed ? '1' : '0');
}

// ✅ 생성된 글 목록 표시 (검색, 정렬, 필터링 지원)
function refreshGeneratedPostsList(): void {
  const listContainer = document.getElementById('generated-posts-list');
  const searchInput = document.getElementById('posts-search-input') as HTMLInputElement;
  const filterSelect = document.getElementById('posts-filter-select') as HTMLSelectElement;
  const sortSelect = document.getElementById('posts-sort-select') as HTMLSelectElement;
  const countBadge = document.getElementById('posts-count-badge');

  if (!listContainer) return;

  // ✅ [2026-01-23 FIX] 모든 계정의 글을 표시 (계정별 분리로 인해 안 보이는 문제 해결)
  let posts = loadAllGeneratedPosts();
  const totalCount = posts.length;

  // ✅ 통계 정보 계산
  const totalImages = posts.reduce((sum, p) => sum + (p.images?.length || 0), 0);
  const totalChars = posts.reduce((sum, p) => sum + p.content.length, 0);
  const avgChars = totalCount > 0 ? Math.round(totalChars / totalCount) : 0;
  const publishedCount = posts.filter(p => p.publishedUrl).length;

  // ✅ 필터링
  if (filterSelect) {
    const filterValue = filterSelect.value;
    switch (filterValue) {
      case 'with-images':
        posts = posts.filter(p => p.images && p.images.length > 0);
        break;
      case 'without-images':
        posts = posts.filter(p => !p.images || p.images.length === 0);
        break;
      case 'with-headings':
        posts = posts.filter(p => p.headings && p.headings.length > 0);
        break;
      case 'without-headings':
        posts = posts.filter(p => !p.headings || p.headings.length === 0);
        break;
      case 'favorites':
        posts = posts.filter(p => p.isFavorite);
        break;
      case 'published':
        posts = posts.filter(p => p.publishedUrl);
        break;
      case 'unpublished':
        posts = posts.filter(p => !p.publishedUrl);
        break;
    }
  }

  // 검색 필터링 (검색어 하이라이트를 위해 검색어 저장)
  let searchTerm = '';
  if (searchInput && searchInput.value.trim()) {
    searchTerm = searchInput.value.trim().toLowerCase();
    posts = posts.filter(post =>
      post.title.toLowerCase().includes(searchTerm) ||
      post.content.toLowerCase().includes(searchTerm) ||
      post.hashtags.some(tag => tag.toLowerCase().includes(searchTerm))
    );
  }

  // 정렬
  if (sortSelect) {
    const sortValue = sortSelect.value;
    posts.sort((a, b) => {
      switch (sortValue) {
        case 'newest':
          return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
        case 'oldest':
          return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime();
        case 'title-asc':
          return (a.title || '').localeCompare(b.title || '', 'ko');
        case 'title-desc':
          return (b.title || '').localeCompare(a.title || '', 'ko');
        case 'updated':
          const aUpdated = a.updatedAt ? new Date(a.updatedAt).getTime() : new Date(a.createdAt).getTime();
          const bUpdated = b.updatedAt ? new Date(b.updatedAt).getTime() : new Date(b.createdAt).getTime();
          return bUpdated - aUpdated;
        case 'content-length':
          return b.content.length - a.content.length;
        default:
          return 0;
      }
    });
  }

  // ✅ 개수 및 통계 표시
  if (countBadge) {
    const statsText = totalCount > 0
      ? `${posts.length}/${totalCount} | 🖼️${totalImages} | 📄${avgChars.toLocaleString()}자 평균 | 📤${publishedCount}`
      : '0';
    countBadge.textContent = statsText;
    countBadge.style.fontSize = '0.7rem';
    countBadge.style.padding = '0.25rem 0.5rem';
  }

  if (posts.length === 0) {
    listContainer.innerHTML = '<div style="color: var(--text-muted); font-style: italic; text-align: center; padding: 2rem;">생성된 글이 없습니다.</div>';
    return;
  }

  // ✅ 검색어 하이라이트 함수
  const highlightText = (text: string, term: string): string => {
    if (!term) return text;
    const regex = new RegExp(`(${term})`, 'gi');
    return text.replace(regex, '<mark style="background: #fef08a; padding: 0.1rem 0.2rem; border-radius: 2px;">$1</mark>');
  };

  const renderGalleryItem = (post: any): string => {
    const firstImage = post.images && post.images.length > 0 ? post.images[0] : null;
    const thumbnailImage = firstImage
      ? (firstImage.previewDataUrl || firstImage.filePath || firstImage.url)
      : null;
    const highlightedTitle = searchTerm ? highlightText(post.title || '(제목 없음)', searchTerm) : (post.title || '(제목 없음)');

    return `
        <div class="post-item-gallery" data-post-id="${post.id}" style="background: var(--bg-secondary); border-radius: 8px; border: 1px solid ${post.isFavorite ? '#fbbf24' : 'var(--border-light)'}; overflow: hidden; cursor: pointer; transition: all 0.2s; position: relative;" onmouseover="this.style.transform='translateY(-4px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none'">
          <input type="checkbox" class="post-checkbox" data-post-id="${post.id}" style="position: absolute; top: 0.5rem; left: 0.5rem; width: 18px; height: 18px; cursor: pointer; z-index: 10;" onchange="event.stopPropagation(); updateBatchDeleteButton();">
          ${post.isFavorite ? '<div style="position: absolute; top: 0.5rem; right: 0.5rem; font-size: 1.25rem; z-index: 10;">⭐</div>' : ''}
          ${post.publishedUrl ? `<div style="position: absolute; top: 0.5rem; left: 2rem; background: #10b981; color: white; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; z-index: 10; cursor: pointer;" onclick="event.stopPropagation(); window.open('${post.publishedUrl}', '_blank');">발행됨</div>` : ''}
          ${thumbnailImage ? `
            <div class="thumbnail-container" style="width: 100%; height: 200px; overflow: hidden; background: var(--bg-tertiary); cursor: pointer;" onclick="event.stopPropagation(); showImageModal('${thumbnailImage}');">
              <img src="${thumbnailImage}" style="width: 100%; height: 100%; object-fit: cover;" onerror="this.style.display='none'; this.parentElement.innerHTML='<div style=\\'width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:3rem;color:var(--text-muted)\\'>🖼️</div>';" />
            </div>
          ` : '<div style="width: 100%; height: 200px; background: var(--bg-tertiary); display: flex; align-items: center; justify-content: center; font-size: 3rem; color: var(--text-muted);">📄</div>'}
          <div style="padding: 1rem;">
            <div style="font-weight: 600; color: var(--text-strong); margin-bottom: 0.5rem; font-size: 1rem; word-break: break-word; line-height: 1.4;">${highlightedTitle}</div>
            <div style="display: flex; gap: 0.75rem; font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.75rem; flex-wrap: wrap;">
              <span>📄 ${post.content.length.toLocaleString()}자</span>
              <span>🖼️ ${post.images?.length || 0}개</span>
              <span>📑 ${post.headings?.length || 0}개</span>
            </div>
            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
              ${post.publishedUrl ? `<button type="button" class="open-url-btn" data-url="${post.publishedUrl}" style="flex: 1; padding: 0.5rem; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.875rem; white-space: nowrap;" title="발행된 글 열기">🔗 바로가기</button>` : ''}
              <button type="button" class="load-post-btn" data-post-id="${post.id}" style="flex: 1; padding: 0.5rem; background: var(--primary); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.875rem; white-space: nowrap;">📂 불러오기</button>
              <button type="button" class="preview-post-btn" data-post-id="${post.id}" style="flex: 1; padding: 0.5rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 4px; cursor: pointer; font-size: 0.875rem; white-space: nowrap;">👁️ 미리보기</button>
            </div>
          </div>
        </div>
      `;
  };

  const renderListItem = (post: any): string => {
    const date = new Date(post.createdAt);
    const dateStr = date.toLocaleString('ko-KR', {
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit'
    });

    const updatedDateStr = post.updatedAt
      ? new Date(post.updatedAt).toLocaleString('ko-KR', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      })
      : null;

    const contentPreview = post.content.length > 100
      ? post.content.substring(0, 100) + '...'
      : post.content;

    const firstImage = post.images && post.images.length > 0 ? post.images[0] : null;
    const thumbnailImage = firstImage
      ? (firstImage.previewDataUrl || firstImage.filePath || firstImage.url)
      : null;

    const highlightedTitle = searchTerm ? highlightText(post.title || '(제목 없음)', searchTerm) : (post.title || '(제목 없음)');
    const highlightedPreview = searchTerm ? highlightText(contentPreview, searchTerm) : contentPreview;

    return `
      <div class="post-item" data-post-id="${post.id}" style="padding: 1rem; margin-bottom: 0.75rem; background: var(--bg-secondary); border-radius: 8px; border: 1px solid ${post.isFavorite ? '#fbbf24' : 'var(--border-light)'}; transition: all 0.2s; cursor: pointer; position: relative;" onmouseover="this.style.borderColor='var(--primary)'; this.style.boxShadow='0 2px 8px rgba(59, 130, 246, 0.2)'" onmouseout="this.style.borderColor='${post.isFavorite ? '#fbbf24' : 'var(--border-light)'}'; this.style.boxShadow='none'">
        <input type="checkbox" class="post-checkbox" data-post-id="${post.id}" style="position: absolute; top: 0.5rem; left: 0.5rem; width: 18px; height: 18px; cursor: pointer; z-index: 10;" onchange="event.stopPropagation(); updateBatchDeleteButton();">
        ${post.isFavorite ? '<div style="position: absolute; top: 0.5rem; right: 0.5rem; font-size: 1.25rem;">⭐</div>' : ''}
        ${post.publishedUrl ? `<div style="position: absolute; top: 0.5rem; left: 2rem; background: #10b981; color: white; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; font-weight: 600; cursor: pointer;" onclick="event.stopPropagation(); window.open('${post.publishedUrl}', '_blank');" title="클릭하여 발행된 글 열기">발행됨</div>` : ''}
        <div style="display: flex; align-items: start; justify-content: space-between; gap: 1rem;">
          ${thumbnailImage ? `
            <div class="thumbnail-container" style="flex-shrink: 0; width: 120px; height: 80px; border-radius: 4px; overflow: hidden; background: var(--bg-tertiary); display: flex; align-items: center; justify-content: center; cursor: pointer;" onclick="event.stopPropagation(); showImageModal('${thumbnailImage}');">
              <img src="${thumbnailImage}" style="width: 100%; height: 100%; object-fit: cover;" onerror="this.style.display='none'; this.parentElement.innerHTML='🖼️';" />
            </div>
          ` : ''}
          <div style="flex: 1; min-width: 0;">
            <div style="font-weight: 600; color: var(--text-strong); margin-bottom: 0.5rem; font-size: 1rem; word-break: break-word;">${highlightedTitle}</div>
            <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.5rem;">
              생성: ${dateStr}${updatedDateStr && updatedDateStr !== dateStr ? ` | 수정: ${updatedDateStr}` : ''}
            </div>
            <div style="font-size: 0.75rem; color: var(--text-muted); margin-bottom: 0.5rem; line-height: 1.4; opacity: 0.8;">${highlightedPreview}</div>
            <div style="display: flex; gap: 1rem; font-size: 0.875rem; color: var(--text-muted); flex-wrap: wrap;">
              <span>📄 ${post.content.length.toLocaleString()}자</span>
              <span>📑 ${post.headings?.length || 0}개 소제목</span>
              <span>🖼️ ${post.images?.length || 0}개 이미지</span>
              ${post.hashtags.length > 0 ? `<span>🏷️ ${post.hashtags.slice(0, 3).join(', ')}${post.hashtags.length > 3 ? '...' : ''}</span>` : ''}
              ${post.publishedUrl ? `<span style="color: #10b981; cursor: pointer; text-decoration: underline;" onclick="event.stopPropagation(); window.open('${post.publishedUrl}', '_blank');" title="클릭하여 발행된 글 열기">✅ 발행됨</span>` : '<span style="color: var(--text-muted);">⏳ 미발행</span>'}
            </div>
          </div>
          <div style="display: flex; flex-direction: column; gap: 0.5rem; flex-shrink: 0;">
            ${post.publishedUrl ? `<button type="button" class="open-url-btn" data-url="${post.publishedUrl}" style="padding: 0.5rem 1rem; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.875rem; white-space: nowrap;" title="발행된 글 열기">🔗 바로가기</button>` : ''}
            <button type="button" class="favorite-post-btn" data-post-id="${post.id}" style="padding: 0.5rem 1rem; background: ${post.isFavorite ? '#fbbf24' : 'var(--bg-tertiary)'}; color: ${post.isFavorite ? 'white' : 'var(--text-strong)'}; border: 1px solid var(--border-light); border-radius: 4px; cursor: pointer; font-size: 0.875rem; white-space: nowrap;">${post.isFavorite ? '⭐ 즐겨찾기 해제' : '☆ 즐겨찾기'}</button>
            <button type="button" class="load-post-btn" data-post-id="${post.id}" style="padding: 0.5rem 1rem; background: var(--primary); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.875rem; white-space: nowrap;">📂 불러오기</button>
            <button type="button" class="copy-post-btn" data-post-id="${post.id}" style="padding: 0.5rem 1rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 4px; cursor: pointer; font-size: 0.875rem; white-space: nowrap;">📋 복사</button>
            <button type="button" class="preview-post-btn" data-post-id="${post.id}" style="padding: 0.5rem 1rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 4px; cursor: pointer; font-size: 0.875rem; white-space: nowrap;">👁️ 미리보기</button>
            <button type="button" class="open-folder-btn" data-post-id="${post.id}" style="padding: 0.5rem 1rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 4px; cursor: pointer; font-size: 0.875rem; white-space: nowrap; display: ${post.images && post.images.length > 0 ? 'block' : 'none'};">📁 폴더 열기</button>
            <button type="button" class="reuse-images-btn" data-post-id="${post.id}" style="padding: 0.5rem 1rem; background: #8b5cf6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.875rem; white-space: nowrap; display: ${post.images && post.images.length > 0 ? 'block' : 'none'};" title="이 글의 이미지를 현재 작업에 재사용">🖼️ 이미지 재사용</button>
            <button type="button" class="delete-post-btn" data-post-id="${post.id}" style="padding: 0.5rem 1rem; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.875rem; white-space: nowrap;">🗑️ 삭제</button>
          </div>
        </div>
      </div>
    `;
  };

  const groups = new Map<string, any[]>();
  for (const p of posts) {
    const key = normalizeGeneratedPostCategoryKey((p as any)?.category);
    const arr = groups.get(key) || [];
    arr.push(p);
    groups.set(key, arr);
  }

  const groupEntries = Array.from(groups.entries()).map(([key, items]) => ({
    key,
    label: getGeneratedPostCategoryLabel(key),
    items,
    collapsed: isGeneratedPostCategoryCollapsed(key),
  }));

  groupEntries.sort((a, b) => {
    if (a.key === 'uncategorized' && b.key !== 'uncategorized') return 1;
    if (b.key === 'uncategorized' && a.key !== 'uncategorized') return -1;
    const diff = b.items.length - a.items.length;
    if (diff !== 0) return diff;
    return a.label.localeCompare(b.label, 'ko');
  });

  listContainer.style.display = 'block';
  listContainer.style.gridTemplateColumns = '';
  listContainer.style.gap = '';

  listContainer.innerHTML = groupEntries.map((g) => {
    const icon = g.collapsed ? '▶' : '▼';
    const bodyStyle = g.collapsed ? 'display:none;' : 'display:block;';
    const bodyHtml = isGalleryView
      ? `<div class="posts-category-body" style="${bodyStyle}">
           <div class="posts-category-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1rem;">
             ${g.items.map(renderGalleryItem).join('')}
           </div>
         </div>`
      : `<div class="posts-category-body" style="${bodyStyle}">
           ${g.items.map(renderListItem).join('')}
         </div>`;

    return `
      <div class="posts-category-group" data-category-key="${escapeHtml(g.key)}" style="margin-bottom: 1rem;">
        <div class="posts-category-header" data-category-key="${escapeHtml(g.key)}" style="display:flex; align-items:center; justify-content:space-between; gap: 0.75rem; padding: 0.75rem 0.9rem; border-radius: 10px; background: var(--bg-tertiary); border: 1px solid var(--border-light); cursor: pointer; user-select: none;">
          <div style="display:flex; align-items:center; gap: 0.6rem; min-width: 0;">
            <span class="posts-category-toggle-icon" style="font-weight: 900; color: var(--text-strong);">${icon}</span>
            <div style="font-weight: 900; color: var(--text-strong); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${escapeHtml(g.label)}</div>
          </div>
          <div style="display:flex; align-items:center; gap: 0.5rem; flex-shrink: 0;">
            <span style="background: rgba(59,130,246,0.15); color: var(--text-strong); padding: 0.2rem 0.55rem; border-radius: 999px; font-size: 0.75rem; font-weight: 900;">${g.items.length}개</span>
          </div>
        </div>
        ${bodyHtml}
      </div>
    `;
  }).join('');

  listContainer.querySelectorAll('.posts-category-header').forEach((headerEl) => {
    headerEl.addEventListener('click', () => {
      const key = String((headerEl as HTMLElement).getAttribute('data-category-key') || '').trim();
      if (!key) return;
      const groupEl = listContainer.querySelector(`.posts-category-group[data-category-key="${CSS.escape(key)}"]`) as HTMLElement | null;
      if (!groupEl) return;
      const body = groupEl.querySelector('.posts-category-body') as HTMLElement | null;
      const icon = groupEl.querySelector('.posts-category-toggle-icon') as HTMLElement | null;
      if (!body) return;
      const willCollapse = body.style.display !== 'none';
      body.style.display = willCollapse ? 'none' : 'block';
      if (icon) icon.textContent = willCollapse ? '▶' : '▼';
      setGeneratedPostCategoryCollapsed(key, willCollapse);
    });
  });

  attachPostItemEventListeners(listContainer);
}

// ✅ 글 항목 이벤트 리스너 연결 (공통 함수)
function attachPostItemEventListeners(listContainer: HTMLElement): void {
  // 글 항목 클릭 시 미리보기
  listContainer.querySelectorAll('.post-item, .post-item-gallery').forEach(item => {
    item.addEventListener('click', (e) => {
      if ((e.target as HTMLElement).tagName === 'BUTTON' || (e.target as HTMLElement).tagName === 'INPUT') return;
      const postId = (item as HTMLElement).getAttribute('data-post-id');
      if (postId) previewGeneratedPost(postId);
    });
  });

  // ✅ 일괄 선택 체크박스 이벤트
  listContainer.querySelectorAll('.post-checkbox').forEach(checkbox => {
    checkbox.addEventListener('change', (e) => {
      e.stopPropagation();
      updateBatchDeleteButton();
    });
  });

  // 기존 이벤트 리스너들
  listContainer.querySelectorAll('.favorite-post-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const postId = (e.target as HTMLElement).getAttribute('data-post-id');
      if (postId) toggleFavoritePost(postId);
    });
  });

  listContainer.querySelectorAll('.load-post-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const postId = (e.target as HTMLElement).getAttribute('data-post-id');
      if (postId) loadGeneratedPostToFields(postId);
    });
  });

  listContainer.querySelectorAll('.copy-post-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const postId = (e.target as HTMLElement).getAttribute('data-post-id');
      if (postId) copyGeneratedPost(postId);
    });
  });

  listContainer.querySelectorAll('.preview-post-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const postId = (e.target as HTMLElement).getAttribute('data-post-id');
      if (postId) previewGeneratedPost(postId);
    });
  });

  listContainer.querySelectorAll('.open-folder-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const postId = (e.target as HTMLElement).getAttribute('data-post-id');
      if (postId) openPostImageFolder(postId);
    });
  });

  // ✅ 발행된 글 바로가기 버튼 (외부 브라우저로 열기)
  listContainer.querySelectorAll('.open-url-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const url = (e.target as HTMLElement).getAttribute('data-url');
      if (url) {
        window.api.openExternalUrl(url);
      }
    });
  });

  listContainer.querySelectorAll('.reuse-images-btn').forEach(btn => {
    btn.addEventListener('click', async (e) => {
      e.stopPropagation();
      const postId = (e.target as HTMLElement).getAttribute('data-post-id');
      if (postId) {
        await reusePostImages(postId);
      }
    });
  });

  listContainer.querySelectorAll('.delete-post-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const postId = (e.target as HTMLElement).getAttribute('data-post-id');
      if (postId && confirm('이 글과 관련된 이미지 폴더도 함께 삭제됩니다. 정말 삭제하시겠습니까?')) {
        deleteGeneratedPost(postId);
        refreshGeneratedPostsList();
      }
    });
  });

  // 썸네일 클릭 이벤트
  listContainer.querySelectorAll('.thumbnail-container').forEach(container => {
    container.addEventListener('click', (e) => {
      e.stopPropagation();
      const img = container.querySelector('img');
      if (img && img.src) {
        showImageModal(img.src);
      }
    });
  });
}

// ✅ 일괄 삭제 버튼 업데이트
function updateBatchDeleteButton(): void {
  const checkboxes = document.querySelectorAll('.post-checkbox:checked') as NodeListOf<HTMLInputElement>;
  const batchDeleteBtn = document.getElementById('posts-batch-delete-btn');

  if (batchDeleteBtn) {
    if (checkboxes.length > 0) {
      batchDeleteBtn.style.display = 'block';
      batchDeleteBtn.textContent = `🗑️ 선택삭제 (${checkboxes.length})`;
    } else {
      batchDeleteBtn.style.display = 'none';
    }
  }
}

// ✅ 전체 선택/해제
function toggleSelectAllPosts(): void {
  const checkboxes = document.querySelectorAll('.post-checkbox') as NodeListOf<HTMLInputElement>;
  const selectAllBtn = document.getElementById('posts-select-all-btn');
  const allChecked = Array.from(checkboxes).every(cb => cb.checked);

  checkboxes.forEach(cb => {
    cb.checked = !allChecked;
  });

  if (selectAllBtn) {
    selectAllBtn.textContent = allChecked ? '☑️ 전체선택' : '☐ 선택해제';
  }

  updateBatchDeleteButton();
}

// ✅ 일괄 삭제
function batchDeletePosts(): void {
  const checkboxes = document.querySelectorAll('.post-checkbox:checked') as NodeListOf<HTMLInputElement>;
  const postIds = Array.from(checkboxes).map(cb => cb.getAttribute('data-post-id')).filter(id => id !== null) as string[];

  if (postIds.length === 0) {
    alert('삭제할 글을 선택해주세요.');
    return;
  }

  if (confirm(`선택한 ${postIds.length}개의 글을 삭제하시겠습니까?\n\n관련된 이미지 폴더도 함께 삭제됩니다.`)) {
    postIds.forEach(postId => {
      if (postId) deleteGeneratedPost(postId);
    });
    refreshGeneratedPostsList();
    appendLog(`🗑️ ${postIds.length}개의 글이 일괄 삭제되었습니다.`);
  }
}

// ✅ 이미지 모달 (확대 보기) - window 객체에 등록하여 inline onclick에서 호출 가능
function showImageModal(imageUrl: string): void {
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.9); z-index: 10001; display: flex;
    align-items: center; justify-content: center; padding: 2rem;
    cursor: pointer;
  `;

  modal.innerHTML = `
    <div style="position: relative; width: min(1100px, 92vw); height: min(78vh, 720px); overflow: hidden; border-radius: 8px; background: rgba(0,0,0,0.2);">
      <button type="button" class="close-image-modal-btn" style="position: absolute; top: -2rem; right: 0; background: rgba(255,255,255,0.2); border: none; border-radius: 50%; width: 32px; height: 32px; cursor: pointer; font-size: 1.5rem; color: white; display: flex; align-items: center; justify-content: center;">×</button>
      <img src="${imageUrl}" style="width: 100%; height: 100%; object-fit: contain;" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22%3E%3Ctext x=%2250%22 y=%2250%22 text-anchor=%22middle%22 dominant-baseline=%22middle%22 fill=%22%23999%22%3E이미지 로드 실패%3C/text%3E%3C/svg%3E';">
    </div>
  `;

  document.body.appendChild(modal);

  const closeBtn = modal.querySelector('.close-image-modal-btn');
  if (closeBtn) {
    closeBtn.addEventListener('click', () => modal.remove());
  }

  modal.addEventListener('click', (e) => {
    if (e.target === modal || (e.target as HTMLElement).classList.contains('close-image-modal-btn')) {
      modal.remove();
    }
  });

  // ESC 키로 닫기
  const handleKeydown = (e: KeyboardEvent) => {
    if (e.key === 'Escape') {
      modal.remove();
      document.removeEventListener('keydown', handleKeydown);
    }
  };
  document.addEventListener('keydown', handleKeydown);
}

function showHeadingImagesModal(encodedHeadingTitle: string, initialImageUrl?: string): void {
  const decodeHeading = (v: string): string => {
    try {
      return decodeURIComponent(String(v || '').trim());
    } catch {
      return String(v || '').trim();
    }
  };

  const headingTitle = decodeHeading(encodedHeadingTitle);
  if (!headingTitle) {
    if (initialImageUrl) showImageModal(initialImageUrl);
    return;
  }

  const titleKey = ImageManager.resolveHeadingKey(headingTitle);
  const getImagesForHeading = (): any[] => {
    try {
      const arr = ImageManager.getImages(titleKey);
      return Array.isArray(arr) ? arr : [];
    } catch {
      return [];
    }
  };

  const toUrl = (img: any): string => {
    const raw = img?.url || img?.filePath || img?.previewDataUrl || '';
    return toFileUrlMaybe(String(raw || '').trim());
  };

  let images = getImagesForHeading();
  if (images.length === 0) {
    if (initialImageUrl) showImageModal(initialImageUrl);
    return;
  }

  let currentIndex = 0;
  const initialDecoded = initialImageUrl ? decodeHeading(String(initialImageUrl || '').trim()) : '';
  const initialNorm = initialDecoded ? toFileUrlMaybe(String(initialDecoded || '').trim()) : '';
  if (initialNorm) {
    const idx = images.findIndex((img: any) => toUrl(img) === initialNorm);
    if (idx >= 0) currentIndex = idx;
  }

  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.92); z-index: 10001; display: flex;
    align-items: center; justify-content: center; padding: 2rem;
  `;

  const render = () => {
    images = getImagesForHeading();
    if (images.length === 0) {
      modal.remove();
      return;
    }
    if (currentIndex < 0) currentIndex = 0;
    if (currentIndex >= images.length) currentIndex = images.length - 1;

    const url = toUrl(images[currentIndex]);
    const titleText = escapeHtml(String(headingTitle || '').trim());
    const counterText = `${currentIndex + 1} / ${images.length}`;

    modal.innerHTML = `
      <div style="position: relative; width: min(1100px, 92vw); height: min(78vh, 720px); display: flex; align-items: center; justify-content: center; overflow: hidden; border-radius: 10px; background: rgba(0,0,0,0.2);">
        <button type="button" class="heading-image-modal-close" style="position: absolute; top: -2.2rem; right: 0; background: rgba(255,255,255,0.2); border: none; border-radius: 50%; width: 32px; height: 32px; cursor: pointer; font-size: 1.5rem; color: white; display: flex; align-items: center; justify-content: center;">×</button>
        <div style="position: absolute; top: -2.1rem; left: 0; color: rgba(255,255,255,0.92); font-weight: 700; font-size: 0.95rem; max-width: 70vw; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${titleText}</div>
        <div style="position: absolute; bottom: -2.1rem; left: 0; color: rgba(255,255,255,0.85); font-size: 0.9rem; font-weight: 700;">${counterText}</div>

        <button type="button" class="heading-image-modal-prev" style="position: absolute; left: 0.75rem; top: 50%; transform: translateY(-50%); z-index: 30; background: rgba(255,255,255,0.15); color: white; border: 1px solid rgba(255,255,255,0.25); border-radius: 12px; padding: 0.75rem 0.9rem; cursor: pointer; font-weight: 900;">◀</button>
        <button type="button" class="heading-image-modal-next" style="position: absolute; right: 0.75rem; top: 50%; transform: translateY(-50%); z-index: 30; background: rgba(255,255,255,0.15); color: white; border: 1px solid rgba(255,255,255,0.25); border-radius: 12px; padding: 0.75rem 0.9rem; cursor: pointer; font-weight: 900;">▶</button>

        <img class="heading-image-modal-img" src="${escapeHtml(url)}" style="width: 100%; height: 100%; object-fit: contain;" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22%3E%3Ctext x=%2250%22 y=%2250%22 text-anchor=%22middle%22 dominant-baseline=%22middle%22 fill=%22%23999%22%3E이미지 로드 실패%3C/text%3E%3C/svg%3E';" />

        <div style="position: absolute; bottom: 1rem; right: 1rem; display: flex; gap: 0.5rem; z-index: 40;">
          <button type="button" class="heading-image-modal-delete" style="background: rgba(239,68,68,0.18); color: #ef4444; border: 1px solid rgba(239,68,68,0.35); border-radius: 10px; padding: 0.65rem 0.9rem; cursor: pointer; font-weight: 900;">삭제</button>
          <button type="button" class="heading-image-modal-close2" style="background: rgba(255,255,255,0.15); color: white; border: 1px solid rgba(255,255,255,0.25); border-radius: 10px; padding: 0.65rem 0.9rem; cursor: pointer; font-weight: 800;">닫기</button>
        </div>
      </div>
    `;

    (modal.querySelector('.heading-image-modal-prev') as HTMLButtonElement | null)?.addEventListener('click', () => {
      currentIndex = (currentIndex - 1 + images.length) % images.length;
      render();
    });
    (modal.querySelector('.heading-image-modal-next') as HTMLButtonElement | null)?.addEventListener('click', () => {
      currentIndex = (currentIndex + 1) % images.length;
      render();
    });

    (modal.querySelector('.heading-image-modal-close') as HTMLButtonElement | null)?.addEventListener('click', () => {
      modal.remove();
    });

    (modal.querySelector('.heading-image-modal-close2') as HTMLButtonElement | null)?.addEventListener('click', () => {
      modal.remove();
    });

    (modal.querySelector('.heading-image-modal-delete') as HTMLButtonElement | null)?.addEventListener('click', () => {
      if (!confirm('이 이미지를 제거하시겠습니까?')) return;
      try {
        ImageManager.removeImageAtIndex(titleKey, currentIndex);
      } catch {
        return;
      }

      try {
        const allImages = ImageManager.getAllImages();
        (window as any).imageManagementGeneratedImages = allImages;
        syncGlobalImagesFromImageManager();
        const sc: any = (window as any).currentStructuredContent;
        if (sc?.headings) updateUnifiedImagePreview(sc.headings, allImages);
        displayGeneratedImages(allImages);
        updatePromptItemsWithImages(allImages);
        ImageManager.syncAllPreviews();
      } catch {
        // ignore
      }

      images = getImagesForHeading();
      if (images.length === 0) {
        modal.remove();
        return;
      }
      if (currentIndex >= images.length) currentIndex = images.length - 1;
      render();
    });
  };

  document.body.appendChild(modal);

  modal.addEventListener('click', (e) => {
    if (e.target === modal) modal.remove();
  });

  const handleKeydown = (e: KeyboardEvent) => {
    if (e.key === 'Escape') {
      modal.remove();
      document.removeEventListener('keydown', handleKeydown);
      return;
    }
    if (e.key === 'ArrowLeft') {
      currentIndex = (currentIndex - 1 + images.length) % images.length;
      render();
    }
    if (e.key === 'ArrowRight') {
      currentIndex = (currentIndex + 1) % images.length;
      render();
    }
  };
  document.addEventListener('keydown', handleKeydown);

  const observer = new MutationObserver(() => {
    if (!modal.isConnected) {
      document.removeEventListener('keydown', handleKeydown);
      observer.disconnect();
    }
  });
  observer.observe(document.body, { childList: true, subtree: true });

  render();
}

// ✅ 통계 대시보드 표시
function showPostsStatsDashboard(): void {
  const posts = loadGeneratedPosts();
  const totalCount = posts.length;
  const totalImages = posts.reduce((sum, p) => sum + (p.images?.length || 0), 0);
  const totalChars = posts.reduce((sum, p) => sum + p.content.length, 0);
  const avgChars = totalCount > 0 ? Math.round(totalChars / totalCount) : 0;
  const publishedCount = posts.filter(p => p.publishedUrl).length;
  const favoritesCount = posts.filter(p => p.isFavorite).length;
  const withImagesCount = posts.filter(p => p.images && p.images.length > 0).length;
  const withHeadingsCount = posts.filter(p => p.headings && p.headings.length > 0).length;

  // 날짜별 통계
  const dateStats: Record<string, number> = {};
  posts.forEach(post => {
    const date = new Date(post.createdAt).toISOString().split('T')[0];
    dateStats[date] = (dateStats[date] || 0) + 1;
  });
  const mostActiveDate = Object.entries(dateStats).sort((a, b) => b[1] - a[1])[0];

  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.7); z-index: 10000; display: flex;
    align-items: center; justify-content: center; padding: 2rem;
  `;

  modal.innerHTML = `
    <div style="background: var(--bg-primary); border-radius: 12px; padding: 2rem; max-width: 800px; max-height: 90vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.3); position: relative;">
      <button type="button" class="close-stats-modal-btn" style="position: absolute; top: 1rem; right: 1rem; background: var(--bg-tertiary); border: none; border-radius: 50%; width: 32px; height: 32px; cursor: pointer; font-size: 1.25rem; display: flex; align-items: center; justify-content: center;">×</button>
      <h2 style="margin: 0 0 1.5rem 0; color: var(--text-strong); font-size: 1.5rem;">📊 글 통계 대시보드</h2>
      
      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
        <div style="background: linear-gradient(135deg, #3b82f6, #1d4ed8); padding: 1.5rem; border-radius: 8px; color: white;">
          <div style="font-size: 2rem; font-weight: 700; margin-bottom: 0.5rem;">${totalCount}</div>
          <div style="font-size: 0.875rem; opacity: 0.9;">총 글 수</div>
        </div>
        <div style="background: linear-gradient(135deg, #10b981, #059669); padding: 1.5rem; border-radius: 8px; color: white;">
          <div style="font-size: 2rem; font-weight: 700; margin-bottom: 0.5rem;">${publishedCount}</div>
          <div style="font-size: 0.875rem; opacity: 0.9;">발행된 글</div>
        </div>
        <div style="background: linear-gradient(135deg, #f59e0b, #d97706); padding: 1.5rem; border-radius: 8px; color: white;">
          <div style="font-size: 2rem; font-weight: 700; margin-bottom: 0.5rem;">${totalImages}</div>
          <div style="font-size: 0.875rem; opacity: 0.9;">총 이미지</div>
        </div>
        <div style="background: linear-gradient(135deg, #8b5cf6, #7c3aed); padding: 1.5rem; border-radius: 8px; color: white;">
          <div style="font-size: 2rem; font-weight: 700; margin-bottom: 0.5rem;">${favoritesCount}</div>
          <div style="font-size: 0.875rem; opacity: 0.9;">즐겨찾기</div>
        </div>
      </div>
      
      <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; margin-bottom: 1.5rem;">
        <h3 style="margin: 0 0 1rem 0; color: var(--text-strong); font-size: 1.1rem;">📈 상세 통계</h3>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
          <div>
            <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.25rem;">평균 글자 수</div>
            <div style="font-size: 1.5rem; font-weight: 600; color: var(--text-strong);">${avgChars.toLocaleString()}자</div>
          </div>
          <div>
            <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.25rem;">이미지 있는 글</div>
            <div style="font-size: 1.5rem; font-weight: 600; color: var(--text-strong);">${withImagesCount}개 (${totalCount > 0 ? Math.round(withImagesCount / totalCount * 100) : 0}%)</div>
          </div>
          <div>
            <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.25rem;">소제목 있는 글</div>
            <div style="font-size: 1.5rem; font-weight: 600; color: var(--text-strong);">${withHeadingsCount}개 (${totalCount > 0 ? Math.round(withHeadingsCount / totalCount * 100) : 0}%)</div>
          </div>
          <div>
            <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.25rem;">발행률</div>
            <div style="font-size: 1.5rem; font-weight: 600; color: var(--text-strong);">${totalCount > 0 ? Math.round(publishedCount / totalCount * 100) : 0}%</div>
          </div>
        </div>
      </div>
      
      ${mostActiveDate ? `
        <div style="background: var(--bg-secondary); padding: 1.5rem; border-radius: 8px;">
          <h3 style="margin: 0 0 1rem 0; color: var(--text-strong); font-size: 1.1rem;">📅 활동 통계</h3>
          <div style="font-size: 0.875rem; color: var(--text-muted);">
            가장 활발한 날: <span style="color: var(--text-strong); font-weight: 600;">${mostActiveDate[0]}</span> (${mostActiveDate[1]}개 글 작성)
          </div>
        </div>
      ` : ''}
      
      <div style="display: flex; gap: 0.5rem; margin-top: 1.5rem;">
        <button type="button" class="close-stats-modal-btn" style="flex: 1; padding: 0.75rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 8px; cursor: pointer; font-weight: 600;">닫기</button>
      </div>
    </div>
  `;

  document.body.appendChild(modal);

  modal.querySelectorAll('.close-stats-modal-btn').forEach(btn => {
    btn.addEventListener('click', () => modal.remove());
  });

  modal.addEventListener('click', (e) => {
    if (e.target === modal) modal.remove();
  });
}

// ✅ 갤러리 뷰 전환
function togglePostsView(): void {
  isGalleryView = !isGalleryView;
  const viewToggleBtn = document.getElementById('posts-view-toggle-btn');
  if (viewToggleBtn) {
    viewToggleBtn.textContent = isGalleryView ? '📋 리스트' : '🖼️ 갤러리';
  }
  refreshGeneratedPostsList();
}

// ✅ 생성된 글을 필드에 불러오기
async function loadGeneratedPostToFields(postId: string): Promise<void> {
  const post = loadGeneratedPost(postId);
  if (!post) {
    alert('글을 찾을 수 없습니다.');
    return;
  }

  // ✅ 기존 콘텐츠 및 이미지 완전 초기화 (이전 글 데이터 충돌 방지)
  currentStructuredContent = null;
  (window as any).currentStructuredContent = null;
  generatedImages = [];
  (window as any).imageManagementGeneratedImages = [];
  ImageManager.clear(); // ✅ ImageManager도 초기화 (이전 글의 이미지 매핑 제거)
  currentPostId = postId; // ✅ 현재 글 ID 설정

  // structuredContent 재구성
  const structuredContent = {
    selectedTitle: post.title,
    bodyPlain: post.content,
    content: post.content,
    hashtags: post.hashtags,
    headings: post.headings || []
  };

  currentStructuredContent = structuredContent as any;
  (window as any).currentStructuredContent = structuredContent;

  // ✅ 반자동 모드 섹션 표시 및 필드 채우기
  const semiAutoSection = document.getElementById('unified-semi-auto-section');
  if (semiAutoSection) {
    semiAutoSection.style.display = 'block';

    // 부드러운 애니메이션
    semiAutoSection.style.opacity = '0';
    setTimeout(() => {
      semiAutoSection.style.opacity = '1';
      semiAutoSection.style.transition = 'opacity 0.5s ease';
    }, 100);
  }

  // ✅ 반자동 모드 필드에 채우기 (수정 가능)
  const titleInput = document.getElementById('unified-generated-title') as HTMLInputElement;
  const contentTextarea = document.getElementById('unified-generated-content') as HTMLTextAreaElement;
  const hashtagsInput = document.getElementById('unified-generated-hashtags') as HTMLInputElement;
  const imageTitleInput = document.getElementById('image-title') as HTMLInputElement;

  if (titleInput) {
    titleInput.value = post.title;
    titleInput.readOnly = false; // 수정 가능하게
  }
  if (contentTextarea) {
    const normalized = normalizeReadableBodyText(post.content);
    contentTextarea.value = normalized;
    contentTextarea.readOnly = false; // 수정 가능하게
  }
  if (hashtagsInput) {
    hashtagsInput.value = post.hashtags.join(' ');
    hashtagsInput.readOnly = false; // 수정 가능하게
  }
  if (imageTitleInput) {
    imageTitleInput.value = post.title;
  }

  // ✅ 이미지 불러오기 (저장된 이미지 경로 사용 및 검증)
  if (post.images && post.images.length > 0) {
    // 이미지 경로 검증 및 복구
    let validImages = await validateAndRecoverImages(post.images, postId);
    if (validImages.length > 0) {
      const headingTitles = (structuredContent?.headings || [])
        .map((h: any) => (typeof h === 'string' ? h : (h?.title || '')))
        .map((t: string) => String(t || '').trim())
        .filter((t: string) => t.length > 0);

      if (headingTitles.length > 0) {
        validImages = validImages.map((img: any, idx: number) => {
          const heading = String(img?.heading || '').trim();
          if (!heading && idx < headingTitles.length) {
            const fixedHeading = headingTitles[idx];
            return {
              ...img,
              heading: fixedHeading,
              prompt: img?.prompt || fixedHeading,
            };
          }
          return img;
        });
      }

      generatedImages = validImages;
      (window as any).imageManagementGeneratedImages = validImages;
      appendLog(`🖼️ ${validImages.length}개의 이미지를 불러왔습니다.`);

      try {
        hydrateImageManagerFromImages(structuredContent, validImages);
        appendLog(`🔗 ImageManager에 ${validImages.length}개 이미지 등록 완료`);
      } catch {
        // ignore
      }

      // 일부 이미지가 복구된 경우 저장
      if (validImages.length !== post.images.length) {
        const updatedPost = { ...post, images: validImages };
        const posts = loadGeneratedPosts();
        const index = posts.findIndex(p => p.id === postId);
        if (index >= 0) {
          posts[index] = updatedPost;
          localStorage.setItem(GENERATED_POSTS_KEY, JSON.stringify(posts));
        }
      }
    } else {
      appendLog(`⚠️ 저장된 이미지 경로가 유효하지 않습니다.`);
    }
  } else {
    // 이미지가 없으면 글 ID 폴더에서 이미지 찾기 시도
    appendLog(`📁 글 ID 폴더에서 이미지를 확인합니다: ${postId}`);
    const folderImages = await loadImagesFromFolder(postId);
    if (folderImages.length > 0) {
      const headingTitles = (structuredContent?.headings || [])
        .map((h: any) => (typeof h === 'string' ? h : (h?.title || '')))
        .map((t: string) => String(t || '').trim())
        .filter((t: string) => t.length > 0);

      const fixedImages = headingTitles.length > 0
        ? folderImages.map((img: any, idx: number) => {
          const heading = String(img?.heading || '').trim();
          if (!heading && idx < headingTitles.length) {
            const fixedHeading = headingTitles[idx];
            return {
              ...img,
              heading: fixedHeading,
              prompt: img?.prompt || fixedHeading,
            };
          }
          return img;
        })
        : folderImages;

      generatedImages = fixedImages;
      (window as any).imageManagementGeneratedImages = fixedImages;
      appendLog(`🖼️ 폴더에서 ${folderImages.length}개의 이미지를 찾았습니다.`);

      try {
        hydrateImageManagerFromImages(structuredContent, fixedImages);
        appendLog(`🔗 ImageManager에 ${fixedImages.length}개 이미지 등록 완료`);
      } catch {
        // ignore
      }
    }
  }

  appendLog(`📂 생성된 글을 불러왔습니다: "${post.title}"`);
  appendLog(`📝 제목: "${post.title}"`);
  appendLog(`📄 본문: ${post.content.length}자`);
  appendLog(`🏷️ 해시태그: ${post.hashtags.join(', ')}`);
  appendLog(`🖼️ 이미지: ${generatedImages.length}개`);
  appendLog(`✅ 반자동 모드에서 수정 후 발행할 수 있습니다.`);

  // ✅ [2026-01-22] 카테고리 복원
  if ((post as any).category) {
    const categorySelect = document.getElementById('unified-category-select') as HTMLSelectElement;
    if (categorySelect) {
      // 카테고리 옵션 중 일치하는 것 선택
      const options = Array.from(categorySelect.options);
      const matchingOption = options.find(opt =>
        opt.value === (post as any).category ||
        opt.textContent?.includes((post as any).category)
      );
      if (matchingOption) {
        categorySelect.value = matchingOption.value;
        appendLog(`📁 카테고리 복원: ${(post as any).category}`);
      }
    }
  }

  // ✅ [2026-01-22] 쇼핑커넥트 모드 복원 (affiliateLink, contentMode)
  if ((post as any).affiliateLink) {
    const affiliateLinkInput = document.getElementById('shopping-connect-affiliate-link') as HTMLInputElement;
    if (affiliateLinkInput) {
      affiliateLinkInput.value = (post as any).affiliateLink;
      appendLog(`🔗 제휴링크 복원: ${(post as any).affiliateLink.substring(0, 50)}...`);
    }
    // 쇼핑커넥트 모드 활성화 (contentMode가 affiliate인 경우)
    if ((post as any).contentMode === 'affiliate') {
      const affiliateModeBtn = document.getElementById('affiliate-mode-btn');
      if (affiliateModeBtn) {
        affiliateModeBtn.click();
        appendLog(`🛒 쇼핑커넥트 모드 복원`);
      }
    }
  }

  // ✅ [2026-01-22] CTA 필드 복원
  if ((post as any).ctas && (post as any).ctas.length > 0) {
    const ctaItemsContainer = document.getElementById('unified-cta-items-container');
    if (ctaItemsContainer) {
      // 기존 CTA 삭제 후 복원
      ctaItemsContainer.innerHTML = '';
      for (const cta of (post as any).ctas) {
        // CTA 추가 버튼 클릭하여 새 CTA 생성
        const addCtaBtn = document.getElementById('unified-add-cta-btn');
        if (addCtaBtn) addCtaBtn.click();
        // 마지막 추가된 CTA 필드에 값 설정
        const ctaItems = ctaItemsContainer.querySelectorAll('.cta-item');
        const lastCtaItem = ctaItems[ctaItems.length - 1];
        if (lastCtaItem) {
          const textInput = lastCtaItem.querySelector('input[data-field="text"], input:first-of-type') as HTMLInputElement;
          const linkInput = lastCtaItem.querySelector('input[data-field="link"], input:last-of-type') as HTMLInputElement;
          if (textInput) textInput.value = cta.text || '';
          if (linkInput) linkInput.value = cta.link || '';
        }
      }
      appendLog(`📎 CTA ${(post as any).ctas.length}개 복원`);
    }
  } else if ((post as any).ctaText) {
    // 단일 CTA 복원, 컨테이너에 없는 경우 기본 필드로
    const ctaTextInput = document.getElementById('unified-cta-text') as HTMLInputElement;
    const ctaLinkInput = document.getElementById('unified-cta-link') as HTMLInputElement;
    if (ctaTextInput) ctaTextInput.value = (post as any).ctaText || '';
    if (ctaLinkInput) ctaLinkInput.value = (post as any).ctaLink || '';
    appendLog(`📎 CTA 복원: ${(post as any).ctaText}`);
  }

  // ✅ 반자동 모드 섹션으로 스크롤
  setTimeout(() => {
    const semiAutoSection = document.getElementById('unified-semi-auto-section');
    if (semiAutoSection) {
      semiAutoSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }, 300);

  // ✅ 글 불러오기 완료 후 자동 소제목 분석
  if (structuredContent?.headings?.length > 0) {
    setTimeout(async () => {
      try {
        appendLog('🔍 자동 소제목 분석 시작...');
        await autoAnalyzeHeadings(structuredContent);

        // ✅ 소제목 분석 완료 후 모든 미리보기 동기화 (영어 프롬프트 + 생성된 이미지)
        ImageManager.setHeadings(structuredContent.headings);
        try {
          syncGlobalImagesFromImageManager();
        } catch {
          // ignore
        }

        const allImagesAfter = (() => {
          try {
            const all = ImageManager.getAllImages();
            return Array.isArray(all) ? all : [];
          } catch {
            return [];
          }
        })();

        displayGeneratedImages(allImagesAfter.length > 0 ? allImagesAfter : generatedImages);
        ImageManager.syncAllPreviews();

        // ✅ 영어 프롬프트 미리보기에도 이미지 업데이트
        (window as any).imageManagementGeneratedImages = allImagesAfter.length > 0 ? allImagesAfter : generatedImages;
        updatePromptItemsWithImages(allImagesAfter.length > 0 ? allImagesAfter : generatedImages);

        appendLog('✅ 소제목 분석 완료! 이미지를 배치할 수 있습니다.');
      } catch (error) {
        appendLog(`⚠️ 소제목 자동 분석 실패: ${(error as Error).message}`);
      }
    }, 500);
  } else {
    // ✅ 소제목이 없어도 이미지는 표시
    const allImagesAfter = (() => {
      try {
        const all = ImageManager.getAllImages();
        return Array.isArray(all) ? all : [];
      } catch {
        return [];
      }
    })();

    displayGeneratedImages(allImagesAfter.length > 0 ? allImagesAfter : generatedImages);

    // ✅ 영어 프롬프트 미리보기에도 이미지 업데이트
    (window as any).imageManagementGeneratedImages = allImagesAfter.length > 0 ? allImagesAfter : generatedImages;
    updatePromptItemsWithImages(allImagesAfter.length > 0 ? allImagesAfter : generatedImages);
  }

  // ✅ CTA 불러오기 (저장된 CTA가 있으면 사용, 없으면 자동 생성)
  const ctaTextInput = document.getElementById('unified-cta-text') as HTMLInputElement;
  const ctaLinkInput = document.getElementById('unified-cta-link') as HTMLInputElement;
  const selectedPostInfo = document.getElementById('selected-previous-post-info') as HTMLDivElement;

  if (post.ctaText || post.ctaLink) {
    // 저장된 CTA가 있으면 불러오기
    if (ctaTextInput) ctaTextInput.value = post.ctaText || '';
    if (ctaLinkInput) ctaLinkInput.value = post.ctaLink || '';
    if (selectedPostInfo) selectedPostInfo.style.display = 'none';
    appendLog(`🔗 저장된 CTA 불러옴: "${post.ctaText || '(없음)'}"`);
  } else {
    // 저장된 CTA가 없으면 자동 생성
    autoGenerateCTA(structuredContent);
  }

  // ✅ 위험 지표 업데이트 (AI탐지, 법적위험, SEO점수)
  updateRiskIndicators(structuredContent as any);

  toastManager.success(`✅ 생성된 글을 불러왔습니다! 반자동 모드에서 수정 후 발행할 수 있습니다.`);
}

// ✅ 이미지 경로 검증 및 복구 (+ prompt 필드 자동 추가)
async function validateAndRecoverImages(images: any[], postId: string): Promise<any[]> {
  const validImages: any[] = [];

  for (let i = 0; i < images.length; i++) {
    const img = images[i];

    // ✅ prompt 필드가 없으면 heading 또는 기본값 사용
    const ensurePrompt = (imgObj: any) => {
      const rawFilePath = String(imgObj.filePath || '').trim();
      const toFileUrl = (p: string): string => {
        const cleaned = String(p || '')
          .replace(/^file:\/\//i, '')
          .replace(/^\/+/, '')
          .replace(/\\/g, '/');
        if (!cleaned) return '';
        return `file:///${cleaned}`;
      };
      const isRenderableUrl = (u: string): boolean => /^(https?:\/\/|data:|blob:|file:\/\/)/i.test(String(u || '').trim());

      const fileUrl = rawFilePath ? toFileUrl(rawFilePath) : '';
      const candidate = String(imgObj.previewDataUrl || imgObj.url || '').trim();
      const displayUrl = candidate
        ? (isRenderableUrl(candidate) ? candidate : toFileUrl(candidate))
        : (fileUrl || '');

      return {
        ...imgObj,
        prompt: imgObj.prompt || imgObj.heading || `이미지 ${i + 1}`,
        url: displayUrl,
        previewDataUrl: displayUrl,
      };
    };

    const isRenderableUrl = (u: string): boolean => /^(https?:\/\/|data:|blob:)/i.test(String(u || '').trim());
    const filePathStr = String(img?.filePath || '').trim();
    const candidateStr = String(img?.previewDataUrl || img?.url || '').trim();

    // ✅ data:/blob:/http(s) 등은 로컬 파일 검증 대상이 아님 (재사용 시 base64 조각이 filePath에 들어오는 케이스 방지)
    if (isRenderableUrl(filePathStr)) {
      validImages.push(ensurePrompt(img));
      continue;
    }
    if (isRenderableUrl(candidateStr)) {
      validImages.push(ensurePrompt({ ...img, filePath: '' }));
      continue;
    }

    // URL인 경우 그대로 사용
    if (img.filePath && (img.filePath.startsWith('http://') || img.filePath.startsWith('https://'))) {
      validImages.push(ensurePrompt(img));
      continue;
    }

    // 로컬 파일 경로인 경우 검증
    if (img.filePath) {
      try {
        // 파일 존재 확인 (IPC를 통해)
        let exists = false;
        if (window.api.checkFileExists) {
          const raw = String(img.filePath)
            .replace(/^file:\/\//i, '')
            .replace(/^\/+/, '')
            .replace(/\\/g, '/');
          exists = await window.api.checkFileExists(raw);
        }

        if (exists) {
          // ✅ 로컬 경로는 브라우저 표시용 file:/// 보장
          const raw = String(img.filePath)
            .replace(/^file:\/\//i, '')
            .replace(/^\/+/, '')
            .replace(/\\/g, '/');
          validImages.push(ensurePrompt({
            ...img,
            filePath: raw,
          }));
        } else {
          // 파일이 없으면 폴더에서 찾기 시도
          const os = await import('os');
          const path = await import('path');
          if (!window.api.getUserHomeDir || !window.api.checkFileExists) {
            console.error('[Image] 파일 시스템 API를 사용할 수 없습니다.');
            continue;
          }

          const originalPath = String(img.filePath).replace(/^file:\/\//i, '').replace(/^\/+/, '');
          const fileName = originalPath.split(/[/\\]/).pop() || '';

          const basePath = await getRequiredImageBasePath();

          const folderPath = `${basePath}/${postId}`.replace(/\\/g, '/');
          const folderFilePath = `${folderPath}/${fileName}`.replace(/\\/g, '/');

          // 폴더에서 이미지 찾기
          const exists = await window.api.checkFileExists(folderFilePath);
          if (exists) {
            // 폴더에서 찾았으면 경로 업데이트
            validImages.push(ensurePrompt({ ...img, filePath: folderFilePath }));
            appendLog(`✅ 이미지 경로 복구: ${fileName}`);
          } else {
            // 폴더에도 없으면 건너뛰기
            appendLog(`⚠️ 이미지를 찾을 수 없습니다: ${fileName}`);
          }
        }
      } catch (error) {
        // 검증 실패 시 건너뛰기
        console.warn('이미지 검증 실패:', error);
      }
    }
  }

  return validImages;
}

// ✅ 즐겨찾기 토글
function toggleFavoritePost(postId: string): void {
  try {
    const posts = loadGeneratedPosts();
    const post = posts.find(p => p.id === postId);
    if (!post) return;

    post.isFavorite = !post.isFavorite;
    if (post.isFavorite) {
      post.updatedAt = new Date().toISOString();
    }

    const index = posts.findIndex(p => p.id === postId);
    if (index >= 0) {
      posts[index] = post;
      localStorage.setItem(GENERATED_POSTS_KEY, JSON.stringify(posts));
      appendLog(`⭐ 즐겨찾기 ${post.isFavorite ? '추가' : '해제'}: "${post.title}"`);
      refreshGeneratedPostsList();
    }
  } catch (error) {
    console.error('즐겨찾기 토글 실패:', error);
  }
}

// ✅ 글의 이미지 재사용
async function reusePostImages(postId: string): Promise<void> {
  try {
    const post = loadGeneratedPost(postId);
    if (!post) {
      alert('글을 찾을 수 없습니다.');
      return;
    }

    if (!post.images || post.images.length === 0) {
      alert('이 글에는 이미지가 없습니다.');
      return;
    }

    // 이미지 경로 검증 및 복구
    let validImages = await validateAndRecoverImages(post.images, postId);

    if (validImages.length === 0) {
      // 폴더에서 이미지 찾기 시도
      const folderImages = await loadImagesFromFolder(postId);
      if (folderImages.length === 0) {
        alert('이미지를 찾을 수 없습니다.');
        return;
      }
      validImages = folderImages;
    }

    // ✅ 현재 이미지 상태를 선택한 글의 이미지 세트로 완전히 교체
    // 1) ImageManager 초기화
    ImageManager.clear();

    // 2) currentStructuredContent 기준으로 소제목 목록 설정 (없으면 post.structuredContent 사용)
    const sc: any = (window as any).currentStructuredContent || currentStructuredContent || post.structuredContent || {};
    const headings = Array.isArray(sc?.headings) ? sc.headings : (post.structuredContent?.headings || []);
    if (Array.isArray(headings) && headings.length > 0) {
      ImageManager.setHeadings(headings);
    }

    // 3) heading 정보 보정 (loadGeneratedPostToFields 와 동일한 방식 재사용)
    const headingTitles = (headings || [])
      .map((h: any) => (typeof h === 'string' ? h : (h?.title || '')))
      .map((t: string) => String(t || '').trim())
      .filter((t: string) => t.length > 0);

    if (headingTitles.length > 0) {
      validImages = validImages.map((img: any, idx: number) => {
        const heading = String(img?.heading || '').trim();
        if (!heading && idx < headingTitles.length) {
          const fixedHeading = headingTitles[idx];
          return {
            ...img,
            heading: fixedHeading,
            prompt: img?.prompt || fixedHeading,
          };
        }
        return img;
      });
    }

    // 4) ImageManager에 이미지 등록 (소제목별로 세팅)
    validImages.forEach((img: any) => {
      const heading = String(img?.heading || '').trim();
      if (!heading) return;
      const candidate = {
        ...img,
        timestamp: Date.now(),
      };

      try {
        // ✅ 소제목당 여러 장 지원 (가능하면 addImage)
        ImageManager.addImage(heading, candidate);
      } catch {
        ImageManager.setImage(heading, candidate);
      }
    });

    // 5) 전역 배열/상태 동기화
    generatedImages = [...validImages];
    (window as any).generatedImages = generatedImages;
    (window as any).imageManagementGeneratedImages = [...validImages];

    appendLog(`🖼️ ${validImages.length}개의 이미지를 재사용했습니다. (${post.title})`);
    alert(`✅ ${validImages.length}개의 이미지를 재사용했습니다!\n\n제목: ${post.title}`);

    // 이미지 관리 탭으로 전환하고 미리보기 업데이트
    const imagesTab = document.querySelector('[data-tab="images"]') as HTMLElement;
    if (imagesTab) {
      imagesTab.click();
    }

    // 이미지/영상 미리보기 전체 업데이트
    const imagesForUi = (() => {
      try {
        const all = ImageManager.getAllImages();
        if (Array.isArray(all) && all.length > 0) return all;
      } catch {
        // ignore
      }
      return Array.isArray(generatedImages) ? generatedImages : [];
    })();

    if (Array.isArray(headings) && headings.length > 0) {
      updateUnifiedImagePreview(headings, imagesForUi);
    } else {
      updateUnifiedImagePreview([], imagesForUi);
    }

    ImageManager.syncAllPreviews();
    syncHeadingVideoInPromptItems();
    syncHeadingVideoSlotsInUnifiedPreview();

    refreshGeneratedPostsList();
  } catch (error) {
    console.error('이미지 재사용 실패:', error);
    alert(`이미지 재사용에 실패했습니다: ${(error as Error).message}`);
  }
}

// ✅ 폴더에서 이미지 불러오기 (IPC 사용)
async function loadImagesFromFolder(postId: string): Promise<any[]> {
  try {
    // ✅ IPC를 통해 파일 시스템 접근
    if (!window.api.getUserHomeDir || !window.api.readDir || !window.api.checkFileExists) {
      console.error('[Image Folder] 파일 시스템 API가 없습니다.');
      return [];
    }

    const basePath = await getRequiredImageBasePath();

    const folderPath = `${basePath}/${postId}`.replace(/\\/g, '/');

    // 폴더 존재 확인
    const exists = await window.api.checkFileExists(folderPath);
    if (!exists) {
      console.log(`폴더가 존재하지 않습니다: ${folderPath}`);
      return [];
    }

    // 폴더 내 파일 목록 읽기
    const files = await window.api.readDir(folderPath);
    const imageFiles = files.filter(f => /\.(jpg|jpeg|png|gif|webp)$/i.test(f));

    const images = imageFiles.map((file, index) => {
      const filePath = `${folderPath}/${file}`.replace(/\\/g, '/');
      const ext = file.split('.').pop()?.toLowerCase() || 'jpg';
      const heading = file.replace(/\.[^/.]+$/, ''); // 파일명에서 확장자 제거
      const fileUrl = `file:///${filePath}`;

      return {
        heading,
        filePath,
        previewDataUrl: fileUrl,
        provider: 'local',
        savedToLocal: true,
        url: fileUrl,
        // ✅ prompt 필드 추가 (영어 프롬프트 미리보기용)
        prompt: heading || `이미지 ${index + 1}`
      };
    });

    return images;
  } catch (error) {
    console.error('폴더에서 이미지 불러오기 실패:', error);
    return [];
  }
}

// ✅ 모든 글의 이미지 폴더에서 이미지 목록 가져오기 (최신순 정렬!)
async function getAllGeneratedImagesFromFolders(): Promise<Array<{ postId: string; postTitle: string; images: any[]; mtime?: number }>> {
  try {
    // ✅ window.api를 통해 파일 시스템 접근
    if (!window.api.checkFileExists || !window.api.readDir) {
      console.error('[Image Folders] 파일 시스템 API가 없습니다.');
      return [];
    }

    const basePath = await getRequiredImageBasePath();

    try {
      // 폴더 존재 확인
      const baseExists = await window.api.checkFileExists(basePath);
      if (!baseExists) {
        console.log('[Image Folders] 이미지 폴더가 없습니다:', basePath);
        return [];
      }

      // ✅ 폴더 목록 읽기 (수정 시간 포함) - 최신순 정렬용
      let folders: string[] = [];
      let folderStats: Map<string, number> = new Map(); // 폴더명 → mtime

      if (window.api.readDirWithStats) {
        // ✅ 수정 시간과 함께 읽기
        const dirEntries = await window.api.readDirWithStats(basePath);
        if (dirEntries && dirEntries.length > 0) {
          // 디렉토리만 필터링하고 mtime으로 정렬 (최신순)
          const sortedDirs = dirEntries
            .filter(entry => entry.isDirectory)
            .sort((a, b) => b.mtime - a.mtime); // 최신이 먼저!

          folders = sortedDirs.map(entry => entry.name);
          sortedDirs.forEach(entry => folderStats.set(entry.name, entry.mtime));

          console.log('[Image Folders] ✅ 최신순 정렬 완료 (폴더 수:', folders.length, ')');
        }
      } else {
        // 폴백: 일반 readDir
        folders = await window.api.readDir(basePath);
      }

      if (!folders || folders.length === 0) {
        console.log('[Image Folders] 이미지 폴더가 비어있습니다.');
        return [];
      }

      const allImages: Array<{ postId: string; postTitle: string; images: any[]; mtime?: number }> = [];

      // 글 목록에서 제목 가져오기
      const posts = loadGeneratedPosts();

      for (const folderName of folders) {
        const folderPath = `${basePath}/${folderName}`.replace(/\\/g, '/');
        try {
          // 폴더 내 파일 목록 읽기
          const files = await window.api.readDir(folderPath);
          if (!files || files.length === 0) continue;

          const imageFiles = files.filter((f: string) => /\.(jpg|jpeg|png|gif|webp)$/i.test(f));

          if (imageFiles.length > 0) {
            const post = posts.find(p => p.id === folderName);
            const images: any[] = [];

            for (const file of imageFiles) {
              const filePath = `${folderPath}/${file}`.replace(/\\/g, '/');
              try {
                // 파일 존재 확인
                const fileExists = await window.api.checkFileExists(filePath);
                if (!fileExists) continue;

                // 이미지를 Data URL로 변환 (브라우저에서 읽기 위해)
                const ext = file.split('.').pop()?.toLowerCase() || 'jpg';
                const previewDataUrl = `file:///${filePath}`;

                images.push({
                  heading: file.replace(/\.[^/.]+$/, ''),
                  filePath,
                  previewDataUrl,
                  provider: 'local',
                  savedToLocal: true,
                  url: filePath
                });
              } catch (err) {
                console.warn(`[Image Folders] 이미지 읽기 실패: ${file}`, err);
              }
            }

            if (images.length > 0) {
              allImages.push({
                postId: folderName,
                postTitle: post?.title || folderName,
                images,
                mtime: folderStats.get(folderName) || 0 // ✅ 수정 시간 저장
              });
            }
          }
        } catch (err) {
          console.warn(`[Image Folders] 폴더 읽기 실패: ${folderName}`, err);
        }
      }

      console.log(`[Image Folders] 총 ${allImages.length}개 폴더에서 이미지 발견`);
      return allImages;
    } catch (err) {
      console.error('[Image Folders] 폴더 스캔 실패:', err);
      return [];
    }
  } catch (error) {
    console.error('이미지 폴더 스캔 실패:', error);
    return [];
  }
}

// ✅ 저장된 이미지 관리 모달 (폴더 열기 + 이미지 불러오기)
async function showLocalImageManagementModal(): Promise<void> {
  try {
    // 소제목 분석 여부 확인
    const headings = currentStructuredContent?.headings || [];
    const hasHeadings = headings.length > 0;

    // 모달 생성
    const modal = document.createElement('div');
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.8); z-index: 10000; display: flex;
      align-items: center; justify-content: center; padding: 2rem;
    `;

    modal.innerHTML = `
      <div style="background: var(--bg-primary); border: 3px solid var(--primary); border-radius: 16px; padding: 2rem; max-width: 600px; width: 100%; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
        <h2 style="color: var(--text-gold); margin-bottom: 1.5rem; display: flex; align-items: center; gap: 0.5rem;">
          <span style="font-size: 2rem;">💾</span>
          <span>저장된 이미지 관리</span>
        </h2>
        
        <div style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(6, 182, 212, 0.05)); border: 2px solid rgba(59, 130, 246, 0.3); border-radius: 12px; padding: 1.5rem; margin-bottom: 1.5rem;">
          <p style="color: var(--text-muted); margin-bottom: 1rem; line-height: 1.6;">
            이미지를 저장하거나 불러올 수 있습니다.
          </p>
          <div style="display: flex; flex-direction: column; gap: 1rem;">
            <button type="button" id="open-folder-btn" style="padding: 1rem; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1rem; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
              <span style="font-size: 1.25rem;">📂</span>
              <span>이미지 저장하러 가기 (새 폴더 생성)</span>
            </button>
            
            <button type="button" id="open-existing-folder-btn" style="padding: 1rem; background: linear-gradient(135deg, #f59e0b, #d97706); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1rem; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
              <span style="font-size: 1.25rem;">💾</span>
              <span>기존 폴더에 저장하기</span>
            </button>
            
            <button type="button" id="load-images-btn" ${!hasHeadings ? 'disabled' : ''} style="padding: 1rem; background: ${hasHeadings ? 'linear-gradient(135deg, #3b82f6, #2563eb)' : 'var(--bg-tertiary)'}; color: ${hasHeadings ? 'white' : 'var(--text-muted)'}; border: none; border-radius: 8px; cursor: ${hasHeadings ? 'pointer' : 'not-allowed'}; font-weight: 600; font-size: 1rem; display: flex; align-items: center; justify-content: center; gap: 0.5rem; opacity: ${hasHeadings ? '1' : '0.5'};">
              <span style="font-size: 1.25rem;">🖼️</span>
              <span>이미지 불러오기</span>
            </button>
          </div>
          
          ${!hasHeadings ? `
            <div style="margin-top: 1rem; padding: 1rem; background: rgba(239, 68, 68, 0.1); border: 2px solid rgba(239, 68, 68, 0.3); border-radius: 8px; color: var(--text-muted); font-size: 0.875rem;">
              ⚠️ 이미지를 불러오려면 먼저 소제목 분석을 완료해주세요.
            </div>
          ` : ''}
        </div>
        
        <div style="display: flex; gap: 1rem;">
          <button type="button" class="close-modal-btn" style="flex: 1; padding: 0.75rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 8px; cursor: pointer; font-weight: 600;">닫기</button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    // 폴더 열기 버튼 (새 폴더 생성)
    const openFolderBtn = modal.querySelector('#open-folder-btn');
    if (openFolderBtn) {
      openFolderBtn.addEventListener('click', async () => {
        await openGeneratedImagesFolder();
      });
    }

    // 기존 폴더에 저장하기 버튼
    const openExistingFolderBtn = modal.querySelector('#open-existing-folder-btn');
    if (openExistingFolderBtn) {
      openExistingFolderBtn.addEventListener('click', async () => {
        await openExistingImageFolder();
      });
    }

    // 이미지 불러오기 버튼
    const loadImagesBtn = modal.querySelector('#load-images-btn');
    if (loadImagesBtn && hasHeadings) {
      loadImagesBtn.addEventListener('click', async () => {
        modal.remove();
        await showFolderSelectionModal();
      });
    }

    // 닫기 버튼
    const closeBtn = modal.querySelector('.close-modal-btn');
    if (closeBtn) {
      closeBtn.addEventListener('click', () => modal.remove());
    }

    // 배경 클릭 시 닫기
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.remove();
    });

  } catch (error) {
    console.error('[Local Image Modal] 모달 표시 실패:', error);
    alert(`모달을 표시할 수 없습니다: ${(error as Error).message}`);
  }
}

// ✅ 생성된 이미지 폴더 열기 (공통 함수) - 제목별 폴더 생성 확인
async function openGeneratedImagesFolder(): Promise<void> {
  try {
    if (!window.api.openPath || !window.api.checkFileExists) {
      alert('파일 시스템 API가 없습니다.');
      return;
    }

    // 현재 글 제목 가져오기
    const titleInput = document.getElementById('image-title-input') as HTMLInputElement;
    const currentTitle = titleInput?.value?.trim() || currentStructuredContent?.selectedTitle || '';

    if (!currentTitle) {
      alert('먼저 글 제목을 입력하거나 콘텐츠를 생성해주세요.');
      return;
    }

    const basePath = await getRequiredImageBasePath();

    // 제목을 안전한 폴더명으로 변환
    const safeTitleFolder = currentTitle.replace(/[<>:"/\\|?*]/g, '_').substring(0, 50).trim() || 'untitled';
    const imageFolderPath = `${basePath}/${safeTitleFolder}`.replace(/\\/g, '/');

    // ✅ 폴더 존재 확인
    const folderExists = await window.api.checkFileExists(imageFolderPath);

    if (!folderExists) {
      // 폴더가 없으면 생성 확인
      const confirmed = window.confirm(
        `"${safeTitleFolder}" 폴더가 없습니다.\n\n폴더를 생성하시겠습니까?\n\n경로: ${imageFolderPath}`
      );

      if (!confirmed) {
        appendLog('⚠️ 폴더 생성이 취소되었습니다.');
        return;
      }
    }

    // ✅ 폴더 열기 (없으면 자동 생성됨)
    const result = await window.api.openPath(imageFolderPath);

    if (result.success) {
      if (!folderExists) {
        toastManager.success(`✅ 폴더를 생성하고 열었습니다: ${safeTitleFolder}`);
        appendLog(`📂 폴더 생성 완료: ${imageFolderPath}`);
      } else {
        toastManager.success(`✅ 이미지 폴더를 열었습니다: ${safeTitleFolder}`);
        appendLog(`📂 이미지 폴더: ${imageFolderPath}`);
      }
    } else {
      // 폴백: 경로를 클립보드에 복사
      await navigator.clipboard.writeText(imageFolderPath);
      alert(`폴더 경로가 클립보드에 복사되었습니다:\n\n${imageFolderPath}\n\n탐색기에서 이 경로를 붙여넣고 폴더를 만들어주세요.`);
      appendLog(`📋 폴더 경로 복사: ${imageFolderPath}`);
    }
  } catch (error) {
    console.error('폴더 열기 실패:', error);
    alert(`폴더를 열 수 없습니다: ${(error as Error).message}`);
  }
}

// ✅ 기존 폴더에 저장하기 (AI 이미지 생성/수집으로 만들어진 폴더 열기)
async function openExistingImageFolder(): Promise<void> {
  try {
    if (!window.api.openPath) {
      alert('파일 시스템 API가 없습니다.');
      return;
    }

    const basePath = await getRequiredImageBasePath();

    // 기존 폴더 목록 가져오기
    const dirEntries = await window.api.readDirWithStats?.(basePath);

    if (!dirEntries || dirEntries.length === 0) {
      alert('저장된 이미지 폴더가 없습니다.\n\n먼저 "이미지 저장하러 가기"를 눌러 이미지를 저장해주세요.');
      return;
    }

    // 폴더만 필터링
    const folders = dirEntries.filter((entry) => entry.isDirectory);

    if (folders.length === 0) {
      alert('저장된 이미지 폴더가 없습니다.\n\n먼저 "이미지 저장하러 가기"를 눌러 이미지를 저장해주세요.');
      return;
    }

    // 최신 폴더 찾기 (수정 시간 기준)
    const sortedFolders = folders.sort((a, b) => {
      return (b.mtime || 0) - (a.mtime || 0);
    });

    const latestFolder = sortedFolders[0];
    const folderPath = `${basePath}/${latestFolder.name}`.replace(/\\/g, '/');

    // 폴더 열기
    const result = await window.api.openPath(folderPath);

    if (result.success) {
      toastManager.success(`✅ 기존 폴더를 열었습니다: ${latestFolder.name}`);
      appendLog(`📂 기존 폴더 열기: ${folderPath}`);
    } else {
      alert(`폴더를 열 수 없습니다: ${result.message || '알 수 없는 오류'}`);
    }
  } catch (error) {
    console.error('기존 폴더 열기 실패:', error);
    alert(`폴더를 열 수 없습니다: ${(error as Error).message}`);
  }
}

// ✅ 폴더 선택 모달 (1단계)
async function showFolderSelectionModal(options?: { onFolderSelected?: (folderName: string) => Promise<void> }): Promise<void> {
  try {
    if (!window.api.readDir || !window.api.checkFileExists) {
      alert('파일 시스템 API를 사용할 수 없습니다.');
      return;
    }

    const modal = document.createElement('div');
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.8); z-index: 10000; display: flex;
      align-items: center; justify-content: center; padding: 2rem;
    `;

    modal.innerHTML = `
      <div style="background: var(--bg-primary); border-radius: 16px; padding: 2rem; max-width: 900px; width: 90%; max-height: 85vh; overflow: hidden; box-shadow: 0 8px 32px rgba(0,0,0,0.5); position: relative; display: flex; flex-direction: column;">
        <button type="button" class="close-modal-btn" style="position: absolute; top: 1rem; right: 1rem; background: rgba(239, 68, 68, 0.9); color: white; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transition: all 0.2s; z-index: 1;">✕</button>
        <h2 style="margin: 0 0 1rem 0; color: var(--text-gold); font-size: 1.5rem; display: flex; align-items: center; gap: 0.5rem;">
          <span style="font-size: 1.75rem;">📁</span>
          <span>폴더 선택</span>
          <span style="font-size: 0.85rem; color: var(--text-muted); font-weight: 400; margin-left: auto;">불러오는 중...</span>
        </h2>
        <div style="flex: 1; display:flex; align-items:center; justify-content:center; color: var(--text-muted); font-weight: 600;">
          ⏳ 폴더 목록을 불러오는 중...
        </div>
        <div style="margin-top: 1rem; padding-top: 1rem; border-top: 2px solid var(--border-light); display: flex; justify-content: flex-end;">
          <button type="button" class="close-modal-btn" style="padding: 0.6rem 1.25rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 8px; cursor: pointer; font-weight: 600;">닫기</button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);
    modal.querySelectorAll('.close-modal-btn').forEach(btn => {
      btn.addEventListener('click', () => modal.remove());
    });
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.remove();
    });

    let basePath = '';
    try {
      basePath = await getRequiredImageBasePath();
    } catch (error) {
      const msg = (error as Error).message || '환경설정에서 이미지 저장 폴더를 먼저 선택해주세요.';
      modal.innerHTML = `
        <div style="background: var(--bg-primary); border-radius: 16px; padding: 2rem; max-width: 900px; width: 90%; max-height: 85vh; overflow: hidden; box-shadow: 0 8px 32px rgba(0,0,0,0.5); position: relative; display: flex; flex-direction: column;">
          <button type="button" class="close-modal-btn" style="position: absolute; top: 1rem; right: 1rem; background: rgba(239, 68, 68, 0.9); color: white; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transition: all 0.2s; z-index: 1;">✕</button>
          <h2 style="margin: 0 0 1rem 0; color: var(--text-gold); font-size: 1.5rem; display: flex; align-items: center; gap: 0.5rem;">
            <span style="font-size: 1.75rem;">📁</span>
            <span>폴더 선택</span>
          </h2>
          <div style="flex: 1; display:flex; align-items:center; justify-content:center; color: var(--text-muted); font-weight: 700; line-height: 1.6; text-align:center; padding: 2rem;">
            ${escapeHtml(msg)}
          </div>
          <div style="margin-top: 1rem; padding-top: 1rem; border-top: 2px solid var(--border-light); display: flex; justify-content: flex-end;">
            <button type="button" class="close-modal-btn" style="padding: 0.6rem 1.25rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 8px; cursor: pointer; font-weight: 600;">닫기</button>
          </div>
        </div>
      `;
      modal.querySelectorAll('.close-modal-btn').forEach(btn => {
        btn.addEventListener('click', () => modal.remove());
      });
      return;
    }

    appendLog(`📁 폴더 목록 확인 중: ${basePath}`);

    // 기본 경로 존재 확인
    const basePathExists = await window.api.checkFileExists(basePath);
    if (!basePathExists) {
      modal.innerHTML = `
        <div style="background: var(--bg-primary); border-radius: 16px; padding: 2rem; max-width: 900px; width: 90%; max-height: 85vh; overflow: hidden; box-shadow: 0 8px 32px rgba(0,0,0,0.5); position: relative; display: flex; flex-direction: column;">
          <button type="button" class="close-modal-btn" style="position: absolute; top: 1rem; right: 1rem; background: rgba(239, 68, 68, 0.9); color: white; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transition: all 0.2s; z-index: 1;">✕</button>
          <h2 style="margin: 0 0 1rem 0; color: var(--text-gold); font-size: 1.5rem; display: flex; align-items: center; gap: 0.5rem;">
            <span style="font-size: 1.75rem;">📁</span>
            <span>폴더 선택</span>
          </h2>
          <div style="flex: 1; display:flex; align-items:center; justify-content:center; color: var(--text-muted); font-weight: 700; line-height: 1.6; text-align:center; padding: 2rem;">
            이미지 폴더가 없습니다.<br/><br/>
            먼저 "이미지 저장하러 가기"를 눌러 폴더를 생성해주세요.<br/><br/>
            <span style="font-size: 0.85rem; color: var(--text-muted);">경로: ${escapeHtml(basePath)}</span>
          </div>
          <div style="margin-top: 1rem; padding-top: 1rem; border-top: 2px solid var(--border-light); display: flex; justify-content: flex-end;">
            <button type="button" class="close-modal-btn" style="padding: 0.6rem 1.25rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 8px; cursor: pointer; font-weight: 600;">닫기</button>
          </div>
        </div>
      `;
      modal.querySelectorAll('.close-modal-btn').forEach(btn => {
        btn.addEventListener('click', () => modal.remove());
      });
      return;
    }

    // 폴더 목록 읽기 (✅ 최신순 보장: readDirWithStats 우선)
    let folderList: string[] = [];
    try {
      if (typeof (window.api as any).readDirWithStats === 'function') {
        const dirEntries = await (window.api as any).readDirWithStats(basePath);
        if (Array.isArray(dirEntries) && dirEntries.length > 0) {
          folderList = dirEntries
            .filter((entry: any) => entry && entry.isDirectory)
            .sort((a: any, b: any) => (Number(b?.mtime || 0) - Number(a?.mtime || 0)))
            .map((entry: any) => String(entry?.name || '').trim())
            .filter((n: string) => n.length > 0);
        }
      }
    } catch {
      // ignore (fallback below)
    }

    if (folderList.length === 0) {
      const folders = await window.api.readDir(basePath);
      folderList = (folders || []).filter((item: string) => {
        // 파일은 제외하고 폴더만 (확장자가 없는 것들)
        return !/\.(jpg|jpeg|png|gif|webp|txt|json)$/i.test(item);
      });
    }

    if (folderList.length === 0) {
      modal.innerHTML = `
        <div style="background: var(--bg-primary); border-radius: 16px; padding: 2rem; max-width: 900px; width: 90%; max-height: 85vh; overflow: hidden; box-shadow: 0 8px 32px rgba(0,0,0,0.5); position: relative; display: flex; flex-direction: column;">
          <button type="button" class="close-modal-btn" style="position: absolute; top: 1rem; right: 1rem; background: rgba(239, 68, 68, 0.9); color: white; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transition: all 0.2s; z-index: 1;">✕</button>
          <h2 style="margin: 0 0 1rem 0; color: var(--text-gold); font-size: 1.5rem; display: flex; align-items: center; gap: 0.5rem;">
            <span style="font-size: 1.75rem;">📁</span>
            <span>폴더 선택</span>
          </h2>
          <div style="flex: 1; display:flex; align-items:center; justify-content:center; color: var(--text-muted); font-weight: 700; line-height: 1.6; text-align:center; padding: 2rem;">
            저장된 이미지 폴더가 없습니다.<br/><br/>
            먼저 "이미지 저장하러 가기"를 눌러 이미지를 저장해주세요.
          </div>
          <div style="margin-top: 1rem; padding-top: 1rem; border-top: 2px solid var(--border-light); display: flex; justify-content: flex-end;">
            <button type="button" class="close-modal-btn" style="padding: 0.6rem 1.25rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 8px; cursor: pointer; font-weight: 600;">닫기</button>
          </div>
        </div>
      `;
      modal.querySelectorAll('.close-modal-btn').forEach(btn => {
        btn.addEventListener('click', () => modal.remove());
      });
      return;
    }

    // ✅ fallback 최신순 정렬 (날짜 형식 YYYY-MM-DD 기준 역순)
    // readDirWithStats를 못 쓰는 환경에서만 의미 있음
    if (!(typeof (window.api as any).readDirWithStats === 'function')) {
      folderList.sort((a: string, b: string) => {
        const dateA = a.match(/(\d{4}-\d{2}-\d{2})/);
        const dateB = b.match(/(\d{4}-\d{2}-\d{2})/);
        if (dateA && dateB) return dateB[1].localeCompare(dateA[1]);
        if (dateA) return -1;
        if (dateB) return 1;
        return b.localeCompare(a);
      });
    }

    appendLog(`✅ ${folderList.length}개의 폴더를 찾았습니다. (최신순 정렬)`);

    const renderFolderItem = (folder: string) => {
      const dateMatch = folder.match(/(\d{4}-\d{2}-\d{2})/);
      const dateLabel = dateMatch ? dateMatch[1] : '';
      const folderTitle = folder.replace(/^\d{4}-\d{2}-\d{2}_?/, '').trim() || folder;
      return `
        <button type="button" class="folder-item" data-folder-name="${folder}" style="width: 100%; padding: 0.9rem 1rem; background: linear-gradient(135deg, var(--bg-secondary), var(--bg-tertiary)); border: 2px solid var(--border-light); border-radius: 12px; cursor: pointer; transition: all 0.2s; text-align: left; display: flex; align-items: center; gap: 0.75rem;">
          <span style="font-size: 1.5rem; line-height: 1;">📂</span>
          <div style="min-width:0; flex: 1;">
            <div style="display:flex; align-items:center; gap: 0.5rem;">
              ${dateLabel ? `<span style="background: rgba(99, 102, 241, 0.2); color: var(--primary); padding: 2px 6px; border-radius: 6px; font-size: 0.75rem; font-weight: 700; white-space: nowrap;">${dateLabel}</span>` : ''}
              <span style="color: var(--text-strong); font-weight: 800; font-size: 0.95rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${folderTitle}</span>
            </div>
            <div style="margin-top: 0.25rem; color: var(--text-muted); font-size: 0.78rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${folder}</div>
          </div>
          <span style="color: var(--text-muted); font-weight: 900;">→</span>
        </button>
      `;
    };

    modal.innerHTML = `
      <div style="background: var(--bg-primary); border-radius: 16px; padding: 2rem; max-width: 900px; width: 90%; max-height: 85vh; overflow: hidden; box-shadow: 0 8px 32px rgba(0,0,0,0.5); position: relative; display: flex; flex-direction: column;">
        <button type="button" class="close-modal-btn" style="position: absolute; top: 1rem; right: 1rem; background: rgba(239, 68, 68, 0.9); color: white; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transition: all 0.2s; z-index: 1;" onmouseover="this.style.background='rgba(220, 38, 38, 1)'; this.style.transform='scale(1.1)';" onmouseout="this.style.background='rgba(239, 68, 68, 0.9)'; this.style.transform='scale(1)';">✕</button>
        <h2 style="margin: 0 0 1rem 0; color: var(--text-gold); font-size: 1.5rem; display: flex; align-items: center; gap: 0.5rem;">
          <span style="font-size: 1.75rem;">📁</span>
          <span>폴더 선택</span>
          <span style="font-size: 0.85rem; color: var(--text-muted); font-weight: 400; margin-left: auto;">⬇️ 최신순</span>
        </h2>
        
        <!-- 검색창 -->
        <div style="margin-bottom: 1rem; display: flex; gap: 0.5rem; align-items: center;">
          <div style="flex: 1; position: relative;">
            <input type="text" id="folder-search-input" placeholder="폴더명 검색 (예: 바디프랜드, 2025-12-05)" style="width: 100%; padding: 0.6rem 0.75rem 0.6rem 2.25rem; background: var(--bg-tertiary); border: 2px solid var(--border-light); border-radius: 8px; color: var(--text-strong); font-size: 0.9rem;"/>
            <span style="position: absolute; left: 0.6rem; top: 50%; transform: translateY(-50%); font-size: 1rem;">🔍</span>
          </div>
          <span id="folder-count-label" style="color: var(--text-muted); font-size: 0.8rem; white-space: nowrap;">${folderList.length}개</span>
        </div>
        
        <div id="folder-grid" style="flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 0.6rem; padding: 0.25rem;">
          ${folderList.map((f: string) => renderFolderItem(f)).join('')}
        </div>
        
        <div style="margin-top: 1rem; padding-top: 1rem; border-top: 2px solid var(--border-light); display: flex; justify-content: flex-end;">
          <button type="button" class="close-modal-btn" style="padding: 0.6rem 1.25rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 8px; cursor: pointer; font-weight: 600;">닫기</button>
        </div>
      </div>
    `;

    // 폴더 이벤트 등록 함수
    const attachFolderEvents = () => {
      modal.querySelectorAll('.folder-item').forEach(item => {
        item.addEventListener('click', async () => {
          const folderName = (item as HTMLElement).dataset.folderName;
          if (folderName) {
            modal.remove();
            if (typeof options?.onFolderSelected === 'function') {
              await options.onFolderSelected(folderName);
              return;
            }
            await showLocalImageSelectionModal(folderName);
          }
        });
        item.addEventListener('mouseenter', () => {
          (item as HTMLElement).style.borderColor = 'var(--primary)';
          (item as HTMLElement).style.transform = 'translateY(-2px)';
          (item as HTMLElement).style.boxShadow = '0 4px 12px rgba(99, 102, 241, 0.3)';
        });
        item.addEventListener('mouseleave', () => {
          (item as HTMLElement).style.borderColor = 'var(--border-light)';
          (item as HTMLElement).style.transform = 'translateY(0)';
          (item as HTMLElement).style.boxShadow = 'none';
        });
      });
    };

    // 초기 이벤트 등록
    attachFolderEvents();

    // ✅ 검색 기능
    const searchInput = modal.querySelector('#folder-search-input') as HTMLInputElement;
    const folderGrid = modal.querySelector('#folder-grid') as HTMLDivElement;
    const countLabel = modal.querySelector('#folder-count-label') as HTMLSpanElement;

    searchInput?.addEventListener('input', () => {
      const query = searchInput.value.toLowerCase().trim();
      const filtered = query === '' ? folderList : folderList.filter((f: string) => f.toLowerCase().includes(query));
      folderGrid.innerHTML = filtered.map((f: string) => renderFolderItem(f)).join('');
      countLabel.textContent = `${filtered.length}개`;
      attachFolderEvents();
    });

    // ESC 키로 닫기
    const handleEsc = (e: KeyboardEvent) => {
      if (e.key === 'Escape') { modal.remove(); document.removeEventListener('keydown', handleEsc); }
    };
    document.addEventListener('keydown', handleEsc);
    setTimeout(() => searchInput?.focus(), 100);

    // 닫기 버튼
    modal.querySelectorAll('.close-modal-btn').forEach(btn => {
      btn.addEventListener('click', () => modal.remove());
    });

  } catch (error) {
    console.error('폴더 선택 모달 오류:', error);
    alert(`폴더 목록을 불러올 수 없습니다: ${(error as Error).message}`);
  }
}

// ✅ 저장된 이미지 선택 모달 (2단계 - 소제목별 배치)
async function showLocalImageSelectionModal(folderName?: string): Promise<void> {
  try {
    // 글 제목별 폴더 경로
    if (!window.api.getUserHomeDir || !window.api.readDir || !window.api.checkFileExists) {
      appendLog('⚠️ 파일 시스템 API를 사용할 수 없습니다.');
      alert('파일 시스템 API를 사용할 수 없습니다.');
      return;
    }

    const basePath = await getRequiredImageBasePath();

    // 폴더명이 제공되지 않으면 현재 글 제목 사용 (하위 호환성)
    let safeTitleFolder: string;
    if (folderName) {
      safeTitleFolder = folderName;
    } else {
      const titleInput = document.getElementById('image-title-input') as HTMLInputElement;
      const currentTitle = titleInput?.value?.trim() || currentStructuredContent?.selectedTitle || '제목 없음';
      safeTitleFolder = currentTitle.replace(/[<>:"/\\|?*]/g, '_').substring(0, 50).trim() || 'untitled';
    }

    const folderPath = `${basePath}/${safeTitleFolder}`.replace(/\\/g, '/');

    appendLog(`📁 폴더 확인 중: ${safeTitleFolder}`);

    // 폴더 존재 확인
    const folderExists = await window.api.checkFileExists(folderPath);
    if (!folderExists) {
      appendLog('⚠️ 이미지 폴더가 존재하지 않습니다.');
      alert(`"${safeTitleFolder}" 폴더에 이미지가 없습니다.\n\n먼저 "이미지 저장하러 가기" 버튼을 눌러 이미지를 저장해주세요.`);
      return;
    }

    // 폴더 내 이미지 파일 읽기
    const files = await window.api.readDir(folderPath);
    const imageFiles = files.filter((f: string) => /\.(jpg|jpeg|png|gif|webp)$/i.test(f));

    if (imageFiles.length === 0) {
      alert(`"${safeTitleFolder}" 폴더에 이미지가 없습니다.\n\n이미지를 폴더에 저장한 후 다시 시도해주세요.`);
      if (window.api.openPath) {
        await window.api.openPath(folderPath);
      }
      return;
    }

    appendLog(`✅ ${imageFiles.length}개의 이미지를 찾았습니다.`);

    // 소제목 목록 가져오기
    const headings = currentStructuredContent?.headings || [];
    if (headings.length === 0) {
      alert('먼저 소제목을 분석해주세요.');
      return;
    }

    // 모달 생성
    const modal = document.createElement('div');
    modal.setAttribute('data-modal-type', 'local-image-selection');
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.7); z-index: 10000; display: flex;
      align-items: center; justify-content: center; padding: 2rem;
    `;

    modal.innerHTML = `
      <div style="background: var(--bg-primary); border-radius: 12px; padding: 2rem; max-width: 1200px; max-height: 90vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.3); position: relative;">
        <button type="button" class="close-modal-btn" style="position: absolute; top: 1rem; right: 1rem; background: rgba(239, 68, 68, 0.9); color: white; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transition: all 0.2s;" onmouseover="this.style.background='rgba(220, 38, 38, 1)'; this.style.transform='scale(1.1)';" onmouseout="this.style.background='rgba(239, 68, 68, 0.9)'; this.style.transform='scale(1)';">✕</button>
        <h2 style="margin: 0 0 1rem 0; color: var(--text-strong); font-size: 1.5rem;">💾 저장된 이미지 선택</h2>
        <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 1.5rem;">
          폴더: ${safeTitleFolder} (${imageFiles.length}개 이미지)
        </div>
        
        <!-- 모드 전환 버튼 -->
        <div style="margin-bottom: 1.5rem; padding: 1rem; background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.05)); border: 2px solid rgba(16, 185, 129, 0.3); border-radius: 12px;">
          <div style="display: flex; align-items: center; justify-content: space-between; gap: 1rem; margin-bottom: 0.75rem;">
            <div style="flex: 1;">
              <div id="mode-status-text" style="font-size: 0.9rem; color: var(--text-muted); font-weight: 500;">일반 모드 - 이미지를 클릭하고 소제목을 선택하세요</div>
            </div>
            <button type="button" id="mode-toggle-btn" style="padding: 0.75rem 1.5rem; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; white-space: nowrap; transition: all 0.2s;">
              🚀 순서대로 배치 모드
            </button>
          </div>
          <div style="font-size: 0.75rem; color: var(--text-muted); line-height: 1.4;">
            💡 <strong>순서대로 배치 모드:</strong> 이미지를 클릭한 순서대로 소제목 1, 2, 3... 에 자동 배치됩니다! (재클릭 시 취소)
          </div>
          <div style="margin-top: 0.5rem; font-size: 0.75rem; color: var(--accent); line-height: 1.4;">
            🎨 <strong>하이브리드 모드:</strong> 일부만 선택하고 나머지는 AI/Pexels 이미지 자동 생성됩니다!
          </div>
        </div>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
          ${imageFiles.map((file: string, index: number) => {
      const filePath = `${folderPath}/${file}`.replace(/\\/g, '/');
      return `
              <div class="local-image-item" data-file-path="${filePath}" data-file-name="${file}" style="border: 2px solid var(--border-light); border-radius: 8px; overflow: hidden; cursor: pointer; transition: all 0.2s; background: var(--bg-secondary); position: relative;">
                <div style="aspect-ratio: 1; background: var(--bg-tertiary); display: flex; align-items: center; justify-content: center; overflow: hidden;">
                  <img src="file:///${filePath}" alt="${file}" style="width: 100%; height: 100%; object-fit: cover;" onerror="this.style.display='none'; this.parentElement.innerHTML='<span style=\\'color: var(--text-muted); font-size: 2rem;\\'>🖼️</span>';">
                </div>
                <div style="padding: 0.5rem; font-size: 0.75rem; color: var(--text-muted); text-align: center; word-break: break-all;">${file}</div>
              </div>
            `;
    }).join('')}
        </div>
        
        <div style="border-top: 2px solid var(--border-light); padding-top: 1.5rem;">
          <h3 style="margin: 0 0 0.5rem 0; color: var(--text-strong); font-size: 1.1rem;">소제목 선택 (일반 모드용)</h3>
          <p style="margin: 0 0 1rem 0; font-size: 0.85rem; color: var(--text-muted);">💡 이미지를 선택한 후 소제목을 클릭하세요. 이미 배치된 이미지는 교체됩니다.</p>
          <div id="heading-selection-list" style="display: flex; flex-direction: column; gap: 0.5rem;">
            ${headings.map((heading: any, index: number) => {
      const headingTitle = heading.title || heading;
      const hasImage = ImageManager.hasImage(headingTitle);
      const buttonStyle = hasImage
        ? 'padding: 0.75rem 1rem; background: linear-gradient(135deg, #10b981, #059669); color: white; border: 2px solid #10b981; border-radius: 8px; cursor: pointer; text-align: left; transition: all 0.2s; font-size: 0.9rem; font-weight: 600;'
        : 'padding: 0.75rem 1rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 8px; text-align: left; cursor: pointer; transition: all 0.2s; font-weight: 500;';
      const iconPrefix = hasImage ? '✅ ' : '';
      return `
              <button type="button" class="heading-select-btn" data-heading-index="${index}" style="${buttonStyle}">
                ${iconPrefix}${index + 1}. ${headingTitle}
              </button>
            `;
    }).join('')}
          </div>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    // ✅ 순서대로 클릭 모드 변수
    let clickOrderMode = false;
    let clickedImages: Array<{ path: string; name: string }> = [];
    let nextHeadingIndex = 0;

    // ✅ 모드 전환 버튼
    const modeToggleBtn = modal.querySelector('#mode-toggle-btn');
    const modeStatusText = modal.querySelector('#mode-status-text');

    if (modeToggleBtn) {
      modeToggleBtn.addEventListener('click', () => {
        clickOrderMode = !clickOrderMode;
        clickedImages = [];
        nextHeadingIndex = 0;

        // UI 업데이트
        if (modeStatusText) {
          if (clickOrderMode) {
            modeStatusText.textContent = '✅ 순서 모드 활성화 - 이미지를 순서대로 클릭하세요!';
            (modeStatusText as HTMLElement).style.color = '#10b981';
            (modeToggleBtn as HTMLElement).textContent = '🔄 일반 모드로 전환';
            (modeToggleBtn as HTMLElement).style.background = 'linear-gradient(135deg, #ef4444, #dc2626)';
          } else {
            modeStatusText.textContent = '일반 모드 - 이미지를 클릭하고 소제목을 선택하세요';
            (modeStatusText as HTMLElement).style.color = 'var(--text-muted)';
            (modeToggleBtn as HTMLElement).textContent = '🚀 순서대로 배치 모드';
            (modeToggleBtn as HTMLElement).style.background = 'linear-gradient(135deg, #10b981, #059669)';
          }
        }

        // 모든 이미지 선택 해제
        modal.querySelectorAll('.local-image-item').forEach(i => {
          (i as HTMLElement).style.borderColor = 'var(--border-light)';
          (i as HTMLElement).style.borderWidth = '2px';
          const badge = (i as HTMLElement).querySelector('.order-badge');
          if (badge) badge.remove();
        });
      });
    }

    // 이벤트 리스너
    let selectedImagePath: string | null = null;
    let selectedImageName: string | null = null;

    // 이미지 선택
    modal.querySelectorAll('.local-image-item').forEach(item => {
      item.addEventListener('click', async () => {
        // ✅ 순서 모드인 경우
        if (clickOrderMode) {
          if (nextHeadingIndex >= headings.length) {
            alert(`모든 소제목(${headings.length}개)에 이미지가 배치되었습니다!`);
            return;
          }

          const imagePath = (item as HTMLElement).dataset.filePath;
          const imageName = (item as HTMLElement).dataset.fileName;

          if (!imagePath || !imageName) return;

          // 이미 클릭된 이미지인지 확인 (취소 가능)
          const existingIndex = clickedImages.findIndex(img => img.path === imagePath);

          if (existingIndex >= 0) {
            // 이미 선택된 이미지 → 취소
            clickedImages.splice(existingIndex, 1);

            // 배지 제거
            const badge = (item as HTMLElement).querySelector('.order-badge');
            if (badge) badge.remove();

            // 테두리 초기화
            (item as HTMLElement).style.borderColor = 'var(--border-light)';
            (item as HTMLElement).style.borderWidth = '2px';
            (item as HTMLElement).style.boxShadow = 'none';

            // 순서 재정렬
            modal.querySelectorAll('.order-badge').forEach((b, idx) => {
              (b as HTMLElement).textContent = (idx + 1).toString();
            });

            nextHeadingIndex = clickedImages.length;

            toastManager.info(`❌ 선택 취소: ${imageName}`);
            appendLog(`❌ 이미지 선택 취소: "${imageName}"`);
            return;
          }

          // 새로 선택
          clickedImages.push({ path: imagePath, name: imageName });

          // 순서 배지 추가
          const badge = document.createElement('div');
          badge.className = 'order-badge';
          badge.style.cssText = `
            position: absolute; top: 0.5rem; right: 0.5rem;
            background: linear-gradient(135deg, #10b981, #059669);
            color: white; border-radius: 50%; width: 32px; height: 32px;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 1rem; z-index: 10;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
          `;
          badge.textContent = (nextHeadingIndex + 1).toString();
          (item as HTMLElement).appendChild(badge);

          // 테두리 강조
          (item as HTMLElement).style.borderColor = '#10b981';
          (item as HTMLElement).style.borderWidth = '3px';
          (item as HTMLElement).style.boxShadow = '0 0 0 3px rgba(16, 185, 129, 0.3)';

          // 소제목에 배치
          const heading = headings[nextHeadingIndex];
          const headingTitle = typeof heading === 'string' ? heading : (heading.title || '');

          const newImage = {
            heading: headingTitle,
            filePath: imagePath,
            previewDataUrl: `file:///${imagePath}`,
            provider: 'local' as 'dalle' | 'pexels',
            savedToLocal: true,
            url: `file:///${imagePath}`
          };

          try {
            // ✅ 순서 모드에서도 소제목당 여러 장 누적 지원
            ImageManager.addImage(headingTitle, newImage);
          } catch {
            // ignore
          }

          try {
            syncGlobalImagesFromImageManager();
          } catch {
            // ignore
          }

          appendLog(`✅ [${nextHeadingIndex + 1}/${headings.length}] "${imageName}" → "${headingTitle}"`);
          toastManager.success(`✅ ${nextHeadingIndex + 1}번 소제목에 배치 완료!`);

          nextHeadingIndex++;

          // 모든 소제목에 배치 완료
          if (nextHeadingIndex >= headings.length) {
            const allImages = (() => {
              try {
                return ImageManager.getAllImages();
              } catch {
                return (window as any).imageManagementGeneratedImages || generatedImages || [];
              }
            })();
            displayGeneratedImages(allImages);
            updatePromptItemsWithImages(allImages);

            alert(`🎉 모든 소제목에 이미지 배치 완료!\n\n총 ${headings.length}개 이미지가 배치되었습니다.`);
            modal.remove();
          }

          return;
        }

        // ✅ 일반 모드인 경우
        // 이전 선택 해제
        modal.querySelectorAll('.local-image-item').forEach(i => {
          (i as HTMLElement).style.borderColor = 'var(--border-light)';
          (i as HTMLElement).style.borderWidth = '2px';
        });

        // 현재 선택
        (item as HTMLElement).style.borderColor = 'var(--primary)';
        (item as HTMLElement).style.borderWidth = '3px';
        selectedImagePath = (item as HTMLElement).dataset.filePath || null;
        selectedImageName = (item as HTMLElement).dataset.fileName || null;
      });
    });

    // 소제목 선택 (이미지 배치) - 일반 모드용
    modal.querySelectorAll('.heading-select-btn').forEach(btn => {
      btn.addEventListener('click', async () => {
        if (clickOrderMode) {
          alert('순서 모드에서는 이미지를 클릭하면 자동으로 배치됩니다!');
          return;
        }

        const headingIndex = parseInt((btn as HTMLElement).dataset.headingIndex || '0');
        const heading = headings[headingIndex];
        const headingTitle = typeof heading === 'string' ? heading : (heading.title || '');

        // ✅ 이미 배치된 소제목인지 확인 (ImageManager 사용)
        const isAlreadyPlaced = ImageManager.hasImage(headingTitle);

        // ✅ 이미 배치된 소제목을 다시 클릭하면 취소 처리
        if (isAlreadyPlaced) {
          // 배치된 소제목 클릭 → 취소
          const existingImage = ImageManager.getImage(headingTitle);
          const removedImageName = existingImage?.filePath?.split('/').pop() || '이미지';

          ImageManager.removeImage(headingTitle);
          appendLog(`❌ ${headingIndex + 1}번 소제목 "${headingTitle}"의 이미지 배치 취소: "${removedImageName}"`);

          toastManager.success(`❌ ${headingIndex + 1}번 소제목 이미지 배치 취소 완료!`);

          // ✅ 이미지가 선택되어 있으면 취소 후 바로 새 이미지 배치
          if (selectedImagePath && selectedImageName) {
            // 잠시 후 새 이미지 배치 (UI 업데이트 후)
            const imagePath = selectedImagePath; // 타입 단언을 위한 변수
            const imageName = selectedImageName;
            setTimeout(() => {
              const newImage = {
                heading: headingTitle,
                filePath: imagePath,
                previewDataUrl: `file:///${imagePath}`,
                provider: 'local' as 'dalle' | 'pexels',
                savedToLocal: true,
                url: `file:///${imagePath}`
              };

              ImageManager.setImage(headingTitle, newImage);
              appendLog(`✅ "${imageName}"을(를) ${headingIndex + 1}번 소제목 "${headingTitle}"에 배치했습니다.`);

              toastManager.success(`✅ ${headingIndex + 1}번 소제목에 새 이미지 배치 완료!`);

              // 선택 초기화
              modal.querySelectorAll('.local-image-item').forEach(i => {
                (i as HTMLElement).style.borderColor = 'var(--border-light)';
                (i as HTMLElement).style.borderWidth = '2px';
              });
              selectedImagePath = null;
              selectedImageName = null;
            }, 100);
          }
          return;
        }

        // 이미지가 선택되지 않았으면 경고
        if (!selectedImagePath || !selectedImageName) {
          alert('먼저 이미지를 선택해주세요.');
          return;
        }

        // 새 이미지 객체 생성
        const newImage = {
          heading: headingTitle,
          filePath: selectedImagePath,
          previewDataUrl: `file:///${selectedImagePath}`,
          provider: 'local' as 'dalle' | 'pexels',
          savedToLocal: true,
          url: `file:///${selectedImagePath}`
        };

        // ✅ ImageManager를 통해 이미지 설정 (자동으로 교체 또는 추가)
        const existingImage = ImageManager.getImage(headingTitle);
        const isReplacing = existingImage !== null;

        if (isReplacing) {
          const oldImageName = existingImage.filePath?.split('/').pop() || '이전 이미지';
          appendLog(`🔄 ${headingIndex + 1}번 소제목 이미지 교체: "${oldImageName}" → "${selectedImageName}"`);
        } else {
          appendLog(`✅ "${selectedImageName}"을(를) ${headingIndex + 1}번 소제목 "${headingTitle}"에 배치했습니다.`);
        }

        ImageManager.setImage(headingTitle, newImage);

        syncGlobalImagesFromImageManager();

        // 소제목 번호
        const headingNumber = headingIndex + 1;

        // ✅ 시각적 알림
        if (isReplacing) {
          toastManager.success(`🔄 ${headingNumber}번 소제목 이미지 교체 완료!`);
          alert(`🔄 이미지 교체 완료!\n\n📍 위치: ${headingNumber}번 소제목\n📝 제목: ${headingTitle}\n🖼️ 새 이미지: ${selectedImageName}`);
        } else {
          toastManager.success(`✅ ${headingNumber}번 소제목에 이미지 배치 완료!`);
          alert(`✅ 이미지 배치 완료!\n\n📍 위치: ${headingNumber}번 소제목\n📝 제목: ${headingTitle}\n🖼️ 이미지: ${selectedImageName}`);
        }

        // 선택 초기화
        modal.querySelectorAll('.local-image-item').forEach(i => {
          (i as HTMLElement).style.borderColor = 'var(--border-light)';
          (i as HTMLElement).style.borderWidth = '2px';
        });
        selectedImagePath = null;
        selectedImageName = null;
      });
    });

    // 닫기 버튼
    modal.querySelector('.close-modal-btn')?.addEventListener('click', () => {
      document.body.removeChild(modal);
    });

    // 배경 클릭 시 닫기
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        document.body.removeChild(modal);
      }
    });

  } catch (error) {
    console.error('저장된 이미지 선택 실패:', error);
    alert(`이미지 선택 중 오류가 발생했습니다: ${(error as Error).message}`);
  }
}

// ✅ 생성된 이미지 폴더에서 이미지 불러오기 모달 (개선 버전: 최신순 정렬, 날짜별 그룹화, 검색)
async function showLoadImagesFromFoldersModal(): Promise<void> {
  try {
    appendLog('📁 생성된 이미지 폴더를 스캔 중...');
    let allImages: any[] = [];
    try {
      allImages = await getAllGeneratedImagesFromFolders();
    } catch (e) {
      const msg = (e as Error).message || '환경설정에서 이미지 저장 폴더를 먼저 선택해주세요.';
      toastManager.error(msg);
      appendLog(`❌ 이미지 폴더 스캔 실패: ${msg}`);
      return;
    }

    // ✅ 폴더가 없으면 안내 후 폴더 선택 다이얼로그 열기 (설정 변경 안함)
    if (allImages.length === 0) {
      const basePath = await getRequiredImageBasePath();
      toastManager.warning('설정된 이미지 폴더에 저장된 이미지가 없습니다. 먼저 이미지를 저장한 뒤 다시 시도하세요.');
      appendLog(`⚠️ 이미지 폴더가 비어있습니다: ${basePath}`);
      return;
    }

    // ✅ 최신순 정렬 (mtime -> createdAt -> postId)
    const sortedImages = [...allImages].sort((a: any, b: any) => {
      const mA = Number(a?.mtime || 0);
      const mB = Number(b?.mtime || 0);
      if (mA !== mB) return mB - mA;
      const cA = a?.createdAt ? new Date(a.createdAt).getTime() : 0;
      const cB = b?.createdAt ? new Date(b.createdAt).getTime() : 0;
      if (cA !== cB) return cB - cA;
      const pA = parseInt(String(a?.postId || '0'), 10) || 0;
      const pB = parseInt(String(b?.postId || '0'), 10) || 0;
      return pB - pA;
    });

    // ✅ 날짜별 그룹화
    const groupedByDate: { [key: string]: any[] } = {};
    sortedImages.forEach((item: any) => {
      let dateKey = '기타';
      if (item.createdAt) {
        const date = new Date(item.createdAt);
        dateKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
      } else if (item.postId) {
        // postId에서 날짜 추출 시도 (타임스탬프 형식인 경우)
        const timestamp = parseInt(item.postId);
        if (timestamp > 1600000000000) { // 2020년 이후 타임스탬프
          const date = new Date(timestamp);
          dateKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
        }
      }
      if (!groupedByDate[dateKey]) groupedByDate[dateKey] = [];
      groupedByDate[dateKey].push(item);
    });

    // 날짜 키 정렬 (최신순)
    const sortedDateKeys = Object.keys(groupedByDate).sort((a, b) => {
      if (a === '기타') return 1;
      if (b === '기타') return -1;
      return b.localeCompare(a);
    });

    const totalImages = sortedImages.reduce((sum, item) => sum + item.images.length, 0);

    // 폴더 아이템 HTML 생성 함수 (✅ HTML 이스케이프 적용)
    const renderFolderItem = (item: any) => {
      const safeTitle = escapeHtml(item.postTitle || '');
      // ✅ 모든 특수문자 이스케이프 (< > " ' &)
      const safeTitleLower = escapeHtml((item.postTitle || '').toLowerCase());
      const safePostId = escapeHtml(item.postId || '');
      return `
      <div class="folder-item" data-post-id="${safePostId}" data-title="${safeTitleLower}" style="padding: 1rem; background: var(--bg-secondary); border-radius: 8px; border: 2px solid var(--border-light); transition: all 0.2s; cursor: pointer;" onmouseover="this.style.borderColor='var(--primary)'; this.style.transform='translateY(-2px)';" onmouseout="this.style.borderColor='var(--border-light)'; this.style.transform='translateY(0)';">
        <div style="display: flex; align-items: start; justify-content: space-between; margin-bottom: 0.75rem;">
          <div style="flex: 1; min-width: 0;">
            <div style="font-weight: 600; color: var(--text-strong); margin-bottom: 0.25rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${safeTitle}">${safeTitle}</div>
            <div style="font-size: 0.75rem; color: var(--text-muted);">${item.images.length}개 이미지</div>
          </div>
          <button type="button" class="load-folder-images-btn" data-post-id="${safePostId}" style="padding: 0.5rem 1rem; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.8rem; white-space: nowrap; font-weight: 600;">불러오기</button>
        </div>
        <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 4px;">
          ${item.images.slice(0, 6).filter((img: any) => img).map((img: any) => `
            <div style="aspect-ratio: 1; background: var(--bg-tertiary); border-radius: 4px; overflow: hidden;">
              <img src="${toFileUrlMaybe(img.previewDataUrl || img.filePath || img.url || '')}" style="width: 100%; height: 100%; object-fit: cover;" onerror="this.style.display='none'; this.parentElement.innerHTML='🖼️';">
            </div>
          `).join('')}
          ${item.images.length > 6 ? `<div style="aspect-ratio: 1; background: var(--bg-tertiary); border-radius: 4px; display: flex; align-items: center; justify-content: center; font-size: 0.65rem; color: var(--text-muted);">+${item.images.length - 6}</div>` : ''}
        </div>
      </div>
    `;
    };

    // 모달 생성
    const modal = document.createElement('div');
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.8); z-index: 10000; display: flex;
      align-items: center; justify-content: center; padding: 1rem;
    `;

    modal.innerHTML = `
      <div style="background: var(--bg-primary); border-radius: 16px; padding: 1.5rem; max-width: 800px; width: 95%; max-height: 90vh; display: flex; flex-direction: column; box-shadow: 0 8px 32px rgba(0,0,0,0.4); position: relative;">
        <button type="button" class="close-modal-btn" style="position: absolute; top: 1rem; right: 1rem; background: rgba(239, 68, 68, 0.9); color: white; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transition: all 0.2s; z-index: 10;" onmouseover="this.style.background='rgba(220, 38, 38, 1)'; this.style.transform='scale(1.1)';" onmouseout="this.style.background='rgba(239, 68, 68, 0.9)'; this.style.transform='scale(1)';">✕</button>
        
        <h2 style="margin: 0 0 0.5rem 0; color: var(--text-strong); font-size: 1.3rem; display: flex; align-items: center; gap: 0.5rem;">
          📁 폴더 선택
        </h2>
        <div style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 1rem;">
          이미지를 불러올 폴더를 선택하세요 (${sortedImages.length}개 폴더)
        </div>
        
        <!-- 검색 바 + 폴더 경로 변경 버튼 -->
        <div style="margin-bottom: 1rem; display: flex; gap: 0.5rem; align-items: center;">
          <div style="flex: 1; position: relative;">
            <input type="text" id="folder-search-input" placeholder="🔍 폴더 제목 검색..." style="width: 100%; padding: 0.75rem 1rem 0.75rem 2.5rem; background: var(--bg-secondary); border: 2px solid var(--border-light); border-radius: 10px; color: var(--text-strong); font-size: 0.9rem; transition: border-color 0.2s;" onfocus="this.style.borderColor='var(--primary)'" onblur="this.style.borderColor='var(--border-light)'">
            <span style="position: absolute; left: 0.75rem; top: 50%; transform: translateY(-50%); font-size: 1rem;">🔍</span>
          </div>
          <button type="button" id="change-folder-path-btn" style="padding: 0.75rem 1rem; background: linear-gradient(135deg, #f59e0b, #d97706); color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: 600; font-size: 0.85rem; white-space: nowrap; display: flex; align-items: center; gap: 0.4rem;">📂 경로 변경</button>
        </div>
        
        <!-- 폴더 목록 (날짜별 그룹) -->
        <div id="folders-container" style="flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 1.5rem;">
          ${sortedDateKeys.map(dateKey => `
            <div class="date-group" data-date="${dateKey}">
              <div style="font-weight: 700; color: var(--primary); font-size: 0.9rem; margin-bottom: 0.75rem; padding: 0.5rem 0.75rem; background: rgba(59, 130, 246, 0.1); border-radius: 8px; display: inline-block;">
                📅 ${dateKey === '기타' ? '기타' : dateKey}
                <span style="font-weight: 400; color: var(--text-muted); margin-left: 0.5rem;">(${groupedByDate[dateKey].length}개)</span>
              </div>
              <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 0.75rem;">
                ${groupedByDate[dateKey].map(item => renderFolderItem(item)).join('')}
              </div>
            </div>
          `).join('')}
        </div>
        
        <!-- 하단 정보 -->
        <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-light); display: flex; justify-content: space-between; align-items: center;">
          <div style="font-size: 0.8rem; color: var(--text-muted);">
            총 ${totalImages}개의 이미지
          </div>
          <button type="button" class="close-modal-btn" style="padding: 0.6rem 1.5rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 0.85rem;">닫기</button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    // 검색 기능
    const searchInput = modal.querySelector('#folder-search-input') as HTMLInputElement;
    searchInput?.addEventListener('input', () => {
      const query = searchInput.value.toLowerCase().trim();
      const folderItems = modal.querySelectorAll('.folder-item');
      const dateGroups = modal.querySelectorAll('.date-group');

      folderItems.forEach(item => {
        const title = item.getAttribute('data-title') || '';
        const matches = query === '' || title.includes(query);
        (item as HTMLElement).style.display = matches ? 'block' : 'none';
      });

      // 빈 그룹 숨기기
      dateGroups.forEach(group => {
        const visibleItems = group.querySelectorAll('.folder-item[style*="display: block"], .folder-item:not([style*="display: none"])');
        const hasVisible = Array.from(group.querySelectorAll('.folder-item')).some(item => {
          const style = (item as HTMLElement).style.display;
          return style !== 'none';
        });
        (group as HTMLElement).style.display = hasVisible ? 'block' : 'none';
      });
    });

    // 닫기 버튼
    modal.querySelectorAll('.close-modal-btn').forEach(btn => {
      btn.addEventListener('click', () => modal.remove());
    });

    // ✅ 폴더 경로 변경 버튼
    const changeFolderPathBtn = modal.querySelector('#change-folder-path-btn');
    if (changeFolderPathBtn) {
      changeFolderPathBtn.addEventListener('click', async () => {
        try {
          if (!window.api.showOpenDialog) {
            alert('폴더 선택 기능을 사용할 수 없습니다.');
            return;
          }

          const result = await window.api.showOpenDialog({
            properties: ['openDirectory', 'createDirectory'],
            title: '이미지 저장 폴더 선택',
            buttonLabel: '선택'
          });

          if (result && !result.canceled && result.filePaths && result.filePaths.length > 0) {
            const selectedPath = result.filePaths[0].replace(/\\/g, '/');

            // 설정에 저장
            try {
              const config = await window.api.getConfig();
              config.customImageSavePath = selectedPath;
              await window.api.saveConfig(config);

              toastManager.success(`✅ 이미지 경로가 변경되었습니다: ${selectedPath}`);
              appendLog(`📁 이미지 저장 경로 변경: ${selectedPath}`);

              // 모달 닫고 다시 열기 (새 경로로 스캔)
              modal.remove();
              await showLoadImagesFromFoldersModal();
            } catch (saveError) {
              console.error('설정 저장 실패:', saveError);
              toastManager.error('경로 설정 저장에 실패했습니다.');
            }
          }
        } catch (error) {
          console.error('폴더 경로 변경 오류:', error);
          alert(`폴더 경로 변경 중 오류가 발생했습니다: ${(error as Error).message}`);
        }
      });
    }

    // 폴더 이미지 불러오기 버튼 → 클릭 순서대로 배치 모달 열기
    modal.querySelectorAll('.load-folder-images-btn').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const postId = (e.target as HTMLElement).getAttribute('data-post-id');
        if (postId) {
          const folderImages = await loadImagesFromFolder(postId);
          if (folderImages.length > 0) {
            modal.remove(); // 폴더 선택 모달 닫기
            // ✅ 클릭 순서대로 배치하는 모달 열기
            await showImagePlacementModal(folderImages);
          } else {
            toastManager.error('이 폴더에서 이미지를 찾을 수 없습니다.');
          }
        }
      });
    });

    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.remove();
    });

    appendLog(`📁 ${sortedImages.length}개의 글 폴더에서 ${totalImages}개의 이미지를 찾았습니다.`);
  } catch (error) {
    console.error('이미지 폴더 모달 표시 실패:', error);
    appendLog(`❌ 이미지 폴더 스캔 실패: ${(error as Error).message}`);
    toastManager.error(`이미지 폴더를 불러오는 중 오류가 발생했습니다.`);
  }
}

/**
 * ✅ 클릭 순서대로 소제목에 이미지 배치하는 모달
 * - 이미지 클릭 → 순서대로 소제목 배치
 * - 다시 클릭 → 배치 취소
 * - 하단 소제목별 배치 현황 표시
 * - 소제목 클릭 → 배치 취소
 * - 영어 프롬프트 미리보기 & 생성 이미지 연동
 */
async function showImagePlacementModal(folderImages: any[]): Promise<void> {
  // 현재 소제목 목록 가져오기
  const headings = currentStructuredContent?.headings || [];
  if (headings.length === 0) {
    toastManager.error('먼저 소제목 분석을 해주세요.');
    return;
  }

  // 배치 상태 관리 (소제목 인덱스 → 이미지 인덱스)
  const placements: Map<number, number> = new Map();
  // 이미지 사용 상태 (이미지 인덱스 → 소제목 인덱스)
  const imageUsage: Map<number, number> = new Map();
  // 다음 배치할 소제목 인덱스
  let nextHeadingIndex = 0;

  // 모달 생성
  const modal = document.createElement('div');
  modal.id = 'image-placement-modal';
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.85); z-index: 10001; display: flex;
    align-items: center; justify-content: center; padding: 1rem;
  `;

  // 다음 배치할 소제목 찾기
  const getNextAvailableHeadingIndex = () => {
    for (let i = 0; i < headings.length; i++) {
      if (!placements.has(i)) return i;
    }
    return -1; // 모든 소제목에 이미지 배치됨
  };

  // 배치 현황 렌더링 (✅ HTML 이스케이프 적용)
  const renderPlacementStatus = () => {
    const statusContainer = modal.querySelector('#placement-status');
    if (!statusContainer) return;

    statusContainer.innerHTML = headings.map((h: any, idx: number) => {
      const imgIdx = placements.get(idx);
      const hasImage = imgIdx !== undefined;
      const img = hasImage ? folderImages[imgIdx] : null;
      const safeTitle = escapeHtml(h.title || '소제목');
      const displayTitle = safeTitle.length > 25 ? safeTitle.substring(0, 25) + '...' : safeTitle;

      return `
        <div class="placement-item" data-heading-idx="${idx}" style="display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem; background: ${hasImage ? 'rgba(16, 185, 129, 0.1)' : 'var(--bg-secondary)'}; border-radius: 8px; border: 2px solid ${hasImage ? '#10b981' : 'var(--border-light)'}; cursor: ${hasImage ? 'pointer' : 'default'}; transition: all 0.2s;">
          <div style="width: 50px; height: 50px; background: var(--bg-tertiary); border-radius: 6px; display: flex; align-items: center; justify-content: center; overflow: hidden; flex-shrink: 0;">
            ${hasImage && img ? `<img src="${toFileUrlMaybe(img.previewDataUrl || img.filePath || img.url || '')}" style="width: 100%; height: 100%; object-fit: cover;">` : `<span style="font-size: 1.5rem; opacity: 0.3;">🖼️</span>`}
          </div>
          <div style="flex: 1; min-width: 0;">
            <div style="font-size: 0.85rem; font-weight: 600; color: var(--text-strong); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${idx + 1}. ${displayTitle}</div>
            <div style="font-size: 0.75rem; color: ${hasImage ? '#10b981' : 'var(--text-muted)'};">${hasImage ? '✅ 배치됨 (클릭하여 취소)' : '⏳ 대기 중'}</div>
          </div>
          ${hasImage ? `<span style="font-size: 1.2rem; color: #ef4444; cursor: pointer;" title="배치 취소">❌</span>` : ''}
        </div>
      `;
    }).join('');

    // 소제목 클릭하여 배치 취소
    statusContainer.querySelectorAll('.placement-item').forEach(item => {
      item.addEventListener('click', () => {
        const headingIdx = parseInt(item.getAttribute('data-heading-idx') || '-1');
        if (headingIdx >= 0 && placements.has(headingIdx)) {
          const imgIdx = placements.get(headingIdx)!;
          placements.delete(headingIdx);
          imageUsage.delete(imgIdx);

          // 이미지 선택 상태 업데이트
          updateImageSelectionUI();
          renderPlacementStatus();

          toastManager.info(`"${headings[headingIdx].title?.substring(0, 20)}..." 배치 취소됨`);
        }
      });
    });
  };

  // 이미지 선택 상태 UI 업데이트
  const updateImageSelectionUI = () => {
    const imagesContainer = modal.querySelector('#images-grid');
    if (!imagesContainer) return;

    imagesContainer.querySelectorAll('.placement-image').forEach((imgEl, imgIdx) => {
      const headingIdx = imageUsage.get(imgIdx);
      const isUsed = headingIdx !== undefined;

      (imgEl as HTMLElement).style.border = isUsed ? '4px solid #10b981' : '2px solid var(--border-light)';
      (imgEl as HTMLElement).style.opacity = isUsed ? '1' : '0.8';

      const badge = imgEl.querySelector('.placement-badge');
      if (badge) {
        (badge as HTMLElement).style.display = isUsed ? 'flex' : 'none';
        (badge as HTMLElement).textContent = isUsed ? `${headingIdx! + 1}` : '';
      }
    });

    // 다음 배치할 소제목 표시 업데이트 (✅ HTML 이스케이프 적용)
    nextHeadingIndex = getNextAvailableHeadingIndex();
    const nextLabel = modal.querySelector('#next-heading-label');
    if (nextLabel) {
      if (nextHeadingIndex >= 0) {
        const safeNextTitle = escapeHtml((headings[nextHeadingIndex].title || '소제목').substring(0, 30));
        nextLabel.textContent = `다음 배치: ${nextHeadingIndex + 1}번 - "${safeNextTitle}..."`;
      } else {
        nextLabel.textContent = '✅ 모든 소제목에 이미지 배치 완료!';
      }
    }
  };

  modal.innerHTML = `
    <div style="background: var(--bg-primary); border-radius: 16px; padding: 1.5rem; max-width: 1000px; width: 95%; max-height: 90vh; display: flex; flex-direction: column; box-shadow: 0 8px 32px rgba(0,0,0,0.4); position: relative;">
      <button type="button" class="close-modal-btn" style="position: absolute; top: 1rem; right: 1rem; background: rgba(239, 68, 68, 0.9); color: white; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; font-weight: bold; z-index: 10;">✕</button>
      
      <h2 style="margin: 0 0 0.5rem 0; color: var(--text-strong); font-size: 1.3rem;">
        🖼️ 이미지를 클릭하여 소제목에 배치
      </h2>
      <div id="next-heading-label" style="font-size: 0.9rem; color: var(--primary); margin-bottom: 1rem; font-weight: 600;">
        다음 배치: 1번 - "${escapeHtml((headings[0]?.title || '소제목').substring(0, 30))}..."
      </div>
      
      <!-- 이미지 그리드 -->
      <div id="images-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 12px; max-height: 320px; overflow-y: auto; padding: 12px; background: var(--bg-secondary); border-radius: 12px; margin-bottom: 1rem;">
        ${folderImages.filter(img => img && typeof img === 'object' && (img.previewDataUrl || img.filePath || img.url)).map((img, idx) => {
    // ✅ 이미지 URL 안전하게 추출
    const imageUrl = (img.previewDataUrl || img.filePath || img.url || '').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
    return `
          <div class="placement-image" data-img-idx="${idx}" style="width: 100%; height: 100px; border-radius: 8px; overflow: hidden; cursor: pointer; border: 2px solid var(--border-light); transition: all 0.2s; opacity: 0.85; position: relative;">
            <img src="${imageUrl}" style="width: 100%; height: 100%; object-fit: cover; display: block;" onerror="this.style.display='none';">
            <div class="placement-badge" style="display: none; position: absolute; top: 4px; right: 4px; width: 24px; height: 24px; background: #10b981; color: white; border-radius: 50%; align-items: center; justify-content: center; font-size: 0.8rem; font-weight: 700;"></div>
          </div>
        `;
  }).join('')}
      </div>
      
      <!-- 소제목별 배치 현황 -->
      <div style="margin-bottom: 1rem;">
        <div style="font-weight: 600; color: var(--text-strong); margin-bottom: 0.5rem; font-size: 0.9rem;">📋 소제목별 배치 현황 (클릭하여 취소)</div>
        <div id="placement-status" style="display: grid; gap: 0.5rem; max-height: 200px; overflow-y: auto;">
          <!-- 동적 생성 -->
        </div>
      </div>
      
      <!-- 버튼 -->
      <div style="display: flex; gap: 0.75rem; justify-content: flex-end;">
        <button type="button" class="reset-placement-btn" style="padding: 0.75rem 1.5rem; background: #ef4444; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">🔄 초기화</button>
        <button type="button" class="apply-placement-btn" style="padding: 0.75rem 1.5rem; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">✅ 적용하기</button>
      </div>
    </div>
  `;

  document.body.appendChild(modal);

  // 초기 배치 현황 렌더링
  renderPlacementStatus();

  // 이미지 클릭 이벤트
  modal.querySelectorAll('.placement-image').forEach((imgEl, imgIdx) => {
    imgEl.addEventListener('click', () => {
      // 이미 사용된 이미지면 취소
      if (imageUsage.has(imgIdx)) {
        const headingIdx = imageUsage.get(imgIdx)!;
        placements.delete(headingIdx);
        imageUsage.delete(imgIdx);
        toastManager.info(`배치 취소됨`);
      } else {
        // 새로 배치
        nextHeadingIndex = getNextAvailableHeadingIndex();
        if (nextHeadingIndex < 0) {
          toastManager.warning('모든 소제목에 이미지가 배치되었습니다.');
          return;
        }

        placements.set(nextHeadingIndex, imgIdx);
        imageUsage.set(imgIdx, nextHeadingIndex);
        toastManager.success(`${nextHeadingIndex + 1}번 소제목에 배치됨`);
      }

      updateImageSelectionUI();
      renderPlacementStatus();
    });

    // 호버 효과
    imgEl.addEventListener('mouseenter', () => {
      (imgEl as HTMLElement).style.transform = 'scale(1.05)';
      (imgEl as HTMLElement).style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
    });
    imgEl.addEventListener('mouseleave', () => {
      (imgEl as HTMLElement).style.transform = 'scale(1)';
      (imgEl as HTMLElement).style.boxShadow = 'none';
    });
  });

  // 초기화 버튼
  modal.querySelector('.reset-placement-btn')?.addEventListener('click', () => {
    placements.clear();
    imageUsage.clear();
    updateImageSelectionUI();
    renderPlacementStatus();
    toastManager.info('배치가 초기화되었습니다.');
  });

  // 적용 버튼
  modal.querySelector('.apply-placement-btn')?.addEventListener('click', () => {
    if (placements.size === 0) {
      toastManager.warning('배치된 이미지가 없습니다.');
      return;
    }

    // ImageManager에 배치 적용
    placements.forEach((imgIdx, headingIdx) => {
      const img = folderImages[imgIdx];
      const heading = headings[headingIdx];
      if (img && heading) {
        const headingTitle = typeof heading === 'string' ? String(heading || '').trim() : String((heading as any)?.title || heading || '').trim();
        if (!headingTitle) return;
        ImageManager.setImage(headingTitle, {
          heading: headingTitle,
          filePath: img.filePath || img.url,
          previewDataUrl: img.previewDataUrl || img.filePath || img.url,
          provider: 'local',
          savedToLocal: img.filePath,
        });
      }
    });

    // ✅ 단일 소스(ImageManager)에서 전역 배열 + 모든 미리보기 동기화
    ImageManager.syncGeneratedImagesArray();
    const allImagesAfter = ImageManager.getAllImages();
    (window as any).imageManagementGeneratedImages = allImagesAfter;

    // UI 업데이트 (영어 프롬프트 미리보기 & 생성 이미지 & 통합 미리보기 연동)
    updateUnifiedImagePreview(headings, allImagesAfter);
    displayGeneratedImages(allImagesAfter);
    updatePromptItemsWithImages(allImagesAfter);
    ImageManager.syncAllPreviews();

    appendLog(`✅ ${placements.size}개의 이미지가 소제목에 배치되었습니다.`);
    toastManager.success(`✅ ${placements.size}개의 이미지가 소제목에 배치되었습니다!`);
    modal.remove();
  });

  // 닫기 버튼
  modal.querySelector('.close-modal-btn')?.addEventListener('click', () => modal.remove());

  // 배경 클릭 닫기
  modal.addEventListener('click', (e) => {
    if (e.target === modal) modal.remove();
  });
}

// 발행용 폼 데이터 수집
function collectUnifiedFormDataForPublish(mode: 'full-auto' | 'semi-auto'): any {
  const generator = (document.getElementById('unified-generator') as HTMLSelectElement)?.value || 'gemini';
  // ✅ 글 톤 설정 - UI에서 선택한 값 사용
  const toneStyle = (document.getElementById('unified-tone-style') as HTMLInputElement)?.value || 'friendly';
  const imageSource = UnifiedDOMCache.getImageSource();
  const skipImages = (document.getElementById('unified-skip-images') as HTMLInputElement)?.checked || false;
  const publishMode = (document.getElementById('unified-publish-mode') as HTMLSelectElement)?.value || 'publish';
  const categoryName = UnifiedDOMCache.getRealCategory();

  const scheduleDate = publishMode === 'schedule' ? (document.getElementById('unified-schedule-date') as HTMLInputElement)?.value : undefined;
  const scheduleType = publishMode === 'schedule' ? ((document.getElementById('unified-schedule-type') as HTMLSelectElement)?.value as 'app-schedule' | 'naver-server' || 'app-schedule') : undefined;

  // ✅ 썸네일 텍스트 포함 여부 (나노 바나나 프로 전용)
  const includeThumbnailText =
    (document.getElementById('full-auto-thumbnail-text') as HTMLInputElement)?.checked ||
    (document.getElementById('semi-auto-thumbnail-text') as HTMLInputElement)?.checked ||
    (document.getElementById('thumbnail-text-option') as HTMLInputElement)?.checked ||
    (document.getElementById('ma-setting-include-thumbnail-text') as HTMLInputElement)?.checked ||
    false;

  const baseData = {
    mode,
    generator,
    targetAge: 'all', // 고정
    toneStyle,
    imageSource,
    skipImages,
    publishMode,
    categoryName,
    scheduleDate,
    scheduleType,
    includeThumbnailText // ✅ 추가
  };

  if (mode === 'full-auto') {
    // 풀오토 모드: 현재 생성된 콘텐츠 사용
    const structuredContent = (window as any).currentStructuredContent;
    if (!structuredContent) {
      throw new Error('먼저 콘텐츠를 생성해주세요.');
    }

    return {
      ...baseData,
      urls: [],
      keywords: [],
      title: structuredContent.selectedTitle,
      structuredContent,
      isFullAuto: true // ✅ 풀오토 모드 플래그 (인덱스 기반 이미지 매칭용)
    };
  } else {
    // 반자동 모드: 수동 입력된 콘텐츠 사용
    const title = (document.getElementById('unified-generated-title') as HTMLInputElement)?.value?.trim();
    const content = (document.getElementById('unified-generated-content') as HTMLTextAreaElement)?.value?.trim();
    const hashtags = (document.getElementById('unified-generated-hashtags') as HTMLInputElement)?.value?.trim();

    if (!title || !content) {
      throw new Error('콘텐츠를 먼저 생성해주세요.');
    }

    const structuredContent = {
      selectedTitle: title,
      bodyPlain: content,
      content: content,
      hashtags: hashtags ? hashtags.split(' ').filter(tag => tag.length > 0) : [],
      headings: [] // 반자동 모드에서는 소제목 없이 진행
    };

    return {
      ...baseData,
      title,
      content,
      hashtags: structuredContent.hashtags,
      structuredContent
    };
  }
}

// 통합 폼 검증
function validateUnifiedFormData(data: any): boolean {
  // 예약 발행 시 날짜 확인
  if (data.publishMode === 'schedule' && !data.scheduleDate) {
    alert('예약 발행을 선택하셨으면 예약 날짜/시간을 설정해주세요.');
    return false;
  }

  // 콘텐츠 존재 확인
  if (!data.structuredContent) {
    alert('먼저 콘텐츠를 생성해주세요.');
    return false;
  }

  return true;
}

// 통합 자동화 실행
async function executeUnifiedAutomation(formData: any): Promise<void> {
  const startBtn = document.getElementById('unified-start-btn') as HTMLButtonElement;

  // 진행률 표시 초기화
  const progressContainer = document.createElement('div');
  progressContainer.id = 'unified-progress-container';
  progressContainer.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    width: 300px;
    background: var(--bg-primary);
    border: 2px solid var(--primary);
    border-radius: var(--radius-lg);
    padding: 1rem;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    z-index: 10000;
    font-family: var(--font-family);
  `;

  // ... 진행률 UI 생성 (기존 코드와 동일)

  if (startBtn) {
    startBtn.disabled = true;
    startBtn.innerHTML = '<span style="font-size: 1.75rem;">⏳</span><span>실행 중...</span>';
  }

  const result = await withErrorHandling(async () => {
    if (formData.mode === 'full-auto') {
      // 풀오토 모드 실행 (기존 로직 재사용)
      return await executeFullAutoFlow(formData);
    } else {
      // 반자동 모드 실행
      return await executeSemiAutoFlow(formData);
    }
  }, 'UnifiedExecution');

  // 진행률 표시 제거 및 버튼 복구
  setTimeout(() => {
    if (progressContainer.parentNode) {
      progressContainer.parentNode.removeChild(progressContainer);
    }
    if (startBtn) {
      startBtn.disabled = false;
      startBtn.innerHTML = '<span style="font-size: 1.75rem;">🚀</span><span>발행 중...</span>';
    }
  }, 2000);

  if (!result) {
    toastManager.error('❌ 통합 자동화 실행에 실패했습니다.');
  } else {
    appendLog('✅ 포스팅 발행 완료!');
    // 연속 발행 모드인 경우 다음 포스팅 예약
    console.log('[Continuous] 통합 자동화 완료 후 연속 발행 체크');
    console.log('[Continuous] 현재 상태 - isContinuousMode:', isContinuousMode, '남은 큐:', continuousQueue.length);

    // ✅ V1 방식 (scheduleNextPosting)은 V1 큐에만 적용
    // V2 방식은 startContinuousPublishingV2가 직접 루프를 관리하므로 여기서 추가 스케줄링 불필요
    const hasItemsV1 = continuousQueue.length > 0;
    const hasItemsV2 = continuousQueueV2.some(i => i.status === 'pending');

    if (isContinuousMode && hasItemsV1 && !hasItemsV2) {
      // ✅ V1 방식만 해당될 때만 scheduleNextPosting 호출
      console.log('[Continuous] V1 방식 다음 포스팅 예약 호출');
      scheduleNextPosting();
    } else if (isContinuousMode && !hasItemsV1 && !hasItemsV2) {
      // ✅ 둘 다 남은 항목이 없으면 연속 발행 종료
      console.log('[Continuous] 연속 발행 완료 - 큐가 비어있음');
      stopContinuousMode('complete');
    } else {
      // ✅ V2 방식은 startContinuousPublishingV2에서 관리
      console.log('[Continuous] V2 방식 - 별도 스케줄링 불필요 (루프가 관리 중)');
    }
  }
}

// ✅ UI 스레드 양보 헬퍼 (Electron 응답 없음 방지)
const yieldToUI = () => new Promise<void>(resolve => setTimeout(resolve, 0));

// 풀오토 모드 실행 플로우
async function executeFullAutoFlow(formData: any): Promise<any> {
  // ✅ 중지 플래그 초기화 (새 발행 시작 시)
  (window as any).stopFullAutoPublish = false;

  // ✅ 진행상황 모달 가져오기
  const modal = (window as any).currentProgressModal as ProgressModal | null;

  // ✅ 중지 체크 헬퍼 함수
  const checkShouldStop = () => {
    if (isFullAutoStopRequested(modal)) {
      appendLog('⏹️ 사용자가 작업을 취소했습니다.');
      throw new Error('사용자가 작업을 취소했습니다.');
    }
  };

  try {
    // ✅ 중지 체크
    checkShouldStop();

    // ✅ 이미 생성된 콘텐츠가 있으면 재사용 (중복 생성 방지!)
    let structuredContent = formData.structuredContent;

    if (structuredContent && structuredContent.headings && structuredContent.headings.length > 0) {
      appendLog('📝 기존 생성된 콘텐츠를 사용합니다.');
      console.log('[FullAuto] 기존 콘텐츠 재사용 - 소제목 개수:', structuredContent.headings.length);
    } else {
      // 새로 생성
      appendLog('📝 콘텐츠 생성 중...');
      await yieldToUI();
      structuredContent = await generateFullAutoContent(formData);
    }

    if (!structuredContent) {
      throw new Error('콘텐츠 생성에 실패했습니다.');
    }

    await yieldToUI(); // UI 업데이트 허용
    await displayContentInAllTabs(structuredContent);
    await yieldToUI();

    // ✅ 콘텐츠 저장 및 postId 생성
    currentStructuredContent = structuredContent;
    (window as any).currentStructuredContent = structuredContent;
    const postId = saveGeneratedPost(structuredContent, false, { category: formData.category || formData.categoryName });
    if (postId) {
      currentPostId = postId;
    }

    await yieldToUI(); // UI 업데이트 허용

    // ✅ 이미지 가져오기 (우선순위: ImageManager > 새로 생성)
    let finalImages: any[] = [];

    // 1. ImageManager에서 이미지 가져오기
    const imageManagerImages = ImageManager.getAllImages();
    if (imageManagerImages && imageManagerImages.length > 0) {
      finalImages = imageManagerImages;
      appendLog(`🖼️ ImageManager에서 ${finalImages.length}개의 이미지를 가져왔습니다.`);
    }

    await yieldToUI();

    // 2. 전역 generatedImages에서 가져오기
    if (finalImages.length === 0 && generatedImages && generatedImages.length > 0) {
      finalImages = generatedImages;
      appendLog(`🖼️ 전역 generatedImages에서 ${finalImages.length}개의 이미지를 가져왔습니다.`);
    }

    await yieldToUI();

    // 3. 이미지가 없고 skipImages가 false면 선택된 이미지 소스로 이미지 생성
    if (finalImages.length === 0 && !formData.skipImages && formData.imageSource && formData.imageSource !== 'skip') {
      appendLog(`🖼️ 이미지 생성 시작 (소스: ${formData.imageSource})...`);
      modal?.addLog(`🖼️ ${formData.imageSource}로 이미지 생성 중...`);
      modal?.setProgress(35, '이미지 생성 중...');

      try {
        const headings = structuredContent.headings || [];

        // ✅ 참조 이미지 추출 (이전에 수집된 이미지가 있다면 사용)
        let referenceImagePath = '';
        const collectedImgs = (window as any).imageManagementGeneratedImages || (window as any).generatedImages || [];
        if (collectedImgs.length > 0) {
          referenceImagePath = collectedImgs[0].filePath || collectedImgs[0].url;
        }

        const imageResult = await generateImagesWithCostSafety({
          provider: formData.imageSource,
          title: structuredContent.selectedTitle || structuredContent.title || '',
          // ✅ [신규] thumbnailOnly 옵션: 1번 소제목만 이미지 생성 (나머지는 텍스트만)
          items: (() => {
            const allItems = headings.map((h: any, idx: number) => {
              const title = String(h.title || h.text || (typeof h === 'string' ? h : '')).trim();
              const prompt = String(h.imagePrompt || h.prompt || title || 'Abstract Image').trim();
              return {
                heading: title || '이미지',
                prompt: prompt,
                isThumbnail: idx === 0,
                allowText: idx === 0 ? !!formData.includeThumbnailText : false
              };
            });

            // thumbnailOnly 옵션이 활성화되면 첫 번째 항목만 반환
            if (formData.thumbnailOnly) {
              console.log('[FullAuto] 📷 썸네일만 생성 모드: 1번 소제목만 이미지 생성');
              return allItems.slice(0, 1).map((item: any) => ({ ...item, allowText: true })); // 텍스트 포함 강제
            }
            return allItems;
          })(),
          category: formData.category || formData.categoryName || '',
          referenceImagePath, // ✅ 참조 이미지 전달
        });

        if (imageResult?.success && imageResult.images && imageResult.images.length > 0) {
          finalImages = imageResult.images;
          // ImageManager에 저장
          imageResult.images.forEach((img: any, idx: number) => {
            const heading = headings[idx]?.title || headings[idx] || `이미지 ${idx + 1}`;
            ImageManager.addImage(heading, {
              filePath: img.filePath,
              provider: img.provider || formData.imageSource,
              url: img.url || img.filePath
            });
          });
          appendLog(`✅ ${finalImages.length}개의 이미지 생성 완료!`);
          modal?.addLog(`✅ 이미지 ${finalImages.length}개 생성 완료`);
        } else {
          appendLog(`⚠️ 이미지 생성 실패 또는 이미지 없음. 텍스트 위주로 발행합니다.`);
          modal?.addLog('⚠️ 이미지 생성 실패, 텍스트로 진행');
        }
      } catch (imgError) {
        console.error('[FullAuto] 이미지 생성 오류:', imgError);
        appendLog(`⚠️ 이미지 생성 중 오류: ${(imgError as Error).message}. 텍스트 위주로 발행을 시도합니다.`);
        modal?.addLog('⚠️ 이미지 생성 오류, 텍스트로 진행');
      }
    } else if (finalImages.length === 0 && formData.skipImages) {
      appendLog('ℹ️ 이미지 건너뛰기 옵션이 선택되어 이미지 없이 발행합니다.');
      modal?.addLog('ℹ️ 이미지 건너뛰기');
    }


    await yieldToUI();

    finalImages = filterImagesForPublish(structuredContent, finalImages);

    // ✅ 이미지 목록 로깅
    if (finalImages.length > 0) {
      appendLog(`✅ 총 ${finalImages.length}개의 이미지를 발행에 사용합니다.`);
      finalImages.forEach((img: any, idx: number) => {
        const provider = img.provider || 'unknown';
        const heading = img.heading || '제목 없음';
        appendLog(`   [${idx + 1}] ${heading} (${provider})`);
      });
    }

    await yieldToUI();

    // 풀오토 발행에서도 이미지 미리보기 표시
    if (structuredContent.headings && structuredContent.headings.length > 0) {
      appendLog('✅ 이미지 준비 완료! 바로 발행을 진행합니다.');
      updateUnifiedImagePreview(structuredContent.headings, finalImages);
    }

    await yieldToUI();

    // ✅ [100점 수정] 후킹 이미지 영상 변환 (쇼핑커넥트 모드 전용)
    // useAffiliateVideo 옵션이 활성화되면 2번째 이미지(본문 첫 이미지)를 영상으로 변환
    if ((formData as any).useAffiliateVideo && finalImages.length >= 2) {
      const hookingImage = finalImages[1]; // 2번째 이미지 (인덱스 1) - 본문 첫 이미지
      const hookingHeading = structuredContent.headings?.[1]?.title || structuredContent.headings?.[1]?.text || '후킹 영상';
      const hookingImagePath = hookingImage?.filePath || '';
      const normalizedHeading = normalizeHeadingKeyForVideoCache(String(hookingHeading).trim());

      // ✅ [100점 개선] 기존 영상 중복 체크
      const existingVideo = typeof (window.api as any)?.getAppliedVideo === 'function'
        ? await (window.api as any).getAppliedVideo(normalizedHeading)
        : null;

      if (existingVideo?.filePath) {
        appendLog(`ℹ️ 이미 영상이 배치되어 있습니다: "${hookingHeading}". 기존 영상을 사용합니다.`);
        modal?.addLog('ℹ️ 기존 영상 재사용');
      } else if (hookingImagePath) {
        appendLog(`🎬 [쇼핑커넥트] 후킹 이미지 영상 변환 시작: "${hookingHeading}"`);
        appendLog('   📐 비율: 1:1 (정사각형, 피드 꽉찬 표시)');
        modal?.addLog('🎬 후킹 영상 생성 중...');
        modal?.setProgress(52, '후킹 영상 생성 중...');

        try {
          // Veo 또는 KenBurns 영상 생성
          let videoResult: any = null;
          const startTime = Date.now();
          const VEO_TIMEOUT_MS = 120000; // 2분 (Veo 워닝용)

          // 먼저 Veo 시도
          if (typeof (window.api as any)?.generateVeoVideo === 'function') {
            // ✅ [100점 개선] 더 효과적인 영상 프롬프트 (피드 주목도 극대화)
            const veoPrompt = `Cinematic product reveal video. The ${hookingHeading} dramatically fills the entire square frame. Slow zoom in with professional studio lighting. Luxurious and premium feel. High contrast, vivid colors. Center-focused composition for maximum visual impact on social media feed.`;

            appendLog('   ⏳ Veo 영상 생성 요청 중... (최대 2~3분 소요)');

            videoResult = await (window.api as any).generateVeoVideo({
              prompt: veoPrompt,
              model: 'veo-3.1-generate-preview',
              durationSeconds: 6,
              aspectRatio: '1:1', // ✅ [100점 개선] 1:1 정사각형 비율로 피드에서 꽉차게 표시
              negativePrompt: 'audio, speech, voice, voiceover, narration, music, singing, lyrics, dialogue, text, watermark, logo',
              imagePath: hookingImagePath,
              heading: String(hookingHeading).trim(),
            });

            // ✅ [100점 개선] 타임아웃 경고
            const elapsedMs = Date.now() - startTime;
            if (elapsedMs > VEO_TIMEOUT_MS && !videoResult?.success) {
              appendLog('   ⏰ Veo 생성이 오래 걸리고 있습니다. KenBurns로 빠르게 전환합니다.');
            }
          }

          // Veo 실패 시 KenBurns 폴백
          if (!videoResult?.success) {
            appendLog(`⚠️ Veo 영상 생성 실패, KenBurns로 폴백: ${videoResult?.message || 'unknown'}`);
            modal?.addLog('🔄 KenBurns 폴백 생성 중...');

            if (typeof (window.api as any)?.createKenBurnsVideo === 'function') {
              videoResult = await (window.api as any).createKenBurnsVideo({
                imagePath: hookingImagePath,
                heading: String(hookingHeading).trim(),
                durationSeconds: 6,
                aspectRatio: '1:1', // ✅ [100점 개선] 1:1 정사각형 비율
              });
            }
          }

          if (videoResult?.success && videoResult?.filePath) {
            appendLog(`✅ 후킹 영상 생성 완료: ${videoResult.filePath}`);
            appendLog('   📐 1:1 정사각형 비율로 피드에서 꽉차게 표시됩니다.');
            modal?.addLog('✅ 후킹 영상 생성 완료');

            // 소제목에 영상 적용
            if (typeof (window.api as any)?.applyHeadingVideo === 'function') {
              await (window.api as any).applyHeadingVideo(String(hookingHeading).trim(), {
                provider: videoResult.filePath?.includes('veo') ? 'veo' : 'kenburns',
                filePath: videoResult.filePath,
                previewDataUrl: '',
                updatedAt: Date.now(),
              });
            }
          } else {
            appendLog(`⚠️ 후킹 영상 생성 실패: ${videoResult?.message || '알 수 없는 오류'}. 영상 없이 진행합니다.`);
            modal?.addLog('⚠️ 후킹 영상 생성 실패, 계속 진행');
          }
        } catch (videoError) {
          console.error('[FullAuto] 후킹 영상 생성 오류:', videoError);
          appendLog(`⚠️ 후킹 영상 생성 중 오류: ${(videoError as Error).message}. 영상 없이 진행합니다.`);
          modal?.addLog('⚠️ 후킹 영상 오류, 계속 진행');
        }

        await yieldToUI();
      } else {
        appendLog('⚠️ 후킹 이미지 경로가 없어 영상 변환을 건너뜁니다.');
      }
    }

    // ✅ 진행상황 모달 업데이트 - 이미지 생성 완료, 로그인 시작
    modal?.setStep(2, 'completed', '완료');
    modal?.setProgress(55, '네이버 로그인 준비 중...');
    modal?.addLog(`✅ 이미지 ${finalImages.length}개 준비 완료`);
    modal?.setStep(3, 'active', '로그인 중...');

    // ✅ 발행 전 중지 체크
    checkShouldStop();

    // ✅ [NEW] CTA 자동 링크 로직 (이전글 엮기)
    // 연속 발행 모드인 경우(isContinuousMode), 매 단계마다 가장 최근 발행글을 새로 찾아서 링크 (체인 엮기)
    const canAutoLink = formData.ctaType === 'previous-post';
    const needsLinkLookup = !formData.ctaUrl || formData.ctaUrl.trim() === '' || isContinuousMode;

    if (canAutoLink && needsLinkLookup) {
      appendLog(`🔗 CTA 자동 링크: 이전글 찾기 시작... (연속발행: ${isContinuousMode ? 'ON' : 'OFF'})`);

      // ✅ [100점 수정] 기존 글 카테고리 마이그레이션 (영어 → 한글 통일)
      ensureCategoryMigration();

      // ✅ [2026-01-24 FIX] 모든 계정의 글에서 이전글 매칭 (계정별 분리로 인한 매칭 실패 해결)
      const allPosts = loadAllGeneratedPosts();

      // ✅ [100점 수정] 현재 카테고리 정규화 적용
      const rawCategory = formData.category || formData.categoryName || '';
      const currentCategory = normalizeCategory(rawCategory);

      // ✅ [디버그] 카테고리 정보 로그
      appendLog(`   📂 현재 카테고리: "${currentCategory || '없음'}" (원본: "${rawCategory}")`);

      // ✅ [수정] 같은 카테고리의 발행된 글 찾기 (정규화된 카테고리로 비교)
      const publishedPosts = allPosts.filter((p: any) => p.publishedUrl && p.publishedUrl.trim());
      appendLog(`   📊 전체 발행글: ${publishedPosts.length}개`);

      // 1차: 정확히 일치하는 카테고리 (가장 최신순)
      let prevPosts = publishedPosts
        .filter((p: any) => {
          if (!currentCategory) return false; // ✅ [수정] 카테고리 없으면 정확 일치 불가
          const postCat = normalizeCategory(p.category || '');
          return postCat === currentCategory;
        })
        .sort((a: any, b: any) => {
          const dateA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
          const dateB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
          return dateB - dateA;
        });

      appendLog(`   🔍 동일 카테고리 글: ${prevPosts.length}개`);

      // 2차: 정확 일치가 없으면 부분 포함으로 검색 (느슨한 매칭)
      if (prevPosts.length === 0 && currentCategory) {
        appendLog(`   ⚠️ 정확 일치 없음, 유사 카테고리 검색 중...`);
        prevPosts = publishedPosts
          .filter((p: any) => {
            const postCat = normalizeCategory(p.category || '');
            if (!postCat) return false;
            return currentCategory.includes(postCat) || postCat.includes(currentCategory);
          })
          .sort((a: any, b: any) => {
            const dateA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
            const dateB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
            return dateB - dateA;
          });
      }

      // 현재 글(구분용 ID가 있다면)은 제외하고 가장 최신 글 선택
      const prevPost = prevPosts[0];

      if (prevPost) {
        formData.ctaUrl = prevPost.publishedUrl;
        // 텍스트가 비어있거나 '📖'로 시작하는 이전 자동 생성 텍스트인 경우 새로 생성
        if (!formData.ctaText || formData.ctaText.startsWith('📖')) {
          formData.ctaText = `📖 추천 글: ${prevPost.title}`;
        }
        appendLog(`✅ 이전글 자동 매칭 성공: "${prevPost.title}" (카테고리: ${prevPost.category || '없음'})`);
        appendLog(`   👉 URL: ${formData.ctaUrl}`);
        modal?.addLog(`🔗 이전글 자동 매칭: ${prevPost.title}`);
      } else {
        if (!currentCategory) {
          appendLog('⚠️ 현재 카테고리가 설정되지 않았습니다. "발행 카테고리" 드롭다운을 확인해주세요.');
        } else {
          appendLog(`⚠️ "${currentCategory}" 카테고리의 이전 발행글을 찾지 못했습니다.`);
        }
        // 만약 수동으로 입력된 링크도 없다면 none으로 변경
        if (!formData.ctaUrl) formData.ctaType = 'none';
      }
    }

    // ✅ [2026-01-24 FIX] 모든 발행 모드에서 이전글 자동 연결 (쇼핑커넥트뿐만 아니라 모든 모드)
    // previousPostUrl이 없을 때만 자동 매칭 수행
    const needsPreviousPostLookup = !formData.previousPostUrl || formData.previousPostUrl.trim() === '';
    const isShoppingConnectMode = formData.affiliateLink && formData.affiliateLink.trim();

    if (needsPreviousPostLookup) {
      const modeLabel = isShoppingConnectMode ? '🛒 쇼핑커넥트' : '📝 일반';
      appendLog(`${modeLabel} 모드: 같은 카테고리 이전글 찾기 시작...`);

      // ✅ [100점 수정] 기존 글 카테고리 마이그레이션 (영어 → 한글 통일)
      ensureCategoryMigration();

      // ✅ [2026-01-24 FIX] 모든 계정의 글에서 이전글 매칭
      const allPosts = loadAllGeneratedPosts();

      // ✅ [100점 수정] 현재 카테고리 정규화 적용
      const rawCategory = formData.category || formData.categoryName || '';
      const currentCategory = normalizeCategory(rawCategory);
      appendLog(`   📂 현재 카테고리: "${currentCategory || '없음'}" (원본: "${rawCategory}")`);

      // ✅ [수정] 같은 카테고리의 발행된 글 찾기 (정규화된 카테고리로 비교)
      const publishedPosts = allPosts.filter((p: any) => p.publishedUrl && p.publishedUrl.trim());
      appendLog(`   📊 전체 발행글: ${publishedPosts.length}개`);

      let prevPosts: any[] = [];

      // 쇼핑커넥트 모드인 경우: 쇼핑커넥트 글 우선 매칭
      if (isShoppingConnectMode) {
        prevPosts = publishedPosts
          .filter((p: any) => {
            if (!currentCategory) return false;
            const postCat = normalizeCategory(p.category || '');
            const categoryMatch = postCat === currentCategory;
            // ✅ 이전글도 쇼핑커넥트 글이어야 함
            const isPostShoppingConnect = !!(p.affiliateLink || p.contentMode === 'shopping-connect');
            return categoryMatch && isPostShoppingConnect;
          })
          .sort((a: any, b: any) => {
            const dateA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
            const dateB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
            return dateB - dateA;
          });

        appendLog(`   🔍 동일 카테고리 쇼핑커넥트 글: ${prevPosts.length}개`);
      }

      // 폴백: 같은 카테고리의 모든 글 검색 (쇼핑커넥트 글이 없거나, 일반 모드인 경우)
      if (prevPosts.length === 0 && currentCategory) {
        if (isShoppingConnectMode) {
          appendLog(`   ⚠️ 쇼핑커넥트 이전글 없음, 같은 카테고리 전체 글 검색 중...`);
        }
        prevPosts = publishedPosts
          .filter((p: any) => {
            const postCat = normalizeCategory(p.category || '');
            return postCat === currentCategory;
          })
          .sort((a: any, b: any) => {
            const dateA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
            const dateB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
            return dateB - dateA;
          });

        appendLog(`   🔍 동일 카테고리 전체 글: ${prevPosts.length}개`);
      }

      const prevPost = prevPosts[0];

      if (prevPost) {
        formData.previousPostTitle = prevPost.title;
        formData.previousPostUrl = prevPost.publishedUrl;
        appendLog(`✅ 이전글 자동 매칭 성공: "${prevPost.title}" (카테고리: ${prevPost.category || '없음'})`);
        appendLog(`   👉 이전글 URL: ${formData.previousPostUrl}`);
        // ✅ [디버깅] 이전글 URL 유효성 확인
        if (formData.previousPostUrl && !formData.previousPostUrl.includes('blog.naver.com')) {
          appendLog(`   ⚠️ [경고] 이전글 URL이 blog.naver.com이 아닙니다: ${formData.previousPostUrl}`);
        }
        modal?.addLog(`🔗 이전글 자동 매칭: ${prevPost.title}`);
      } else {
        if (!currentCategory) {
          appendLog('⚠️ 현재 카테고리가 설정되지 않았습니다. "발행 카테고리" 드롭다운을 확인해주세요.');
        } else {
          appendLog(`⚠️ "${currentCategory}" 카테고리의 이전 발행글을 찾지 못했습니다.`);
        }
      }
    }

    // 즉시 발행 진행
    const automationResult = await executeBlogPublishing(structuredContent, finalImages, formData);

    // ✅ 발행 완료 시 글 정보 업데이트 (이미지, URL, 발행상태)
    if (currentPostId && automationResult?.success) {
      const publishedUrl = automationResult.url || automationResult.postUrl || automationResult.blogUrl;
      if (publishedUrl) {
        updatePostAfterPublish(currentPostId, publishedUrl);
      }
      // ✅ 이미지 정보도 글목록에 저장
      updatePostImages(currentPostId, finalImages);
    }

    // ✅ 진행상황 모달 업데이트 - 발행 완료
    modal?.setStep(3, 'completed', '완료');
    modal?.setStep(4, 'completed', '완료');
    modal?.setProgress(100, '발행 완료!');
    modal?.addLog('✅ 블로그 발행 완료!');

    // ✅ Unified Progress Bar도 100%로 강제 업데이트 (95%에서 멈춤 방지)
    showUnifiedProgress(100, '발행 완료!', '모든 작업이 완료되었습니다.');

    // ✅ 발행 완료 시 자동 저장/백업 중지 및 임시 데이터 삭제
    try {
      stopAutosave();
      stopAutoBackup();
      clearAutosavedContent();
      appendLog('💾 임시 저장 데이터 삭제 완료');
    } catch (e) {
      console.error('[FullAutoFlow] 임시 데이터 정리 중 오류:', e);
    }

    // ✅ 모든 필드 초기화 (3초 후)
    setTimeout(() => {
      try {
        resetAllFields();
        // ✅ Unified Progress Bar 숨기기 추가
        hideUnifiedProgress();
      } catch (e) {
        console.error('[FullAutoFlow] 필드 초기화 중 오류:', e);
      }
    }, 3000);

    return automationResult;
  } catch (error) {
    console.error('[FullAutoFlow] 오류:', error);
    throw error;
  }
}

// 반자동 모드 실행 플로우
async function executeSemiAutoFlow(formData: any): Promise<any> {
  // 반자동 로직 구현
  appendLog('🔧 반자동 모드: 수동 콘텐츠 기반 자동화 시작');
  showUnifiedProgress(5, '수동 콘텐츠 처리 시작', '입력된 콘텐츠를 분석하고 있습니다.');

  // ✅ [2026-01-21 FIX] 반자동 발행 시 프리셋 썸네일 복원
  // 썸네일 생성기에서 저장한 image-tab 프리셋이 있으면 복원
  const imageTabPreset = applyPresetThumbnailIfExists('image-tab');
  if (imageTabPreset.applied) {
    appendLog('🎨 미리 세팅된 썸네일이 복원됩니다!');

    // ImageManager에 1번 소제목 이미지로 복원
    const firstHeadingTitle = resolveFirstHeadingTitleForThumbnail();
    if (firstHeadingTitle && imageTabPreset.forHeading) {
      imageTabPreset.forHeading.heading = firstHeadingTitle;
      ImageManager.setImage(firstHeadingTitle, imageTabPreset.forHeading);

      // generatedImages 업데이트
      if (!formData.imageManagementImages || formData.imageManagementImages.length === 0) {
        formData.imageManagementImages = [imageTabPreset.forHeading];
      } else {
        formData.imageManagementImages[0] = imageTabPreset.forHeading;
      }

      // thumbnailPath도 설정 (쇼핑커넥트 대비)
      if (imageTabPreset.forThumbnail) {
        (window as any).thumbnailPath = imageTabPreset.forThumbnail;
        formData.thumbnailPath = imageTabPreset.forThumbnail;
      }
    }
  }

  // 구조화된 콘텐츠 사용 (formData에서 전달된 structuredContent 사용)
  // 반자동 모드는 이미 생성된 콘텐츠를 사용하므로 소제목 정보도 포함되어야 함
  const structuredContent = formData.structuredContent || {
    selectedTitle: formData.title,
    bodyPlain: formData.content,
    content: formData.content,
    hashtags: formData.hashtags,
    headings: formData.structuredContent?.headings || [] // 소제목 정보 보존
  };

  // 소제목 정보가 있으면 로그 출력
  if (structuredContent.headings && structuredContent.headings.length > 0) {
    appendLog(`📑 소제목 ${structuredContent.headings.length}개가 포함되어 있습니다.`);
  }

  // 미리보기 업데이트
  updateUnifiedPreview(structuredContent);
  showUnifiedProgress(30, '콘텐츠 준비 완료', '수동 입력 콘텐츠가 준비되었습니다.');
  appendLog('✅ 콘텐츠 준비 완료');

  // ✅ 이미지 관리 탭에서 생성한 이미지가 있으면 사용, 없으면 생성
  let generatedImagesForPublish: any[] = [];

  // ✅ 디버깅: formData.imageManagementImages 확인
  console.log('[SemiAuto] formData.imageManagementImages:', formData.imageManagementImages);
  console.log('[SemiAuto] imageManagementImages.length:', formData.imageManagementImages?.length);
  console.log('[SemiAuto] skipImages:', formData.skipImages);

  // ✅ 이미지 관리 탭에서 생성한 이미지가 있으면 사용 (빈 배열도 '사용자 의도'로 간주), 없으면 생성
  // ✅ [수정] imageManagementImages가 배열이면 (빈 배열 포함) 사용자가 이미지 관리 탭을 사용한 것으로 간주
  //    - 자동 생성 하지 않고 그대로 사용 (빈 슬롯은 이미지 없이 발행)
  const hasImageManagementData = Array.isArray(formData.imageManagementImages);

  if (hasImageManagementData && formData.imageManagementImages.length > 0) {
    // 이미지 관리 탭에서 생성한 이미지 사용
    showUnifiedProgress(50, '이미지 준비 완료', `이미지 관리 탭에서 생성한 ${formData.imageManagementImages.length}개의 이미지를 사용합니다.`);
    appendLog(`✅ 이미지 관리 탭에서 생성한 ${formData.imageManagementImages.length}개의 이미지를 사용합니다.`);

    generatedImagesForPublish = filterImagesForPublish(structuredContent, [...formData.imageManagementImages]);

    showUnifiedProgress(60, '이미지 준비 완료', '이미지가 준비되었습니다.');
    appendLog('✅ 이미지 준비 완료!');
  } else if (hasImageManagementData && formData.imageManagementImages.length === 0) {
    // ✅ [New] 이미지 관리 탭에서 의도적으로 이미지를 비워둔 경우 → 자동 생성 없이 발행
    showUnifiedProgress(50, '이미지 없이 발행', '이미지 관리 탭에 이미지가 없어 이미지 없이 발행합니다.');
    appendLog('⏭️ 이미지 관리 탭에 이미지가 없습니다. 이미지 없이 발행합니다.');
    generatedImagesForPublish = [];
  } else if (!formData.skipImages) {
    // 이미지 관리 탭을 사용하지 않은 경우에만 새로 이미지 생성
    showUnifiedProgress(40, '이미지 생성 시작...', '제목에 맞는 이미지를 생성하고 있습니다.');
    appendLog('🎨 이미지가 없습니다. 새로 생성 중...');
    appendLog(`   [디버그] imageManagementImages가 없어서 새로 생성: ${JSON.stringify(formData.imageManagementImages)}`);
    generatedImagesForPublish = await generateImagesForContent(structuredContent, formData);

    // ✅ 생성된 이미지를 ImageManager에 등록 (발행 시 매칭을 위해 필수!)
    if (generatedImagesForPublish.length > 0) {
      generatedImagesForPublish.forEach((img: any) => {
        if (img.heading) {
          ImageManager.setImage(img.heading, img);
        }
      });
      appendLog(`🔗 ImageManager에 ${generatedImagesForPublish.length}개 이미지 등록 완료`);
    }

    showUnifiedProgress(60, '이미지 생성 완료', '이미지가 성공적으로 생성되었습니다.');
    appendLog('✅ 이미지 생성 완료');
  } else {
    appendLog('⏭️ 이미지 생성 건너뛰기 (skipImages = true)');
  }

  // 블로그 발행
  showUnifiedProgress(80, '블로그 발행 준비 중...', '네이버 블로그에 발행할 준비를 하고 있습니다.');
  appendLog('📤 블로그 발행 시작...');
  appendLog(`📊 발행 정보: 제목="${structuredContent.selectedTitle}", 이미지=${generatedImagesForPublish.length}개`);
  showUnifiedProgress(90, '블로그 발행 중...', '네이버 블로그에 콘텐츠를 발행하고 있습니다.');
  const automationResult = await executeBlogPublishing(structuredContent, generatedImagesForPublish, formData);

  // ✅ 발행 완료 시 글 정보 업데이트 (이미지, URL, 발행상태)
  if (currentPostId && automationResult?.success) {
    const publishedUrl = automationResult.url || automationResult.postUrl || automationResult.blogUrl;
    if (publishedUrl) {
      updatePostAfterPublish(currentPostId, publishedUrl);
    }
    // ✅ 이미지 정보도 글목록에 저장
    updatePostImages(currentPostId, generatedImagesForPublish);
  }

  showUnifiedProgress(100, '발행 완료!', '🎉 반자동 발행이 성공적으로 완료되었습니다!');
  appendLog('✅ 반자동 모드 자동화 완료');

  // ✅ 발행 완료 시 자동 저장/백업 중지 및 임시 데이터 삭제
  stopAutosave();
  stopAutoBackup();
  clearAutosavedContent();
  appendLog('💾 임시 저장 데이터 삭제 완료');

  // ✅ 모든 필드 초기화 (3초 후)
  setTimeout(() => {
    resetAllFields();
    // 썸네일 생성기도 함께 초기화
    resetThumbnailGeneratorOnPublish();
  }, 3000);

  // 2초 후 진행률 숨김
  setTimeout(() => {
    const progressContainer = document.getElementById('unified-progress-container');
    if (progressContainer) {
      progressContainer.style.display = 'none';
    }
  }, 3000);

  return automationResult;
}

// 통합 미리보기 업데이트
function updateUnifiedPreview(structuredContent: any): void {
  const previewSection = document.getElementById('unified-preview-section');
  if (!previewSection) return;

  // 미리보기 표시 애니메이션
  previewSection.style.display = 'block';

  // 부드러운 애니메이션 효과
  setTimeout(() => {
    previewSection.style.opacity = '1';
    previewSection.style.transform = 'translateY(0)';
  }, 100);

  // 성공 효과음 같은 시각적 피드백
  previewSection.style.boxShadow = '0 0 20px rgba(16, 185, 129, 0.3)';

  // 테두리 색상 변화 애니메이션
  let borderAnimationCount = 0;
  const borderAnimation = setInterval(() => {
    borderAnimationCount++;
    if (borderAnimationCount % 2 === 0) {
      previewSection.style.borderColor = 'var(--accent)';
    } else {
      previewSection.style.borderColor = 'var(--primary)';
    }

    if (borderAnimationCount >= 6) { // 3번 깜빡임
      clearInterval(borderAnimation);
      previewSection.style.borderColor = 'var(--primary)';
      previewSection.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.1)';
    }
  }, 200);

  // 미리보기로 자동 스크롤
  setTimeout(() => {
    previewSection.scrollIntoView({
      behavior: 'smooth',
      block: 'center'
    });
  }, 300);
  // ✅ 생성된 이미지 미리보기 섹션 표시
  const generatedImagesSection = document.getElementById('generated-images-section');
  if (generatedImagesSection) {
    generatedImagesSection.style.display = 'block';
  }

  // ✅ MP4 목록 섹션도 표시 + 초기 로드
  const mp4FilesSection = document.getElementById('mp4-files-section');
  if (mp4FilesSection) {
    mp4FilesSection.style.display = 'block';
  }
  refreshMp4FilesList();

  // ✅ 영상 provider 선택값 복원/저장
  const videoProviderSelect = document.getElementById('video-provider-select') as HTMLSelectElement | null;
  if (videoProviderSelect) {
    try {
      const raw = String(window.localStorage?.getItem('videoProvider') || '').trim().toLowerCase();
      const stored: VideoProvider = raw === 'kenburns' ? 'kenburns' : 'veo';
      setCurrentVideoProvider(stored);
    } catch {
      setCurrentVideoProvider('veo');
    }

    if (!videoProviderSelect.hasAttribute('data-listener-added')) {
      videoProviderSelect.setAttribute('data-listener-added', 'true');
      videoProviderSelect.addEventListener('change', () => {
        try {
          setCurrentVideoProvider(getCurrentVideoProvider());
        } catch {
          // ignore
        }
      });
    }
  }

  // ✅ 이미지 폴더 열기 버튼 이벤트
  const openImagesFolderBtn = document.getElementById('open-images-folder-btn');
  if (openImagesFolderBtn && !openImagesFolderBtn.hasAttribute('data-listener-added')) {
    openImagesFolderBtn.setAttribute('data-listener-added', 'true');
    openImagesFolderBtn.addEventListener('click', async () => {
      try {
        if (!window.api.openPath) {
          appendLog('⚠️ 파일 시스템 API를 사용할 수 없습니다.');
          alert('파일 시스템 API를 사용할 수 없습니다.');
          return;
        }

        const imageFolderPath = await getRequiredImageBasePath();

        // window.api.openPath가 있으면 사용
        if (window.api.openPath) {
          await window.api.openPath(imageFolderPath);
          appendLog(`📂 이미지 폴더를 열었습니다: ${imageFolderPath}`);
        } else {
          // 폴백: 경로를 클립보드에 복사
          await navigator.clipboard.writeText(imageFolderPath);
          alert(`이미지 폴더 경로가 클립보드에 복사되었습니다:\n\n${imageFolderPath}\n\n탐색기에서 이 경로를 붙여넣어 주세요.`);
        }
      } catch (error) {
        console.error('폴더 열기 실패:', error);
        alert((error as Error).message || '폴더를 열 수 없습니다. 경로를 확인해주세요.');
      }
    });
  }

  // ✅ 기존 폴더에 저장하기 버튼(최근 폴더 열기)
  const openExistingImagesFolderBtn = document.getElementById('open-existing-images-folder-btn');
  if (openExistingImagesFolderBtn && !openExistingImagesFolderBtn.hasAttribute('data-listener-added')) {
    openExistingImagesFolderBtn.setAttribute('data-listener-added', 'true');
    openExistingImagesFolderBtn.addEventListener('click', async () => {
      try {
        await openExistingImageFolder();
      } catch (e) {
        console.error('기존 폴더 열기 실패:', e);
        toastManager.error((e as Error).message || '기존 폴더를 열 수 없습니다.');
      }
    });
  }

  // ✅ 폴더에서 이미지 불러오기 버튼 이벤트 (한 번만 등록)
  const loadImagesFromFoldersBtn = document.getElementById('load-images-from-folders-btn');
  if (loadImagesFromFoldersBtn && !loadImagesFromFoldersBtn.hasAttribute('data-listener-added')) {
    loadImagesFromFoldersBtn.setAttribute('data-listener-added', 'true');
    loadImagesFromFoldersBtn.addEventListener('click', async () => {
      await showLoadImagesFromFoldersModal();
    });
  }

  const undoImageChangeBtn = document.getElementById('undo-image-change-btn');
  if (undoImageChangeBtn && !undoImageChangeBtn.hasAttribute('data-listener-added')) {
    undoImageChangeBtn.setAttribute('data-listener-added', 'true');
    undoImageChangeBtn.addEventListener('click', () => {
      undoLastImageChange();
    });
  }

  // ✅ MP4 폴더 열기 버튼 (상단/하단 둘 다)
  const openMp4Btns = [
    document.getElementById('open-mp4-folder-btn'),
    document.getElementById('open-mp4-folder-btn-2'),
  ].filter(Boolean) as HTMLElement[];

  openMp4Btns.forEach((btn) => {
    if (btn.hasAttribute('data-listener-added')) return;
    btn.setAttribute('data-listener-added', 'true');
    btn.addEventListener('click', async () => {
      try {
        const dir = await getAiVideoFolderPath();
        await window.api.openPath(dir);
      } catch (e) {
        console.error('[AI-VIDEO] 폴더 열기 실패:', e);
        toastManager.error((e as Error).message || 'AI 영상 폴더를 열 수 없습니다.');
      }
    });
  });

  // ✅ MP4 목록 새로고침
  const refreshMp4ListBtn = document.getElementById('refresh-mp4-list-btn');
  if (refreshMp4ListBtn && !refreshMp4ListBtn.hasAttribute('data-listener-added')) {
    refreshMp4ListBtn.setAttribute('data-listener-added', 'true');
    refreshMp4ListBtn.addEventListener('click', async () => {
      await refreshMp4FilesList();
    });
  }

  // ✅ MP4 영상 불러오기(내 PC mp4를 AI 영상 폴더로 복사)
  const importMp4Btn = document.getElementById('import-mp4-btn');
  if (importMp4Btn && !importMp4Btn.hasAttribute('data-listener-added')) {
    importMp4Btn.setAttribute('data-listener-added', 'true');
    importMp4Btn.addEventListener('click', async () => {
      try {
        if (typeof (window.api as any)?.showOpenDialog !== 'function') {
          toastManager.error('파일 선택 기능을 사용할 수 없습니다.');
          return;
        }

        const pick = await (window.api as any).showOpenDialog({
          properties: ['openFile'],
          filters: [{ name: 'MP4 Videos', extensions: ['mp4'] }],
        });

        if (!pick || pick.canceled || !Array.isArray(pick.filePaths) || pick.filePaths.length === 0) return;
        const sourcePath = String(pick.filePaths[0] || '').trim();
        if (!sourcePath) return;

        const dirPath = await getAiVideoFolderPath();

        // IPC가 아직 없으면 폴더만 열어주고 사용자가 복사하도록 안내
        if (typeof (window.api as any)?.importMp4 !== 'function') {
          await window.api.openPath(dirPath);
          appendLog('⚠️ 영상 불러오기 기능(복사)이 아직 준비되지 않았습니다. 열린 폴더에 mp4를 직접 복사한 뒤, AI 영상 목록에서 새로고침을 눌러주세요.');
          toastManager.warning('아직 자동 불러오기가 준비되지 않았습니다. 폴더에 직접 복사 후 새로고침 해주세요.');
          return;
        }

        appendLog(`📥 영상 불러오기 시작: ${sourcePath.split(/[\\/]/).pop() || 'video.mp4'}`);
        const res = await (window.api as any).importMp4({ sourcePath, dirPath });
        if (!res?.success) {
          toastManager.error(res?.message || '영상 불러오기 실패');
          appendLog(`❌ 영상 불러오기 실패: ${res?.message || 'unknown'}`);
          return;
        }

        toastManager.success('✅ 영상이 AI 영상 목록에 추가되었습니다.');
        appendLog(`✅ 영상 불러오기 완료: ${String(res?.fileName || '')}`);
        await refreshMp4FilesList();
      } catch (e) {
        console.error('[AI-VIDEO] import mp4 실패:', e);
        toastManager.error(`영상 불러오기 오류: ${(e as Error).message}`);
        appendLog(`❌ 영상 불러오기 오류: ${(e as Error).message}`);
      }
    });
  }

  // ✅ AI 영상 만들기 (Gemini Veo)
  const createVeoVideoBtn = document.getElementById('create-veo-video-btn');
  if (createVeoVideoBtn && !createVeoVideoBtn.hasAttribute('data-listener-added')) {
    createVeoVideoBtn.setAttribute('data-listener-added', 'true');
    createVeoVideoBtn.addEventListener('click', async () => {
      try {
        const ok = window.confirm(
          '⚠️ 안내\n\n현재 "AI 영상 만들기"는 텍스트 프롬프트 기반(Veo) 생성입니다.\n\n실존 인물/유명인/특정 인물의 얼굴(닮은꼴 포함)은 정책(안전 필터)로 차단될 수 있습니다.\n프롬프트에 이름/비교/누구처럼 등의 표현을 넣지 마세요.\n\n계속 진행할까요?'
        );
        if (!ok) return;
        await openVeoHeadingSelectModal();
      } catch (e) {
        console.error('[VEO] generateVeoVideo 실패:', e);
        const msg = (e as Error).message || String(e);
        toastManager.error(`AI 영상 생성 오류: ${msg}`);
        appendLog(`❌ AI 영상 생성 중 오류: ${msg}`);
      }
    });
  }

}

function updateUnifiedImagePreview(headings: any[], generatedImages?: any[]): void {
  const integratedPreview = document.getElementById('unified-integrated-preview');
  if (!integratedPreview) return;

  ensureUnifiedPreviewVideoDelegation();

  // ✅ structuredContent에서 본문 정보 가져오기
  const structuredContent = (window as any).currentStructuredContent;
  const bodyPlain = structuredContent?.bodyPlain || '';

  const integratedHtml = headings.map((heading: any, index: number) => {
    const generatedImage = generatedImages?.[index];
    const imageStatus = generatedImage ? '✅ 생성됨' : '⏳ 준비중';
    const statusColor = generatedImage ? 'var(--success)' : 'var(--accent)';

    // ✅ heading이 문자열인 경우와 객체인 경우 모두 처리
    let headingTitle = typeof heading === 'string' ? heading : (heading.title || heading);

    // ✅ [2026-01-07 버그 수정] bodyPlain에서 소제목 추출 로직 비활성화
    // 이 로직이 소제목을 본문 일부와 잘못 매칭하여 소제목을 망가뜨리는 버그 발생
    // AI가 생성한 원래 소제목(heading.title)을 그대로 사용하는 것이 더 안전함
    // 아래 주석 처리된 코드는 추후 개선된 로직 도입 시 참고용

    const normalizedHeadingTitle = normalizeHeadingKeyForVideoCache(String(headingTitle || '').trim());
    let headingContent = typeof heading === 'string' ? '' : (heading.content || '');

    // ✅ 안전한 HTML 이스케이프 적용
    const safeTitle = escapeHtml(headingTitle);

    // ✅ content가 없으면 본문에서 해당 소제목 이후 내용 추출
    if (!headingContent && bodyPlain) {
      const headingIndex = bodyPlain.indexOf(headingTitle);
      if (headingIndex !== -1) {
        // 소제목 다음 텍스트 추출
        const startIndex = headingIndex + headingTitle.length;
        let endIndex = bodyPlain.length;

        // 다음 소제목 찾기
        for (let i = index + 1; i < headings.length; i++) {
          const nextTitle = typeof headings[i] === 'string' ? headings[i] : (headings[i].title || headings[i]);
          const nextIndex = bodyPlain.indexOf(nextTitle, startIndex);
          if (nextIndex !== -1) {
            endIndex = nextIndex;
            break;
          }
        }

        headingContent = bodyPlain.substring(startIndex, endIndex).trim();
      }
    }

    // ✅ 본문도 이스케이프 처리
    const safeContent = escapeHtml(headingContent.substring(0, 400)) + (headingContent.length > 400 ? '...' : '');

    let imageDisplay = '';
    const headingKey = encodeURIComponent(String(normalizedHeadingTitle || '').trim());
    const getFromCache2 = (window as any).getHeadingVideoPreviewFromCache || getHeadingVideoPreviewFromCache;
    const cachedVideo = getFromCache2(normalizedHeadingTitle);
    const cachedVideoUrl = cachedVideo?.url ? String(cachedVideo.url) : '';

    if (cachedVideoUrl) {
      const safeVideoUrl = escapeHtml(cachedVideoUrl);
      imageDisplay = `
        <div class="unified-heading-video" data-video-url="${safeVideoUrl}" data-video-title="${safeTitle}" data-heading-video-slot="${headingKey}" style="width: 100%; height: 100%;">
          <video class="unified-heading-video-player" src="${safeVideoUrl}" muted autoplay loop playsinline preload="metadata" style="width: 100%; height: 100%; object-fit: cover; border-radius: 6px; background: #000;"></video>
        </div>
      `;
    }

    if (generatedImage) {
      const imageRaw = generatedImage.url || generatedImage.filePath || generatedImage.previewDataUrl || '';
      const imageUrl = toFileUrlMaybe(String(imageRaw || '').trim());
      // 실제 생성된 이미지가 있으면 표시
      if (!imageDisplay) {
        const headingEnc = encodeURIComponent(String(headingTitle || '').trim());
        const imageEnc = encodeURIComponent(String(imageUrl || '').trim());
        imageDisplay = `
          <div data-heading-video-slot="${headingKey}" style="width: 100%; height: 100%;">
            <img src="${escapeHtml(imageUrl)}" alt="${safeTitle}" class="ken-burns-media" style="width: 100%; height: 100%; object-fit: cover; border-radius: 6px; cursor: pointer;" onclick="showHeadingImagesModal('${headingEnc}','${imageEnc}')">
          </div>
        `;
      }
    } else {
      // 이미지가 없으면 플레이스홀더 표시
      if (!imageDisplay) {
        imageDisplay = `
          <div data-heading-video-slot="${headingKey}" style="width: 100%; height: 100%; border-radius: 6px; background: linear-gradient(135deg, var(--primary), var(--secondary)); display: flex; align-items: center; justify-content: center; color: white; font-size: 1rem; font-weight: 600;">${index + 1}</div>
        `;
      }
    }

    return `<div style="margin-bottom: 1rem; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px; border: 1px solid var(--border-light);">
      <!-- 이미지 영역 -->
      <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.75rem; padding: 0.5rem; background: rgba(59, 130, 246, 0.1); border-radius: 6px;">
        <div style="width: 60px; height: 40px; border-radius: 6px; overflow: hidden; border: 2px solid var(--border-color);">
          ${imageDisplay}
        </div>
        <div style="flex: 1;">
          <div style="font-size: 0.9rem; color: var(--text-strong); font-weight: 500;">🖼️ ${generatedImage ? '이미지 생성됨' : '이미지 생성 예정'}</div>
          <div style="font-size: 0.75rem; color: var(--text-muted);">소제목에 맞는 이미지가 ${generatedImage ? '완성되었습니다' : '생성됩니다'}</div>
        </div>
        <div style="font-size: 0.8rem; color: ${statusColor}; font-weight: 600;">${imageStatus}</div>
      </div>

      <!-- 소제목 + 본문 영역 -->
      <div style="padding: 0.75rem; background: var(--bg-primary); border-radius: 6px; border-left: 3px solid var(--success);">
        <div style="font-weight: 600; color: var(--text-strong); margin-bottom: 0.75rem; font-size: 1rem; word-break: keep-all; line-height: 1.4; overflow-wrap: break-word;">📝 ${safeTitle}</div>
        <div style="font-size: 0.9rem; color: var(--text-muted); line-height: 1.7; white-space: pre-line;">${safeContent}</div>
      </div>
    </div>`;
  }).join('');

  integratedPreview.innerHTML = integratedHtml || '<div style="color: var(--text-muted); font-style: italic;">소제목이 없습니다.</div>';

  const headingTitles = headings
    .map((h: any) => (typeof h === 'string' ? h : (h?.title || h)))
    .map((t: any) => String(t || '').trim())
    .filter((t: string) => t.length > 0);

  headingTitles.forEach((t: string) => {
    prefetchHeadingVideoPreview(t);
    if (headingVideoPreviewInFlight.has(t)) {
      headingVideoPreviewInFlight.get(t)!.then((entry: HeadingVideoPreviewCacheEntry) => {
        if (!entry || !entry.url) return;
        const normalizedT = normalizeHeadingKeyForVideoCache(t);
        const key = encodeURIComponent(normalizedT);
        const slot = integratedPreview.querySelector(`[data-heading-video-slot="${key}"]`) as HTMLElement | null;
        if (!slot) return;
        const safeVideoUrl = escapeHtml(String(entry.url));
        const safeTitle = escapeHtml(t);
        slot.innerHTML = `
          <div class="unified-heading-video" data-video-url="${safeVideoUrl}" data-video-title="${safeTitle}" data-heading-video-slot="${key}" style="width: 100%; height: 100%;">
            <video class="unified-heading-video-player" src="${safeVideoUrl}" muted autoplay loop playsinline preload="metadata" style="width: 100%; height: 100%; object-fit: cover; border-radius: 6px; background: #000;"></video>
          </div>
        `;
        const v = slot.querySelector('.unified-heading-video-player') as HTMLVideoElement | null;
        if (v) {
          try {
            v.play().catch(() => {
              // ignore
            });
          } catch {
            // ignore
          }
        }
      });
    }
  });

  integratedPreview.querySelectorAll('.unified-heading-video-player').forEach((el) => {
    try {
      (el as HTMLVideoElement).play().catch(() => {
        // ignore
      });
    } catch {
      // ignore
    }
  });
}


// 이미지 소스 선택 기능
function initFullAutoImageSourceSelection(): void {
  const imageSourceBtns = document.querySelectorAll('.full-auto-img-source-btn');

  imageSourceBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const source = (btn as HTMLElement).dataset.source;

      if ((btn as HTMLElement).hasAttribute('disabled')) {
        alert('이 기능은 현재 사용할 수 없습니다.');
        return;
      }

      // 모든 버튼에서 선택 해제
      imageSourceBtns.forEach(b => b.classList.remove('selected'));
      imageSourceBtns.forEach(b => (b as HTMLElement).style.borderColor = 'transparent');

      // 현재 버튼 선택
      btn.classList.add('selected');
      (btn as HTMLElement).style.borderColor = 'var(--primary)';

      // 이미지 라이브러리 카테고리 컨테이너 표시/숨김
      const categoryContainer = document.getElementById('full-auto-library-category-container');
      if (categoryContainer) {
        categoryContainer.style.display = source === 'library' ? 'block' : 'none';
      }

      console.log(`[FullAuto] 이미지 소스 선택됨: ${source}`);
    });
  });
}

// 풀오토 실행 로직
function initFullAutoExecution(): void {
  const startBtn = document.getElementById('full-auto-start-btn') as HTMLButtonElement;

  if (startBtn) {
    startBtn.addEventListener('click', async () => {
      try {
        // 폼 데이터 수집
        const formData = collectFullAutoFormData();

        if (!validateFullAutoFormData(formData)) {
          return;
        }

        // 자동화 실행
        await executeFullAutoAutomation(formData);

      } catch (error) {
        console.error('[FullAuto] 실행 오류:', error);
        alert(`풀오토 실행 중 오류가 발생했습니다: ${(error as Error).message}`);
      }
    });
  }
}

// 폼 데이터 수집
function collectFullAutoFormData(): any {
  const urls = Array.from(document.querySelectorAll('#full-auto-url-fields-container .url-field-input'))
    .map(input => (input as HTMLInputElement).value.trim())
    .filter(url => url.length > 0);

  const keywords = (document.getElementById('full-auto-keywords') as HTMLInputElement)?.value.trim() || '';
  const title = (document.getElementById('full-auto-title') as HTMLInputElement)?.value.trim() || '';
  const generator = (document.getElementById('full-auto-generator') as HTMLSelectElement)?.value || 'gemini';
  const targetAge = (document.getElementById('full-auto-target-age') as HTMLSelectElement)?.value || 'all';
  const imageSource = UnifiedDOMCache.getImageSource();
  const skipImages = (document.getElementById('full-auto-skip-images') as HTMLInputElement)?.checked || false;
  const publishMode = (document.getElementById('full-auto-publish-mode') as HTMLSelectElement)?.value || 'draft';
  const scheduleDate = publishMode === 'schedule' ? (document.getElementById('full-auto-schedule-date') as HTMLInputElement)?.value : undefined;
  const autoPublish = (document.getElementById('auto-publish-after-generate') as HTMLInputElement)?.checked || false;

  // ✅ 1번 이미지 텍스트 옵션 (풀오토)
  const includeThumbnailText = (document.getElementById('full-auto-thumbnail-text') as HTMLInputElement)?.checked || false;

  // 고급 옵션들
  const enablePreview = (document.getElementById('full-auto-enable-preview') as HTMLInputElement)?.checked ?? true;
  const autoOptimize = (document.getElementById('full-auto-auto-optimize') as HTMLInputElement)?.checked ?? true;
  const enableBackup = (document.getElementById('full-auto-enable-backup') as HTMLInputElement)?.checked ?? true;
  const contentTemplate = (document.getElementById('full-auto-content-template') as HTMLSelectElement)?.value || 'auto';
  const toneStyle = (document.getElementById('full-auto-tone-style') as HTMLSelectElement)?.value || 'professional';

  return {
    urls,
    keywords,
    title,
    generator,
    targetAge,
    imageSource,
    skipImages,
    publishMode,
    scheduleDate,
    includeThumbnailText, // ✅ 1번 이미지 텍스트 옵션
    // 고급 옵션들
    enablePreview,
    autoOptimize,
    enableBackup,
    contentTemplate,
    toneStyle
  };
}

// 폼 데이터 검증 (URL 우선)
function validateFullAutoFormData(data: any): boolean {
  // URL, 키워드, 제목 모두 선택사항이지만 최소 하나의 입력은 필요
  if (data.urls.length === 0 && !data.keywords && !data.title) {
    alert('URL, 키워드, 제목 중 최소 하나 이상을 입력해주세요.');
    return false;
  }

  // ✅ 제목 필드에 키워드처럼 보이는 값이 입력된 경우 안내 메시지
  if (data.title && !data.keywords) {
    // 제목이 짧고 쉼표가 포함되어 있으면 키워드로 판단
    const looksLikeKeywords = data.title.includes(',') ||
      (data.title.length < 20 && !data.title.includes(' '));

    if (looksLikeKeywords) {
      const userChoice = confirm(
        `💡 안내: 제목 필드 사용법\n\n` +
        `현재 입력: "${data.title}"\n\n` +
        `• 제목 필드: 블로그 글 제목을 입력하세요\n` +
        `  예) "${new Date().getFullYear()}년 다이어트 성공 비법 총정리"\n\n` +
        `• 키워드 필드: 검색 키워드를 입력하세요\n` +
        `  예) "다이어트, 건강, 운동"\n\n` +
        `⚠️ 실시간 정보 기반 체크박스를 반드시 켜주세요!\n` +
        `   → AI 할루시네이션(거짓 정보) 방지에 필수입니다.\n\n` +
        `그래도 현재 입력으로 진행하시겠습니까?`
      );

      if (!userChoice) {
        return false;
      }
    }
  }

  // ✅ 실시간 정보 수집 체크박스 확인 및 권장
  const realtimeCheckbox = document.getElementById('full-auto-realtime-crawl') as HTMLInputElement;
  if (realtimeCheckbox && !realtimeCheckbox.checked) {
    const enableRealtime = confirm(
      `⚠️ 실시간 정보 수집이 꺼져 있습니다!\n\n` +
      `실시간 정보 수집을 켜면:\n` +
      `• 최신 뉴스, 블로그, 카페 정보 반영\n` +
      `• AI 할루시네이션(거짓 정보) 방지\n` +
      `• 더 정확하고 신뢰할 수 있는 글 생성\n\n` +
      `실시간 정보 수집을 켜시겠습니까?`
    );

    if (enableRealtime) {
      realtimeCheckbox.checked = true;
    }
  }

  return true;
}

// 풀오토 자동화 실행 (정확한 순서로 수정)
async function executeFullAutoAutomation(formData: any): Promise<void> {
  const startBtn = document.getElementById('full-auto-start-btn') as HTMLButtonElement;

  // 진행률 표시 초기화 (모달 대신 로그 위에 표시)
  const progressContainer = document.createElement('div');
  progressContainer.id = 'full-auto-progress-container';
  progressContainer.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    width: 300px;
    background: var(--bg-primary);
    border: 2px solid var(--primary);
    border-radius: var(--radius-lg);
    padding: 1rem;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    z-index: 10000;
    font-family: var(--font-family);
  `;

  const progressBar = document.createElement('div');
  progressBar.style.cssText = `
    width: 100%;
    height: 8px;
    background: var(--bg-secondary);
    border-radius: 4px;
    overflow: hidden;
    margin: 0.5rem 0;
  `;

  const progressFill = document.createElement('div');
  progressFill.style.cssText = `
    height: 100%;
    background: linear-gradient(90deg, var(--primary), var(--success));
    width: 0%;
    transition: width 0.3s ease;
    border-radius: 4px;
  `;

  const progressText = document.createElement('div');
  progressText.style.cssText = `
    font-size: 0.9rem;
    color: var(--text-strong);
    text-align: center;
    font-weight: 600;
  `;

  progressBar.appendChild(progressFill);
  progressContainer.appendChild(progressText);
  progressContainer.appendChild(progressBar);
  document.body.appendChild(progressContainer);

  // 진행률 업데이트 함수
  const updateProgress = (percent: number, text: string) => {
    progressFill.style.width = `${percent}%`;
    progressText.textContent = text;
    console.log(`[FullAuto Progress] ${percent}%: ${text}`);
  };

  if (startBtn) {
    startBtn.disabled = true;
    startBtn.innerHTML = '<span style="font-size: 1.75rem;">⏳</span><span>실행 중...</span>';
  }

  const result = await withErrorHandling(async () => {
    // 통합 진행률 표시 시작
    updateProgress(5, '콘텐츠 생성 준비 중...');
    showUnifiedProgress(5, '콘텐츠 생성 준비 중...', 'AI가 글을 생성할 준비를 하고 있습니다.');
    appendLog('🚀 풀오토 자동화를 시작합니다!');

    // 1단계: 콘텐츠 생성 (structured content)
    const structuredContent = await generateFullAutoContent(formData);
    if (!structuredContent) {
      throw new Error('콘텐츠 생성에 실패했습니다.');
    }
    updateProgress(25, '콘텐츠 생성 완료');
    showUnifiedProgress(25, '콘텐츠 생성 완료', 'AI 글 생성이 완료되었습니다.');

    // ✅ 콘텐츠 저장 및 postId 생성
    currentStructuredContent = structuredContent;
    (window as any).currentStructuredContent = structuredContent;
    const postId = saveGeneratedPost(structuredContent);
    if (postId) {
      currentPostId = postId; // 전역 변수에 저장 (이미지 생성 시 사용)
    }

    // 2단계: 소제목 분석 및 모든 탭 필드에 표시
    await displayContentInAllTabs(structuredContent);
    updateProgress(40, '소제목 분석 완료');
    showUnifiedProgress(40, '소제목 분석 완료', '생성된 콘텐츠의 소제목을 분석하고 있습니다.');

    // 3단계: 이미지 생성 (소제목 기반)
    updateProgress(45, '이미지 생성 시작...');
    const generatedImages = await generateImagesForContent(structuredContent, formData);
    updateProgress(70, '이미지 생성 완료');
    showUnifiedProgress(70, '이미지 생성 완료', '소제목에 맞는 이미지가 모두 생성되었습니다.');

    // 4단계: 블로그 발행
    updateProgress(90, '블로그 발행 중...');
    showUnifiedProgress(90, '블로그 발행 중...', '네이버 블로그에 콘텐츠를 발행하고 있습니다.');
    const automationResult = await executeBlogPublishing(structuredContent, generatedImages, formData);

    // ✅ 발행 완료 시 글 정보 업데이트
    if (currentPostId && automationResult?.success) {
      const publishedUrl = automationResult.url || automationResult.postUrl || automationResult.blogUrl;
      if (publishedUrl) {
        updatePostAfterPublish(currentPostId, publishedUrl);
      }
    }

    updateProgress(100, '발행 완료! 🎉');
    showUnifiedProgress(100, '발행 완료!', '🎉 모든 작업이 성공적으로 완료되었습니다!');
    appendLog('🎉 풀오토 자동화가 성공적으로 완료되었습니다!');

    // ✅ 발행 완료 시 자동 저장/백업 중지 및 임시 데이터 삭제
    stopAutosave();
    stopAutoBackup();
    clearAutosavedContent();
    appendLog('💾 임시 저장 데이터 삭제 완료');

    // ✅ 모든 필드 초기화 (3초 후)
    setTimeout(() => {
      resetAllFields();
    }, 3000);

    return automationResult;
  }, 'FullAutoExecution');

  // 진행률 표시 제거
  setTimeout(() => {
    if (progressContainer.parentNode) {
      progressContainer.parentNode.removeChild(progressContainer);
    }
  }, 2000);

  if (!result) {
    if (progressContainer.parentNode) {
      progressContainer.parentNode.removeChild(progressContainer);
    }
    toastManager.error('❌ 풀오토 실행에 실패했습니다.');
  } else {
    // ✅ 발행 성공 시 추가 초기화 (3초 후)
    setTimeout(() => {
      console.log('[FullAuto] 발행 완료 후 필드 초기화 시작');
      resetAllFields();
      toastManager.success('🆕 다음 글 작성을 위해 필드가 초기화되었습니다.');
      // ✅ 생성된 글 목록도 새로고침
      refreshGeneratedPostsList();
    }, 3000);
  }

  if (startBtn) {
    startBtn.disabled = false;
    startBtn.innerHTML = '<span style="font-size: 1.75rem;">🚀</span><span>풀 오토 발행 시작</span>';
  }
}

// 1단계: 콘텐츠 생성
async function generateFullAutoContent(formData: any) {
  // ✅ 기존 콘텐츠 초기화 (타임아웃 방지)
  if (currentStructuredContent) {
    appendLog('🔄 기존 콘텐츠를 초기화하고 새로운 콘텐츠를 생성합니다...');
    currentStructuredContent = null;
    (window as any).currentStructuredContent = null;
    generatedImages = [];
    (window as any).imageManagementGeneratedImages = null;

    // ✅ [Fix] 이전 세션의 리뷰 모드 강제 해제 (소제목 leakage 방지)
    (window as any).selectedContentType = 'info';
    const typeEl = document.getElementById('unified-article-type') as HTMLSelectElement;
    if (typeEl && typeEl.value !== 'review') {
      (window as any).selectedContentType = 'info';
    } else if (typeEl && typeEl.value === 'review') {
      (window as any).selectedContentType = 'review';
    }
  }

  // ✅ [Alert] 커스텀 프롬프트 사용 시 알림
  const customPromptEl = document.getElementById('unified-custom-prompt') as HTMLTextAreaElement;
  if (customPromptEl && customPromptEl.value.trim()) {
    appendLog('⚠️ [주의] 커스텀 프롬프트가 설정되어 있습니다. 생성 결과에 영향을 줄 수 있습니다.');
  }

  // Determine if URL mode is active (assuming formData.urls is used for URL mode)
  const isUrlMode = formData.urls && formData.urls.length > 0;
  appendLog(`🤖 AI 콘텐츠 생성을 시작합니다... (방식: ${isUrlMode ? 'URL 뉴스' : '키워드'})`);

  // URL 배열 안전하게 처리
  const urls = formData.urls || [];
  const keywords = formData.keywords || '';

  const payload = {
    assembly: {
      generator: formData.generator,
      keywords: keywords ? keywords.split(',').map((k: string) => k.trim()).filter((k: string) => k.length > 0) : [],
      rssUrl: urls.length > 0 ? urls[0] : undefined,
      title: formData.title ? String(formData.title || '').trim() || undefined : undefined,
      targetAge: formData.targetAge,
      minChars: formData.minChars || 2500, // 기본 글자수
      customPrompt: (document.getElementById('unified-custom-prompt') as HTMLTextAreaElement)?.value?.trim() || undefined,
      // ✅ CRITICAL: 카테고리, 모드, 톤 정보 추가 (제목/소제목 생성에 필수!)
      categoryHint: formData.category || formData.categoryName || formData.categoryHint,
      contentMode: formData.contentMode || 'seo',
      articleType: formData.articleType,
      toneStyle: formData.toneStyle || formData.tone
    }
  };

  appendLog('📝 콘텐츠 조립 정보를 준비했습니다.');

  const apiClient = EnhancedApiClient.getInstance();
  const apiResponse = await apiClient.call(
    'generateStructuredContent',
    [payload],
    {
      retryCount: 3,
      retryDelay: 2000,
      timeout: 600000
    }
  );

  const result = apiResponse.data || { success: false, message: apiResponse.error };
  if (isPaywallPayload(result)) {
    activatePaywall(result);
    return;
  }
  if (!result.success) {
    appendLog('❌ 콘텐츠 생성에 실패했습니다.');
    throw new Error(result.message || '콘텐츠 생성 실패');
  }

  appendLog('✅ AI 콘텐츠 생성이 완료되었습니다!');

  // ✅ [Shopping Connect] 수집된 이미지가 있으면 전역 이미지 배열에 추가 (참조 이미지로 사용)
  if (result.content.collectedImages && result.content.collectedImages.length > 0) {
    console.log(`[FullAuto] 수집된 이미지 ${result.content.collectedImages.length}장을 참조 이미지로 등록합니다.`);

    // 중복 방지하며 추가
    const win = window as any;
    const existingUrls = new Set([...generatedImages, ...(win.imageManagementGeneratedImages || [])]);
    const newImages = result.content.collectedImages.filter((url: string) => !existingUrls.has(url));

    if (newImages.length > 0) {
      generatedImages.push(...newImages);
      if (!win.imageManagementGeneratedImages) win.imageManagementGeneratedImages = [];
      win.imageManagementGeneratedImages.push(...newImages);
      appendLog(`📸 쇼핑몰/사이트에서 ${newImages.length}장의 제품 이미지를 확보했습니다.`);
    }
  }

  console.log('[FullAuto] 구조화 콘텐츠 생성 완료:', result.content);
  return result.content;
}

// 2단계: 통합 탭 콘텐츠 표시 및 미리보기
async function displayContentInAllTabs(structuredContent: any) {
  appendLog('📋 생성된 콘텐츠를 통합 탭에 표시합니다.');

  // 통합 탭 미리보기 업데이트
  updateUnifiedPreview(structuredContent);

  // 소제목이 있으면 이미지 미리보기도 업데이트
  if (structuredContent.headings && structuredContent.headings.length > 0) {
    updateUnifiedImagePreview(structuredContent.headings);
  }

  // 통합 탭은 탭 전환이 필요 없음 - 바로 다음 단계로 진행
  appendLog('✅ 콘텐츠 표시가 완료되었습니다.');
  console.log('[Unified] 통합 탭 콘텐츠 표시 완료');
}

// 3단계: 소제목 기반 이미지 생성
async function generateImagesForContent(structuredContent: any, formData: any) {
  if (formData.skipImages) {
    appendLog('🚫 이미지 생성을 건너뜁니다.');
    console.log('[FullAuto] 이미지 생성 건너뜀');
    return [];
  }

  const headings = structuredContent.headings || [];
  if (headings.length === 0) {
    appendLog('⚠️ 소제목이 없어 이미지 생성을 건너뜁니다.');
    console.log('[FullAuto] 소제목이 없어 이미지 생성 건너뜀');
    return [];
  }

  appendLog(`🎨 ${headings.length}개 소제목의 이미지를 생성합니다.`);
  const sourceDisplayNames: Record<string, string> = {
    'pollinations': 'Pollinations (FLUX, 무료)',
    'nano-banana-pro': '나노 바나나 프로 (Gemini API 키, 과금 가능)',
    'dalle': 'DALL-E 3 (OpenAI)',
    'pexels': 'Pexels',
    'stability': 'Stability AI',
    'prodia': 'Prodia AI',
    'library': '이미지 라이브러리'
  };
  appendLog(`📸 이미지 소스: ${sourceDisplayNames[formData.imageSource] || formData.imageSource}`);

  // 미리보기 활성화 여부 확인
  const isPreviewEnabled = (document.getElementById('full-auto-enable-preview') as HTMLInputElement)?.checked;
  if (isPreviewEnabled) {
    updateFullAutoPreview(structuredContent);
  }

  let generatedImages: any[] = [];

  // 이미지 라이브러리는 사용하지 않음 - DALL-E 또는 Pexels만 사용
  if (formData.imageSource === 'library') {
    appendLog('⚠️ 이미지 라이브러리는 지원하지 않습니다. DALL-E로 전환합니다.');
    formData.imageSource = 'dalle';
  }

  // DALL-E 또는 Pexels로만 이미지 생성
  generatedImages = await generateAIImagesForHeadings(headings, formData);

  console.log(`[FullAuto] ${generatedImages.length}개 이미지 생성 완료`);
  appendLog(`✅ ${generatedImages.length}개의 이미지가 생성되었습니다!`);

  // 미리보기 업데이트 (실제 생성된 이미지 표시)
  const isPreviewEnabled2 = (document.getElementById('full-auto-enable-preview') as HTMLInputElement)?.checked;
  if (isPreviewEnabled2) {
    updateFullAutoFinalImagePreview(generatedImages);
  }

  return generatedImages;
}

// 라이브러리 이미지 생성 (소제목 기반)
async function generateLibraryImagesForHeadings(headings: any[], formData: any) {
  const images: any[] = [];

  for (const heading of headings) {
    try {
      // 소제목에서 검색 의도가 명확한 키워드 추출
      const extractedKeywords = extractSearchKeywords(heading.title, heading.content);
      appendLog(`🔍 소제목 "${heading.title}"의 검색 키워드: ${extractedKeywords.join(', ')}`);

      const libraryImages = await window.api.getLibraryImages('', extractedKeywords);

      if (libraryImages.length > 0) {
        // 가장 관련성 높은 이미지 선택
        const selectedImage = libraryImages[0];
        images.push({
          heading: heading.title,
          filePath: selectedImage.url,
          provider: 'library',
          alt: selectedImage.sourceTitle || heading.title,
          previewDataUrl: selectedImage.previewDataUrl || selectedImage.url
        });
      }
    } catch (error) {
      console.warn(`[FullAuto] 라이브러리 이미지 검색 실패 (${heading.title}):`, error);
    }
  }

  return images;
}

// AI 이미지 생성 (소제목 기반 영어 프롬프트) - ✅ 병렬 처리로 속도 2-3배 향상
async function generateAIImagesForHeadings(headings: any[], formData: any) {
  // 이미지 소스 확인 및 로깅
  const imageSource = formData.imageSource || 'nano-banana-pro'; // ✅ 기본값을 nano-banana-pro로 변경 (Gemini API 키 사용)
  console.log(`[AI Images] 이미지 생성 시작 - 소스: ${imageSource}, 소제목 개수: ${headings.length}`);

  const sourceNames: Record<string, string> = {
    'pollinations': 'Pollinations (FLUX, 무료)',
    'nano-banana-pro': '나노 바나나 프로 (Gemini API 키, 과금 가능)',
    'prodia': 'Prodia (과금 가능)',
    'dalle': 'DALL-E 3',
    'pexels': 'Pexels',
    'stability': 'Stability AI'
  };
  appendLog(`🎨 ${sourceNames[imageSource] || imageSource}로 ${headings.length}개 이미지 생성 시작...`);
  // ✅ 비용/과금 위험 provider는 동시 요청을 막기 위해 순차 처리
  try {
    const providerForLock = String(imageSource || '').trim() === 'pollinations' ? 'nano-banana-pro' : String(imageSource || '').trim();
    const shouldRunSequentially = isCostRiskImageProvider(providerForLock);
    appendLog(shouldRunSequentially ? '⏳ 과금/쿼터 보호를 위해 순차 처리로 생성합니다.' : '⚡ 병렬 처리로 속도 2-3배 향상!');
  } catch {
    appendLog('⚡ 병렬 처리로 속도 2-3배 향상!');
  }

  // 진행률 추적
  let completedCount = 0;
  const progressStart = 45;
  const progressEnd = 70;

  // ✅ [2026-01-22 NEW] 수동 썸네일 체크 - 이미지 관리 탭에서 수동으로 설정한 썸네일이 있는지 확인
  const existingImages = (window as any).imageManagementGeneratedImages || [];
  const hasManualThumbnail = existingImages.length > 0 && (
    existingImages[0]?.isManualThumbnail === true ||
    existingImages[0]?.source === 'manual' ||
    existingImages[0]?.source === 'thumbnail-generator'
  );

  if (hasManualThumbnail) {
    appendLog(`🎨 수동 설정 썸네일 감지됨 → 썸네일(0번) 건너뛰고 1번 소제목부터 이미지 생성`);
    console.log(`[AI Images] ✅ 수동 썸네일 감지: 첫 번째 이미지 건너뛰기`);
  }

  // ✅ 병렬 처리: 모든 이미지를 동시에 생성
  // ✅ 1번 이미지 텍스트 포함 여부 (formData에서 가져오거나 체크박스에서 확인)
  const thumbnailTextCheckbox = document.getElementById('thumbnail-text-option') as HTMLInputElement;
  const fullAutoThumbnailCheckbox = document.getElementById('full-auto-thumbnail-text') as HTMLInputElement;
  const semiAutoThumbnailCheckbox = document.getElementById('semi-auto-thumbnail-text') as HTMLInputElement;

  // ✅ [FIX] 쇼핑 커넥트 관련 데이터 추출 - contentMode 기반으로만 판단
  // affiliateLink만 있으면 쇼핑커넥트로 판단하지 않음 (일반 모드에서도 링크가 남아있을 수 있음)
  const isShoppingConnect = formData.isShoppingConnect === true || formData.contentMode === 'affiliate';

  // ✅ [FIX] 쇼핑커넥트 모드에서는 1번 이미지에 텍스트 자동 포함
  const includeThumbnailText = isShoppingConnect ? true : (
    formData.includeThumbnailText ??
    fullAutoThumbnailCheckbox?.checked ??
    semiAutoThumbnailCheckbox?.checked ??
    thumbnailTextCheckbox?.checked ?? false
  );

  if (isShoppingConnect) {
    console.log(`[AI Images] ✅ 쇼핑커넥트 모드: 1번 이미지 텍스트 포함 자동 활성화`);
  }

  // ✅ 쇼핑커넥트 모드에서만 수집 이미지를 참조로 사용 (일반 모드에서는 사용 안 함)
  let collectedImages = isShoppingConnect
    ? (formData.collectedImages || currentStructuredContent?.collectedImages || currentStructuredContent?.images || [])
    : [];

  // ✅ [신규] 쇼핑커넥트인데 수집된 이미지가 없으면, affiliateLink에서 자동 수집
  if (isShoppingConnect && collectedImages.length === 0 && formData.affiliateLink) {
    appendLog(`🛒 쇼핑커넥트 모드: 제휴 링크에서 이미지 자동 수집 중...`);
    console.log(`[AI Images] 🛒 affiliateLink에서 이미지 자동 수집 시작: ${formData.affiliateLink}`);

    try {
      const collectResult = await window.api.collectImagesFromShopping(formData.affiliateLink);
      if (collectResult.success && collectResult.images && collectResult.images.length > 0) {
        collectedImages = collectResult.images.map((img: any, idx: number) => ({
          url: typeof img === 'string' ? img : (img.url || img.link || img.thumbnail || ''),
          filePath: typeof img === 'string' ? img : (img.url || img.link || img.thumbnail || ''),
          heading: headings[idx]?.title || `소제목 ${idx + 1}`,
          headingIndex: idx
        }));

        // ✅ currentStructuredContent에도 저장 (다른 함수에서 참조용)
        if (currentStructuredContent) {
          (currentStructuredContent as any).images = collectedImages;
          (currentStructuredContent as any).collectedImages = collectedImages;
        }

        appendLog(`✅ 제휴 링크에서 ${collectedImages.length}개 이미지 자동 수집 완료!`);
        console.log(`[AI Images] ✅ affiliateLink 이미지 수집 완료: ${collectedImages.length}개`);
      } else {
        appendLog(`⚠️ 제휴 링크에서 이미지를 찾을 수 없습니다. AI 생성으로 진행합니다.`);
        console.warn(`[AI Images] ⚠️ affiliateLink 이미지 수집 실패:`, collectResult.message);
      }
    } catch (err) {
      appendLog(`⚠️ 이미지 자동 수집 실패: ${(err as Error).message}`);
      console.warn(`[AI Images] ⚠️ affiliateLink 이미지 수집 오류:`, err);
    }
  }

  if (isShoppingConnect && collectedImages.length > 0) {
    appendLog(`🛒 쇼핑 커넥트 모드: ${collectedImages.length}개 수집 이미지를 참조로 사용합니다.`);
  }

  const providerForLock = String(imageSource || '').trim() === 'pollinations' ? 'nano-banana-pro' : String(imageSource || '').trim();
  const shouldRunSequentially = isCostRiskImageProvider(providerForLock);

  const generateOne = async (heading: any, i: number): Promise<any[]> => {
    try {
      // ✅ 각 이미지 생성 전 중지 체크
      if (isFullAutoStopRequested()) {
        appendLog(`⏹️ 이미지 생성 중지됨 (${i + 1}/${headings.length})`);
        return [];
      }

      // ✅ [2026-01-22 NEW] 수동 썸네일이 있으면 첫 번째 이미지(썸네일) 건너뛰기
      if (hasManualThumbnail && i === 0) {
        console.log(`[AI Images] ⏭️ 수동 썸네일 있음 → 0번(썸네일) 이미지 생성 건너뛰기`);
        appendLog(`⏭️ 수동 설정 썸네일 사용 → 자동 생성 건너뛰기`);
        completedCount++;
        return []; // 빈 배열 반환하여 수동 썸네일 유지
      }

      // ✅ [2026-01-23 FIX v3] 쇼핑커넥트 이미지 로직 (사용자 요청 반영)
      // - 썸네일(i===0): 항상 수집 이미지 직접 사용 + 텍스트 오버레이 (AI 생성 아님!)
      // - 나머지(i>0): useAiImage 체크박스에 따라
      //   - 체크(true): 수집 이미지 참조하여 AI 라이프스타일 이미지 생성
      //   - 해제(false): 수집 이미지 직접 사용

      // ✅ [2026-01-23] useAiImage 플래그 읽기 (체크박스 값)
      const useAiImageChecked = (document.getElementById('unified-use-ai-image') as HTMLInputElement)?.checked ?? true;

      // 소제목을 기반으로 영어 프롬프트 생성
      const englishPrompt = await generateEnglishPromptForHeading(heading, formData.keywords);
      console.log(`[AI Images] ${i + 1}/${headings.length} - 프롬프트: ${englishPrompt}`);

      // ✅ [2026-01-23 FIX] 쇼핑커넥트 모드에서 텍스트 오버레이 결정
      // - 썸네일(i===0)만 텍스트 오버레이 포함
      // - 나머지 이미지는 텍스트 없음 (제품 라이프스타일 이미지)
      const shouldIncludeText = isShoppingConnect
        ? (i === 0) // 쇼핑커넥트: 썸네일만 텍스트
        : (includeThumbnailText && i === 0); // 일반 모드: 기존 로직

      const isThumbnail = i === 0;
      console.log(`[AI Images] ${i + 1}번 소제목 - isThumbnail: ${isThumbnail}, allowText: ${shouldIncludeText}, useAiImage: ${useAiImageChecked} (쇼핑커넥트: ${isShoppingConnect})`);

      // ✅ [FIX] 참조 이미지 결정 (쇼핑 커넥트면 수집된 이미지 사용)
      let ref: any = {};

      if (isShoppingConnect && collectedImages.length > 0) {
        // 수집된 이미지를 순환하며 할당 (AI 생성 시 참조용)
        const refImg = collectedImages[i % collectedImages.length];
        const refUrl = typeof refImg === 'string' ? refImg : (refImg?.url || refImg?.filePath || refImg?.thumbnailUrl);
        if (refUrl) {
          ref = { referenceImagePath: refUrl };
          console.log(`[AI Images] 🛒 쇼핑 커넥트 참조 이미지 적용: ${refUrl}`);
        }
      } else {
        // 기존 로직: 소제목별 참조 이미지
        ref = await resolveReferenceImageForHeadingAsync(String(heading.title || heading || '').trim());
      }

      // ✅ [2026-01-23 NEW] 쇼핑커넥트: 썸네일 또는 AI생성 미사용 시 수집 이미지 직접 사용
      if (isShoppingConnect && collectedImages.length > 0) {
        const shouldUseCollectedImageDirectly = (i === 0) || !useAiImageChecked;

        if (shouldUseCollectedImageDirectly) {
          const collectedImg = collectedImages[i % collectedImages.length];
          const imgUrl = typeof collectedImg === 'string' ? collectedImg : (collectedImg?.url || collectedImg?.filePath || collectedImg?.thumbnailUrl || '');

          if (imgUrl) {
            const imageType = i === 0 ? '썸네일' : `${i + 1}번`;
            console.log(`[AI Images] 🛒 쇼핑커넥트: ${imageType} → 수집 이미지 직접 사용: ${imgUrl.substring(0, 60)}...`);
            appendLog(`🛒 ${i + 1}/${headings.length} 수집 이미지 직접 사용 (${imageType}): ${heading.title}`);

            // ✅ [2026-01-23 FIX] 썸네일 포함 모든 이미지: 수집 이미지 URL 그대로 사용 (AI 재생성 없음)
            // 썸네일 텍스트 오버레이는 블로그 에디터에서 제목으로 대체됨
            completedCount++;
            const currentProgress = progressStart + ((progressEnd - progressStart) * (completedCount / headings.length));
            showUnifiedProgress(
              Math.round(currentProgress),
              `이미지 적용 중... (${completedCount}/${headings.length})`,
              `\"${heading.title}\" 수집 이미지 적용 완료`
            );

            return [{
              heading: heading.title,
              headingIndex: i,
              url: imgUrl,
              filePath: imgUrl,
              isCollectedImage: true,
              isThumbnail: i === 0,
              source: 'collected'
            }];
          }
        }
      }

      // ✅ 일반 모드 또는 쇼핑커넥트+AI생성 활성화 시: AI 이미지 생성
      const imageResult = await generateImagesWithCostSafety({
        provider: imageSource, // dalle 또는 pexels
        items: [{
          heading: heading.title,
          prompt: englishPrompt,
          isThumbnail: isThumbnail, // ✅ 첫 번째 소제목은 썸네일
          allowText: shouldIncludeText, // ✅ 쇼핑커넥트: 썸네일만 텍스트, 나머지는 텍스트 없음
          ...ref, // ✅ 참조 이미지 적용
        }],
        postTitle: currentStructuredContent?.selectedTitle,
        postId: currentPostId || undefined, // ✅ 글 ID 전달
        isFullAuto: formData.mode === 'full-auto', // ✅ 풀오토 모드: 100% 성공률 보장
        // ✅ [FIX] 쇼핑 커넥트 정보 전달 (중요!)
        isShoppingConnect: isShoppingConnect,
        collectedImages: collectedImages
      });

      // 진행률 업데이트 (완료된 개수 기준)
      completedCount++;
      const currentProgress = progressStart + ((progressEnd - progressStart) * (completedCount / headings.length));
      showUnifiedProgress(
        Math.round(currentProgress),
        `이미지 생성 중... (${completedCount}/${headings.length})`,
        `\"${heading.title}\" 이미지 생성 완료`
      );

      console.log(`[AI Images] ${i + 1}/${headings.length} - 결과:`, imageResult.success ? '성공' : '실패');

      if (imageResult.success && imageResult.images && imageResult.images.length > 0) {
        appendLog(`✅ ${completedCount}/${headings.length} 이미지 생성 완료: ${heading.title}`);
        return imageResult.images;
      } else {
        appendLog(`⚠️ ${completedCount}/${headings.length} 이미지 생성 실패: ${heading.title}`);
        return [];
      }
    } catch (error) {
      completedCount++;
      console.warn(`[AI Images] ${i + 1}/${headings.length} 이미지 생성 오류 (${heading.title}):`, error);
      appendLog(`❌ ${completedCount}/${headings.length} 이미지 생성 오류: ${(error as Error).message}`);
      return [];
    }
  };

  const results: any[][] = [];
  if (shouldRunSequentially) {
    for (let i = 0; i < headings.length; i++) {
      results.push(await generateOne(headings[i], i));
    }
  } else {
    const imagePromises = headings.map(async (heading, i) => generateOne(heading, i));
    results.push(...(await Promise.all(imagePromises)));
  }
  const images = results.flat(); // 2차원 배열을 1차원으로 평탄화

  console.log(`[AI Images] 이미지 생성 완료 - 총 ${images.length}개 생성됨 (병렬 처리)`);
  return images;
}

// 소제목을 위한 영어 프롬프트 생성
async function generateEnglishPromptForHeading(heading: any, baseKeywords?: string) {
  // ✅ 이미지 관리 탭과 동일한 정교한 프롬프트 생성 로직 사용
  const headingTitle = heading.title || heading;
  const prompt = generateEnglishPromptForHeadingSync(headingTitle);

  console.log(`[FullAuto] 프롬프트 생성: ${headingTitle} → ${prompt}`);
  return prompt;
}

// 4단계: 블로그 발행 실행
async function executeBlogPublishing(structuredContent: any, generatedImages: any[], formData: any) {
  // ✅ 진행상황 모달 가져오기
  const modal = (window as any).currentProgressModal as ProgressModal | null;

  appendLog('📤 블로그 발행을 준비합니다.');
  showUnifiedProgress(85, '블로그 발행 준비 중...', '네이버 계정 정보를 확인하고 있습니다.');
  modal?.setProgress(60, '네이버 계정 확인 중...');

  // ✅ 입력 필드에서 네이버 계정 정보 가져오기 (우선순위)
  const naverIdInput = document.getElementById('naver-id') as HTMLInputElement;
  const naverPasswordInput = document.getElementById('naver-password') as HTMLInputElement;

  let naverId: string | undefined;
  let naverPassword: string | undefined;

  // 입력 필드에 값이 있으면 우선 사용
  if (naverIdInput && naverIdInput.value.trim()) {
    naverId = naverIdInput.value.trim();
  }
  if (naverPasswordInput && naverPasswordInput.value.trim()) {
    naverPassword = naverPasswordInput.value.trim();
  }

  // 입력 필드에 값이 없으면 저장된 값 사용
  if (!naverId || !naverPassword) {
    const config = await window.api.getConfig();
    if (config.savedNaverId && !naverId) {
      naverId = config.savedNaverId;
    }
    if (config.savedNaverPassword && !naverPassword) {
      naverPassword = config.savedNaverPassword;
    }
  }

  // 최종 확인
  if (!naverId || !naverPassword) {
    appendLog('❌ 네이버 계정 정보가 설정되지 않았습니다.');
    appendLog('💡 네이버 아이디와 비밀번호를 입력 필드에 입력하거나, "기억하기"를 체크하여 저장해주세요.');
    throw new Error('네이버 아이디와 비밀번호가 설정되지 않았습니다.');
  }

  appendLog('🔐 네이버 계정 정보를 확인했습니다.');
  showUnifiedProgress(87, '페이로드 구성 중...', '발행할 콘텐츠를 준비하고 있습니다.');

  // ✅ CTA 정보 가져오기 (formData에서 또는 자동 생성)
  let ctaText = formData.ctaText;
  let ctaLink = formData.ctaLink;

  // formData에 CTA가 없으면 자동 생성
  if (!ctaText || !ctaLink) {
    const autoCTA = generateAutoCTA(structuredContent.selectedTitle || '', '');
    ctaText = ctaText || autoCTA.ctaText;
    ctaLink = ctaLink || autoCTA.ctaLink;
  }

  if (ctaLink) {
    appendLog(`📢 CTA 버튼 포함: "${ctaText}"`);
  }

  // ✅ 다중 CTA 우선: formData.ctas → (ctaText/ctaLink) 폴백
  const resolvedCtas = (() => {
    const list = (Array.isArray(formData?.ctas) ? formData.ctas : [])
      .map((c: any) => ({
        text: String(c?.text || '').trim(),
        link: String(c?.link || '').trim() || undefined,
      }))
      .filter((c: any) => Boolean(c?.text));
    if (list.length > 0) return list;
    const t = String(ctaText || '').trim();
    const l = String(ctaLink || '').trim();
    return t ? [{ text: t, link: l || undefined }] : [];
  })();

  const imagesForPayloadSource = (() => {
    // ✅ [2026-01-21] 연속 발행에서 저장된 window.generatedImages 우선 체크
    try {
      const fromWindowGenerated = (window as any).generatedImages;
      if (Array.isArray(fromWindowGenerated) && fromWindowGenerated.length > 0) {
        console.log('[executeBlogPublishing] ✅ window.generatedImages에서 이미지 사용:', fromWindowGenerated.length);
        return fromWindowGenerated;
      }
    } catch {
      // ignore
    }
    try {
      const fromGlobal = (window as any).imageManagementGeneratedImages;
      if (Array.isArray(fromGlobal) && fromGlobal.length > 0) {
        console.log('[executeBlogPublishing] ✅ imageManagementGeneratedImages에서 이미지 사용:', fromGlobal.length);
        return fromGlobal;
      }
    } catch {
      // ignore
    }
    try {
      const fromManager = ImageManager.getAllImages();
      if (Array.isArray(fromManager) && fromManager.length > 0) {
        console.log('[executeBlogPublishing] ✅ ImageManager에서 이미지 사용:', fromManager.length);
        return fromManager;
      }
    } catch {
      // ignore
    }
    console.log('[executeBlogPublishing] ⚠️ 이미지 소스 없음, generatedImages 폴백:', Array.isArray(generatedImages) ? generatedImages.length : 0);
    return Array.isArray(generatedImages) ? generatedImages : [];
  })();

  const normalizedImagesForPayload = filterImagesForPublish(structuredContent, imagesForPayloadSource)
    .map((img: any) => {
      const filePath = img?.filePath || img?.url || img?.previewDataUrl;
      return {
        ...img,
        filePath,
      };
    })
    .filter((img: any) => Boolean(img?.filePath));

  // ✅ 대표사진(썸네일) 경로 가져오기 (1번 이미지 사용)
  let thumbnailPath = (window as any).thumbnailPath || formData.thumbnailPath;
  if (!thumbnailPath && normalizedImagesForPayload && normalizedImagesForPayload.length > 0) {
    // 1번 이미지를 대표사진으로 사용
    const firstImage = normalizedImagesForPayload[0];
    thumbnailPath = firstImage?.filePath || firstImage?.url || firstImage?.previewDataUrl;
  }

  if (thumbnailPath) {
    appendLog(`📷 대표사진 설정됨: ${thumbnailPath.substring(0, 50)}...`);
  }

  // ✅ 제목은 UI/사용자 입력을 최우선으로 사용 (풀오토에서 AI 제목으로 바뀌는 문제 방지)
  const preferredTitle = (() => {
    try {
      const generatedTitleUi = (document.getElementById('unified-generated-title') as HTMLInputElement | null)?.value?.trim();
      if (generatedTitleUi) return generatedTitleUi;
    } catch {
      // ignore
    }
    try {
      const unifiedTitleUi = (document.getElementById('unified-title') as HTMLInputElement | null)?.value?.trim();
      if (unifiedTitleUi) return unifiedTitleUi;
    } catch {
      // ignore
    }
    const fromFormData = String(formData?.title || '').trim();
    if (fromFormData) return fromFormData;
    return String(structuredContent?.selectedTitle || '').trim();
  })();

  if (preferredTitle) {
    structuredContent.selectedTitle = preferredTitle;
  }

  // ✅ 본문도 UI/사용자 입력을 최우선으로 사용 (반자동 편집에서 수정한 내용 반영)
  const preferredContent = (() => {
    try {
      const generatedContentUi = (document.getElementById('unified-generated-content') as HTMLTextAreaElement | null)?.value?.trim();
      if (generatedContentUi && generatedContentUi.length > 0) return generatedContentUi;
    } catch {
      // ignore
    }
    try {
      const postContentUi = (document.getElementById('post-content') as HTMLTextAreaElement | null)?.value?.trim();
      if (postContentUi && postContentUi.length > 0) return postContentUi;
    } catch {
      // ignore
    }
    return structuredContent.content || structuredContent.bodyPlain || '';
  })();

  // ✅ 해시태그도 UI/사용자 입력을 최우선으로 사용
  const preferredHashtags = (() => {
    try {
      const hashtagsUi = (document.getElementById('unified-generated-hashtags') as HTMLInputElement | null)?.value?.trim();
      if (hashtagsUi) {
        // 해시태그 문자열을 배열로 변환 (쉼표, 공백, # 기준으로 분리)
        return hashtagsUi.split(/[,\s#]+/).map(h => h.trim()).filter(h => h.length > 0);
      }
    } catch {
      // ignore
    }
    try {
      const postTagsUi = (document.getElementById('post-tags') as HTMLInputElement | null)?.value?.trim();
      if (postTagsUi) {
        return postTagsUi.split(/[,\s#]+/).map(h => h.trim()).filter(h => h.length > 0);
      }
    } catch {
      // ignore
    }
    return structuredContent.hashtags || [];
  })();

  // ✅ UI에서 가져온 값으로 structuredContent 업데이트
  if (preferredContent) {
    structuredContent.content = preferredContent;
    structuredContent.bodyPlain = preferredContent;
  }
  if (preferredHashtags && preferredHashtags.length > 0) {
    structuredContent.hashtags = preferredHashtags;
  }

  // ✅ 본문에서 ** 문구 제거 (마크다운 볼드 처리)
  // ✅ content가 없으면 bodyPlain 사용 (키워드 글생성 시 bodyPlain만 있는 경우)
  const rawContent = structuredContent.content || structuredContent.bodyPlain || '';
  const cleanedContent = normalizeReadableBodyText(rawContent);
  structuredContent.bodyPlain = cleanedContent;
  structuredContent.content = cleanedContent;

  // ✅ 디버깅: 본문 내용 확인
  console.log('[executeBlogPublishing] rawContent 길이:', rawContent.length);
  console.log('[executeBlogPublishing] cleanedContent 길이:', cleanedContent.length);
  if (!cleanedContent || cleanedContent.length < 10) {
    appendLog(`⚠️ 본문 내용이 비어있거나 너무 짧습니다. (${cleanedContent.length}자)`);
    console.warn('[executeBlogPublishing] 본문 내용 부족:', {
      content: structuredContent.content?.substring(0, 100),
      bodyPlain: structuredContent.bodyPlain?.substring(0, 100)
    });
  }

  // 자동화 페이로드 구성
  const payload: RendererAutomationPayload = {
    naverId: naverId,
    naverPassword: naverPassword,
    title: preferredTitle || structuredContent.selectedTitle,
    content: cleanedContent,
    lines: cleanedContent.split('\n'),
    hashtags: structuredContent.hashtags,
    structuredContent: structuredContent,
    generatedImages: normalizedImagesForPayload,
    imageMode: formData.skipImages ? 'skip' : 'full-auto',
    autoGenerate: true,
    publishMode: formData.publishMode as 'draft' | 'publish' | 'schedule',
    scheduleDate: formData.publishMode === 'schedule' ? formData.scheduleDate : undefined,
    scheduleType: formData.publishMode === 'schedule' ? (formData.scheduleType as 'app-schedule' | 'naver-server' || 'app-schedule') : undefined,
    toneStyle: formData.toneStyle as 'professional' | 'friendly' | 'casual' | 'formal' | 'humorous' | undefined,
    postId: currentPostId || undefined, // ✅ 현재 글 ID 전달
    thumbnailPath: thumbnailPath, // ✅ 대표사진 경로 추가
    categoryName: formData.categoryName || formData.category, // ✅ 발행 카테고리명 추가 (category도 호환성 지원)
    // ✅ CTA 설정
    ctaText: formData.skipCta ? undefined : ctaText,
    ctaLink: formData.skipCta ? undefined : ctaLink,
    ctas: formData.skipCta ? [] : resolvedCtas,
    ctaPosition: formData.ctaPosition as 'top' | 'middle' | 'bottom' || 'bottom', // ✅ CTA 위치
    skipCta: formData.skipCta || false, // ✅ CTA 없이 발행
    contentMode: formData.contentMode || 'seo', // ✅ 콘텐츠 모드 추가
    affiliateLink: formData.affiliateLink, // ✅ 제휴 링크 추가
    // ✅ [2026-01-22 버그 수정] 이전글 정보 추가 (기존에 누락되어 있었음!)
    previousPostTitle: formData.previousPostTitle || undefined,
    previousPostUrl: formData.previousPostUrl || undefined,
    customBannerPath: formData.customBannerPath || (window as any).customBannerPath || undefined, // ✅ [2026-01-18] 커스텀 배너 경로
    autoBannerGenerate: formData.autoBannerGenerate || false, // ✅ [2026-01-21] 배너 자동 랜덤 생성 옵션
  };

  // ✅ 예약 발행인 경우 postId 확인 및 자동 저장
  if (formData.publishMode === 'schedule') {
    if (!currentPostId) {
      // postId가 없으면 자동으로 생성 및 저장
      appendLog('⚠️ 글 ID가 없습니다. 자동으로 저장합니다...');
      const postId = saveGeneratedPost(structuredContent);
      if (postId) {
        currentPostId = postId;
        payload.postId = postId;
        appendLog(`💾 글이 자동으로 저장되었습니다 (ID: ${postId})`);
      } else {
        appendLog('❌ 글 저장에 실패했습니다. 예약 발행이 정상적으로 작동하지 않을 수 있습니다.');
      }
    }

    // localStorage 확인 (올바른 키 사용)
    const generatedPosts = JSON.parse(localStorage.getItem(GENERATED_POSTS_KEY) || '[]');
    const postExists = generatedPosts.some((p: any) => p.id === currentPostId);

    if (postExists) {
      appendLog(`📝 예약 발행 글 ID: ${currentPostId} (localStorage 확인 완료)`);
      console.log('[Publish] 예약 발행 postId:', currentPostId, 'localStorage 존재:', true);
    } else {
      appendLog(`⚠️ localStorage에 글이 없습니다. 다시 저장합니다...`);
      console.warn('[Publish] localStorage에 postId가 없음:', currentPostId);
      // 강제로 다시 저장
      const newPostId = saveGeneratedPost(structuredContent);
      if (newPostId) {
        currentPostId = newPostId;
        payload.postId = newPostId;
        appendLog(`💾 글이 다시 저장되었습니다 (ID: ${newPostId})`);
      }
    }
  }

  appendLog('🚀 블로그 자동화를 시작합니다...');

  // ✅ 자동화 실행 전 ImageMap 동기화 (Renderer -> Main)
  if (typeof (window as any).ImageManager !== 'undefined' && (window as any).ImageManager.imageMap) {
    console.log('[Renderer] 블로그 발행 시작 전 ImageManager 동기화 시도...');
    try {
      await window.api.syncImageManager((window as any).ImageManager.imageMap);
    } catch (e) {
      console.error('[Renderer] ImageManager 동기화 실패:', e);
    }
  }

  modal?.addLog('🔐 네이버 로그인 시도 중...');

  // 진행률을 90%로 설정하고 발행 시작 표시
  showUnifiedProgress(90, '블로그 발행 시작...', '네이버 블로그에 접속하고 있습니다.');

  // 블로그 자동화 실행 (향상된 재시도 로직 적용)
  const apiClient = EnhancedApiClient.getInstance();

  // 진행률을 92%로 업데이트
  setTimeout(() => {
    showUnifiedProgress(92, '블로그 로그인 중...', '네이버 계정으로 로그인하고 있습니다.');
    modal?.setProgress(70, '네이버 로그인 중...');
  }, 1000);

  // ✅ 진행상황 모달 업데이트 - 발행 단계 시작
  modal?.setStep(4, 'active', '발행 중...');
  modal?.setProgress(75, '블로그 발행 중...');

  // 블로그 발행은 시간이 오래 걸릴 수 있으므로 타임아웃을 매우 길게 설정
  // 실제로는 자동화가 진행 중이므로 타임아웃은 단순히 응답 대기 시간일 뿐
  const apiResponse = await apiClient.call(
    'runAutomation',
    [payload],
    {
      retryCount: 3, // 재시도 횟수 감소 (타임아웃은 실제 오류가 아니므로)
      retryDelay: 5000, // 재시도 간격 증가
      timeout: 600000 // 타임아웃을 10분으로 증가 (블로그 발행은 매우 오래 걸릴 수 있음)
    }
  );

  // 진행률을 95%로 업데이트
  showUnifiedProgress(95, '콘텐츠 발행 중...', '네이버 블로그에 콘텐츠를 업로드하고 있습니다.');

  // 타임아웃 오류인 경우 특별 처리
  if (!apiResponse.success) {
    const errorMsg = apiResponse.error || '블로그 발행 실패';

    // 타임아웃 오류인 경우 - 실제로는 자동화가 진행 중일 수 있음
    if (errorMsg.includes('타임아웃') || errorMsg.includes('timeout')) {
      // 타임아웃은 실제 오류가 아닐 수 있으므로 성공으로 간주
      // 실제로는 main.ts에서 자동화가 완료되면 성공으로 처리됨
      return { success: true };
    } else {
      appendLog(`❌ 블로그 발행에 실패했습니다: ${errorMsg}`);
      throw new Error(errorMsg);
    }
  } else if (!apiResponse.data?.success) {
    const errorMsg = apiResponse.data?.message || apiResponse.error || '블로그 발행 실패';

    // "이미 자동화가 실행 중" 오류는 실제로 진행 중이므로 무시
    if (errorMsg.includes('이미 자동화가 실행 중')) {
      appendLog('ℹ️ 자동화가 이미 실행 중입니다. 진행 상황을 확인합니다...');
      // 자동화가 완료될 때까지 대기
      await new Promise(resolve => setTimeout(resolve, 3000));
      // 재시도하지 않고 성공으로 간주 (실제로는 진행 중)
      return { success: true };
    }

    appendLog(`❌ 블로그 발행에 실패했습니다: ${errorMsg}`);
    throw new Error(errorMsg);
  }

  const automationResult = apiResponse.data;

  // 진행률을 98%로 업데이트
  showUnifiedProgress(98, '발행 완료 확인...', '블로그 발행이 완료되었는지 확인하고 있습니다.');

  // 최종 완료 표시
  setTimeout(() => {
    showUnifiedProgress(100, '발행 완료!', '🎉 블로그 발행이 성공적으로 완료되었습니다!');
    appendLog('✅ 블로그 발행이 성공적으로 완료되었습니다!');
    console.log('[FullAuto] 블로그 발행 완료');
  }, 500);

  return automationResult;
}

// 진행률 업데이트
function updateFullAutoProgress(percent: number, text: string, detail?: string): void {
  const progressBar = document.getElementById('full-auto-progress-bar');
  const progressPercent = document.getElementById('full-auto-progress-percent');
  const progressText = document.getElementById('full-auto-progress-text');
  const progressDetail = document.getElementById('full-auto-progress-detail');

  if (progressBar) progressBar.style.width = `${percent}%`;
  if (progressPercent) progressPercent.textContent = `${percent}%`;
  if (progressText) progressText.textContent = text;
  if (progressDetail && detail) progressDetail.textContent = detail;
}

// 초기화 기능
function initFullAutoReset(): void {
  const resetBtn = document.getElementById('full-auto-reset-btn') as HTMLButtonElement;

  if (resetBtn) {
    resetBtn.addEventListener('click', () => {
      if (confirm('모든 입력 내용을 초기화하시겠습니까?')) {
        resetFullAutoForm();
      }
    });
  }
}

function resetFullAutoForm(): void {
  // URL 필드 초기화 (첫 번째만 남기고 삭제)
  const container = document.getElementById('full-auto-url-fields-container') as HTMLDivElement;
  const urlItems = container?.querySelectorAll('.url-field-item');

  if (urlItems && urlItems.length > 1) {
    for (let i = 1; i < urlItems.length; i++) {
      urlItems[i].remove();
    }
  }

  // 첫 번째 URL 필드 초기화
  const firstUrlInput = container?.querySelector('.url-field-input') as HTMLInputElement;
  if (firstUrlInput) firstUrlInput.value = '';

  // 다른 필드들 초기화
  const fieldsToReset = [
    'full-auto-keywords',
    'full-auto-title',
    'full-auto-generated-title',
    'full-auto-generated-content'
  ];

  fieldsToReset.forEach(id => {
    const element = document.getElementById(id) as HTMLInputElement;
    if (element) element.value = '';
  });

  // 진행률 초기화
  updateFullAutoProgress(0, '준비 중...');

  // 생성된 콘텐츠 섹션 숨김
  const generatedSections = [
    'full-auto-generated-title-field',
    'full-auto-generated-content-field',
    'full-auto-structured-content-preview'
  ];

  generatedSections.forEach(id => {
    const element = document.getElementById(id);
    if (element) element.style.display = 'none';
  });

  console.log('[FullAuto] 폼 초기화 완료');
}

// 추천 시간 설정
function initFullAutoRecommendTime(): void {
  const recommendBtn = document.getElementById('full-auto-recommend-time-btn') as HTMLButtonElement;
  const scheduleInput = document.getElementById('full-auto-schedule-date') as HTMLInputElement;

  if (recommendBtn && scheduleInput) {
    recommendBtn.addEventListener('click', () => {
      const recommendedTime = getRecommendedScheduleTime();
      scheduleInput.value = recommendedTime;
      console.log(`[FullAuto] 추천 시간 설정: ${recommendedTime}`);
    });
  }
}

// ✅ [2026-01-25 모듈화] getRecommendedScheduleTime
// → ./utils/dateUtils.js로 이동됨 (상단 import 참조)

// ============================================
// 향상된 오류 처리 시스템
// ============================================

// ✅ [2026-01-25 모듈화] ErrorType, ErrorInfo, showError, handleApiError, errorHandler
// → ./utils/errorHandlerUtils.js로 이동됨 (상단 import 참조)

// ============================================
// (중복 함수 제거됨 - 상단의 withErrorHandling 사용)

// 자동화 실행 시 오류 처리
async function executeAutomationWithErrorHandling(payload: RendererAutomationPayload): Promise<RendererStatus> {
  const result = await withErrorHandling(
    async () => {
      // ✅ 자동화 실행 전 ImageMap 동기화 (Renderer -> Main)
      if (typeof (window as any).ImageManager !== 'undefined' && (window as any).ImageManager.imageMap) {
        console.log('[Renderer] 자동화 시작 전 ImageManager 동기화 시도...');
        await window.api.syncImageManager((window as any).ImageManager.imageMap);
      }

      const result = await window.api.runAutomation(payload);
      if (!result.success) {
        throw new Error(result.message || '자동화 실행 실패');
      }
      return result;
    },
    'Automation',
    { showToast: true, logError: true }
  );

  return result || { success: false, message: '자동화 실행 중 오류가 발생했습니다.' };
}

// ============================================
// 향상된 API 클라이언트
// ============================================

// ✅ [2026-01-25 모듈화] EnhancedApiClient, ApiRequestOptions, ApiResponse
// → ./utils/apiClient.js로 이동됨 (상단 import 참조)

// 편의 함수들
(window as any).enhancedApiCall = (method: string, args?: any[], options?: ApiRequestOptions) =>
  apiClient.call(method, args, options);

(window as any).clearApiCache = () => apiClient.clearCache();

(window as any).getApiStats = () => apiClient.getCacheStats();

// ============================================
// UI/UX 개선 시스템
// ============================================

// ✅ [2026-01-25 모듈화] LoadingManager, ToastManager, AnimationHelper
// → ./utils/uiManagers.js로 이동됨 (상단 import 참조)

// 편의 함수들
(window as any).showLoading = (text?: string, progress?: number) => loadingManager.show(text, progress);
(window as any).updateLoading = (text: string, progress: number) => loadingManager.update(text, progress);
(window as any).hideLoading = () => loadingManager.hide();

(window as any).showToast = (message: string, type?: string, duration?: number) =>
  toastManager.show(message, type as any, duration);
(window as any).showSuccessToast = (message: string, duration?: number) =>
  toastManager.success(message, duration);
(window as any).showErrorToast = (message: string, duration?: number) =>
  toastManager.error(message, duration);


// ============================================
// 라이선스 코드 테스트 (개발용)
// ============================================
async function testLicenseCode(code: string): Promise<void> {
  const result = await withErrorHandling(
    async () => {
      console.log('[Renderer] 라이선스 코드 테스트 시작:', code);

      const deviceId = await window.api.getDeviceId();
      const result = await window.api.verifyLicense(code, deviceId);
      console.log('[Renderer] 라이선스 검증 결과:', result);

      if (result.valid) {
        toastManager.success(`✅ 라이선스 코드 유효!\n${JSON.stringify(result.license, null, 2)}`);
      } else {
        toastManager.error(`❌ 라이선스 코드无效!\n메시지: ${result.message}`);
      }

      return result;
    },
    'LicenseTest',
    { showToast: false, logError: false } // 이미 내부에서 처리
  );
}


// ============================================
// 라이선스 배지 초기화 및 업데이트
// ============================================
async function initLicenseBadge(): Promise<void> {
  const licenseBadge = document.getElementById('license-badge') as HTMLDivElement;
  const licenseBadgeText = document.getElementById('license-badge-text') as HTMLSpanElement;

  if (!licenseBadge || !licenseBadgeText) {
    console.warn('[LicenseBadge] 라이선스 배지 요소를 찾을 수 없습니다.');
    return;
  }

  const floatingContainer = document.getElementById('right-floating-buttons') as HTMLDivElement | null;
  const leftStatusContainer = document.getElementById('left-status-badges') as HTMLDivElement | null;
  const escapeHtml = (input: string): string =>
    String(input)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');

  const ensureMemberBadge = (): HTMLDivElement | null => {
    if (!leftStatusContainer) return null;
    let memberBadge = document.getElementById('member-badge') as HTMLDivElement | null;
    if (!memberBadge) {
      memberBadge = document.createElement('div');
      memberBadge.id = 'member-badge';
      memberBadge.style.display = 'none';
      memberBadge.style.background = 'linear-gradient(135deg, rgba(212, 175, 55, 0.22), rgba(255, 215, 0, 0.12))';
      memberBadge.style.border = '1px solid rgba(212, 175, 55, 0.62)';
      memberBadge.style.borderRadius = '14px';
      memberBadge.style.padding = '0.7rem 0.9rem';
      memberBadge.style.fontSize = '0.85rem';
      memberBadge.style.fontWeight = '700';
      memberBadge.style.color = '#22c55e';
      memberBadge.style.boxShadow = '0 12px 30px rgba(0,0,0,0.35)';
      memberBadge.style.textAlign = 'center';
      memberBadge.style.minWidth = '160px';
      memberBadge.style.letterSpacing = '0.2px';
      memberBadge.style.backdropFilter = 'blur(10px)';
      memberBadge.innerHTML =
        '<span style="display:inline-flex;align-items:center;gap:0.6rem;justify-content:center;">' +
        '<span id="member-badge-icon" style="width:22px;height:22px;border-radius:999px;display:inline-flex;align-items:center;justify-content:center;background:rgba(212,175,55,0.20);border:1px solid rgba(212,175,55,0.55);font-size:12px;color:#22c55e;">👤</span>' +
        '<span id="member-badge-text">회원</span>' +
        '</span>';
      leftStatusContainer.appendChild(memberBadge);
    }
    return memberBadge;
  };

  const ensureFreeQuotaCounter = (): HTMLDivElement | null => {
    if (!leftStatusContainer) return null;
    let counter = document.getElementById('free-quota-counter') as HTMLDivElement | null;
    if (!counter) {
      counter = document.createElement('div');
      counter.id = 'free-quota-counter';
      counter.style.display = 'none';
      counter.style.background = 'linear-gradient(135deg, rgba(16, 185, 129, 0.18), rgba(5, 150, 105, 0.10))';
      counter.style.border = '2px solid rgba(16, 185, 129, 0.55)';
      counter.style.borderRadius = '14px';
      counter.style.padding = '0.9rem 0.95rem';
      counter.style.fontSize = '1.05rem';
      counter.style.fontWeight = '900';
      counter.style.color = '#22c55e';
      counter.style.boxShadow = '0 12px 30px rgba(0,0,0,0.28)';
      counter.style.textAlign = 'center';
      counter.style.minWidth = '160px';
      counter.style.lineHeight = '1.25';
      counter.style.backdropFilter = 'blur(10px)';

      leftStatusContainer.appendChild(counter);
    }
    return counter;
  };

  const showWelcomeOnce = (userLabel: string): void => {
    try {
      if (sessionStorage.getItem('welcome_shown_v1') === '1') return;
      sessionStorage.setItem('welcome_shown_v1', '1');
      const safe = escapeHtml(userLabel);
      toastManager.info(
        `<div style="font-weight:800;font-size:14px;letter-spacing:0.2px;">${safe}님 환영합니다</div><div style="margin-top:4px;opacity:0.95;font-size:12px;">Better Life Naver에 오신 것을 환영해요.</div>`,
        4200,
      );
    } catch {
      // ignore
    }
  };

  let freeQuotaInterval: number | null = null;
  const updateFreeQuota = async (): Promise<void> => {
    try {
      const counter = ensureFreeQuotaCounter();
      if (!counter) return;
      if (typeof (window as any).api?.getQuotaStatus !== 'function') {
        counter.style.display = 'block';
        counter.innerHTML = '<div style="font-size:12px;color:red;">API Error</div>';
        return;
      }
      const status = await (window as any).api.getQuotaStatus();

      // 디버깅: 상태가 올바르지 않으면 에러 표시
      if (!status?.success) {
        counter.style.display = 'block';
        counter.innerHTML = `<div style="font-size:11px;color:red;line-height:1.2;">Error: ${status?.message || 'Unknown'}</div>`;
        return;
      }
      if (!status?.isFree) {
        // ✅ 유료 사용자는 쿼터 표시 안 함 - 완전히 숨김
        counter.style.display = 'none';
        return;
      }

      const q = status.quota;
      if (!q || !q.usage) {
        counter.style.display = 'block';
        counter.innerHTML = `<div style="font-size:11px;color:red;">No Quota Data</div>`;
        return;
      }

      // ✅ 발행 쿼터만 체크 (글생성+발행 = 1세트)
      const usedPublish = Number((q as any)?.usage?.publish) || 0;
      const limitPublish = Number((q as any)?.limits?.publish) || 2;
      const remaining = Math.max(0, limitPublish - usedPublish);

      // ✅ "0/2" 형태로 표시
      const isExhausted = remaining <= 0;
      const color = isExhausted ? '#ef4444' : '#22c55e';
      const text = `${usedPublish}/${limitPublish}`;
      counter.innerHTML =
        `<div style="font-size:0.85rem;font-weight:900;letter-spacing:0.2px;color:rgba(255,255,255,0.92);margin-bottom:4px;">오늘 발행</div>` +
        `<div style="font-size:1.45rem;font-weight:1000;color:${color};letter-spacing:0.2px;">${text}</div>`;
      counter.style.display = 'block';
    } catch (e) {
      const counter = ensureFreeQuotaCounter();
      if (counter) {
        counter.style.display = 'block';
        counter.innerHTML = `<div style="font-size:11px;color:red;">Exec Error: ${(e as Error).message}</div>`;
      }
    }
  };
  // ✅ [2026-01-16] 외부에서 호출 가능하도록 전역 노출
  (window as any).updateFreeQuota = updateFreeQuota;


  async function updateLicenseBadge(): Promise<void> {
    try {
      const result = await window.api.getLicense();

      if (result.license && result.license.isValid) {
        const licenseType = String((result.license as any).licenseType || '').trim();
        const memberBadge = ensureMemberBadge();
        const memberUserId = String((result.license as any).userId || '').trim();
        const memberLabel = licenseType === 'free' ? '무료사용자' : memberUserId;
        if (memberBadge) {
          const memberIcon = memberBadge.querySelector('#member-badge-icon') as HTMLElement | null;
          const memberText = memberBadge.querySelector('#member-badge-text') as HTMLElement | null;
          if (memberText) {
            memberText.textContent = licenseType === 'free' ? '무료사용자' : `회원: ${memberLabel || '회원'}`;
          }
          if (memberIcon) {
            memberIcon.textContent = licenseType === 'free' ? '🆓' : '👤';
            memberIcon.style.background = 'rgba(212,175,55,0.20)';
            memberIcon.style.borderColor = 'rgba(212,175,55,0.55)';
            memberIcon.style.color = '#22c55e';
          }
          memberBadge.style.display = 'block';
        }

        if (licenseType === 'free') {
          licenseBadge.style.display = 'none';
        } else {
          licenseBadge.style.display = 'flex';
        }

        if (memberLabel) {
          showWelcomeOnce(memberLabel);
        }

        if (licenseType === 'free') {
          if (freeQuotaInterval === null) {
            await updateFreeQuota();
            freeQuotaInterval = window.setInterval(() => {
              void updateFreeQuota();
            }, 30 * 1000);
          }
          return;
        } else {
          const counter = document.getElementById('free-quota-counter') as HTMLDivElement | null;
          if (counter) counter.style.display = 'none';
          if (freeQuotaInterval !== null) {
            window.clearInterval(freeQuotaInterval);
            freeQuotaInterval = null;
          }
        }

        // 만료일이 있는 경우 남은 기간 계산
        if (result.license.expiresAt) {
          const expiresAt = new Date(result.license.expiresAt);
          const now = new Date();

          // 날짜만 비교 (만료일은 해당 날짜의 끝까지 유효)
          const expiresDate = new Date(expiresAt.getFullYear(), expiresAt.getMonth(), expiresAt.getDate(), 23, 59, 59, 999);
          const nowDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);

          const diffTime = expiresDate.getTime() - nowDate.getTime();
          const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

          if (diffDays < 0) {
            // 만료됨
            licenseBadgeText.textContent = '⚠️ 라이선스 만료됨';
            licenseBadge.style.background = 'linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(220, 38, 38, 0.1))';
            licenseBadge.style.borderColor = '#ef4444';
            licenseBadgeText.style.color = '#ef4444';
          } else if (diffDays <= 7) {
            // 7일 이하 남음 (경고)
            licenseBadgeText.textContent = `⚠️ ${diffDays}일 남음`;
            licenseBadge.style.background = 'linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(217, 119, 6, 0.1))';
            licenseBadge.style.borderColor = '#f59e0b';
            licenseBadgeText.style.color = '#f59e0b';
          } else if (diffDays <= 30) {
            // 30일 이하 남음 (주의)
            licenseBadgeText.textContent = `⏰ ${diffDays}일 남음`;
            licenseBadge.style.background = 'linear-gradient(135deg, rgba(212, 175, 55, 0.2), rgba(255, 215, 0, 0.1))';
            licenseBadge.style.borderColor = '#FFD700';
            licenseBadgeText.style.color = '#FFD700';
          } else {
            // 정상
            licenseBadgeText.textContent = `✅ ${diffDays}일 남음`;
            licenseBadge.style.background = 'linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(22, 163, 74, 0.1))';
            licenseBadge.style.borderColor = '#22c55e';
            licenseBadgeText.style.color = '#22c55e';
          }
        } else {
          // 만료일이 없는 경우 - 영구 라이선스이거나 초기 등록 시 서버에서 계산 중일 수 있음
          // 서버에서 재검증 시도 (한 번만)
          try {
            console.log('[LicenseBadge] 만료일 정보 없음, 서버에서 재검증 시도...');
            const revalidateResult = await window.api.revalidateLicense();
            if (revalidateResult) {
              // 재검증 성공, 다시 라이선스 정보 가져오기
              const updatedResult = await window.api.getLicense();
              if (updatedResult.license?.expiresAt) {
                // 만료일 정보가 업데이트됨
                const expiresAt = new Date(updatedResult.license.expiresAt);
                const now = new Date();

                // 날짜만 비교 (만료일은 해당 날짜의 끝까지 유효)
                const expiresDate = new Date(expiresAt.getFullYear(), expiresAt.getMonth(), expiresAt.getDate(), 23, 59, 59, 999);
                const nowDate = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);

                const diffTime = expiresDate.getTime() - nowDate.getTime();
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                if (diffDays < 0) {
                  licenseBadgeText.textContent = '⚠️ 라이선스 만료됨';
                  licenseBadge.style.background = 'linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(220, 38, 38, 0.1))';
                  licenseBadge.style.borderColor = '#ef4444';
                  licenseBadgeText.style.color = '#ef4444';
                } else if (diffDays <= 7) {
                  licenseBadgeText.textContent = `⚠️ ${diffDays}일 남음`;
                  licenseBadge.style.background = 'linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(217, 119, 6, 0.1))';
                  licenseBadge.style.borderColor = '#f59e0b';
                  licenseBadgeText.style.color = '#f59e0b';
                } else if (diffDays <= 30) {
                  licenseBadgeText.textContent = `⏰ ${diffDays}일 남음`;
                  licenseBadge.style.background = 'linear-gradient(135deg, rgba(212, 175, 55, 0.2), rgba(255, 215, 0, 0.1))';
                  licenseBadge.style.borderColor = '#FFD700';
                  licenseBadgeText.style.color = '#FFD700';
                } else {
                  licenseBadgeText.textContent = `✅ ${diffDays}일 남음`;
                  licenseBadge.style.background = 'linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(22, 163, 74, 0.1))';
                  licenseBadge.style.borderColor = '#22c55e';
                  licenseBadgeText.style.color = '#22c55e';
                }
                return; // 업데이트 완료
              } else {
                // 재검증 후에도 만료일이 없으면 영구 라이선스로 판단
                console.log('[LicenseBadge] 재검증 후에도 만료일이 없음 - 영구 라이선스로 판단');
                licenseBadgeText.textContent = '♾️ 영구 라이선스';
                licenseBadge.style.background = 'linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(22, 163, 74, 0.1))';
                licenseBadge.style.borderColor = '#22c55e';
                licenseBadgeText.style.color = '#22c55e';
                return;
              }
            } else {
              // 재검증 실패 - 영구 라이선스일 가능성이 높음
              console.log('[LicenseBadge] 재검증 실패 - 영구 라이선스로 판단');
              licenseBadgeText.textContent = '♾️ 영구 라이선스';
              licenseBadge.style.background = 'linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(22, 163, 74, 0.1))';
              licenseBadge.style.borderColor = '#22c55e';
              licenseBadgeText.style.color = '#22c55e';
            }
          } catch (error) {
            console.error('[LicenseBadge] 서버 재검증 실패:', error);
            // 재검증 실패 시 영구 라이선스로 판단
            licenseBadgeText.textContent = '♾️ 영구 라이선스';
            licenseBadge.style.background = 'linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(22, 163, 74, 0.1))';
            licenseBadge.style.borderColor = '#22c55e';
            licenseBadgeText.style.color = '#22c55e';
          }
        }
      } else {
        // 라이선스 없음
        licenseBadge.style.display = 'none';
        const memberBadge = document.getElementById('member-badge') as HTMLDivElement | null;
        if (memberBadge) memberBadge.style.display = 'none';
        const counter = document.getElementById('free-quota-counter') as HTMLDivElement | null;
        if (counter) counter.style.display = 'none';
        if (freeQuotaInterval !== null) {
          window.clearInterval(freeQuotaInterval);
          freeQuotaInterval = null;
        }
      }
    } catch (error) {
      console.error('[LicenseBadge] 라이선스 정보 업데이트 실패:', error);
      licenseBadge.style.display = 'none';
      const memberBadge = document.getElementById('member-badge') as HTMLDivElement | null;
      if (memberBadge) memberBadge.style.display = 'none';
      const counter = document.getElementById('free-quota-counter') as HTMLDivElement | null;
      if (counter) counter.style.display = 'none';
      if (freeQuotaInterval !== null) {
        window.clearInterval(freeQuotaInterval);
        freeQuotaInterval = null;
      }
    }
  }

  // 초기 업데이트
  await updateLicenseBadge();

  // 1시간마다 업데이트 (만료일이 가까워질 수 있으므로)
  setInterval(updateLicenseBadge, 60 * 60 * 1000);
}

// ============================================
// 고객센터 버튼 초기화
// ============================================
function initCustomerServiceButton(): void {
  const customerServiceBtn = document.getElementById('customer-service-btn') as HTMLButtonElement;

  if (!customerServiceBtn) {
    console.warn('[CustomerService] 고객센터 버튼을 찾을 수 없습니다.');
    return;
  }

  customerServiceBtn.addEventListener('click', async () => {
    // 카카오톡 오픈챗 링크를 기본 브라우저로 열기
    const kakaoOpenChatUrl = 'https://open.kakao.com/o/sPcaslwh';

    try {
      if (window.api && window.api.openExternalUrl) {
        await window.api.openExternalUrl(kakaoOpenChatUrl);
        console.log('[CustomerService] 기본 브라우저로 카카오톡 오픈챗 열기:', kakaoOpenChatUrl);
      } else {
        // 폴백: shell.openExternal 사용 불가 시 window.open
        window.open(kakaoOpenChatUrl, '_blank');
      }
    } catch (error) {
      console.error('[CustomerService] 오픈챗 열기 실패:', error);
      // 폴백
      window.open(kakaoOpenChatUrl, '_blank');
    }
  });
}

// ============================================
// 전체 초기화 버튼 초기화
// ============================================
function initGlobalRefreshButton(): void {
  const globalRefreshBtn = document.getElementById('global-refresh-btn');
  if (globalRefreshBtn) {
    globalRefreshBtn.addEventListener('click', () => {
      // 확인 다이얼로그
      const confirmed = window.confirm(
        '⚠️ 전체 초기화\n\n' +
        '모든 입력 필드, 생성된 콘텐츠, 로그가 초기화됩니다.\n' +
        '(설정, 네이버 계정, 생성된 글 목록은 유지됩니다)\n\n' +
        '정말 초기화하시겠습니까?'
      );

      if (confirmed) {
        performGlobalRefresh();
      }
    });
  }
}

// 전체 초기화 실행
function performGlobalRefresh(): void {
  try {
    appendLog('🔄 전체 초기화를 시작합니다...');

    // 네이버 아이디/비밀번호 백업
    const naverIdInput = document.getElementById('naver-id') as HTMLInputElement;
    const naverPasswordInput = document.getElementById('naver-password') as HTMLInputElement;
    const naverRememberCheckbox = document.getElementById('remember-credentials') as HTMLInputElement;

    const savedNaverId = naverIdInput?.value || '';
    const savedNaverPassword = naverPasswordInput?.value || '';
    const savedRememberState = naverRememberCheckbox?.checked || false;

    // 1. 모든 입력 필드 초기화
    const allInputs = document.querySelectorAll('input[type="text"], input[type="url"], input[type="number"], input[type="datetime-local"], input[type="password"], textarea');
    allInputs.forEach(input => {
      if (input instanceof HTMLInputElement || input instanceof HTMLTextAreaElement) {
        // 설정 모달의 입력과 네이버 계정 정보는 제외
        if (!input.closest('#settings-modal') &&
          input.id !== 'naver-id' &&
          input.id !== 'naver-password') {
          input.value = '';
        }
      }
    });

    // 2. 모든 셀렉트 박스 초기화 (기본값으로)
    const allSelects = document.querySelectorAll('select');
    allSelects.forEach(select => {
      if (select instanceof HTMLSelectElement) {
        // 설정 모달의 셀렉트는 제외
        if (!select.closest('#settings-modal')) {
          select.selectedIndex = 0;
        }
      }
    });

    // 3. 체크박스 초기화
    const allCheckboxes = document.querySelectorAll('input[type="checkbox"]');
    allCheckboxes.forEach(checkbox => {
      if (checkbox instanceof HTMLInputElement) {
        // 설정 모달의 체크박스와 네이버 계정 기억하기는 제외
        if (!checkbox.closest('#settings-modal') &&
          checkbox.id !== 'remember-credentials') {
          checkbox.checked = false;
        }
      }
    });

    // 4. 로그 초기화
    const logOutputs = ['unified-log-output', 'images-log-output'];
    logOutputs.forEach(id => {
      const logElement = document.getElementById(id);
      if (logElement) {
        logElement.innerHTML = '';
      }
    });

    // 5. 진행상황 초기화
    const progressContainers = ['unified-progress-container', 'images-progress-container'];
    progressContainers.forEach(id => {
      const progressElement = document.getElementById(id);
      if (progressElement) {
        progressElement.innerHTML = '';
        progressElement.style.display = 'none';
      }
    });

    // 6. 생성된 이미지 미리보기 초기화
    const imageGrids = ['unified-generated-images-grid', 'images-generated-images-grid'];
    imageGrids.forEach(id => {
      const gridElement = document.getElementById(id);
      if (gridElement) {
        gridElement.innerHTML = '';
      }
    });

    // 7. 반자동 모드 섹션 숨기기
    const semiAutoSection = document.getElementById('unified-semi-auto-section');
    if (semiAutoSection) {
      semiAutoSection.style.display = 'none';
    }

    // 8. 전역 변수 초기화
    if (typeof window !== 'undefined') {
      (window as any).currentStructuredContent = null;
      (window as any).generatedImages = [];
      (window as any).currentPostId = null;
    }

    // 9. 임시 저장 데이터 삭제
    try {
      localStorage.removeItem('autosave_unified_url');
      localStorage.removeItem('autosave_unified_keywords');
      localStorage.removeItem('autosave_unified_title');
      localStorage.removeItem('autosave_unified_content');
      localStorage.removeItem('autosave_unified_hashtags');
    } catch (e) {
      // localStorage 접근 실패 시 무시
    }

    // 10. 네이버 아이디/비밀번호 복원
    if (naverIdInput && savedNaverId) {
      naverIdInput.value = savedNaverId;
    }
    if (naverPasswordInput && savedNaverPassword) {
      naverPasswordInput.value = savedNaverPassword;
    }
    if (naverRememberCheckbox) {
      naverRememberCheckbox.checked = savedRememberState;
    }

    // 11. 첫 번째 탭으로 이동
    const firstTab = document.querySelector('.tab-button[data-tab="main"]') as HTMLButtonElement;
    if (firstTab) {
      firstTab.click();
    }

    appendLog('✅ 전체 초기화가 완료되었습니다! (네이버 계정 정보는 유지됨)');
    toastManager.success('✅ 전체 초기화 완료!');

    // 성공 메시지 표시 후 로그도 초기화
    setTimeout(() => {
      logOutputs.forEach(id => {
        const logElement = document.getElementById(id);
        if (logElement) {
          logElement.innerHTML = '<div class="log-entry" style="color: var(--success);">✅ 초기화 완료! 새로운 작업을 시작하세요.</div>';
        }
      });
    }, 1000);

  } catch (error) {
    console.error('전체 초기화 중 오류:', error);
    appendLog(`❌ 초기화 중 오류 발생: ${(error as Error).message}`);
    toastManager.error('❌ 초기화 중 오류가 발생했습니다.');
  }
}

// ============================================
// 라이선스 모달 초기화
// ============================================
async function initLicenseModal(): Promise<void> {
  const licenseStatusText = document.getElementById('license-status-text') as HTMLParagraphElement;
  const licenseInputSection = document.getElementById('license-input-section') as HTMLDivElement;
  const licenseCodeInput = document.getElementById('license-code-input') as HTMLInputElement;
  const verifyLicenseBtn = document.getElementById('verify-license-btn') as HTMLButtonElement;
  const openSettingsFromLicense = document.getElementById('open-settings-from-license') as HTMLButtonElement;
  const openExternalLinksFromLicense = document.getElementById('open-external-links-from-license') as HTMLButtonElement;

  // 라이선스 상태 확인
  try {
    const result = await window.api.getLicense();
    if (result.license && result.license.isValid) {
      if (licenseStatusText) {
        licenseStatusText.textContent = `✅ 라이선스 인증 완료 (${result.license.licenseType || 'standard'})`;
      }

      // 관리자 패널 연동 (syncAdminSettings는 connectToAdminPanel 내부에서 호출됨)
      await connectToAdminPanel();
    } else {
      // ✅ 라이선스가 없으면 모달 표시
      if (licenseModal) {
        licenseModal.setAttribute('aria-hidden', 'false');
        licenseModal.style.display = 'flex';
      }
      if (licenseStatusText) {
        licenseStatusText.textContent = '❌ 라이선스가 인증되지 않았습니다.';
      }
      if (licenseInputSection) licenseInputSection.style.display = 'block';
      if (verifyLicenseBtn) verifyLicenseBtn.style.display = 'inline-block';
    }
  } catch (error) {
    // ✅ 오류 발생 시에도 모달 표시
    if (licenseModal) {
      licenseModal.setAttribute('aria-hidden', 'false');
      licenseModal.style.display = 'flex';
    }
    if (licenseStatusText) {
      licenseStatusText.textContent = `오류: ${(error as Error).message}`;
    }
    if (licenseInputSection) licenseInputSection.style.display = 'block';
    if (verifyLicenseBtn) verifyLicenseBtn.style.display = 'inline-block';
  }

  // 인증 버튼
  if (verifyLicenseBtn && licenseCodeInput) {
    verifyLicenseBtn.addEventListener('click', async () => {
      const code = licenseCodeInput.value.trim();
      if (!code) {
        alert('라이선스 코드를 입력해주세요.');
        return;
      }

      verifyLicenseBtn.disabled = true;
      verifyLicenseBtn.textContent = '인증 중...';

      try {
        const deviceId = await window.api.getDeviceId();
        const result = await window.api.verifyLicense(code, deviceId);
        if (result.valid && result.license) {
          alert('✅ 라이선스 인증이 완료되었습니다!');
          if (licenseModal) {
            licenseModal.setAttribute('aria-hidden', 'true');
            licenseModal.style.display = 'none';
          }
          // 라이선스 배지 업데이트
          await initLicenseBadge();
          location.reload();
        } else {
          alert(`❌ 인증 실패: ${result.message || '알 수 없는 오류'}`);
        }
      } catch (error) {
        alert(`❌ 오류: ${(error as Error).message}`);
      } finally {
        verifyLicenseBtn.disabled = false;
        verifyLicenseBtn.textContent = '인증하기';
      }
    });
  }

  // 환경 설정 열기
  if (openSettingsFromLicense && settingsModal) {
    openSettingsFromLicense.addEventListener('click', () => {
      if (licenseModal) {
        licenseModal.setAttribute('aria-hidden', 'true');
        licenseModal.style.display = 'none';
      }
      settingsModal.setAttribute('aria-hidden', 'false');
      settingsModal.style.display = 'flex';
    });
  }

  // ✅ 외부유입 열기 (라이선스 체크 완화)
  if (openExternalLinksFromLicense && externalLinksModal) {
    openExternalLinksFromLicense.addEventListener('click', async () => {
      console.log('[Settings] 외부유입 모달 열기');

      // 라이선스 확인은 로그만 남기고 모달은 항상 열기
      try {
        const licenseResult = await window.api.getLicense();
        if (licenseResult.license && licenseResult.license.expiresAt) {
          console.log('[Settings] 라이선스 만료일:', new Date(licenseResult.license.expiresAt).toLocaleDateString('ko-KR'));
        } else {
          console.log('[Settings] 라이선스 정보 없음 - 기본 모드로 진행');
        }
      } catch (licenseError) {
        console.warn('[Settings] 라이선스 확인 실패, 기본 모드로 진행:', licenseError);
      }

      // ✅ 외부유입 모달 항상 표시
      if (licenseModal) {
        licenseModal.setAttribute('aria-hidden', 'true');
        licenseModal.style.display = 'none';
      }
      externalLinksModal.setAttribute('aria-hidden', 'false');
      externalLinksModal.style.display = 'flex';
    });
  }
}

// ============================================
// ✅ 오류 알림 모달 (수동으로 닫기)
// ============================================
function showErrorAlertModal(title: string, message: string): void {
  // 기존 모달 제거
  const existingModal = document.getElementById('error-alert-modal');
  if (existingModal) existingModal.remove();

  const modal = document.createElement('div');
  modal.id = 'error-alert-modal';
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0, 0, 0, 0.7); display: flex; align-items: center;
    justify-content: center; z-index: 10000; backdrop-filter: blur(4px);
  `;

  modal.innerHTML = `
    <div style="background: var(--bg-secondary); border-radius: 16px; padding: 2rem; max-width: 500px; width: 90%; border: 2px solid #ef4444; box-shadow: 0 20px 60px rgba(239, 68, 68, 0.3);">
      <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1.5rem;">
        <div style="width: 48px; height: 48px; background: rgba(239, 68, 68, 0.2); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.5rem;">⚠️</div>
        <h3 style="margin: 0; color: #ef4444; font-size: 1.3rem;">${title}</h3>
      </div>
      <div style="background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem;">
        <p style="margin: 0; color: var(--text-strong); line-height: 1.6; white-space: pre-wrap;">${message}</p>
      </div>
      <div style="background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem;">
        <p style="margin: 0; color: var(--text-muted); font-size: 0.9rem; line-height: 1.5;">
          💡 <strong>해결 방법:</strong><br>
          1. 스케줄 관리 탭에서 실패한 항목을 확인하세요.<br>
          2. "시간 변경 후 재시도" 버튼으로 새 시간을 설정하세요.<br>
          3. 캡차가 필요하면 브라우저에서 직접 해결해주세요.
        </p>
      </div>
      <button type="button" id="error-alert-close-btn" style="width: 100%; padding: 1rem; background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; border: none; border-radius: 8px; font-weight: 600; font-size: 1rem; cursor: pointer;">
        확인
      </button>
    </div>
  `;

  document.body.appendChild(modal);

  // 닫기 버튼 이벤트
  const closeBtn = document.getElementById('error-alert-close-btn');
  if (closeBtn) {
    closeBtn.addEventListener('click', () => modal.remove());
  }

  // 배경 클릭으로는 닫히지 않음 (수동으로만 닫기)
}

// ============================================
// ✅ 시간 변경 모달
// ============================================
function showRescheduleModal(postId: string, title: string, onConfirm: (newDate: string) => void): void {
  // 기존 모달 제거
  const existingModal = document.getElementById('reschedule-modal');
  if (existingModal) existingModal.remove();

  // 기본값: 현재 시간 + 10분
  const defaultDate = new Date(Date.now() + 10 * 60 * 1000);
  const defaultDateStr = defaultDate.toISOString().slice(0, 16);

  const modal = document.createElement('div');
  modal.id = 'reschedule-modal';
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0, 0, 0, 0.7); display: flex; align-items: center;
    justify-content: center; z-index: 10000; backdrop-filter: blur(4px);
  `;

  modal.innerHTML = `
    <div style="background: var(--bg-secondary); border-radius: 16px; padding: 2rem; max-width: 450px; width: 90%; border: 1px solid var(--border-light); box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);">
      <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1.5rem;">
        <div style="width: 48px; height: 48px; background: rgba(245, 158, 11, 0.2); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.5rem;">📅</div>
        <div>
          <h3 style="margin: 0; color: var(--text-strong); font-size: 1.2rem;">예약 시간 변경</h3>
          <p style="margin: 0.25rem 0 0 0; color: var(--text-muted); font-size: 0.85rem;">${title}</p>
        </div>
      </div>
      <div style="margin-bottom: 1.5rem;">
        <label style="display: block; color: var(--text-muted); font-size: 0.9rem; margin-bottom: 0.5rem;">새 발행 시간</label>
        <input type="datetime-local" id="reschedule-datetime" value="${defaultDateStr}" style="width: 100%; padding: 0.75rem; background: var(--bg-primary); border: 1px solid var(--border-light); border-radius: 8px; color: var(--text-strong); font-size: 1rem;">
      </div>
      <div style="display: flex; gap: 0.75rem;">
        <button type="button" id="reschedule-cancel-btn" style="flex: 1; padding: 0.75rem; background: var(--bg-tertiary); color: var(--text-muted); border: 1px solid var(--border-light); border-radius: 8px; font-weight: 600; cursor: pointer;">
          취소
        </button>
        <button type="button" id="reschedule-confirm-btn" style="flex: 1; padding: 0.75rem; background: linear-gradient(135deg, #f59e0b, #d97706); color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
          시간 변경
        </button>
      </div>
    </div>
  `;

  document.body.appendChild(modal);

  // 취소 버튼
  const cancelBtn = document.getElementById('reschedule-cancel-btn');
  if (cancelBtn) {
    cancelBtn.addEventListener('click', () => modal.remove());
  }

  // 확인 버튼
  const confirmBtn = document.getElementById('reschedule-confirm-btn');
  const datetimeInput = document.getElementById('reschedule-datetime') as HTMLInputElement;

  if (confirmBtn && datetimeInput) {
    confirmBtn.addEventListener('click', () => {
      const newDate = datetimeInput.value;
      if (!newDate) {
        toastManager.warning('발행 시간을 선택해주세요.');
        return;
      }

      const selectedDate = new Date(newDate);
      if (selectedDate <= new Date()) {
        toastManager.warning('현재 시간 이후로 설정해주세요.');
        return;
      }

      modal.remove();
      onConfirm(newDate);
    });
  }

  // 배경 클릭으로 닫기
  modal.addEventListener('click', (e) => {
    if (e.target === modal) modal.remove();
  });
}

// ============================================
// 스케줄 관리 초기화
// ============================================
async function initScheduleManagement(): Promise<void> {
  console.log('[ScheduleManager] 스케줄 관리 초기화 시작');

  const refreshScheduleBtn = document.getElementById('schedule-refresh-btn') as HTMLButtonElement;
  const scheduledPostsList = document.getElementById('schedule-list-container') as HTMLDivElement;
  const scheduleFilter = document.getElementById('schedule-filter') as HTMLSelectElement;

  console.log('[ScheduleManager] 요소 확인:', {
    refreshScheduleBtn: !!refreshScheduleBtn,
    scheduledPostsList: !!scheduledPostsList,
    scheduleFilter: !!scheduleFilter
  });

  async function loadScheduledPosts(): Promise<void> {
    if (!scheduledPostsList) {
      console.warn('[ScheduleManager] schedule-list-container 요소가 없습니다.');
      return;
    }

    try {
      console.log('[ScheduleManager] getScheduledPosts 호출 시도...');

      // window.api 존재 여부 확인
      if (!window.api) {
        console.error('[ScheduleManager] window.api가 정의되지 않았습니다!');
        scheduledPostsList.innerHTML = `
          <div style="text-align: center; padding: 3rem; color: #ef4444;">
            <div style="font-size: 3rem; margin-bottom: 1rem;">⚠️</div>
            <p style="font-size: 1.1rem;">API가 초기화되지 않았습니다</p>
            <p style="font-size: 0.9rem; margin-top: 0.5rem;">앱을 재시작해주세요</p>
          </div>
        `;
        return;
      }

      // getScheduledPosts 함수 존재 여부 확인
      if (typeof window.api.getScheduledPosts !== 'function') {
        console.error('[ScheduleManager] window.api.getScheduledPosts 함수가 없습니다!');
        scheduledPostsList.innerHTML = `
          <div style="text-align: center; padding: 3rem; color: #ef4444;">
            <div style="font-size: 3rem; margin-bottom: 1rem;">⚠️</div>
            <p style="font-size: 1.1rem;">스케줄 API가 없습니다</p>
            <p style="font-size: 0.9rem; margin-top: 0.5rem;">앱 버전을 확인해주세요</p>
          </div>
        `;
        return;
      }

      const result = await window.api.getScheduledPosts();
      console.log('[ScheduleManager] getScheduledPosts 결과:', result);

      if (result.success && result.posts && result.posts.length > 0) {
        // 필터 적용
        const filterValue = scheduleFilter?.value || 'all';
        const filteredPosts = filterValue === 'all'
          ? result.posts
          : result.posts.filter(post => post.status === filterValue);

        if (filteredPosts.length === 0) {
          scheduledPostsList.innerHTML = `
            <div style="text-align: center; padding: 3rem; color: var(--text-muted);">
              <div style="font-size: 3rem; margin-bottom: 1rem;">📭</div>
              <p style="font-size: 1.1rem;">필터 조건에 맞는 예약이 없습니다</p>
            </div>
          `;
          return;
        }

        scheduledPostsList.innerHTML = filteredPosts.map((post: any) => {
          const scheduleDate = new Date(post.scheduleDate);
          const now = new Date();
          const isPast = scheduleDate < now;
          const scheduleDateStr = scheduleDate.toLocaleString('ko-KR', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
          });

          // 발행 완료 시간
          let publishedDateStr = '';
          if (post.publishedAt) {
            const publishedDate = new Date(post.publishedAt);
            publishedDateStr = publishedDate.toLocaleString('ko-KR', {
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit',
            });
          }

          // 상태 표시
          let statusText = '';
          let statusColor = '';
          let statusIcon = '';
          if (post.status === 'published') {
            statusText = '✅ 발행 완료';
            statusColor = '#10b981';
            statusIcon = '✅';
          } else if (post.status === 'cancelled') {
            statusText = '❌ 취소됨';
            statusColor = '#ef4444';
            statusIcon = '❌';
          } else if (post.status === 'failed') {
            statusText = '⚠️ 발행 실패';
            statusColor = '#ef4444';
            statusIcon = '⚠️';
          } else if (isPast) {
            statusText = '⏰ 발행 대기';
            statusColor = '#f59e0b';
            statusIcon = '⏰';
          } else {
            statusText = '📅 예약됨';
            statusColor = '#3b82f6';
            statusIcon = '📅';
          }

          // 제목 클릭 가능 여부
          const titleClickable = post.status === 'published' && post.publishedUrl;
          const titleHtml = titleClickable
            ? `<a href="${post.publishedUrl}" target="_blank" style="font-size: 1.2rem; font-weight: 600; color: var(--primary); margin: 0; text-decoration: none; cursor: pointer; transition: all 0.3s;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">${post.title || '제목 없음'} 🔗</a>`
            : `<h3 style="font-size: 1.2rem; font-weight: 600; color: var(--text-strong); margin: 0;">${post.title || '제목 없음'}</h3>`;

          return `
            <div style="background: var(--bg-secondary); border: 2px solid var(--border-light); border-radius: 12px; padding: 1.5rem; margin-bottom: 1rem; transition: all 0.3s;">
              <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 1rem;">
                ${titleHtml}
                <div style="display: flex; gap: 0.5rem;">
                  <button type="button" class="scheduled-post-preview" data-post-id="${post.postId || ''}" data-title="${(post.title || '').replace(/"/g, '&quot;')}" style="padding: 0.5rem 1rem; background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; transition: all 0.3s;">
                    👁️ 미리보기
                  </button>
                  <button type="button" class="scheduled-post-remove" data-post-id="${post.id}" style="padding: 0.5rem 1rem; background: linear-gradient(135deg, #ef4444, #dc2626); color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; transition: all 0.3s;">
                    🗑️ 삭제
                  </button>
                </div>
              </div>
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; font-size: 0.95rem; margin-bottom: 0.75rem;">
                <div>
                  <span style="color: var(--text-muted);">📅 예약 일시:</span>
                  <span style="color: var(--text-strong); font-weight: 600; margin-left: 0.5rem;">${scheduleDateStr}</span>
                </div>
                <div>
                  <span style="color: var(--text-muted);">상태:</span>
                  <span style="color: ${statusColor}; font-weight: 600; margin-left: 0.5rem;">${statusText}</span>
                </div>
              </div>
              ${post.status === 'published' && publishedDateStr ? `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; font-size: 0.95rem;">
                  <div>
                    <span style="color: var(--text-muted);">⏰ 완료 시간:</span>
                    <span style="color: #10b981; font-weight: 600; margin-left: 0.5rem;">${publishedDateStr}</span>
                  </div>
                  ${post.publishedUrl ? `
                    <div>
                      <span style="color: var(--text-muted);">🔗 발행 URL:</span>
                      <a href="#" class="external-link-btn" data-url="${post.publishedUrl}" style="color: var(--primary); font-weight: 600; margin-left: 0.5rem; text-decoration: none; cursor: pointer;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">바로가기</a>
                    </div>
                  ` : ''}
                </div>
              ` : ''}
              ${post.status === 'failed' ? `
                <div style="margin-top: 1rem; padding: 1rem; background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 8px;">
                  <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.75rem;">
                    <span style="font-size: 1.25rem;">⚠️</span>
                    <strong>발행 실패</strong>
                  </div>
                  <p style="color: var(--text-muted); font-size: 0.9rem; margin: 0 0 1rem 0; line-height: 1.5;">
                    ${post.error || '알 수 없는 오류가 발생했습니다.'}
                  </p>
                  <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                    <button type="button" class="scheduled-post-reschedule" data-post-id="${post.id}" data-title="${(post.title || '').replace(/"/g, '&quot;')}" style="padding: 0.5rem 1rem; background: linear-gradient(135deg, #f59e0b, #d97706); color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 0.85rem;">
                      📅 시간 변경 후 재시도
                    </button>
                    <button type="button" class="scheduled-post-retry" data-post-id="${post.id}" style="padding: 0.5rem 1rem; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 0.85rem;">
                      🔄 즉시 재시도
                    </button>
                  </div>
                </div>
              ` : ''}
            </div>
          `;
        }).join('');

        // 미리보기 버튼 이벤트 추가
        scheduledPostsList.querySelectorAll('.scheduled-post-preview').forEach(btn => {
          btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const postId = (btn as HTMLButtonElement).getAttribute('data-post-id');
            const title = (btn as HTMLButtonElement).getAttribute('data-title');

            console.log('[Schedule Preview] postId:', postId, 'title:', title);

            try {
              // localStorage에서 글 데이터 가져오기 (올바른 키 사용)
              const generatedPosts = JSON.parse(localStorage.getItem(GENERATED_POSTS_KEY) || '[]');
              console.log('[Schedule Preview] 전체 글 수:', generatedPosts.length);

              // ✅ 전체 글 제목과 ID 출력 (디버깅 강화)
              console.log('[Schedule Preview] 저장된 글 목록:');
              generatedPosts.forEach((p: any, idx: number) => {
                console.log(`  [${idx + 1}] ID: ${p.id}, 제목: ${p.title}`);
              });

              // postId가 있으면 postId로 찾고, 없으면 title로 찾기
              let postData;
              // ✅ postId가 유효한지 확인 (null, undefined, 빈 문자열, "null", "undefined" 제외)
              if (postId && postId.trim() && postId !== 'null' && postId !== 'undefined') {
                console.log('[Schedule Preview] 검색할 postId:', postId);
                postData = generatedPosts.find((p: any) => p.id === postId);
                console.log('[Schedule Preview] postId로 검색 결과:', postData ? `찾음 (${postData.title})` : '못 찾음');

                // ✅ postId로 못 찾으면 저장된 모든 ID와 비교 출력
                if (!postData) {
                  console.warn('[Schedule Preview] ⚠️ postId로 글을 찾지 못했습니다!');
                  console.warn('[Schedule Preview] 검색한 postId:', postId);
                  console.warn('[Schedule Preview] 저장된 postId 목록:', generatedPosts.map((p: any) => p.id));
                }
              } else {
                console.log('[Schedule Preview] postId가 유효하지 않음:', postId, '- title로 검색합니다');
              }

              if (!postData && title) {
                // 정확한 제목으로 검색
                postData = generatedPosts.find((p: any) => p.title === title);
                console.log('[Schedule Preview] 정확한 제목으로 검색:', title, '결과:', !!postData);

                // 정확한 제목으로 못 찾으면 유사한 제목으로 검색
                if (!postData) {
                  const normalizedTitle = title.toLowerCase().replace(/[^a-z0-9가-힣]/g, '');
                  postData = generatedPosts.find((p: any) => {
                    const normalizedPostTitle = (p.title || '').toLowerCase().replace(/[^a-z0-9가-힣]/g, '');
                    return normalizedPostTitle.includes(normalizedTitle) || normalizedTitle.includes(normalizedPostTitle);
                  });
                  console.log('[Schedule Preview] 유사 제목으로 검색:', normalizedTitle, '결과:', !!postData);
                }

                // 여전히 못 찾으면 가장 최근 글 사용
                if (!postData && generatedPosts.length > 0) {
                  postData = generatedPosts.sort((a: any, b: any) => {
                    const timeA = new Date(a.updatedAt || a.createdAt || 0).getTime();
                    const timeB = new Date(b.updatedAt || b.createdAt || 0).getTime();
                    return timeB - timeA;
                  })[0];
                  console.log('[Schedule Preview] 가장 최근 글 사용:', postData?.title);
                  toastManager.warning('⚠️ 정확한 글을 찾지 못해 가장 최근 글을 표시합니다.');
                }
              }

              if (!postData) {
                console.error('[Schedule Preview] 글을 찾을 수 없음. postId:', postId, 'title:', title);
                toastManager.error('❌ 글 데이터를 찾을 수 없습니다. 글이 삭제되었을 수 있습니다.');
                return;
              }

              console.log('[Schedule Preview] 미리보기 표시:', postData.title);
              // 미리보기 모달 표시
              showSchedulePreviewModal(postData);
            } catch (error) {
              console.error('[Schedule Preview] 오류:', error);
              toastManager.error(`❌ 미리보기 오류: ${(error as Error).message}`);
            }
          });
        });

        // 삭제 버튼 이벤트 추가
        scheduledPostsList.querySelectorAll('.scheduled-post-remove').forEach(btn => {
          btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const postId = (btn as HTMLButtonElement).getAttribute('data-post-id');
            if (postId && confirm('예약된 포스팅을 삭제하시겠습니까?')) {
              try {
                const result = await window.api.removeScheduledPost(postId);
                if (result.success) {
                  toastManager.success('✅ 예약이 삭제되었습니다');
                  await loadScheduledPosts();
                } else {
                  toastManager.error(`❌ 삭제 실패: ${result.message || '알 수 없는 오류'}`);
                }
              } catch (error) {
                toastManager.error(`❌ 오류: ${(error as Error).message}`);
              }
            }
          });
        });

        // ✅ 시간 변경 후 재시도 버튼 이벤트
        scheduledPostsList.querySelectorAll('.scheduled-post-reschedule').forEach(btn => {
          btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const postId = (btn as HTMLButtonElement).getAttribute('data-post-id');
            const title = (btn as HTMLButtonElement).getAttribute('data-title') || '예약 발행';

            if (!postId) return;

            // 시간 변경 모달 표시
            showRescheduleModal(postId, title, async (newDate: string) => {
              try {
                const result = await window.api.reschedulePost(postId, newDate);
                if (result.success) {
                  toastManager.success('✅ 예약 시간이 변경되었습니다. 새 시간에 자동 발행됩니다.');
                  await loadScheduledPosts();
                } else {
                  showErrorAlertModal('예약 시간 변경 실패', result.message || '알 수 없는 오류가 발생했습니다.');
                }
              } catch (error) {
                showErrorAlertModal('예약 시간 변경 오류', (error as Error).message);
              }
            });
          });
        });

        // ✅ 즉시 재시도 버튼 이벤트
        scheduledPostsList.querySelectorAll('.scheduled-post-retry').forEach(btn => {
          btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const postId = (btn as HTMLButtonElement).getAttribute('data-post-id');

            if (!postId) return;

            if (confirm('지금 바로 발행을 재시도하시겠습니까?')) {
              try {
                toastManager.info('🔄 발행 재시도 중...');
                const result = await window.api.retryScheduledPost(postId);
                if (result.success) {
                  toastManager.success('✅ 발행이 완료되었습니다!');
                  await loadScheduledPosts();
                } else {
                  showErrorAlertModal('발행 재시도 실패', result.message || '알 수 없는 오류가 발생했습니다. 캡차 인증이 필요할 수 있습니다.');
                }
              } catch (error) {
                showErrorAlertModal('발행 재시도 오류', (error as Error).message);
              }
            }
          });
        });

      } else {
        scheduledPostsList.innerHTML = `
          <div style="text-align: center; padding: 3rem; color: var(--text-muted);">
            <div style="font-size: 3rem; margin-bottom: 1rem;">📭</div>
            <p style="font-size: 1.1rem;">예약된 발행이 없습니다</p>
            <p style="font-size: 0.9rem; margin-top: 0.5rem;">스마트 자동 발행 탭에서 예약 발행을 설정해보세요!</p>
          </div>
        `;
      }
    } catch (error) {
      console.error('스케줄 로드 실패:', error);
      scheduledPostsList.innerHTML = `
        <div style="text-align: center; padding: 3rem; color: #ef4444;">
          <div style="font-size: 3rem; margin-bottom: 1rem;">⚠️</div>
          <p style="font-size: 1.1rem;">예약된 포스팅을 불러오는 중 오류가 발생했습니다</p>
          <p style="font-size: 0.9rem; margin-top: 0.5rem;">${(error as Error).message}</p>
        </div>
      `;
    }
  }

  // 새로고침 버튼
  if (refreshScheduleBtn) {
    refreshScheduleBtn.addEventListener('click', async () => {
      refreshScheduleBtn.disabled = true;
      const originalText = refreshScheduleBtn.textContent;
      refreshScheduleBtn.textContent = '로딩 중...';
      await loadScheduledPosts();
      refreshScheduleBtn.disabled = false;
      refreshScheduleBtn.textContent = originalText || '🔄 새로고침';
      toastManager.success('✅ 새로고침 완료');
    });
  }

  // 필터 변경 이벤트
  if (scheduleFilter) {
    scheduleFilter.addEventListener('change', async () => {
      await loadScheduledPosts();
    });
  }

  // 초기 로드
  await loadScheduledPosts();
}

// ============================================
// 스케줄 미리보기 모달
// ============================================
function showSchedulePreviewModal(postData: any): void {
  // 기존 모달 제거
  const existingModal = document.getElementById('schedule-preview-modal');
  if (existingModal) {
    existingModal.remove();
  }

  // 본문 포맷팅
  let formattedBody = postData.content || postData.bodyPlain || ''; // ✅ content 우선 사용
  if (formattedBody) {
    formattedBody = formattedBody
      .split('\n')
      .filter((line: string) => line.trim())
      .map((line: string) => `<p style="margin-bottom: 1rem; line-height: 1.8;">${line}</p>`)
      .join('');
  }

  // 해시태그 포맷팅
  let formattedHashtags = '';
  if (postData.hashtags && postData.hashtags.length > 0) {
    formattedHashtags = postData.hashtags.map((tag: string) => `<span style="display: inline-block; background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(16, 185, 129, 0.05)); color: var(--primary); padding: 0.25rem 0.75rem; border-radius: 6px; margin-right: 0.5rem; margin-bottom: 0.5rem; font-size: 0.9rem;">#${tag}</span>`).join('');
  }

  const modalHtml = `
    <div id="schedule-preview-modal" class="modal-backdrop" style="display: flex; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 10000; align-items: center; justify-content: center; backdrop-filter: blur(5px);">
      <div class="modal-panel" style="background: var(--bg-primary); border: 3px solid var(--border-gold); border-radius: 20px; max-width: 900px; max-height: 90vh; overflow-y: auto; box-shadow: 0 20px 40px rgba(0,0,0,0.3); position: relative; padding: 2rem;">
        <button type="button" class="close-modal-btn" style="position: absolute; top: 1rem; right: 1rem; background: #ef4444; color: white; border: none; width: 40px; height: 40px; border-radius: 50%; font-size: 1.5rem; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4); transition: all 0.3s;" onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'">×</button>
        
        <h2 style="font-size: 1.8rem; font-weight: 700; color: var(--text-strong); margin-bottom: 2rem; padding-right: 3rem;">📄 글 미리보기</h2>
        
        <!-- 제목 -->
        <div style="margin-bottom: 2rem; padding: 1.5rem; background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(16, 185, 129, 0.05)); border-radius: 12px; border: 2px solid rgba(59, 130, 246, 0.3);">
          <h3 style="font-size: 0.9rem; font-weight: 600; color: var(--text-muted); margin-bottom: 0.75rem; text-transform: uppercase; letter-spacing: 1px;">📌 제목</h3>
          <p style="font-size: 1.3rem; font-weight: 600; color: var(--text-strong); line-height: 1.6; margin: 0;">${postData.title || '제목 없음'}</p>
        </div>

        <!-- 본문 -->
        <div style="margin-bottom: 2rem; padding: 1.5rem; background: var(--bg-secondary); border-radius: 12px; border: 2px solid var(--border-light);">
          <h3 style="font-size: 0.9rem; font-weight: 600; color: var(--text-muted); margin-bottom: 1rem; text-transform: uppercase; letter-spacing: 1px;">📝 본문</h3>
          <div style="color: var(--text-strong); line-height: 1.8; max-height: 400px; overflow-y: auto;">
            ${formattedBody || '<p style="color: var(--text-muted); font-style: italic;">본문 내용이 없습니다</p>'}
          </div>
        </div>

        <!-- 해시태그 -->
        ${postData.hashtags && postData.hashtags.length > 0 ? `
          <div style="margin-bottom: 2rem; padding: 1.5rem; background: var(--bg-secondary); border-radius: 12px; border: 2px solid var(--border-light);">
            <h3 style="font-size: 0.9rem; font-weight: 600; color: var(--text-muted); margin-bottom: 1rem; text-transform: uppercase; letter-spacing: 1px;">🏷️ 해시태그</h3>
            <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
              ${formattedHashtags}
            </div>
          </div>
        ` : ''}

        <!-- 닫기 버튼 -->
        <div style="display: flex; justify-content: center; margin-top: 2rem;">
          <button type="button" class="close-modal-btn" style="padding: 0.875rem 2.5rem; background: linear-gradient(135deg, #6366f1, #4f46e5); color: white; border: none; border-radius: 12px; font-weight: 600; font-size: 1rem; cursor: pointer; transition: all 0.3s; box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(99, 102, 241, 0.5)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(99, 102, 241, 0.4)'">
            닫기
          </button>
        </div>
      </div>
    </div>
  `;

  document.body.insertAdjacentHTML('beforeend', modalHtml);

  // 닫기 이벤트
  const modal = document.getElementById('schedule-preview-modal');
  const closeButtons = modal?.querySelectorAll('.close-modal-btn');

  closeButtons?.forEach(btn => {
    btn.addEventListener('click', () => {
      modal?.remove();
    });
  });

  // 배경 클릭 시 닫기
  modal?.addEventListener('click', (e) => {
    if (e.target === modal) {
      modal.remove();
    }
  });
}


// ============================================
// 관리자 패널 연동
// ============================================
async function connectToAdminPanel(): Promise<void> {
  try {
    console.log('[AdminPanel] 라이선스 유효 - 관리자 패널 연결 시도...');

    // 관리자 패널 상태 표시 (UI에 추가될 수 있음)
    const adminStatus = document.getElementById('admin-panel-status');
    if (adminStatus) {
      adminStatus.textContent = '관리자 패널 연결 중...';
      adminStatus.style.color = '#ffd700';
    }

    // 관리자 패널 연결 API 호출
    const result = await (window.api as any).adminConnect();
    if (!result.success) {
      throw new Error(result.message);
    }

    console.log('[AdminPanel] 관리자 패널 연결 성공');
    if (adminStatus) {
      adminStatus.textContent = '관리자 패널 연결됨';
      adminStatus.style.color = '#4caf50';
    }

    // 연결 성공 시 설정 동기화
    await syncAdminSettings();

  } catch (error) {
    console.error('[AdminPanel] 관리자 패널 연결 실패:', error);
    const adminStatus = document.getElementById('admin-panel-status');
    if (adminStatus) {
      adminStatus.textContent = '관리자 패널 연결 실패';
      adminStatus.style.color = '#f44336';
    }
  }
}

async function syncAdminSettings(): Promise<void> {
  try {
    console.log('[AdminPanel] 관리자 설정 동기화 중...');

    // 관리자 설정 동기화 API 호출
    const result = await (window.api as any).adminSyncSettings();
    if (!result.success) {
      throw new Error(result.message);
    }

    // 동기화된 설정이 있으면 로컬에 적용
    if (result.settings) {
      const currentConfig = await window.api.getConfig();
      const updatedConfig = { ...currentConfig, ...result.settings };
      await window.api.saveConfig(updatedConfig);
      console.log('[AdminPanel] 관리자 설정이 로컬에 적용됨');
    }

    console.log('[AdminPanel] 관리자 설정 동기화 완료');
  } catch (error) {
    console.error('[AdminPanel] 관리자 설정 동기화 실패:', error);
  }
}

async function sendAdminReport(data: any): Promise<void> {
  try {
    console.log('[AdminPanel] 관리자 보고서 전송 중...');

    // 관리자 보고서 전송 API 호출
    const result = await (window.api as any).adminSendReport(data);
    if (!result.success) {
      throw new Error(result.message);
    }

    console.log('[AdminPanel] 관리자 보고서 전송 완료');
  } catch (error) {
    console.error('[AdminPanel] 관리자 보고서 전송 실패:', error);
  }
}

// 관리자 권한 확인
async function checkAdminPermissions(): Promise<any> {
  try {
    console.log('[AdminPanel] 관리자 권한 확인 중...');

    const result = await (window.api as any).adminCheckPermissions();
    if (!result.success) {
      console.warn('[AdminPanel] 권한 확인 실패:', result);
      return { isValid: false };
    }

    console.log('[AdminPanel] 관리자 권한 확인 완료:', result.permissions);
    return result.permissions;
  } catch (error) {
    console.error('[AdminPanel] 권한 확인 실패:', error);
    return { isValid: false, error: (error as Error).message };
  }
}

// ============================================
// 환경 설정 모달 초기화
// ============================================
async function initSettingsModal(): Promise<void> {
  // ✅ 가격 정보 모달 열기/닫기 로직 추가
  const openPriceInfoBtn = document.getElementById('open-price-info-btn');
  const priceInfoModal = document.getElementById('price-info-modal');
  const closePriceModalBtn = document.getElementById('close-price-modal-btn');
  const confirmPriceBtn = document.getElementById('confirm-price-btn');

  if (openPriceInfoBtn && priceInfoModal) {
    // 열기
    openPriceInfoBtn.addEventListener('click', () => {
      priceInfoModal.style.display = 'flex';
      priceInfoModal.setAttribute('aria-hidden', 'false');
    });

    // 닫기 함수
    const closePriceModal = () => {
      priceInfoModal.style.display = 'none';
      priceInfoModal.setAttribute('aria-hidden', 'true');
    };

    if (closePriceModalBtn) closePriceModalBtn.addEventListener('click', closePriceModal);
    if (confirmPriceBtn) confirmPriceBtn.addEventListener('click', closePriceModal);

    // 배경 클릭 닫기
    priceInfoModal.addEventListener('click', (e) => {
      if (e.target === priceInfoModal) closePriceModal();
    });
  }

  // ✅ 이미지 경로 설정 버튼 이벤트
  const browseImagePathBtn = document.getElementById('browse-image-path-btn') as HTMLButtonElement;
  const resetImagePathBtn = document.getElementById('reset-image-path-btn') as HTMLButtonElement;
  const customImageSavePathInput = document.getElementById('custom-image-save-path') as HTMLInputElement;

  // 폴더 선택 버튼
  if (browseImagePathBtn) {
    browseImagePathBtn.addEventListener('click', async () => {
      try {
        if (!window.api.showOpenDialog) {
          alert('폴더 선택 기능을 사용할 수 없습니다.');
          return;
        }

        const result = await window.api.showOpenDialog({
          properties: ['openDirectory', 'createDirectory'],
          title: '이미지 저장 폴더 선택',
          buttonLabel: '선택'
        });

        if (result && !result.canceled && result.filePaths && result.filePaths.length > 0) {
          const selectedPath = result.filePaths[0].replace(/\\/g, '/');
          customImageSavePathInput.value = selectedPath;
          appendLog(`📁 이미지 저장 경로 선택: ${selectedPath}`);
          toastManager.success('폴더가 선택되었습니다!');
        }
      } catch (error) {
        console.error('폴더 선택 오류:', error);
        alert(`폴더 선택 중 오류가 발생했습니다: ${(error as Error).message}`);
      }
    });
  }

  // 기본값으로 재설정 버튼
  if (resetImagePathBtn) {
    resetImagePathBtn.addEventListener('click', async () => {
      customImageSavePathInput.value = '';

      alert('이미지 저장 경로가 초기화되었습니다.\n\n환경설정에서 이미지 저장 폴더를 다시 선택해주세요.');
      appendLog('📁 이미지 저장 경로 초기화 (재설정 필요)');
    });
  }

  const geminiApiKey = document.getElementById('gemini-api-key') as HTMLInputElement;
  const unsplashApiKey = document.getElementById('unsplash-api-key') as HTMLInputElement;
  const pixabayApiKey = document.getElementById('pixabay-api-key') as HTMLInputElement;
  const prodiaTokenInput = document.getElementById('prodia-token') as HTMLInputElement;
  const naverClientId = document.getElementById('naver-client-id') as HTMLInputElement; // ✅ 네이버 API
  const naverClientSecret = document.getElementById('naver-client-secret') as HTMLInputElement; // ✅ 네이버 API
  const dailyPostLimit = document.getElementById('daily-post-limit') as HTMLInputElement;
  const freeQuotaPublish = document.getElementById('free-quota-publish') as HTMLInputElement;
  const freeQuotaContent = document.getElementById('free-quota-content') as HTMLInputElement;
  const freeQuotaMedia = document.getElementById('free-quota-media') as HTMLInputElement;
  const externalApiCostConsent = document.getElementById('external-api-cost-consent') as HTMLInputElement;
  const externalApiPerRunImageLimit = document.getElementById('external-api-per-run-image-limit') as HTMLInputElement;
  const externalApiDailyImageLimit = document.getElementById('external-api-daily-image-limit') as HTMLInputElement;
  const externalApiUsageText = document.getElementById('external-api-usage-text') as HTMLParagraphElement;
  const saveSettingsBtn = document.getElementById('save-settings-btn') as HTMLButtonElement;

  // 설정 로드
  try {
    console.log('[Settings] 설정 로드 시작...');
    const config = await window.api.getConfig();
    console.log('[Settings] 설정 로드 성공:', Object.keys(config || {}).length, '개 항목');

    if (!config) {
      console.warn('[Settings] ⚠️ 설정이 null 또는 undefined입니다.');
      throw new Error('설정을 불러올 수 없습니다 (null/undefined)');
    }

    const isPackaged = await window.api.isPackaged();
    console.log('[Settings] 배포 모드:', isPackaged);

    // 사용자 프로필 필드
    const userDisplayName = document.getElementById('user-display-name') as HTMLInputElement;
    const userEmail = document.getElementById('user-email') as HTMLInputElement;
    const userTimezone = document.getElementById('user-timezone') as HTMLSelectElement;

    // 고급 설정 필드
    const enableDebugMode = document.getElementById('enable-debug-mode') as HTMLInputElement;
    const autoSaveDrafts = document.getElementById('auto-save-drafts') as HTMLInputElement;
    const backupFrequency = document.getElementById('backup-frequency') as HTMLSelectElement;

    // 배포용 vs 개발용 모드 처리
    if (isPackaged) {
      // 배포용: 개발자 전용 기능 숨김
      document.querySelectorAll('.dev-only').forEach(el => {
        (el as HTMLElement).style.display = 'none';
      });
    } else {
      // 개발용: 모든 설정 표시 (개발자 전용 기능 포함)
      document.querySelectorAll('.dev-only').forEach(el => {
        (el as HTMLElement).style.display = 'block';
      });
    }

    // 패키지 환경에서도 API 키를 로드하고 표시 (입력 가능하도록)
    if (geminiApiKey) {
      geminiApiKey.value = config.geminiApiKey || '';
      if (config.geminiApiKey) {
        console.log('[Settings] Gemini API 키 로드됨:', config.geminiApiKey.substring(0, 10) + '...');
      }
    }

    // ✅ Stability AI API 키 로드
    const stabilityApiKeyInput = document.getElementById('stability-api-key') as HTMLInputElement;
    if (stabilityApiKeyInput) {
      stabilityApiKeyInput.value = config.stabilityApiKey || '';
      if (config.stabilityApiKey) {
        console.log('[Settings] Stability AI API 키 로드됨:', config.stabilityApiKey.substring(0, 10) + '...');
      }
    }

    // ✅ Gemini 모델 선택 로드
    const geminiModelSelect = document.getElementById('gemini-model-select') as HTMLSelectElement;
    if (geminiModelSelect) {
      geminiModelSelect.value = config.geminiModel || 'gemini-1.5-flash';
      console.log('[Settings] Gemini 모델 로드됨:', config.geminiModel || 'gemini-1.5-flash (기본)');
    }

    // ✅ Gemini 텍스트 주력 모델 라디오 버튼 로드
    if (config.primaryGeminiTextModel) {
      const modelRadios = document.getElementsByName('primaryGeminiTextModel') as NodeListOf<HTMLInputElement>;
      modelRadios.forEach(radio => {
        if (radio.value === config.primaryGeminiTextModel) {
          radio.checked = true;
        }
      });
      console.log('[Settings] Gemini 텍스트 주력 모델 로드됨:', config.primaryGeminiTextModel);
    }

    // ✅ Gemini 이미지 플랜 라디오 버튼 로드
    const planType = config.geminiPlanType || 'paid'; // 기본값: paid
    const planRadios = document.getElementsByName('geminiPlanType') as NodeListOf<HTMLInputElement>;
    planRadios.forEach(radio => {
      if (radio.value === planType) {
        radio.checked = true;
      }
    });
    console.log('[Settings] Gemini 이미지 플랜 로드됨:', planType);

    try {
      const unifiedGeminiModel = document.getElementById('unified-gemini-model') as HTMLSelectElement | null;
      if (unifiedGeminiModel) {
        unifiedGeminiModel.value = config.geminiModel || 'gemini-1.5-flash';
      }
    } catch {
      // ignore
    }
    if (unsplashApiKey) unsplashApiKey.value = config.unsplashApiKey || '';
    if (pixabayApiKey) pixabayApiKey.value = config.pixabayApiKey || '';
    if (prodiaTokenInput) prodiaTokenInput.value = config.prodiaToken || '';
    if (naverClientId) {
      naverClientId.value = config.naverClientId || config.naverDatalabClientId || '';
      if (config.naverClientId || config.naverDatalabClientId) {
        console.log('[Settings] 네이버 Client ID 로드됨:', (config.naverClientId || config.naverDatalabClientId).substring(0, 10) + '...');
      }
    }
    if (naverClientSecret) {
      naverClientSecret.value = config.naverClientSecret || config.naverDatalabClientSecret || '';
      if (config.naverClientSecret || config.naverDatalabClientSecret) {
        console.log('[Settings] 네이버 Client Secret 로드됨:', (config.naverClientSecret || config.naverDatalabClientSecret).substring(0, 10) + '...');
      }
    }
    // ✅ 네이버 광고 API 키 로드
    const naverAdApiKey = document.getElementById('naver-ad-api-key') as HTMLInputElement;
    const naverAdSecretKey = document.getElementById('naver-ad-secret-key') as HTMLInputElement;
    const naverAdCustomerId = document.getElementById('naver-ad-customer-id') as HTMLInputElement;
    if (naverAdApiKey) {
      naverAdApiKey.value = config.naverAdApiKey || '';
      if (config.naverAdApiKey) {
        console.log('[Settings] 네이버 광고 API Key 로드됨:', config.naverAdApiKey.substring(0, 10) + '...');
      }
    }
    if (naverAdSecretKey) {
      naverAdSecretKey.value = config.naverAdSecretKey || '';
      if (config.naverAdSecretKey) {
        console.log('[Settings] 네이버 광고 Secret Key 로드됨:', config.naverAdSecretKey.substring(0, 10) + '...');
      }
    }
    if (naverAdCustomerId) {
      naverAdCustomerId.value = config.naverAdCustomerId || '';
      if (config.naverAdCustomerId) {
        console.log('[Settings] 네이버 광고 Customer ID 로드됨:', config.naverAdCustomerId);
      }
    }
    if (dailyPostLimit) dailyPostLimit.value = String(config.dailyPostLimit || 3);
    if (freeQuotaPublish) freeQuotaPublish.value = String((config as any).freeQuotaPublish ?? 2);
    if (freeQuotaContent) freeQuotaContent.value = String((config as any).freeQuotaContent ?? 5);
    if (freeQuotaMedia) freeQuotaMedia.value = String((config as any).freeQuotaMedia ?? 30);
    if (customImageSavePathInput) customImageSavePathInput.value = config.customImageSavePath || '';

    try {
      if (externalApiCostConsent) externalApiCostConsent.checked = config.externalApiCostConsent === true;
      if (externalApiPerRunImageLimit) externalApiPerRunImageLimit.value = String((config as any).externalApiPerRunImageLimit ?? 10);
      if (externalApiDailyImageLimit) externalApiDailyImageLimit.value = String((config as any).externalApiDailyImageLimit ?? 30);

      if (externalApiUsageText) {
        const today = (() => {
          const d = new Date();
          const yyyy = d.getFullYear();
          const mm = String(d.getMonth() + 1).padStart(2, '0');
          const dd = String(d.getDate()).padStart(2, '0');
          return `${yyyy}-${mm}-${dd}`;
        })();
        const used = (config as any).externalApiDailyImageDate === today ? Number((config as any).externalApiDailyImageCount ?? 0) : 0;
        const dailyLimit = Number((config as any).externalApiDailyImageLimit ?? 30);
        externalApiUsageText.textContent = `오늘 사용량: ${used} / ${dailyLimit}장`;
      }
    } catch {
      // ignore
    }

    // ✅ [2026-01-16] 이미지 모델 고급 설정 로드
    try {
      const falaiModelSelect = document.getElementById('falai-model-select') as HTMLSelectElement;
      const stabilityModelSelect = document.getElementById('stability-model-select') as HTMLSelectElement;
      const nanoBananaMainModel = document.getElementById('nano-banana-main-model') as HTMLSelectElement;
      const nanoBananaSubModel = document.getElementById('nano-banana-sub-model') as HTMLSelectElement;
      // nanoBananaThumbnailModel 제거됨 (대표 이미지와 통합)
      const pollinationsModelSelect = document.getElementById('pollinations-model-select') as HTMLSelectElement;

      if (falaiModelSelect) falaiModelSelect.value = (config as any).falaiModel || 'flux-realism';
      if (stabilityModelSelect) stabilityModelSelect.value = (config as any).stabilityModel || 'sd35-large-turbo';
      if (nanoBananaMainModel) nanoBananaMainModel.value = (config as any).nanoBananaMainModel || 'gemini-3-pro';
      if (nanoBananaSubModel) nanoBananaSubModel.value = (config as any).nanoBananaSubModel || 'gemini-3-pro';  // ✅ [2026-01-21] 기본값 1K로 변경
      if (pollinationsModelSelect) pollinationsModelSelect.value = (config as any).pollinationsModel || 'default';

      console.log('[Settings] 이미지 모델 고급 설정 로드됨:', {
        falaiModel: (config as any).falaiModel,
        stabilityModel: (config as any).stabilityModel,
        nanoBananaMainModel: (config as any).nanoBananaMainModel,
        nanoBananaSubModel: (config as any).nanoBananaSubModel,
        nanoBananaThumbnailModel: (config as any).nanoBananaThumbnailModel
      });

      // ✅ 비용표 토글 버튼 이벤트
      const togglePriceTableBtn = document.getElementById('toggle-price-table-btn');
      const priceTablePanel = document.getElementById('image-price-table-panel');
      if (togglePriceTableBtn && priceTablePanel) {
        togglePriceTableBtn.onclick = () => {
          const isVisible = priceTablePanel.style.display !== 'none';
          priceTablePanel.style.display = isVisible ? 'none' : 'block';
          togglePriceTableBtn.textContent = isVisible ? '💰 비용표 보기' : '💰 비용표 숨기기';
        };
      }

      const presetBudgetBtn = document.getElementById('preset-budget-btn');
      const imagePresetInput = document.getElementById('image-preset-input') as HTMLInputElement;
      if (presetBudgetBtn) {
        presetBudgetBtn.onclick = () => {
          if (falaiModelSelect) falaiModelSelect.value = 'flux-schnell';
          if (stabilityModelSelect) stabilityModelSelect.value = 'sdxl-1.0';
          if (nanoBananaMainModel) nanoBananaMainModel.value = 'gemini-3-pro';  // ✅ 가성비도 1K 기본
          if (nanoBananaSubModel) nanoBananaSubModel.value = 'gemini-3-pro';
          if (imagePresetInput) imagePresetInput.value = 'budget';
          console.log('[Settings] 💰 가성비 조합 프리셋 적용됨');
          toastManager.success('💰 가성비 조합이 적용되었습니다. 저장 버튼을 눌러주세요!');
        };
      }

      const presetPremiumBtn = document.getElementById('preset-premium-btn');
      if (presetPremiumBtn) {
        presetPremiumBtn.onclick = () => {
          if (falaiModelSelect) falaiModelSelect.value = 'flux-1.1-pro';
          if (stabilityModelSelect) stabilityModelSelect.value = 'stable-image-ultra';
          if (nanoBananaMainModel) nanoBananaMainModel.value = 'gemini-3-pro-4k';
          if (nanoBananaSubModel) nanoBananaSubModel.value = 'gemini-3-pro';
          if (imagePresetInput) imagePresetInput.value = 'premium';
          console.log('[Settings] 🏆 고퀄리티 조합 프리셋 적용됨');
          toastManager.success('🏆 고퀄리티 조합이 적용되었습니다. 저장 버튼을 눌러주세요!');
        };
      }
    } catch (e) {
      console.warn('[Settings] 이미지 모델 고급 설정 로드 중 오류 (무시 가능):', e);
    }

    // ✅ 로드 완료 로그
    console.log('[Settings] 모든 설정 필드 로드 완료');


    // 사용자 프로필 설정 (개발 모드에서만 표시)
    if (!isPackaged) {
      if (userDisplayName) userDisplayName.value = config.userDisplayName || '';
      if (userEmail) userEmail.value = config.userEmail || '';
      if (userTimezone) userTimezone.value = config.userTimezone || 'Asia/Seoul';

      // 고급 설정
      if (enableDebugMode) enableDebugMode.checked = config.enableDebugMode || false;
      if (autoSaveDrafts) autoSaveDrafts.checked = config.autoSaveDrafts || false;
      if (backupFrequency) backupFrequency.value = config.backupFrequency || 'never';
    }
  } catch (error) {
    console.error('[Settings] ❌ 설정 로드 실패:', error);
    console.error('[Settings] 오류 상세:', {
      message: (error as Error).message,
      stack: (error as Error).stack,
      name: (error as Error).name
    });

    // 사용자에게 알림
    const errorMessage = (error as Error).message || '알 수 없는 오류';
    alert(`⚠️ 환경설정을 불러올 수 없습니다.\n\n오류: ${errorMessage}\n\n콘솔을 확인해주세요.`);

    // 기본값으로 설정 필드 초기화
    if (geminiApiKey) geminiApiKey.value = '';
    if (dailyPostLimit) dailyPostLimit.value = '3';
    if (freeQuotaPublish) freeQuotaPublish.value = '2';
    if (freeQuotaContent) freeQuotaContent.value = '5';
    if (freeQuotaMedia) freeQuotaMedia.value = '30';
  }

  // 설정 저장 (중복 등록 방지)
  if (saveSettingsBtn && !saveSettingsBtn.hasAttribute('data-listener-added')) {
    saveSettingsBtn.setAttribute('data-listener-added', 'true');
    saveSettingsBtn.addEventListener('click', async () => {
      try {
        const isPackaged = await window.api.isPackaged();

        // 사용자 프로필 필드
        const userDisplayName = document.getElementById('user-display-name') as HTMLInputElement;
        const userEmail = document.getElementById('user-email') as HTMLInputElement;
        const userTimezone = document.getElementById('user-timezone') as HTMLSelectElement;

        // 고급 설정 필드
        const enableDebugMode = document.getElementById('enable-debug-mode') as HTMLInputElement;
        const autoSaveDrafts = document.getElementById('auto-save-drafts') as HTMLInputElement;
        const backupFrequency = document.getElementById('backup-frequency') as HTMLSelectElement;

        // 패키지 환경에서도 모든 설정을 저장할 수 있도록 수정
        const customImageSavePathInput = document.getElementById('custom-image-save-path') as HTMLInputElement;

        // ✅ 저장 시점에 다시 요소 찾기 (스코프 문제 해결)
        const naverClientIdInput = document.getElementById('naver-client-id') as HTMLInputElement;
        const naverClientSecretInput = document.getElementById('naver-client-secret') as HTMLInputElement;
        // ✅ 네이버 광고 API 키 필드
        const naverAdApiKeyInput = document.getElementById('naver-ad-api-key') as HTMLInputElement;
        const naverAdSecretKeyInput = document.getElementById('naver-ad-secret-key') as HTMLInputElement;
        const naverAdCustomerIdInput = document.getElementById('naver-ad-customer-id') as HTMLInputElement;

        // 디버깅 로그
        console.log('[Settings] 네이버 Client ID 입력값:', naverClientIdInput?.value?.substring(0, 10) + '...');
        console.log('[Settings] 네이버 Client Secret 입력값:', naverClientSecretInput?.value ? '***' : '없음');
        console.log('[Settings] 네이버 광고 API Key 입력값:', naverAdApiKeyInput?.value?.substring(0, 10) + '...');

        // ✅ 이미지 생성 필드
        const prodiaTokenInput = document.getElementById('prodia-token') as HTMLInputElement;
        const stabilityApiKeyInput = document.getElementById('stability-api-key') as HTMLInputElement;

        let config: any = {
          dailyPostLimit: parseInt(dailyPostLimit?.value || '3'),
          freeQuotaPublish: parseInt(freeQuotaPublish?.value || '2'),
          freeQuotaContent: parseInt(freeQuotaContent?.value || '5'),
          freeQuotaMedia: parseInt(freeQuotaMedia?.value || '30'),
          geminiApiKey: geminiApiKey?.value.trim() || undefined,
          unsplashApiKey: unsplashApiKey?.value.trim() || undefined,
          pixabayApiKey: pixabayApiKey?.value.trim() || undefined,
          prodiaToken: prodiaTokenInput?.value.trim() || undefined,
          naverClientId: naverClientIdInput?.value.trim() || undefined, // ✅ 네이버 검색 API 호환용
          naverClientSecret: naverClientSecretInput?.value.trim() || undefined, // ✅ 네이버 검색 API 호환용
          naverDatalabClientId: naverClientIdInput?.value.trim() || undefined, // ✅ 네이버 검색 API
          naverDatalabClientSecret: naverClientSecretInput?.value.trim() || undefined, // ✅ 네이버 검색 API
          naverAdApiKey: naverAdApiKeyInput?.value.trim() || undefined, // ✅ 네이버 광고 API
          naverAdSecretKey: naverAdSecretKeyInput?.value.trim() || undefined, // ✅ 네이버 광고 API
          naverAdCustomerId: naverAdCustomerIdInput?.value.trim() || undefined, // ✅ 네이버 광고 API
          stabilityApiKey: stabilityApiKeyInput?.value.trim() || undefined, // ✅ Stability AI API
          falaiApiKey: (document.getElementById('falai-api-key') as HTMLInputElement)?.value.trim() || undefined, // ✅ Fal.ai API
          customImageSavePath: customImageSavePathInput?.value.trim() || undefined,
          primaryGeminiTextModel: (document.querySelector('input[name="primaryGeminiTextModel"]:checked') as HTMLInputElement)?.value || 'gemini-3-pro-preview', // ✅ Gemini 텍스트 주력 모델
          geminiPlanType: (document.querySelector('input[name="geminiPlanType"]:checked') as HTMLInputElement)?.value as 'free' | 'paid' || 'paid', // ✅ Gemini 이미지 플랜
          // ✅ [2026-01-16] 이미지 생성 모델 고급 설정
          falaiModel: (document.getElementById('falai-model-select') as HTMLSelectElement)?.value || 'flux-realism',
          stabilityModel: (document.getElementById('stability-model-select') as HTMLSelectElement)?.value || 'sd35-large-turbo',
          nanoBananaMainModel: (document.getElementById('nano-banana-main-model') as HTMLSelectElement)?.value || 'gemini-3-pro',
          nanoBananaSubModel: (document.getElementById('nano-banana-sub-model') as HTMLSelectElement)?.value || 'gemini-2.5-flash',
          // nanoBananaThumbnailModel 제거됨 (대표 이미지와 통합)
          pollinationsModel: (document.getElementById('pollinations-model-select') as HTMLSelectElement)?.value || 'default',
          imagePreset: (document.getElementById('image-preset-input') as HTMLInputElement)?.value as 'budget' | 'premium' | 'custom' || 'custom',
        };


        try {
          if (externalApiCostConsent) {
            const consent = externalApiCostConsent.checked === true;
            config.externalApiCostConsent = consent;
            if (consent) {
              config.externalApiCostConsentAt = new Date().toISOString();
            }
          }
          if (externalApiPerRunImageLimit) {
            const v = Math.max(1, Math.floor(Number(externalApiPerRunImageLimit.value || 10)));
            config.externalApiPerRunImageLimit = v;
          }
          if (externalApiDailyImageLimit) {
            const v = Math.max(1, Math.floor(Number(externalApiDailyImageLimit.value || 30)));
            config.externalApiDailyImageLimit = v;
          }
        } catch {
          // ignore
        }

        // 디버깅: 최종 config 확인
        console.log('[Settings] 저장할 config 네이버 키:', {
          naverDatalabClientId: config.naverDatalabClientId?.substring(0, 10) + '...',
          naverDatalabClientSecret: config.naverDatalabClientSecret ? '***' : '없음'
        });

        // 개발 모드에서만 사용자 프로필 및 고급 설정 저장
        if (!isPackaged) {
          config = {
            ...config,
            userDisplayName: userDisplayName?.value.trim() || undefined,
            userEmail: userEmail?.value.trim() || undefined,
            userTimezone: userTimezone?.value || 'Asia/Seoul',
            enableDebugMode: enableDebugMode?.checked || false,
            autoSaveDrafts: autoSaveDrafts?.checked || false,
            backupFrequency: backupFrequency?.value || 'never',
          };
        }

        const saveResult = await apiClient.call('saveConfig', [config], {
          retryCount: 2,
          timeout: 10000
        });

        if (saveResult.success) {
          // ✅ 저장 성공 로그
          console.log('[Settings] 설정 저장 완료:', Object.keys(config).length, '개 항목');

          // API 키 저장 확인 로그
          if (config.geminiApiKey) {
            appendLog(`✅ Gemini API 키 저장됨 (길이: ${config.geminiApiKey.length}자, 형식: 올바름)`);
          }

          appendLog('⚙️ 설정이 저장되었습니다.');
          toastManager.success('✅ 설정이 저장되었습니다. 앱을 껐다 켜도 유지됩니다!');

          try {
            const unifiedGeminiModel = document.getElementById('unified-gemini-model') as HTMLSelectElement | null;
            if (unifiedGeminiModel) {
              unifiedGeminiModel.value = config.geminiModel || 'gemini-2.5-flash';
            }
          } catch {
            // ignore
          }
        } else {
          toastManager.error(`❌ 설정 저장 실패: ${saveResult.error}`);
          return;
        }
        const settingsModal = document.getElementById('settings-modal') as HTMLDivElement;
        if (settingsModal) {
          settingsModal.setAttribute('aria-hidden', 'true');
          settingsModal.style.display = 'none';
        }
      } catch (error) {
        alert(`❌ 설정 저장 실패: ${(error as Error).message}`);
      }
    });
  }

  // ✅ 다계정 관리 기능 초기화
  await initMultiAccountManager();

  // ✅ 환경설정에서 다계정 관리 버튼 클릭
  const openMultiAccountFromSettings = document.getElementById('open-multi-account-from-settings');
  if (openMultiAccountFromSettings) {
    openMultiAccountFromSettings.addEventListener('click', () => {
      // 환경설정 모달 닫기
      const settingsModal = document.getElementById('settings-modal') as HTMLDivElement;
      if (settingsModal) {
        settingsModal.style.display = 'none';
      }
      // 다계정 관리 모달 열기
      const multiAccountBtn = document.getElementById('multi-account-btn');
      multiAccountBtn?.click();
    });
  }

  // ✅ 환경설정에서 가이드/분석 버튼 클릭
  const openGuideFromSettings = document.getElementById('open-guide-from-settings');
  if (openGuideFromSettings) {
    openGuideFromSettings.addEventListener('click', () => {
      // 환경설정 모달 닫기
      const settingsModal = document.getElementById('settings-modal') as HTMLDivElement;
      if (settingsModal) {
        settingsModal.style.display = 'none';
      }
      // 가이드/분석 모달 열기
      const toolsHubModal = document.getElementById('tools-hub-modal');
      if (toolsHubModal) {
        toolsHubModal.style.display = 'flex';
      }
    });
  }

  // 라이선스 코드 테스트
  const testLicenseCodeBtn = document.getElementById('test-license-code-btn') as HTMLButtonElement;
  const testLicenseCodeInput = document.getElementById('test-license-code') as HTMLInputElement;
  if (testLicenseCodeBtn && testLicenseCodeInput) {
    testLicenseCodeBtn.addEventListener('click', async () => {
      const code = testLicenseCodeInput.value.trim();
      if (!code) {
        alert('테스트할 라이선스 코드를 입력해주세요.');
        return;
      }
      await testLicenseCode(code);
    });
  }

  // 외부 유입 라이선스 등록
  const registerExternalInflowBtn = document.getElementById('register-external-inflow-btn') as HTMLButtonElement;
  if (registerExternalInflowBtn) {
    registerExternalInflowBtn.addEventListener('click', async () => {
      if (confirm('외부 유입 90일 라이선스를 등록하시겠습니까?\n\n등록 후 90일 동안 외부 유입 기능을 사용할 수 있습니다.')) {
        try {
          registerExternalInflowBtn.disabled = true;
          registerExternalInflowBtn.textContent = '등록 중...';

          const result = await window.api.registerExternalInflowLicense();

          if (result.success) {
            // 만료일 정확한 표시
            const expiresAt = result.expiresAt ? new Date(result.expiresAt) : null;
            const formattedDate = expiresAt ?
              `${expiresAt.getFullYear()}년 ${expiresAt.getMonth() + 1}월 ${expiresAt.getDate()}일` :
              '알 수 없음';

            alert(`✅ ${result.message}\n\n만료일: ${formattedDate}`);
            toastManager.success('외부 유입 라이선스가 등록되었습니다!');
          } else {
            alert(`❌ ${result.message}`);
          }
        } catch (error) {
          console.error('외부 유입 라이선스 등록 오류:', error);
          alert(`❌ 라이선스 등록 중 오류가 발생했습니다: ${(error as Error).message}`);
        } finally {
          registerExternalInflowBtn.disabled = false;
          registerExternalInflowBtn.textContent = '🎯 외부 유입 90일 라이선스 등록';
        }
      }
    });
  }

  // ✅ 네트워크 진단 버튼 이벤트 리스너
  const networkDiagnosticsBtn = document.getElementById('network-diagnostics-btn') as HTMLButtonElement;
  if (networkDiagnosticsBtn && !networkDiagnosticsBtn.hasAttribute('data-listener-added')) {
    networkDiagnosticsBtn.setAttribute('data-listener-added', 'true');
    networkDiagnosticsBtn.addEventListener('click', async () => {
      networkDiagnosticsBtn.disabled = true;
      networkDiagnosticsBtn.textContent = '🔄 진단 중...';

      let diagnosticResults: string[] = [];
      diagnosticResults.push('===== 네트워크 진단 결과 =====\n');

      try {
        // 1. 라이선스 서버 연결 테스트
        diagnosticResults.push('📡 라이선스 서버 연결 테스트...');
        try {
          const licenseResult = await window.api.testLicenseServer();
          if (licenseResult.success) {
            diagnosticResults.push(`✅ 라이선스 서버: 연결 성공`);
          } else {
            diagnosticResults.push(`❌ 라이선스 서버: ${licenseResult.message}`);
          }
        } catch (e) {
          diagnosticResults.push(`❌ 라이선스 서버: 연결 실패 - ${(e as Error).message}`);
        }

        // 2. OpenAI API 연결 테스트
        diagnosticResults.push('\n📡 OpenAI API 연결 테스트...');
        try {
          const openaiResponse = await fetch('https://api.openai.com/v1/models', {
            method: 'GET',
            headers: { 'Authorization': 'Bearer test' },
            signal: AbortSignal.timeout(10000)
          });
          diagnosticResults.push(`✅ OpenAI API: 도달 가능 (상태: ${openaiResponse.status})`);
        } catch (e) {
          const errMsg = (e as Error).message;
          if (errMsg.includes('timeout') || errMsg.includes('Timeout')) {
            diagnosticResults.push(`⚠️ OpenAI API: 응답 지연 (10초 초과)`);
          } else {
            diagnosticResults.push(`❌ OpenAI API: ${errMsg}`);
          }
        }

        // 3. Google/Gemini API 연결 테스트
        diagnosticResults.push('\n📡 Google API (Gemini) 연결 테스트...');
        try {
          const googleResponse = await fetch('https://generativelanguage.googleapis.com/', {
            method: 'GET',
            signal: AbortSignal.timeout(10000)
          });
          diagnosticResults.push(`✅ Google API: 도달 가능 (상태: ${googleResponse.status})`);
        } catch (e) {
          const errMsg = (e as Error).message;
          if (errMsg.includes('timeout') || errMsg.includes('Timeout')) {
            diagnosticResults.push(`⚠️ Google API: 응답 지연 (10초 초과)`);
          } else {
            diagnosticResults.push(`❌ Google API: ${errMsg}`);
          }
        }

        // 4. Anthropic (Claude) API 연결 테스트
        diagnosticResults.push('\n📡 Anthropic (Claude) API 연결 테스트...');
        try {
          const anthropicResponse = await fetch('https://api.anthropic.com/', {
            method: 'GET',
            signal: AbortSignal.timeout(10000)
          });
          diagnosticResults.push(`✅ Anthropic API: 도달 가능 (상태: ${anthropicResponse.status})`);
        } catch (e) {
          const errMsg = (e as Error).message;
          if (errMsg.includes('timeout') || errMsg.includes('Timeout')) {
            diagnosticResults.push(`⚠️ Anthropic API: 응답 지연 (10초 초과)`);
          } else {
            diagnosticResults.push(`❌ Anthropic API: ${errMsg}`);
          }
        }

        // 5. 네이버 API 연결 테스트
        diagnosticResults.push('\n📡 네이버 API 연결 테스트...');
        try {
          const naverResponse = await fetch('https://openapi.naver.com/', {
            method: 'GET',
            signal: AbortSignal.timeout(10000)
          });
          diagnosticResults.push(`✅ 네이버 API: 도달 가능 (상태: ${naverResponse.status})`);
        } catch (e) {
          const errMsg = (e as Error).message;
          if (errMsg.includes('timeout') || errMsg.includes('Timeout')) {
            diagnosticResults.push(`⚠️ 네이버 API: 응답 지연 (10초 초과)`);
          } else {
            diagnosticResults.push(`❌ 네이버 API: ${errMsg}`);
          }
        }

        // 6. API 키 설정 상태 확인
        diagnosticResults.push('\n🔑 API 키 설정 상태...');
        try {
          const config = await window.api.getConfig();
          const geminiKey = config.geminiApiKey?.trim();
          const openaiKey = config.openaiApiKey?.trim();
          const claudeKey = config.claudeApiKey?.trim();

          if (geminiKey && geminiKey.length > 10) {
            diagnosticResults.push(`✅ Gemini API 키: 설정됨 (${geminiKey.length}자)`);
          } else {
            diagnosticResults.push(`❌ Gemini API 키: 미설정 ← 반드시 설정 필요!`);
          }

          if (openaiKey && openaiKey.length > 10) {
            diagnosticResults.push(`✅ OpenAI API 키: 설정됨 (${openaiKey.length}자)`);
          } else {
            diagnosticResults.push(`⚠️ OpenAI API 키: 미설정`);
          }

          if (claudeKey && claudeKey.length > 10) {
            diagnosticResults.push(`✅ Claude API 키: 설정됨 (${claudeKey.length}자)`);
          } else {
            diagnosticResults.push(`⚠️ Claude API 키: 미설정`);
          }
        } catch (e) {
          diagnosticResults.push(`❌ 설정 로드 실패: ${(e as Error).message}`);
        }

        // 문제 자동 진단 및 해결책 제시
        diagnosticResults.push('\n===== 📋 진단 결과 및 해결 방법 =====\n');

        const hasApiKeyIssue = diagnosticResults.some(r => r.includes('Gemini API 키: 미설정'));
        const hasNetworkIssue = diagnosticResults.some(r => r.includes('❌') && !r.includes('API 키'));
        const hasSlowNetwork = diagnosticResults.some(r => r.includes('응답 지연'));

        if (hasApiKeyIssue) {
          diagnosticResults.push('🚨 문제: Gemini API 키가 설정되지 않았습니다!');
          diagnosticResults.push('');
          diagnosticResults.push('📌 해결 방법:');
          diagnosticResults.push('1. Google AI Studio 접속: https://aistudio.google.com');
          diagnosticResults.push('2. "Get API Key" 클릭 → API 키 생성');
          diagnosticResults.push('3. 환경설정(⚙️) → Gemini API 키에 붙여넣기');
          diagnosticResults.push('4. 저장 버튼 클릭');
          diagnosticResults.push('5. 앱 재시작 또는 다시 시도');
        } else if (hasNetworkIssue) {
          diagnosticResults.push('🚨 문제: 네트워크 연결에 문제가 있습니다!');
          diagnosticResults.push('');
          diagnosticResults.push('📌 해결 방법:');
          diagnosticResults.push('1. 인터넷 연결 확인');
          diagnosticResults.push('2. VPN 사용 중이면 끄기');
          diagnosticResults.push('3. 방화벽에서 앱 허용');
          diagnosticResults.push('4. 회사/학교 네트워크면 다른 네트워크 사용');
        } else if (hasSlowNetwork) {
          diagnosticResults.push('⚠️ 주의: 네트워크가 느립니다!');
          diagnosticResults.push('');
          diagnosticResults.push('📌 해결 방법:');
          diagnosticResults.push('1. WiFi 신호 확인 (라우터 가까이)');
          diagnosticResults.push('2. 다른 프로그램의 인터넷 사용 줄이기');
          diagnosticResults.push('3. 유선 연결 권장');
          diagnosticResults.push('4. 잠시 후 다시 시도');
        } else {
          diagnosticResults.push('✅ 모든 연결이 정상입니다!');
          diagnosticResults.push('');
          diagnosticResults.push('💡 그래도 안 되면:');
          diagnosticResults.push('1. 앱 완전히 종료 후 재시작');
          diagnosticResults.push('2. 환경설정에서 API 키 다시 저장');
          diagnosticResults.push('3. 컴퓨터 재부팅');
        }

        alert(diagnosticResults.join('\n'));
        appendLog('🔍 네트워크 진단 완료 - 결과를 확인해주세요');

      } catch (error) {
        alert(`네트워크 진단 중 오류가 발생했습니다:\n${(error as Error).message}`);
      } finally {
        networkDiagnosticsBtn.disabled = false;
        networkDiagnosticsBtn.textContent = '🔍 네트워크 진단 실행';
      }
    });
  }

  // ✅ 원클릭 네트워크 최적화 버튼 이벤트 리스너
  const networkOptimizeBtn = document.getElementById('network-optimize-btn') as HTMLButtonElement;
  if (networkOptimizeBtn && !networkOptimizeBtn.hasAttribute('data-listener-added')) {
    networkOptimizeBtn.setAttribute('data-listener-added', 'true');
    networkOptimizeBtn.addEventListener('click', async () => {
      // 경고 메시지 표시
      const confirmed = confirm(
        '⚡ 원클릭 네트워크 최적화\n\n' +
        '다음 작업을 수행합니다:\n' +
        '• DNS 캐시 갱신 (관리자 권한 필요)\n' +
        '• API 서버 연결 테스트\n' +
        '• 최적 연결 상태 확인\n\n' +
        '계속하시겠습니까?'
      );

      if (!confirmed) return;

      networkOptimizeBtn.disabled = true;
      networkOptimizeBtn.textContent = '⚡ 최적화 중...';
      appendLog('🔄 네트워크 최적화 시작...');

      try {
        const result = await window.api.networkOptimize();

        // 결과 표시
        alert(result.results.join('\n'));

        if (result.success) {
          appendLog('✅ 네트워크 최적화 완료!');
          toastManager.success('네트워크 최적화가 완료되었습니다!');
        } else {
          appendLog('⚠️ 네트워크 최적화 완료 (일부 문제 발견)');
          toastManager.warning('네트워크에 일부 문제가 있습니다. 결과를 확인하세요.');
        }

      } catch (error) {
        alert(`네트워크 최적화 중 오류가 발생했습니다:\n${(error as Error).message}`);
        appendLog(`❌ 네트워크 최적화 실패: ${(error as Error).message}`);
      } finally {
        networkOptimizeBtn.disabled = false;
        networkOptimizeBtn.textContent = '⚡ 원클릭 네트워크 최적화';
      }
    });
  }
}

// ============================================
// 아이디/비밀번호 저장 기능
// ============================================
async function initCredentialsSave(): Promise<void> {
  // DOM 요소가 로드될 때까지 잠시 대기
  await new Promise(resolve => setTimeout(resolve, 200));

  // 통합 탭의 네이버 계정 필드 사용
  const rememberCheckbox = document.getElementById('remember-credentials') as HTMLInputElement;
  const naverIdInput = document.getElementById('naver-id') as HTMLInputElement;
  const naverPasswordInput = document.getElementById('naver-password') as HTMLInputElement;

  if (!rememberCheckbox || !naverIdInput || !naverPasswordInput) {
    console.error('[자격증명] 필수 DOM 요소를 찾을 수 없습니다.');
    return;
  }

  // 저장된 자격증명 로드
  try {
    const config = await window.api.getConfig();
    console.log('[자격증명] 설정 로드됨:', {
      savedNaverId: config.savedNaverId ? '있음' : '없음',
      savedNaverPassword: config.savedNaverPassword ? '있음' : '없음',
      rememberCredentials: config.rememberCredentials
    });

    // ✅ 저장된 값이 있으면 무조건 로드 (rememberCredentials 체크 여부와 관계없이)
    if (config.savedNaverId || config.savedNaverPassword) {
      // 체크박스 자동 체크
      rememberCheckbox.checked = true;

      // 저장된 값 표시
      if (config.savedNaverId) {
        naverIdInput.value = config.savedNaverId;
        console.log('[자격증명] 네이버 아이디 자동 입력:', config.savedNaverId.substring(0, 3) + '***');
      }

      if (config.savedNaverPassword) {
        naverPasswordInput.value = config.savedNaverPassword;
        console.log('[자격증명] 네이버 비밀번호 자동 입력: ***');
      }
    } else {
      console.log('[자격증명] 저장된 네이버 계정 정보가 없습니다.');
    }
  } catch (error) {
    console.error('[자격증명] 로드 실패:', error);
  }

  // 저장 체크박스 변경 시 자동 저장
  if (rememberCheckbox) {
    rememberCheckbox.addEventListener('change', async () => {
      try {
        const config = await window.api.getConfig();

        if (rememberCheckbox.checked) {
          // ✅ 체크 시: 현재 입력된 값 저장
          const updatedConfig: AppConfig = {
            ...config,
            rememberCredentials: true,
            savedNaverId: naverIdInput?.value.trim() || config.savedNaverId,
            savedNaverPassword: naverPasswordInput?.value.trim() || config.savedNaverPassword,
          };
          await window.api.saveConfig(updatedConfig);
          toastManager.success('✅ 네이버 계정 정보가 저장되었습니다.');
        } else {
          // ✅ 체크 해제 시: 저장된 값 삭제
          const updatedConfig: AppConfig = {
            ...config,
            rememberCredentials: false,
            savedNaverId: undefined,
            savedNaverPassword: undefined,
          };
          await window.api.saveConfig(updatedConfig);
          // 입력 필드도 초기화
          if (naverIdInput) naverIdInput.value = '';
          if (naverPasswordInput) naverPasswordInput.value = '';
          toastManager.info('네이버 계정 정보 저장이 해제되었습니다.');
        }
      } catch (error) {
        console.error('[자격증명] 저장 실패:', error);
        toastManager.error('계정 정보 저장에 실패했습니다.');
      }
    });
  }

  // 아이디/비밀번호 입력 시 자동 저장 (체크박스가 체크되어 있을 때만)
  if (naverIdInput) {
    let saveTimeout: NodeJS.Timeout | null = null;
    naverIdInput.addEventListener('input', () => {
      if (rememberCheckbox?.checked) {
        if (saveTimeout) clearTimeout(saveTimeout);
        saveTimeout = setTimeout(async () => {
          try {
            const config = await window.api.getConfig();
            const updatedConfig: AppConfig = {
              ...config,
              savedNaverId: naverIdInput.value.trim() || undefined,
            };
            await window.api.saveConfig(updatedConfig);
            console.log('[자격증명] 아이디 자동 저장 완료');
          } catch (error) {
            console.error('아이디 저장 실패:', error);
          }
        }, 500);
      }
    });
  }

  if (naverPasswordInput) {
    let saveTimeout: NodeJS.Timeout | null = null;
    naverPasswordInput.addEventListener('input', () => {
      if (rememberCheckbox?.checked) {
        if (saveTimeout) clearTimeout(saveTimeout);
        saveTimeout = setTimeout(async () => {
          try {
            const config = await window.api.getConfig();
            const updatedConfig: AppConfig = {
              ...config,
              savedNaverPassword: naverPasswordInput.value.trim() || undefined,
            };
            await window.api.saveConfig(updatedConfig);
            console.log('[자격증명] 비밀번호 자동 저장 완료');
          } catch (error) {
            console.error('비밀번호 저장 실패:', error);
          }
        }, 500);
      }
    });
  }
}

// ============================================
// AI 자동 제목 생성 기능
// ============================================
function initTitleGeneration(): void {
  const generateTitleBtn = document.getElementById('generate-title-btn') as HTMLButtonElement;
  const titleInput = document.getElementById('post-title') as HTMLInputElement;
  const contentTextarea = document.getElementById('post-content') as HTMLTextAreaElement;
  const urlFields = document.querySelectorAll('.url-field-input') as NodeListOf<HTMLInputElement>;

  // 수동 제목으로 글생성하기 버튼
  const generateFromManualTitleBtn = document.getElementById('generate-from-manual-title-btn') as HTMLButtonElement;
  if (generateFromManualTitleBtn) {
    generateFromManualTitleBtn.addEventListener('click', async () => {
      if (!generateFromManualTitleBtn) return;

      generateFromManualTitleBtn.disabled = true;
      generateFromManualTitleBtn.textContent = '글 생성 중...';

      // ✅ 새 글 생성 전 이전 콘텐츠 자동 초기화 (제목 버그 방지)
      if (currentStructuredContent) {
        console.log('[ManualTitle] 이전 콘텐츠를 초기화합니다...');
        currentStructuredContent = null;
        (window as any).currentStructuredContent = null;
        generatedImages = [];
        (window as any).imageManagementGeneratedImages = null;
      }

      appendLog('🤖 수동 제목으로 글 생성을 시작합니다...');

      try {
        // 입력된 정보 수집
        const title = titleInput?.value.trim() || '';
        const urls = Array.from(urlFields)
          .map(field => field.value.trim())
          .filter(url => url.length > 0)
          .join('\n');

        if (!title) {
          alert('글 생성을 위해 제목을 입력해주세요.');
          generateFromManualTitleBtn.disabled = false;
          generateFromManualTitleBtn.textContent = '수동 제목으로 글생성하기';
          return;
        }

        if (!urls) {
          alert('글 생성을 위해 URL을 입력해주세요.');
          generateFromManualTitleBtn.disabled = false;
          generateFromManualTitleBtn.textContent = '수동 제목으로 글생성하기';
          return;
        }

        // 구조화 콘텐츠 생성 (수동 제목 기반)
        const targetAgeSelect = document.getElementById('target-age') as HTMLSelectElement;
        const targetAge = (targetAgeSelect?.value as '20s' | '30s' | '40s' | '50s' | 'all') || 'all';

        const apiClient = EnhancedApiClient.getInstance();
        const apiResponse = await apiClient.call(
          'generateStructuredContent',
          [{
            assembly: {
              rssUrl: urls,
              baseText: title, // 수동 제목을 baseText로 사용
              targetAge: targetAge,
              generator: 'gemini',
              minChars: 2500,
            }
          }],
          {
            retryCount: 3,
            retryDelay: 2000,
            timeout: 600000
          }
        );

        const result = apiResponse.data || { success: false, message: apiResponse.error };

        if (isPaywallPayload(result)) {
          activatePaywall(result);
          return;
        }

        if (result.success && result.content) {
          const structuredContent = result.content as StructuredContent & { content?: string };

          // 필드 채우기 (타이밍 보장)
          setTimeout(async () => {
            // 제목 필드는 이미 입력되어 있으므로 유지
            // 본문 필드에 입력
            if (contentTextarea && structuredContent.bodyPlain) {
              const normalized = normalizeReadableBodyText(structuredContent.bodyPlain);
              structuredContent.bodyPlain = normalized;
              structuredContent.content = normalized;
              contentTextarea.value = normalized;
            }

            // 해시태그 필드에 입력
            const tagsInput = document.getElementById('post-tags') as HTMLInputElement;
            if (tagsInput && structuredContent.hashtags) {
              tagsInput.value = structuredContent.hashtags.join(' ');
            }

            // 소제목 정보 저장 (이미지 생성에 사용)
            (window as any).currentStructuredContent = structuredContent;

            // 소제목 표시 (반자동 발행 탭)
            displayStructuredContentPreview(structuredContent);

            // 풀오토 탭에도 소제목 표시
            updateFullAutoHeadingsPreview(structuredContent);

            // 모든 탭의 제목 필드에 설정 (이미 입력된 제목을 다른 탭에도 복사)
            setTitleInAllTabs(title);

            // 성공 알림 및 로그
            appendLog('✅ 수동 제목으로 글 생성이 완료되었습니다!');
            appendLog(`📝 제목: "${title}" (수동 입력)`);
            appendLog(`📄 본문: ${structuredContent.bodyPlain.length}자`);
            appendLog(`🏷️ 해시태그: ${structuredContent.hashtags?.join(', ') || '없음'}`);
            appendLog(`📑 소제목: ${structuredContent.headings?.length || 0}개`);

            // 필드가 채워진 후 알림 표시
            alert('✅ 수동 제목으로 글 생성이 완료되었습니다!\n\n본문과 해시태그가 자동으로 입력되었습니다.');

            // 이미지 자동 생성 및 발행 (옵션)
            const autoPublishCheckbox = document.getElementById('auto-publish-after-generate') as HTMLInputElement;
            if (autoPublishCheckbox?.checked) {
              setTimeout(() => {
                autoGenerateImagesAndPublish(structuredContent);
              }, 1000);
            }
          }, 500); // 필드 채우기 대기 시간 추가

        } else {
          appendLog(`❌ 글 생성 실패: ${result.message || '알 수 없는 오류'}`);
          alert(`❌ 글 생성 실패: ${result.message || '알 수 없는 오류'}`);
        }
      } catch (error) {
        appendLog(`❌ 글 생성 오류: ${(error as Error).message}`);
        alert(`❌ 오류: ${(error as Error).message}`);
      } finally {
        generateFromManualTitleBtn.disabled = false;
        generateFromManualTitleBtn.textContent = '수동 제목으로 글생성하기';
      }
    });
  }

  // AI 자동 글 생성하기 버튼
  if (generateTitleBtn) {
    generateTitleBtn.addEventListener('click', async () => {
      if (!generateTitleBtn) return;

      generateTitleBtn.disabled = true;
      generateTitleBtn.textContent = '글 생성 중...';

      // ✅ 새 글 생성 전 이전 콘텐츠 자동 초기화 (제목 버그 방지)
      if (currentStructuredContent) {
        console.log('[AIGenerate] 이전 콘텐츠를 초기화합니다...');
        currentStructuredContent = null;
        (window as any).currentStructuredContent = null;
        generatedImages = [];
        (window as any).imageManagementGeneratedImages = null;
      }

      appendLog('🤖 AI 글 생성을 시작합니다...');

      try {
        // 입력된 정보 수집
        const urls = Array.from(urlFields)
          .map(field => field.value.trim())
          .filter(url => url.length > 0)
          .join('\n');

        if (!urls) {
          alert('글 생성을 위해 URL을 입력해주세요.');
          generateTitleBtn.disabled = false;
          generateTitleBtn.textContent = 'AI 자동 글 생성하기';
          return;
        }

        // 구조화 콘텐츠 생성 (전체 콘텐츠)
        const targetAgeSelect = document.getElementById('target-age') as HTMLSelectElement;
        const targetAge = (targetAgeSelect?.value as '20s' | '30s' | '40s' | '50s' | 'all') || 'all';

        const apiClient = EnhancedApiClient.getInstance();
        const apiResponse = await apiClient.call(
          'generateStructuredContent',
          [{
            assembly: {
              rssUrl: urls,
              targetAge: targetAge,
              generator: 'gemini',
              minChars: 2500,
            }
          }],
          {
            retryCount: 3,
            retryDelay: 2000,
            timeout: 600000
          }
        );

        const result = apiResponse.data || { success: false, message: apiResponse.error };

        if (isPaywallPayload(result)) {
          activatePaywall(result);
          return;
        }

        if (result.success && result.content) {
          const structuredContent = result.content as StructuredContent & { content?: string };

          // 제목 필드에 입력
          if (titleInput && structuredContent.selectedTitle) {
            titleInput.value = structuredContent.selectedTitle;
          }

          // 본문 필드에 입력
          if (contentTextarea && structuredContent.bodyPlain) {
            const normalized = normalizeReadableBodyText(structuredContent.bodyPlain);
            structuredContent.bodyPlain = normalized;
            structuredContent.content = normalized;
            contentTextarea.value = normalized;
          }

          // 해시태그 필드에 입력
          const tagsInput = document.getElementById('post-tags') as HTMLInputElement;
          if (tagsInput && structuredContent.hashtags) {
            tagsInput.value = structuredContent.hashtags.join(' ');
          }

          // 소제목 정보 저장 (이미지 생성에 사용)
          (window as any).currentStructuredContent = structuredContent;

          // 소제목 표시 (반자동 발행 탭)
          displayStructuredContentPreview(structuredContent);

          // 풀오토 탭에도 소제목 표시
          updateFullAutoHeadingsPreview(structuredContent);

          // 성공 알림 및 로그
          appendLog('✅ AI 글 생성이 완료되었습니다!');
          appendLog(`📝 제목: "${structuredContent.selectedTitle}"`);
          appendLog(`📄 본문: ${structuredContent.bodyPlain.length}자`);
          appendLog(`🏷️ 해시태그: ${structuredContent.hashtags?.join(', ') || '없음'}`);
          appendLog(`📑 소제목: ${structuredContent.headings?.length || 0}개`);

          alert('✅ AI 글 생성이 완료되었습니다!\n\n제목, 본문, 해시태그가 자동으로 입력되었습니다.');

          // 이미지 자동 생성 및 발행 (옵션)
          const autoPublishCheckbox = document.getElementById('auto-publish-after-generate') as HTMLInputElement;
          if (autoPublishCheckbox?.checked) {
            setTimeout(() => {
              autoGenerateImagesAndPublish(structuredContent);
            }, 1000);
          }

        } else {
          appendLog(`❌ 글 생성 실패: ${result.message || '알 수 없는 오류'}`);
          alert(`❌ 글 생성 실패: ${result.message || '알 수 없는 오류'}`);
        }
      } catch (error) {
        appendLog(`❌ 글 생성 오류: ${(error as Error).message}`);
        alert(`❌ 오류: ${(error as Error).message}`);
      } finally {
        generateTitleBtn.disabled = false;
        generateTitleBtn.textContent = 'AI 자동 글 생성하기';
      }
    });
  }
}

// ============================================
// 글자수 표시 및 목표 글자수 업데이트 기능
// ============================================
function initCharCountDisplay(): void {
  const contentTextarea = document.getElementById('post-content') as HTMLTextAreaElement;
  const charCountSpan = document.getElementById('content-char-count') as HTMLSpanElement;
  const targetCharCountDisplay = document.getElementById('target-char-count-display') as HTMLSpanElement;
  const targetAgeSelect = document.getElementById('target-age') as HTMLSelectElement;

  // 연령대별 목표 글자수
  const getTargetCharsForAge = (targetAge: string): number => {
    switch (targetAge) {
      case '20s':
        return 3000;
      case '30s':
        return 4250;
      case '40s':
      case '50s':
        return 5500;
      case 'all':
      default:
        return 3000;
    }
  };

  // 글자수 업데이트 함수
  const updateCharCount = (): void => {
    if (!contentTextarea || !charCountSpan) return;

    const text = contentTextarea.value;
    const charCount = text.replace(/\s+/g, '').length;
    charCountSpan.textContent = `${charCount.toLocaleString()}자`;

    // 목표 글자수 표시
    if (targetCharCountDisplay && targetAgeSelect) {
      const targetAge = targetAgeSelect.value;
      const targetRange = targetAge === '20s' ? '2,500~3,500자'
        : targetAge === '30s' ? '3,500~5,000자'
          : targetAge === '40s' || targetAge === '50s' ? '4,500~6,500자'
            : '2,000자 이상';

      targetCharCountDisplay.textContent = `(목표: ${targetRange})`;

      // 목표 달성 여부에 따라 색상 변경
      const targetChars = getTargetCharsForAge(targetAge);
      if (charCount >= targetChars * 0.9) {
        charCountSpan.style.color = 'var(--text-strong)';
      } else if (charCount >= targetChars * 0.7) {
        charCountSpan.style.color = 'var(--text-gold)';
      } else {
        charCountSpan.style.color = 'var(--text-muted)';
      }
    }
  };

  // 본문 입력 시 글자수 업데이트
  if (contentTextarea) {
    contentTextarea.addEventListener('input', updateCharCount);
    contentTextarea.addEventListener('paste', () => {
      setTimeout(updateCharCount, 10);
    });
    updateCharCount();
  }

  // 연령대 변경 시 목표 글자수 업데이트
  if (targetAgeSelect && targetCharCountDisplay) {
    targetAgeSelect.addEventListener('change', updateCharCount);
    updateCharCount();
  }
}

// ============================================
// 풀오토 미리보기 기능
// ============================================

// 풀오토 콘텐츠 미리보기 업데이트
function updateFullAutoPreview(structuredContent: any): void {
  const previewSection = document.getElementById('full-auto-preview-section');
  if (!previewSection) return;

  previewSection.style.display = 'block';

  const contentPreview = document.getElementById('full-auto-content-preview');
  if (contentPreview) {
    const contentText = structuredContent.bodyPlain || structuredContent.content || '';
    const sentences = contentText.split(/([.!?。！？])\s*/).filter((s: string) => s.trim());
    let formattedContent = '';
    let sentenceCount = 0;
    let currentParagraph = '';

    for (let i = 0; i < sentences.length; i++) {
      const sentence = sentences[i].trim();
      if (!sentence) continue;

      currentParagraph += sentence;

      if (/[.!?。！？]/.test(sentence)) {
        sentenceCount++;
        if (sentenceCount % 5 === 0 || i === sentences.length - 1) {
          formattedContent += currentParagraph + '\n\n';
          currentParagraph = '';
        } else {
          currentParagraph += ' ';
        }
      }
    }

    const truncatedContent = formattedContent.length > 500 ? formattedContent.substring(0, 500) + '...' : formattedContent;
    contentPreview.innerHTML = truncatedContent ?
      `<div style="white-space: pre-line; line-height: 1.6;">${truncatedContent.replace(/\n/g, '<br>')}</div>` :
      '<div style="color: var(--text-muted); font-style: italic;">생성된 본문이 없습니다.</div>';
  }

  const integratedPreview = document.getElementById('full-auto-integrated-preview');
  if (integratedPreview) {
    const hs = Array.isArray(structuredContent?.headings) ? structuredContent.headings : [];
    const integratedHtml = hs.map((heading: any, index: number) =>
      `<div style="margin-bottom: 1rem; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px; border: 1px solid var(--border-light);">
        <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.75rem; padding: 0.5rem; background: rgba(59, 130, 246, 0.1); border-radius: 6px;">
          <div style="width: 40px; height: 40px; border-radius: 6px; background: linear-gradient(135deg, var(--primary), var(--secondary)); display: flex; align-items: center; justify-content: center; color: white; font-size: 1rem; font-weight: 600;">${index + 1}</div>
          <div style="flex: 1;">
            <div style="font-size: 0.9rem; color: var(--text-strong); font-weight: 500;">🖼️ 이미지 생성 예정</div>
            <div style="font-size: 0.75rem; color: var(--text-muted);">소제목에 맞는 이미지가 생성됩니다</div>
          </div>
          <div style="font-size: 0.8rem; color: var(--accent); font-weight: 600;">⏳ 준비중</div>
        </div>
        <div style="padding: 0.5rem; background: var(--bg-primary); border-radius: 6px; border-left: 3px solid var(--success);">
          <div style="font-weight: 600; color: var(--text-strong); margin-bottom: 0.5rem;">📝 ${heading.title || '제목 없음'}</div>
          <div style="font-size: 0.9rem; color: var(--text-muted); line-height: 1.4;">${(heading.content || '').substring(0, 150)}${(heading.content || '').length > 150 ? '...' : ''}</div>
        </div>
      </div>`
    ).join('');

    integratedPreview.innerHTML = integratedHtml || '<div style="color: var(--text-muted); font-style: italic;">생성할 이미지가 없습니다.</div>';
  }
}

// 풀오토 최종 이미지 미리보기 업데이트
function updateFullAutoFinalImagePreview(generatedImages: any[]): void {
  const integratedPreview = document.getElementById('full-auto-integrated-preview');
  if (!integratedPreview) return;

  const integratedHtml = generatedImages.map((image: any, index: number) =>
    `<div style="margin-bottom: 1rem; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px; border: 1px solid var(--border-light);">
      <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.75rem; padding: 0.5rem; background: rgba(16, 185, 129, 0.1); border-radius: 6px;">
        <div style="width: 40px; height: 40px; border-radius: 6px; background: linear-gradient(135deg, #10b981, #059669); display: flex; align-items: center; justify-content: center; color: white; font-size: 1rem; font-weight: 600;">✓</div>
        <div style="flex: 1;">
          <div style="font-size: 0.9rem; color: var(--text-strong); font-weight: 500;">🖼️ 이미지 생성 완료</div>
          <div style="font-size: 0.75rem; color: var(--text-muted);">이미지가 성공적으로 생성되었습니다</div>
        </div>
        <div style="font-size: 0.8rem; color: var(--success); font-weight: 600;">✅ 완료</div>
      </div>
      <div style="padding: 0.5rem; background: var(--bg-primary); border-radius: 6px; border-left: 3px solid var(--success);">
        <div style="font-weight: 600; color: var(--text-strong); margin-bottom: 0.5rem;">📝 ${image.headingTitle || `소제목 ${index + 1}`}</div>
        <div style="font-size: 0.9rem; color: var(--text-muted); line-height: 1.4;">${(image.headingContent || '').substring(0, 150)}${(image.headingContent || '').length > 150 ? '...' : ''}</div>
      </div>
    </div>`
  ).join('');

  integratedPreview.innerHTML = integratedHtml || '<div style="color: var(--text-muted); font-style: italic;">생성된 이미지가 없습니다.</div>';
}

// 미리보기 활성화/비활성화 토글
function toggleFullAutoPreview(): void {
  const isPreviewEnabled = (document.getElementById('full-auto-enable-preview') as HTMLInputElement)?.checked;
  const previewSection = document.getElementById('full-auto-preview-section');

  if (previewSection) {
    previewSection.style.display = isPreviewEnabled ? 'block' : 'none';
  }
}

// 풀오토 탭 소제목 미리보기 업데이트
function updateFullAutoHeadingsPreview(structuredContent: any): void {
  const headingsPreview = document.getElementById('full-auto-headings-preview');
  if (!headingsPreview || !structuredContent.headings) return;

  const headingsHtml = structuredContent.headings.map((heading: any, index: number) =>
    `<div style="margin-bottom: 0.75rem; padding: 0.5rem; background: var(--bg-tertiary); border-radius: 6px; border-left: 3px solid var(--primary);">
      <div style="font-weight: 600; color: var(--text-strong); margin-bottom: 0.25rem;">${index + 1}. ${heading.title || '제목 없음'}</div>
      <div style="font-size: 0.85rem; color: var(--text-muted);">${(heading.content || '').substring(0, 100)}${(heading.content || '').length > 100 ? '...' : ''}</div>
    </div>`
  ).join('');

  headingsPreview.innerHTML = headingsHtml || '<div style="color: var(--text-muted); font-style: italic;">소제목이 없습니다.</div>';
}

// 소제목에서 검색 의도가 명확한 키워드 추출
function extractSearchKeywords(title: string, content?: string): string[] {
  const keywords: string[] = [];

  const titleWords = title.split(' ').filter(word => word.length > 1);
  const personNamePattern = /^[가-힣]{2,4}$|^[A-Z][a-z]+(\s[A-Z][a-z]+)*$/;

  const personNames = titleWords.filter(word => personNamePattern.test(word));
  if (personNames.length > 0) {
    keywords.push(...personNames);
    appendLog(`👤 인물 감지됨: ${personNames.join(', ')}`);
  }

  const titleKeywords = titleWords.filter(word => {
    if (personNames.includes(word)) return false;
    if (/^[가-힣]{2,10}$/.test(word)) return true;
    if (/^[A-Za-z]{3,}$/.test(word)) return true;
    return false;
  });

  keywords.push(...titleKeywords);

  if (content) {
    const contentWords = content.split(' ').filter(word => word.length > 1);
    const contentKeywords = contentWords.filter(word =>
      /^[가-힣]{2,6}$/.test(word) || /^[A-Za-z]{4,}$/.test(word)
    ).slice(0, 3);
    keywords.push(...contentKeywords);
  }

  const uniqueKeywords = Array.from(new Set(keywords)).slice(0, 5);
  return uniqueKeywords.length > 0 ? uniqueKeywords : [title];
}

// 모든 탭의 제목 필드에 제목 설정
function setTitleInAllTabs(title: string): void {
  if (!title) return;

  const semiAutoTitleInput = document.getElementById('post-title') as HTMLInputElement;
  if (semiAutoTitleInput) {
    semiAutoTitleInput.value = title;
  }

  const imageTabTitleInput = document.querySelector('#tab-images input[type="text"][placeholder*="제목"]') as HTMLInputElement;
  if (imageTabTitleInput) {
    imageTabTitleInput.value = title;
  }

  const libraryTabTitleInput = document.querySelector('#tab-library input[type="text"][placeholder*="제목"]') as HTMLInputElement;
  if (libraryTabTitleInput) {
    libraryTabTitleInput.value = title;
  }

  const allTitleInputs = document.querySelectorAll('input[type="text"][id*="title"], input[type="text"][placeholder*="제목"]') as NodeListOf<HTMLInputElement>;
  allTitleInputs.forEach(input => {
    if (input.id !== 'post-title') {
      input.value = title;
    }
  });

  appendLog(`📝 모든 탭의 제목 필드에 "${title}" 설정됨`);
}

// 이미지 자동 생성 및 발행
async function autoGenerateImagesAndPublish(structuredContent: any): Promise<void> {
  try {
    appendLog('🎨 이미지 자동 생성을 시작합니다...');

    const generatedImages = await generateImagesForContent(structuredContent, {
      imageSource: 'dalle',
      skipImages: false
    });

    appendLog('📤 자동 발행을 시작합니다...');

    await executeBlogPublishing(structuredContent, generatedImages, {
      publishMode: 'publish'
    });

    appendLog('🎉 자동 발행이 완료되었습니다!');
    alert('🎉 이미지 생성 및 발행이 자동으로 완료되었습니다!');

  } catch (error) {
    appendLog(`❌ 자동 발행 실패: ${(error as Error).message}`);
    alert(`❌ 자동 발행 실패: ${(error as Error).message}`);
  }
}

// ============================================
// 이미지 관리 탭 초기화
// ============================================
function initImageManagementTab(): void {
  // ✅ AI 영상 목록 토글 기능
  const toggleHeader = document.getElementById('toggle-mp4-list-header');
  const mp4ListContainer = document.getElementById('mp4-files-list');
  const toggleIcon = document.getElementById('mp4-list-toggle-icon');

  if (toggleHeader && mp4ListContainer && toggleIcon) {
    toggleHeader.addEventListener('click', () => {
      const isHidden = mp4ListContainer.style.display === 'none';
      mp4ListContainer.style.display = isHidden ? 'block' : 'none';
      toggleIcon.style.transform = isHidden ? 'rotate(0deg)' : 'rotate(-90deg)';

      // 상태 저장 (선택 사항)
      localStorage.setItem('mp4-list-collapsed', (!isHidden).toString());
    });

    // 초기 상태 로드
    const isCollapsed = localStorage.getItem('mp4-list-collapsed') === 'true';
    if (isCollapsed) {
      mp4ListContainer.style.display = 'none';
      toggleIcon.style.transform = 'rotate(-90deg)';
    }
  }

  // 이미지 소스 선택 버튼 이벤트
  const imageSourceBtns = document.querySelectorAll('.image-source-btn') as NodeListOf<HTMLButtonElement>;
  const imageTitleInput = document.getElementById('image-title') as HTMLInputElement;

  imageSourceBtns.forEach(btn => {
    btn.addEventListener('click', async () => {
      // 나노 바나나 프로 버튼 클릭 시 정보 모달 표시 (Pollinations는 무료이므로 제외)
      if (btn.dataset.source === 'nano-banana-pro') {
        const modalHtml = `
          <div id="nano-banana-pro-modal" style="position: fixed; inset: 0; background: rgba(0,0,0,0.5); z-index: 10000; display: flex; align-items: center; justify-content: center;">
            <div style="background: var(--bg-primary, #1e293b); border-radius: 16px; padding: 2rem; max-width: 480px; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5); border: 1px solid var(--border-medium, #334155);">
              <div style="text-align: center; margin-bottom: 1.5rem;">
                <span style="font-size: 3rem;">🍌</span>
                <h2 style="color: var(--text-strong, #f1f5f9); margin: 1rem 0 0.5rem; font-size: 1.4rem;">나노 바나나 프로</h2>
                <p style="color: var(--text-muted, #94a3b8); font-size: 0.9rem;">Gemini API를 활용한 AI 이미지 생성</p>
              </div>
              
              <div style="background: rgba(234, 179, 8, 0.1); border-radius: 12px; padding: 1rem; margin-bottom: 1rem; border: 1px solid rgba(234, 179, 8, 0.3);">
                <h4 style="color: #eab308; margin-bottom: 0.5rem; font-size: 0.9rem;">✨ 주요 특징</h4>
                <ul style="color: var(--text-muted, #94a3b8); font-size: 0.85rem; margin: 0; padding-left: 1.2rem; line-height: 1.8;">
                  <li>텍스트 없는 깔끔한 이미지 생성</li>
                  <li>Gemini 3 모델 기반 고품질 출력</li>
                  <li>블로그/광고용에 최적화</li>
                  <li>무료 쿼터 내 사용 가능</li>
                </ul>
              </div>
              
              <div style="background: rgba(239, 68, 68, 0.1); border-radius: 12px; padding: 1rem; margin-bottom: 1rem; border: 1px solid rgba(239, 68, 68, 0.3);">
                <h4 style="color: #ef4444; margin-bottom: 0.5rem; font-size: 0.9rem;">⚠️ 과금 안내</h4>
                <p style="color: var(--text-muted, #94a3b8); font-size: 0.85rem; margin: 0; line-height: 1.6;">
                  Gemini API 키를 사용하며, Google 정책 및 계정 설정에 따라 <strong style="color: #f87171;">과금될 수 있습니다</strong>.<br>
                  사용 전 Google AI Studio에서 청구 설정을 확인하세요.
                </p>
              </div>
              
              <button type="button" id="nano-banana-pro-modal-get-key" style="width: 100%; padding: 0.75rem 1rem; background: linear-gradient(135deg, #3b82f6, #2563eb); color: #fff; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; margin-bottom: 0.5rem; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                🔑 Gemini API 키 발급받기 (외부 브라우저)
              </button>
              
              <button type="button" id="nano-banana-pro-modal-check-usage" style="width: 100%; padding: 0.75rem 1rem; background: linear-gradient(135deg, #10b981, #059669); color: #fff; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; margin-bottom: 1rem; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                📊 사용량/과금 확인하러가기 (외부 브라우저)
              </button>
              
              <div style="display: flex; gap: 0.75rem;">
                <button type="button" id="nano-banana-pro-modal-cancel" style="flex: 1; padding: 0.75rem 1rem; background: var(--bg-secondary, #334155); color: var(--text-strong, #f1f5f9); border: 1px solid var(--border-medium, #475569); border-radius: 8px; cursor: pointer; font-weight: 600;">취소</button>
                <button type="button" id="nano-banana-pro-modal-confirm" style="flex: 1; padding: 0.75rem 1rem; background: linear-gradient(135deg, #eab308, #ca8a04); color: #000; border: none; border-radius: 8px; cursor: pointer; font-weight: 700;">확인 후 사용</button>
              </div>
            </div>
          </div>
        `;

        document.getElementById('nano-banana-pro-modal')?.remove();
        document.body.insertAdjacentHTML('beforeend', modalHtml);

        const modal = document.getElementById('nano-banana-pro-modal');
        const cancelBtn = document.getElementById('nano-banana-pro-modal-cancel');
        const confirmBtn = document.getElementById('nano-banana-pro-modal-confirm');
        const getKeyBtn = document.getElementById('nano-banana-pro-modal-get-key');
        const checkUsageBtn = document.getElementById('nano-banana-pro-modal-check-usage');

        getKeyBtn?.addEventListener('click', () => {
          const geminiApiUrl = 'https://aistudio.google.com/app/apikey';
          if ((window as any).api?.openUrl) {
            (window as any).api.openUrl(geminiApiUrl);
          } else if ((window as any).api?.openExternal) {
            (window as any).api.openExternal(geminiApiUrl);
          } else {
            window.open(geminiApiUrl, '_blank');
          }
          appendLog('🔑 Gemini API 키 발급 페이지를 외부 브라우저에서 열었습니다.');
        });

        checkUsageBtn?.addEventListener('click', () => {
          const usageUrl = 'https://aistudio.google.com/app/usage?timeRange=last-28-days&tab=billing&project=gen-lang-client-0528067248';
          if ((window as any).api?.openUrl) {
            (window as any).api.openUrl(usageUrl);
          } else if ((window as any).api?.openExternal) {
            (window as any).api.openExternal(usageUrl);
          } else {
            window.open(usageUrl, '_blank');
          }
          appendLog('📊 Gemini API 사용량/과금 확인 페이지를 외부 브라우저에서 열었습니다.');
        });

        cancelBtn?.addEventListener('click', () => {
          modal?.remove();
          appendLog('⚠️ 나노 바나나 프로 사용이 취소되었습니다.');
        });

        confirmBtn?.addEventListener('click', () => {
          modal?.remove();

          imageSourceBtns.forEach(b => {
            b.classList.remove('selected');
            b.style.background = 'var(--bg-primary)';
            b.style.color = 'var(--text-strong)';
            b.style.borderColor = 'var(--border-medium)';
            b.style.boxShadow = 'none';
          });

          btn.classList.add('selected');
          btn.style.background = 'linear-gradient(135deg, #eab308, #ca8a04)';
          btn.style.color = '#000';
          btn.style.borderColor = '#eab308';
          btn.style.boxShadow = '0 4px 15px rgba(234, 179, 8, 0.4)';

          const stabilityModelContainer = document.getElementById('stability-model-selection-container');
          if (stabilityModelContainer) stabilityModelContainer.style.display = 'none';

          appendLog('✅ 나노 바나나 프로가 선택되었습니다. (Gemini API 사용)');
        });

        modal?.addEventListener('click', (e) => {
          if (e.target === modal) modal.remove();
        });

        return;
      }

      // "저장된 이미지" 버튼 클릭 시 저작권 경고 표시
      if (btn.dataset.source === 'local' || btn.dataset.source === 'saved') {
        const confirmed = window.confirm(
          '⚠️ 저작권 경고\n\n' +
          '저장된 이미지를 사용할 경우, 해당 이미지의 저작권 및 초상권 문제는 전적으로 사용자 본인이 책임져야 합니다.\n\n' +
          '이미지 사용으로 인해 발생하는 모든 법적 책임은 사용자에게 있으며, 본 프로그램 제작자는 어떠한 책임도 지지 않습니다.\n\n' +
          '위 내용을 충분히 숙지하셨습니까?'
        );

        if (!confirmed) {
          appendLog('⚠️ 저장된 이미지 사용이 취소되었습니다.');
          return;
        }

        imageSourceBtns.forEach(b => {
          b.classList.remove('selected');
          b.style.background = 'var(--bg-primary)';
          b.style.color = 'var(--text-strong)';
          b.style.borderColor = 'var(--border-medium)';
          b.style.boxShadow = 'none';
        });

        btn.classList.add('selected');
        btn.style.background = 'linear-gradient(135deg, #8b5cf6, #7c3aed)';
        btn.style.color = 'white';
        btn.style.borderColor = '#8b5cf6';
        btn.style.boxShadow = '0 4px 15px rgba(139, 92, 246, 0.4)';

        await showLocalImageManagementModal();
        return;
      }

      // ✅ Pollinations 버튼 클릭 시 모달 없이 바로 선택 (무료)
      if (btn.dataset.source === 'pollinations') {
        imageSourceBtns.forEach(b => {
          b.classList.remove('selected');
          b.style.background = 'var(--bg-primary)';
          b.style.color = 'var(--text-strong)';
          b.style.borderColor = 'var(--border-medium)';
          b.style.boxShadow = 'none';
        });

        btn.classList.add('selected');
        btn.style.background = 'linear-gradient(135deg, #ec4899, #db2777)';
        btn.style.color = '#fff';
        btn.style.borderColor = '#ec4899';
        btn.style.boxShadow = '0 4px 15px rgba(236, 72, 153, 0.4)';

        const stabilityModelContainer = document.getElementById('stability-model-selection-container');
        if (stabilityModelContainer) stabilityModelContainer.style.display = 'none';

        appendLog('✅ Pollinations(FLUX, 무료)가 선택되었습니다.');
        return;
      }

      // 일반 소스 선택
      imageSourceBtns.forEach(b => {
        b.classList.remove('selected');
        b.style.opacity = '0.65';
        b.style.borderColor = 'var(--border-medium)';
        b.style.boxShadow = 'none';
      });

      btn.classList.add('selected');
      btn.style.opacity = '1';
      btn.style.borderColor = '#8b5cf6';
      btn.style.boxShadow = '0 4px 15px rgba(139, 92, 246, 0.4)';

      const stabilityModelContainer = document.getElementById('stability-model-selection-container');
      if (stabilityModelContainer) {
        if (btn.dataset.source === 'stability') {
          stabilityModelContainer.style.display = 'block';
          stabilityModelContainer.style.animation = 'fadeIn 0.3s ease-out';
        } else {
          stabilityModelContainer.style.display = 'none';
        }
      }
    });
  });

  // ✅ [Fix] 이미지 관리 탭 초기 진입 시 기존 이미지 그리드 즉시 렌더링
  // 페이지 로드 시점이나 탭 전환 시점에 실행됨
  setTimeout(() => {
    const existingImages = (window as any).imageManagementGeneratedImages || generatedImages || [];
    if (Array.isArray(existingImages) && existingImages.length > 0) {
      console.log('[ImageManager] 초기 이미지 그리드 자동 렌더링:', existingImages.length);
      displayGeneratedImages(existingImages);
      // 영어 프롬프트용 데이터도 업데이트
      updatePromptItemsWithImages(existingImages);
    }
  }, 1000);

  // ✅ [New] 쇼핑 커넥트 일괄 링크 적용
  const batchLinkApplyBtn = document.getElementById('batch-link-apply-btn');
  if (batchLinkApplyBtn) {
    batchLinkApplyBtn.addEventListener('click', () => {
      const batchInput = document.getElementById('batch-link-input') as HTMLInputElement;
      const linkUrl = batchInput?.value?.trim();

      if (!linkUrl) {
        alert('적용할 링크 URL을 입력해주세요. (예: https://coupa.ng/...)');
        batchInput?.focus();
        return;
      }

      // 간단한 URL 검증
      if (!/^https?:\/\//i.test(linkUrl)) {
        if (!confirm('링크가 http:// 또는 https:// 로 시작하지 않습니다.\n정말 적용하시겠습니까?')) {
          batchInput?.focus();
          return;
        }
      }

      if (!confirm(`현재 목록의 모든 이미지에 아래 링크를 적용하시겠습니까?\n\n🔗 ${linkUrl}\n\n⚠️ 기존 링크는 덮어씌워집니다.`)) {
        return;
      }

      try {
        // 전역 이미지 배열 사용 (ImageManager.getAllImages() 대신)
        const allImages = (window as any).imageManagementGeneratedImages || generatedImages || [];
        if (!allImages || allImages.length === 0) {
          alert('적용할 이미지가 없습니다.');
          return;
        }

        let count = 0;
        allImages.forEach((img: any) => {
          img.link = linkUrl;
          count++;
        });

        // 전역 상태 업데이트
        (window as any).imageManagementGeneratedImages = allImages;
        generatedImages = allImages;

        // 그리드 갱신
        displayGeneratedImages(allImages);

        toastManager.success(`✅ 총 ${count}개 이미지에 링크가 일괄 적용되었습니다!`);
        appendLog(`🔗 [일괄 적용] 모든 이미지 링크 변경됨: ${linkUrl}`);

        // 입력창 초기화 (선택사항)
        // batchInput.value = ''; 

      } catch (error) {
        console.error('Batch link processing error:', error);
        alert(`❌ 일괄 적용 중 오류가 발생했습니다: ${(error as Error).message}`);
      }
    });
  }
}


function initHeadingImageGeneration(): void {
  const analyzeBtn = document.getElementById('analyze-headings-btn') as HTMLButtonElement;
  const headingAnalysisContent = document.getElementById('heading-analysis-content') as HTMLTextAreaElement;
  const headingsSelectionContainer = document.getElementById('headings-selection-container') as HTMLDivElement;
  const headingsCheckboxList = document.getElementById('headings-checkbox-list') as HTMLDivElement;
  const generateImagesBtn = document.getElementById('generate-heading-images-btn') as HTMLButtonElement;
  const imageGeneratorProvider = document.getElementById('image-generator-provider') as HTMLSelectElement;
  const generatedImagesPreview = document.getElementById('generated-images-preview') as HTMLDivElement;
  const generatedImagesGrid = document.getElementById('generated-images-grid') as HTMLDivElement;

  let analyzedHeadings: Array<{ title: string; imagePrompt: string; referenceImagePath?: string; referenceImageUrl?: string }> = [];

  // 소제목 분석 버튼
  if (analyzeBtn && headingAnalysisContent) {
    analyzeBtn.addEventListener('click', async () => {
      const content = headingAnalysisContent.value.trim();
      if (!content) {
        alert('콘텐츠를 입력해주세요.');
        return;
      }

      analyzeBtn.disabled = true;
      analyzeBtn.textContent = '분석 중...';
      appendLog('🔍 소제목 분석 중...');

      try {
        // 구조화 콘텐츠 생성으로 소제목 추출
        const apiClient = EnhancedApiClient.getInstance();
        const apiResponse = await apiClient.call(
          'generateStructuredContent',
          [{
            assembly: {
              baseText: content,
              generator: 'gemini',
            }
          }],
          {
            retryCount: 3,
            retryDelay: 2000,
            timeout: 600000
          }
        );
        const result = apiResponse.data || { success: false, message: apiResponse.error };

        if (result.success && result.content?.headings && result.content.headings.length > 0) {
          analyzedHeadings = result.content.headings.map((h: any) => ({
            title: String(h.title || h),
            imagePrompt: String(h.imagePrompt || h.title || h),
          }));

          // 체크박스 목록 생성 (최대 10개) (✅ HTML 이스케이프 적용)
          const displayHeadings = analyzedHeadings.slice(0, 10);
          headingsCheckboxList.innerHTML = displayHeadings.map((heading: any, index: number) => {
            const safeTitle = escapeHtml(heading.title || '');
            const safeImagePrompt = escapeHtml(heading.imagePrompt || '');
            return `
              <label style="display: flex; align-items: flex-start; gap: 0.5rem; padding: 0.5rem; border-radius: 0.25rem; cursor: pointer; transition: background var(--transition-fast);">
                <input type="checkbox" class="heading-checkbox" data-heading-index="${index}" checked style="margin-top: 0.25rem;">
                <div style="flex: 1;">
                  <div style="font-weight: 600; margin-bottom: 0.25rem;">${safeTitle}</div>
                  <div style="font-size: 0.875rem; color: var(--text-muted);">프롬프트: ${safeImagePrompt}</div>
                </div>
              </label>
            `;
          }).join('');

          // 체크박스 호버 효과
          headingsCheckboxList.querySelectorAll('label').forEach(label => {
            label.addEventListener('mouseenter', () => {
              label.style.background = 'var(--bg-hover)';
            });
            label.addEventListener('mouseleave', () => {
              label.style.background = 'transparent';
            });
          });

          headingsSelectionContainer.style.display = 'block';
          appendLog(`✅ ${displayHeadings.length}개의 소제목이 분석되었습니다.`);
        } else {
          appendLog(`❌ 소제목 분석 실패: ${result.message || '알 수 없는 오류'}`);
          alert(`❌ 소제목 분석 실패: ${result.message || '알 수 없는 오류'}`);
        }
      } catch (error) {
        appendLog(`❌ 분석 오류: ${(error as Error).message}`);
        alert(`❌ 오류: ${(error as Error).message}`);
      } finally {
        analyzeBtn.disabled = false;
        analyzeBtn.textContent = '소제목 분석하기';
      }
    });
  }

  // 이미지 생성 버튼
  if (generateImagesBtn && imageGeneratorProvider) {
    generateImagesBtn.addEventListener('click', async () => {
      const selectedCheckboxes = headingsCheckboxList.querySelectorAll('.heading-checkbox:checked');
      if (selectedCheckboxes.length === 0) {
        alert('생성할 소제목을 최소 1개 이상 선택해주세요.');
        return;
      }

      if (selectedCheckboxes.length > 10) {
        alert('최대 10개까지만 선택할 수 있습니다.');
        return;
      }

      generateImagesBtn.disabled = true;
      generateImagesBtn.textContent = '이미지 생성 중...';

      try {
        const selectedIndices = Array.from(selectedCheckboxes).map(checkbox =>
          parseInt((checkbox as HTMLInputElement).getAttribute('data-heading-index') || '0')
        );

        const selectedHeadings = selectedIndices.map(index => analyzedHeadings[index]);

        // ✅ 이미 이미지가 있는 소제목 필터링
        const existingImageHeadings = new Set(generatedImages.map(img => img.heading));
        const headingsToGenerate = selectedHeadings.filter(h => !existingImageHeadings.has(h.title));

        if (headingsToGenerate.length === 0) {
          alert(`선택한 모든 소제목(${selectedHeadings.length}개)에 이미 이미지가 있습니다!\n\n💡 이미지를 변경하려면 미리보기에서 ❌ 제거 버튼을 먼저 눌러주세요.`);
          appendLog(`⚠️ 선택한 소제목에 이미 이미지가 모두 있습니다.`);
          generateImagesBtn.disabled = false;
          generateImagesBtn.textContent = '선택한 소제목 이미지 생성하기';
          return;
        }

        // 건너뛴 소제목 로그
        const skippedHeadings = selectedHeadings.filter(h => existingImageHeadings.has(h.title));
        if (skippedHeadings.length > 0) {
          appendLog(`⏭️ 이미 이미지가 있는 소제목 ${skippedHeadings.length}개는 건너뜁니다:`);
          skippedHeadings.forEach(h => {
            appendLog(`   - "${h.title}"`);
          });
        }

        appendLog(`🎨 ${headingsToGenerate.length}개 소제목의 이미지 생성 시작... (전체 ${selectedHeadings.length}개 중)`);

        const selectedBtn = (document.querySelector('.image-source-btn.selected') || document.querySelector('.unified-img-source-btn.selected')) as HTMLButtonElement;
        const provider = (selectedBtn?.dataset.source || 'nano-banana-pro') as 'dalle' | 'pexels' | 'nano-banana-pro' | 'prodia' | 'stability';

        const result = await generateImagesWithCostSafety({
          provider,
          items: headingsToGenerate.map(h => ({
            heading: h.title,
            prompt: h.imagePrompt,
            referenceImagePath: h.referenceImagePath, // ✅ 참조 이미지 경로 전달
            referenceImageUrl: h.referenceImageUrl,   // ✅ 참조 이미지 URL 전달
          })),
          postTitle: currentStructuredContent?.selectedTitle,
          postId: currentPostId || undefined,
          isFullAuto: true
        });

        if (result.success && result.images && result.images.length > 0) {
          // 생성된 이미지 목록에 추가
          result.images.forEach((img: any) => {
            generatedImages.push({
              heading: img.heading,
              filePath: img.filePath,
              previewDataUrl: img.previewDataUrl,
              provider: img.provider,
            });
          });

          // 이미지 그리드 표시 (✅ HTML 이스케이프 적용)
          generatedImagesGrid.innerHTML = result.images.filter((img: any) => img).map((img: any) => {
            const safeHeading = escapeHtml(img.heading || '');
            const safeFilePath = escapeHtml(img.filePath || '');
            const imageUrl = img.previewDataUrl || img.filePath || (img as any).url || '';
            return `
              <div class="image-item" data-image-id="${safeFilePath}">
                <img src="${imageUrl}" alt="${safeHeading}" loading="lazy" style="width: 100%; height: 200px; object-fit: cover; border-radius: var(--radius-md);">
                <div style="padding: 0.5rem; font-size: 0.875rem; font-weight: 600;">${safeHeading}</div>
              </div>
            `;
          }).join('');

          generatedImagesPreview.style.display = 'block';

          // ✅ 전체 이미지 수 표시
          const totalImages = generatedImages.length;
          const totalHeadings = analyzedHeadings.length;
          const remainingHeadings = totalHeadings - totalImages;

          appendLog(`✅ ${result.images.length}개의 이미지가 새로 생성되었습니다.`);
          appendLog(`📊 전체 진행 상황: ${totalImages}/${totalHeadings}개 완료 (남은 소제목: ${remainingHeadings}개)`);

          if (remainingHeadings > 0) {
            alert(`✅ ${result.images.length}개의 이미지가 생성되었습니다!\n\n📊 전체 진행 상황:\n- 완료: ${totalImages}/${totalHeadings}개\n- 남은 소제목: ${remainingHeadings}개\n\n💡 나머지 소제목을 선택하고 다시 생성 버튼을 누르면 됩니다!`);
          } else {
            alert(`🎉 모든 소제목(${totalImages}/${totalHeadings}개)의 이미지 생성 완료!\n\n이제 반자동 발행을 진행하세요!`);
          }
        } else {
          appendLog(`❌ 이미지 생성 실패: ${result.message || '알 수 없는 오류'}`);
          alert(`❌ 이미지 생성 실패: ${result.message || '알 수 없는 오류'}`);
        }
      } catch (error) {
        appendLog(`❌ 이미지 생성 오류: ${(error as Error).message}`);
        alert(`❌ 오류: ${(error as Error).message}`);
      } finally {
        generateImagesBtn.disabled = false;
        generateImagesBtn.textContent = '선택한 소제목 이미지 생성하기';
      }
    });
  }

  // ✅ 프롬프트 새로고침 버튼 이벤트
  const refreshPromptsBtn = document.getElementById('refresh-prompts-btn') as HTMLButtonElement;
  const setFirstHeadingThumbnailBtn = document.getElementById('set-first-heading-thumbnail-btn') as HTMLButtonElement;

  if (refreshPromptsBtn) {
    refreshPromptsBtn.addEventListener('click', async () => {
      const headings = getCurrentImageHeadings();
      if (headings.length === 0) {
        alert('새로고침할 소제목이 없습니다.');
        return;
      }

      if (!confirm(`영어 프롬프트를 새로 생성하시겠습니까?\n\n현재 ${headings.length}개의 프롬프트가 다시 생성됩니다.`)) {
        return;
      }

      try {
        refreshPromptsBtn.disabled = true;
        refreshPromptsBtn.innerHTML = '<span>🔄</span><span>생성 중...</span>';

        appendLog(`🔄 ${headings.length}개 소제목의 영어 프롬프트를 새로 생성합니다...`, 'images-log-output');

        // 프롬프트 재생성
        const refreshedHeadings = headings.map((h: any) => {
          const title = String(h.title || h.text || (typeof h === 'string' ? h : '')).trim();
          return {
            title: title || '소제목',
            prompt: generateEnglishPromptForHeadingSync(title || 'Abstract Subject')
          };
        });

        displayImageHeadingsWithPrompts(refreshedHeadings);

        appendLog(`✅ ${refreshedHeadings.length}개 프롬프트가 새로고침되었습니다!`, 'images-log-output');
        toastManager.success(`✅ ${refreshedHeadings.length}개 프롬프트 새로고침 완료!`);
      } catch (error) {
        appendLog(`❌ 프롬프트 새로고침 실패: ${(error as Error).message}`, 'images-log-output');
        alert(`❌ 오류: ${(error as Error).message}`);
      } finally {
        refreshPromptsBtn.disabled = false;
        refreshPromptsBtn.innerHTML = '<span>🔄</span><span>새로고침</span>';
      }
    });
  }

  if (setFirstHeadingThumbnailBtn && !setFirstHeadingThumbnailBtn.hasAttribute('data-listener-added')) {
    setFirstHeadingThumbnailBtn.setAttribute('data-listener-added', 'true');
    setFirstHeadingThumbnailBtn.addEventListener('click', async () => {
      try {
        // ✅ 1번 소제목은 DOM 의존하지 않고 structuredContent/ImageManager에서 우선 찾기
        const structured = (window as any).currentStructuredContent as any;
        const firstHeading = structured?.headings?.[0] ?? ImageManager.headings?.[0] ?? null;
        let firstHeadingTitle = '';
        if (typeof firstHeading === 'string') firstHeadingTitle = firstHeading;
        else if (firstHeading && typeof firstHeading === 'object') firstHeadingTitle = firstHeading.title || '';

        if (!firstHeadingTitle) {
          const firstPromptItem = document.querySelector('#prompts-container .prompt-item[data-index="1"]') as HTMLElement | null;
          firstHeadingTitle = (firstPromptItem?.querySelector('.heading-title-text')?.textContent || '').trim();
        }

        if (!firstHeadingTitle) {
          toastManager.warning('1번 소제목을 찾을 수 없습니다. 먼저 소제목 분석을 해주세요.');
          return;
        }

        const ensureFileUrl = (p: string): string => {
          if (!p) return '';
          const s = String(p).trim();
          if (!s) return '';
          if (/^https?:\/\//i.test(s) || /^data:/i.test(s) || /^file:\/\//i.test(s)) return s;
          const normalized = s.replace(/^\/+/, '').replace(/\\/g, '/');
          return `file:///${normalized}`;
        };

        // 1) ✅ 생성/배치 데이터 기반 우선순위 매칭: isThumbnail 또는 headingIndex===0
        const allImages = ImageManager.getAllImages();
        let firstImage: any | null =
          allImages.find((img: any) => img?.isThumbnail === true) ||
          allImages.find((img: any) => img?.headingIndex === 0) ||
          null;

        // 2) ImageManager 매핑(타이틀)로 찾기
        if (!firstImage) {
          firstImage = ImageManager.getImage(firstHeadingTitle);
        }

        // 3) 전체 이미지에서 heading 텍스트로 매칭
        if (!firstImage) {
          firstImage = allImages.find((img: any) => (img.heading || '').trim() === firstHeadingTitle.trim()) || null;
        }

        // 4) 최후 폴백: 첫 이미지
        if (!firstImage && allImages.length > 0) {
          firstImage = allImages[0];
        }

        const imageUrl = ensureFileUrl(firstImage?.previewDataUrl || firstImage?.url || firstImage?.filePath || '');
        if (!imageUrl) {
          toastManager.warning('1번 소제목 이미지가 없습니다. 먼저 이미지 생성/수집 후 다시 시도하세요.');
          return;
        }

        const imageToolsTab = document.querySelector('[data-tab="image-tools"]') as HTMLElement | null;
        imageToolsTab?.click();

        const thumbnailSubtabBtn = document.querySelector('.image-tools-subtab[data-subtab="thumbnail"]') as HTMLElement | null;
        thumbnailSubtabBtn?.click();

        setTimeout(async () => {
          try {
            if (!thumbnailGenerator) {
              thumbnailGenerator = new ThumbnailGenerator();
            }

            // ✅ [2026-01-21] 쇼핑커넥트 모드: 글 제목을 메인 텍스트로 사용 (소제목이 아닌 블로그 제목)
            const blogTitle =
              (document.getElementById('unified-generated-title') as HTMLInputElement)?.value?.trim() ||
              (document.getElementById('unified-title') as HTMLInputElement)?.value?.trim() ||
              ((window as any).currentStructuredContent as any)?.selectedTitle?.trim() ||
              firstHeadingTitle; // 폴백: 1번 소제목

            thumbnailGenerator.setMainText(blogTitle);
            await thumbnailGenerator.setBackgroundFromUrl(imageUrl);
            toastManager.success('✅ 썸네일 생성기에 글 제목과 이미지가 적용되었습니다!');
          } catch (e) {
            console.error('[Thumbnail] 썸네일 생성기 자동 설정 실패:', e);
            toastManager.error('❌ 썸네일 자동 설정에 실패했습니다.');
          }
        }, 200);
      } catch (error) {
        console.error('[Thumbnail] 1번 소제목 썸네일 지정 실패:', error);
        toastManager.error('❌ 썸네일 자동 설정에 실패했습니다.');
      }
    });
  }

  // ✅ 수집/생성된 이미지를 기반으로 나노 바나나 프로 예비 이미지 생성
  async function generateReserveDetailImagesFromBaseImages(baseImages: any[], blogTitle: string): Promise<any[]> {
    const MAX_RESERVES = 6;
    if (!Array.isArray(baseImages) || baseImages.length === 0) {
      return [];
    }

    const baseCount = baseImages.length;
    const reserveCount = Math.min(MAX_RESERVES, Math.max(1, baseCount));

    appendLog(`🧩 예비 이미지 ${reserveCount}개를 나노 바나나 프로로 생성합니다...`, 'images-log-output');
    showImagesProgress(85, '예비 이미지 생성 중...', `나노 바나나 프로로 예비 이미지 ${reserveCount}개 생성 중`);

    const items = [] as any[];
    for (let i = 0; i < reserveCount; i++) {
      const base = baseImages[i % baseCount] || {};
      const headingTitle = String(base.heading || `소제목 ${i + 1}`).trim();
      const promptTextSource = String(base.prompt || headingTitle || blogTitle || '').trim();
      const prompt = promptTextSource || headingTitle || blogTitle || `상세 이미지 ${i + 1}`;
      const rawPath = String(base.filePath || base.url || '').trim();

      items.push({
        heading: `예비 이미지 ${i + 1}`,
        prompt,
        allowText: true,
        referenceImagePath: rawPath || undefined,
        referenceImageUrl: rawPath || undefined,
      });
    }

    try {
      const result = await generateImagesWithCostSafety({
        provider: 'nano-banana-pro',
        items,
        postTitle: blogTitle,
        isFullAuto: false,
      });

      if (!result?.success || !Array.isArray(result.images) || result.images.length === 0) {
        throw new Error(String(result?.message || '예비 상세 이미지 생성 실패'));
      }

      const reserves = result.images.map((img: any, idx: number) => {
        const raw = String(img.filePath || img.url || img.previewDataUrl || '').trim();
        const url = raw || '';
        const preview = img.previewDataUrl || url;
        return {
          heading: `예비 이미지 ${idx + 1}`,
          filePath: raw,
          url,
          previewDataUrl: preview,
          prompt: items[idx]?.prompt || '',
          headingIndex: -1, // 예비 이미지는 소제목 인덱스와 무관
          provider: 'nano-banana-pro',
        };
      });

      appendLog(`✅ 예비 이미지 ${reserves.length}개 생성 완료`, 'images-log-output');
      return reserves;
    } catch (error) {
      appendLog(`⚠️ 예비 이미지 생성 실패: ${(error as Error).message}`, 'images-log-output');
      return [];
    }
  }

  // 이미지 생성 버튼 이벤트
  const generateImagesBtnMain = document.getElementById('generate-images-btn') as HTMLButtonElement;

  generateImagesBtnMain?.addEventListener('click', async () => {
    const headings = getCurrentImageHeadings();
    if (headings.length === 0) {
      alert('먼저 소제목을 분석해주세요.');
      return;
    }

    const selectedSource = document.querySelector('.image-source-btn.selected') as HTMLButtonElement;
    const imageSource = selectedSource?.dataset.source || 'dalle';

    try {
      generateImagesBtnMain.disabled = true;
      generateImagesBtnMain.innerHTML = '<span style="font-size: 1.25rem;">🎨</span><span>생성 중...</span>';

      // ✅ 고급 진행률 모달 표시(로그 동기화)
      aiProgressModal.show('이미지 생성 중...', {
        autoAnimate: false,
        icon: '🎨',
        initialLog: '⏳ 이미지 생성을 시작합니다...',
      });

      // 진행률 표시 시작
      showImagesProgress(0, '이미지 생성 준비 중...', '소제목 분석 완료, 이미지 병렬 생성 시작');
      appendLog('🎨 이미지를 병렬로 생성하는 중입니다... ⚡', 'images-log-output');
      appendLog('⚡ 병렬 처리로 속도 2-3배 향상!', 'images-log-output');
      aiProgressModal.update(0, '이미지 생성 준비 중...');
      aiProgressModal.addLog('🎨 이미지를 병렬로 생성하는 중입니다... ⚡');
      aiProgressModal.addLog('⚡ 병렬 처리로 속도 2-3배 향상!');

      // ✅ [2026-01-21] 썸네일/마무리 제외 - 일반 소제목만 AI 이미지 생성
      // 썸네일: 수집된 이미지 사용, 마무리: 이미지 불필요
      const filteredHeadings = headings.filter((h: any) => {
        const title = String(h.title || '').trim();
        return !title.includes('🖼️ 썸네일') &&
          !title.includes('썸네일') &&
          !title.includes('📝 마무리') &&
          !title.includes('마무리') &&
          !h.isThumbnail &&
          !h.isConclusion;
      });

      if (filteredHeadings.length === 0) {
        appendLog('⚠️ AI 이미지를 생성할 소제목이 없습니다. (썸네일/마무리 제외됨)', 'images-log-output');
        aiProgressModal.hide();
        generateImagesBtnMain.disabled = false;
        generateImagesBtnMain.innerHTML = '<span style="font-size: 1.25rem;">🎨</span><span>AI 이미지 생성</span>';
        return;
      }

      appendLog(`📋 ${headings.length}개 섹션 중 ${filteredHeadings.length}개 소제목 이미지 생성 (썸네일/마무리 제외)`, 'images-log-output');
      aiProgressModal.addLog(`📋 ${filteredHeadings.length}개 소제목 대상 (썸네일/마무리 제외)`);

      // ✅ 병렬 처리: 각 소제목별로 이미지 동시 생성
      const totalHeadings = filteredHeadings.length;
      let completedCount = 0;

      // ✅ 블로그 제목 가져오기 (썸네일용)
      const blogTitle = (document.getElementById('unified-generated-title') as HTMLInputElement)?.value?.trim() ||
        (document.getElementById('unified-title') as HTMLInputElement)?.value?.trim() ||
        (document.getElementById('image-title') as HTMLInputElement)?.value?.trim() || '';

      // ✅ 1번 이미지 텍스트 포함 여부 체크박스 확인
      const thumbnailTextCheckbox = document.getElementById('thumbnail-text-option') as HTMLInputElement;
      const includeThumbnailText = thumbnailTextCheckbox?.checked ?? false; // 기본값: 텍스트 없음

      // ✅ [2026-01-18] nano-banana-pro/pollinations: 배치 요청으로 내부 병렬 처리 활성화 (속도 2-3배 향상)
      if (imageSource === 'nano-banana-pro' || imageSource === 'pollinations') {
        appendLog(`⚡ ${imageSource === 'nano-banana-pro' ? '나노 바나나 프로' : 'Pollinations'} 배치 병렬 처리 시작!`, 'images-log-output');
        aiProgressModal.addLog(`⚡ 배치 병렬 처리로 빠른 생성!`);

        // 모든 소제목을 한 번에 배치로 요청
        const batchItems = filteredHeadings.map((heading: any, i: number) => {
          const isThumbnail = includeThumbnailText && i === 0;
          const ref = resolveReferenceImageForHeading(String(heading.title || '').trim());
          return {
            heading: heading.title,
            prompt: heading.prompt,
            isThumbnail: isThumbnail,
            allowText: isThumbnail,
            ...ref,
          };
        });

        try {
          const imageResult = await generateImagesWithCostSafety({
            provider: imageSource,
            items: batchItems,
            postTitle: blogTitle,
            isFullAuto: true,
          });

          if (imageResult.success && imageResult.images && imageResult.images.length > 0) {
            // 결과를 소제목에 매핑
            let successCount = 0;
            let failCount = 0;
            for (let i = 0; i < imageResult.images.length; i++) {
              const img = imageResult.images[i];
              const heading = filteredHeadings[i];
              if (img && heading) {
                const imageUrl = img.previewDataUrl || img.filePath;
                if (imageUrl) {
                  ImageManager.setImage(heading.title, { url: imageUrl, prompt: heading.prompt, heading: heading.title });
                  successCount++;
                  const progress = Math.floor(((i + 1) / totalHeadings) * 100);
                  showImagesProgress(progress, `이미지 생성 중... (${i + 1}/${totalHeadings})`, `"${heading.title}" 완료`);
                  aiProgressModal.update(progress, `이미지 생성 중... (${i + 1}/${totalHeadings})`);
                  aiProgressModal.addLog(`✅ [${i + 1}/${totalHeadings}] ${String(heading.title || '').substring(0, 25)}... 완료`);
                } else {
                  failCount++;
                  aiProgressModal.addLog(`⚠️ [${i + 1}/${totalHeadings}] ${String(heading.title || '').substring(0, 25)}... 이미지 없음`);
                }
              } else {
                failCount++;
              }
            }

            // ✅ 부분 성공도 처리
            if (successCount > 0) {
              showImagesProgress(100, '이미지 생성 완료', `성공 ${successCount}개${failCount > 0 ? `, 실패 ${failCount}개` : ''}`);
              appendLog(`🎉 총 ${successCount}개 이미지 생성 완료!${failCount > 0 ? ` (${failCount}개 실패)` : ''}`, 'images-log-output');
              aiProgressModal.update(100, '이미지 생성 완료');
              aiProgressModal.addLog(`🎉 성공: ${successCount}개${failCount > 0 ? `, 실패: ${failCount}개` : ''}`);
              updatePromptItemsWithImages(imageResult.images.filter((img: any) => img && (img.previewDataUrl || img.filePath)));
            } else {
              throw new Error('모든 이미지 생성 실패');
            }
          } else {
            throw new Error(imageResult.message || '배치 이미지 생성 실패');
          }
        } catch (batchError) {
          appendLog(`❌ 배치 이미지 생성 실패: ${(batchError as Error).message}`, 'images-log-output');
          aiProgressModal.addLog(`❌ 실패: ${(batchError as Error).message}`);
        }

        generateImagesBtnMain.disabled = false;
        generateImagesBtnMain.innerHTML = '<span style="font-size: 1.25rem;">🎨</span><span>AI 이미지 생성</span>';
        appendLog('💾 이미지가 저장되었습니다. 반자동 발행 시 자동으로 삽입됩니다.', 'images-log-output');
        return; // 배치 처리 완료, 아래 순차 처리 스킵
      }

      // ✅ 비용/과금 위험 provider는 동시 요청을 막기 위해 순차 처리 (nano-banana-pro 제외)
      try {
        const providerForLock =
          imageSource === 'dalle' || imageSource === 'imagen4'
            ? 'imagen4'
            : imageSource === 'prodia'
              ? 'prodia'
              : imageSource === 'stability'
                ? 'stability'
                : '';
        const sequential = providerForLock ? isCostRiskImageProvider(providerForLock) : false;
        if (sequential) {
          showImagesProgress(0, '이미지 생성 준비 중...', '소제목 분석 완료, 순차 생성 시작');
          appendLog(`⏳ ${getCostRiskProviderLabel(providerForLock)} 보호를 위해 순차 처리로 생성합니다.`, 'images-log-output');
          aiProgressModal.addLog(`⏳ ${getCostRiskProviderLabel(providerForLock)} 보호를 위해 순차 처리로 생성합니다.`);
        }
      } catch {
        // ignore
      }

      const providerForLock =
        imageSource === 'dalle' || imageSource === 'imagen4'
          ? 'imagen4'
          : imageSource === 'pollinations' || imageSource === 'nano-banana-pro'
            ? 'nano-banana-pro'
            : imageSource === 'prodia'
              ? 'prodia'
              : imageSource === 'stability'
                ? 'stability'
                : '';
      const shouldRunSequentially = providerForLock ? isCostRiskImageProvider(providerForLock) : false;

      const generateOne = async (heading: any, i: number): Promise<any | null> => {
        try {
          // ✅ 1번 이미지 텍스트 옵션에 따라 썸네일 여부 결정
          // includeThumbnailText가 true면 1번만 썸네일(텍스트 포함), false면 모두 텍스트 없음
          const isThumbnail = includeThumbnailText && i === 0;
          appendLog(`📸 [${i + 1}/${totalHeadings}] 이미지 생성 중: ${heading.prompt} ${isThumbnail ? '(썸네일+텍스트)' : '(텍스트 없음)'}`, 'images-log-output');

          let imageUrl: string;

          if (imageSource === 'dalle' || imageSource === 'imagen4') {
            // ✅ Imagen4/DALL-E: IPC 통해 메인 프로세스에서 생성 (풀오토와 동일)
            const ref = resolveReferenceImageForHeading(String(heading.title || '').trim());
            const imageResult = await generateImagesWithCostSafety({
              provider: imageSource === 'dalle' ? 'imagen4' : 'imagen4',
              items: [{
                heading: heading.title,
                prompt: heading.prompt,
                isThumbnail: isThumbnail,
                allowText: isThumbnail,
                ...ref,
              }],
              postTitle: blogTitle,
              isFullAuto: true // ✅ 풀오토 모드로 처리
            });
            if (imageResult.success && imageResult.images && imageResult.images.length > 0) {
              imageUrl = imageResult.images[0].previewDataUrl || imageResult.images[0].filePath;
            } else {
              throw new Error(imageResult.message || 'Imagen4 이미지 생성 실패');
            }
          } else if (imageSource === 'pollinations' || imageSource === 'nano-banana-pro') {
            // ✅ 선택된 소스(Pollinations 또는 Nano Banana Pro) 사용
            const ref = resolveReferenceImageForHeading(String(heading.title || '').trim());
            const imageResult = await generateImagesWithCostSafety({
              provider: imageSource, // ✅ 고정된 'nano-banana-pro' 대신 imageSource 사용
              items: [{
                heading: heading.title,
                prompt: heading.prompt,
                isThumbnail: isThumbnail,
                allowText: isThumbnail,
                ...ref,
              }],
              postTitle: blogTitle,
              isFullAuto: true // ✅ 풀오토 모드로 처리
            });
            if (imageResult.success && imageResult.images && imageResult.images.length > 0) {
              imageUrl = imageResult.images[0].previewDataUrl || imageResult.images[0].filePath;
            } else {
              throw new Error(imageResult.message || '나노 바나나 프로 이미지 생성 실패');
            }
          } else if (imageSource === 'prodia') {
            const ref = resolveReferenceImageForHeading(String(heading.title || '').trim());
            const imageResult = await generateImagesWithCostSafety({
              provider: 'prodia',
              items: [{
                heading: heading.title,
                prompt: heading.prompt,
                isThumbnail: isThumbnail,
                allowText: isThumbnail,
                ...ref,
              }],
              postTitle: blogTitle,
              isFullAuto: true,
            });
            if (imageResult.success && imageResult.images && imageResult.images.length > 0) {
              imageUrl = imageResult.images[0].previewDataUrl || imageResult.images[0].filePath;
            } else {
              throw new Error(imageResult.message || 'Prodia 이미지 생성 실패');
            }
          } else if (imageSource === 'stability') {
            // ✅ Stability: 전용 파라미터(모델 등)와 함께 호출
            const stabilityModel = (document.getElementById('stability-model-select') as HTMLSelectElement)?.value || 'ultra';
            const ref = resolveReferenceImageForHeading(String(heading.title || '').trim());
            const imageResult = await generateImagesWithCostSafety({
              provider: 'stability',
              items: [{
                heading: heading.title,
                prompt: heading.prompt,
                isThumbnail: isThumbnail,
                allowText: isThumbnail,
                ...ref,
              }],
              postTitle: blogTitle,
              isFullAuto: true,
              model: stabilityModel
            });
            if (imageResult.success && imageResult.images && imageResult.images.length > 0) {
              imageUrl = imageResult.images[0].previewDataUrl || imageResult.images[0].filePath;
            } else {
              throw new Error(imageResult.message || 'Stability AI 이미지 생성 실패');
            }
          } else if (imageSource === 'falai') {
            // ✅ Fal.ai: 전용 파라미터와 함께 호출
            const ref = resolveReferenceImageForHeading(String(heading.title || '').trim());
            const imageResult = await generateImagesWithCostSafety({
              provider: 'falai',
              items: [{
                heading: heading.title,
                prompt: heading.prompt,
                isThumbnail: isThumbnail,
                allowText: isThumbnail,
                ...ref,
              }],
              postTitle: blogTitle,
              isFullAuto: true,
            });
            if (imageResult.success && imageResult.images && imageResult.images.length > 0) {
              imageUrl = imageResult.images[0].previewDataUrl || imageResult.images[0].filePath;
            } else {
              throw new Error(imageResult.message || 'Fal.ai 이미지 생성 실패');
            }
          } else if (imageSource === 'naver-search' || imageSource === 'naver') {
            // ✅ 네이버 이미지 검색: 사용자가 명시적으로 선택한 경우에만 사용
            imageUrl = await searchNaverImage(heading.prompt);
          } else {
            // ✅ [FIX] 기본값: 알 수 없는 이미지 소스는 nano-banana-pro 사용 (네이버 검색으로 폴백하지 않음)
            console.warn(`[ImageGen] 알 수 없는 이미지 소스 "${imageSource}", 기본 AI 이미지 생성기(nano-banana-pro) 사용`);
            const ref = resolveReferenceImageForHeading(String(heading.title || '').trim());
            const imageResult = await generateImagesWithCostSafety({
              provider: 'nano-banana-pro',
              items: [{
                heading: heading.title,
                prompt: heading.prompt,
                isThumbnail: isThumbnail,
                allowText: isThumbnail,
                ...ref,
              }],
              postTitle: blogTitle,
              isFullAuto: true,
            });
            if (imageResult.success && imageResult.images && imageResult.images.length > 0) {
              imageUrl = imageResult.images[0].previewDataUrl || imageResult.images[0].filePath;
            } else {
              throw new Error(imageResult.message || '기본 AI 이미지 생성 실패');
            }
          }

          // 진행률 업데이트 (완료된 개수 기준)
          completedCount++;
          const headingProgressMax = 100;
          const currentProgress = Math.floor((completedCount / totalHeadings) * headingProgressMax);
          showImagesProgress(currentProgress, `이미지 생성 중... (${completedCount}/${totalHeadings})`, `"${heading.title}" 이미지 생성 완료`);
          appendLog(`✅ [${completedCount}/${totalHeadings}] 이미지 생성 완료`, 'images-log-output');
          aiProgressModal.update(currentProgress, `이미지 생성 중... (${completedCount}/${totalHeadings})`);
          aiProgressModal.addLog(`✅ [${completedCount}/${totalHeadings}] ${String(heading.title || '').trim()} 완료`);

          return {
            url: imageUrl,
            prompt: heading.prompt,
            heading: heading.title,
            index: i
          };
        } catch (error) {
          completedCount++;
          const currentProgress = Math.floor((completedCount / totalHeadings) * 100);
          appendLog(`❌ [${completedCount}/${totalHeadings}] 이미지 생성 실패: ${(error as Error).message}`, 'images-log-output');
          showImagesProgress(currentProgress, `이미지 생성 중... (${completedCount}/${totalHeadings})`, `"${heading.title}" 이미지 생성 실패`);
          aiProgressModal.update(currentProgress, `이미지 생성 중... (${completedCount}/${totalHeadings})`);
          aiProgressModal.addLog(`❌ [${completedCount}/${totalHeadings}] ${String(heading.title || '').trim()} 실패: ${(error as Error).message}`);
          return null;
        }
      };

      const results: Array<any | null> = [];
      if (shouldRunSequentially) {
        for (let i = 0; i < filteredHeadings.length; i++) {
          results.push(await generateOne(filteredHeadings[i], i));
        }
      } else {
        const imagePromises = filteredHeadings.map(async (heading: any, i: number) => generateOne(heading, i));
        results.push(...(await Promise.all(imagePromises)));
      }

      // ✅ IMPORTANT: 결과 null(실패) 때문에 인덱스가 당겨지면 소제목 매칭이 깨짐.
      // 따라서 headings 기준으로 인덱스를 고정한 채, 성공한 항목만 이미지로 채운다.
      const normalizedImages = filteredHeadings
        .map((heading: any, idx: number) => {
          const img = results[idx];
          if (!img) return null;
          const headingTitle = String(img?.heading || heading?.title || `소제목 ${idx + 1}`).trim();
          const rawUrl = String(img?.url || '').trim();
          if (!rawUrl) return null;
          return {
            heading: headingTitle,
            filePath: rawUrl,
            url: rawUrl,
            previewDataUrl: rawUrl,
            prompt: String(img?.prompt || heading?.prompt || '').trim(),
            headingIndex: idx,
            isThumbnail: idx === 0,
          };
        })
        .filter((v: any) => v !== null);

      const generatedImages = normalizedImages;

      const allImagesForManagement = normalizedImages;
      (window as any).imageManagementGeneratedImages = allImagesForManagement;

      // ✅ 소제목 정보도 동기화 (썸네일/발행에서 인덱스 매칭 안정화)
      ImageManager.setHeadings(filteredHeadings);

      // ✅ 썸네일 지정/발행에서 확실히 찾도록 ImageManager에도 등록 (소제목 이미지만)
      normalizedImages.forEach((img: any) => {
        if (img?.heading) {
          ImageManager.setImage(img.heading, {
            ...img,
            timestamp: Date.now(),
          });
        }
      });

      // ✅ 영어 프롬프트 이미지 미리보기 업데이트
      updatePromptItemsWithImages(normalizedImages);

      const totalCount = (allImagesForManagement || []).length;
      showImagesProgress(100, '이미지 생성 완료', totalCount > 0 ? `소제목 이미지 ${totalCount}개 준비 완료` : '이미지 생성 완료');
      aiProgressModal.update(100, '✅ 이미지 생성 완료!');
      aiProgressModal.addLog('🎉 이미지 생성이 완료되었습니다.');

      appendLog(`🎉 총 ${generatedImages.length}개의 소제목 이미지가 생성되었습니다!`, 'images-log-output');
      appendLog(`💾 이미지가 저장되었습니다. 반자동 발행 시 자동으로 삽입됩니다.`, 'images-log-output');
      aiProgressModal.addLog(`🎉 총 ${generatedImages.length}개의 소제목 이미지가 생성되었습니다!`);
      aiProgressModal.addLog('💾 이미지가 저장되었습니다.');

      aiProgressModal.complete(true, {
        successTitle: '이미지 생성 완료!',
        successIcon: '✅',
        successLog: '🎉 이미지 생성 완료!'
      });

    } catch (error) {
      appendLog(`❌ 이미지 생성 실패: ${(error as Error).message}`, 'images-log-output');
      alert(`❌ 이미지 생성 실패: ${(error as Error).message}`);
      aiProgressModal.complete(false, {
        failureTitle: '이미지 생성 실패',
        failureIcon: '❌',
        failureLog: `❌ 이미지 생성 실패: ${(error as Error).message}`,
      });
    } finally {
      if (generateImagesBtnMain) {
        generateImagesBtnMain.disabled = false;
        generateImagesBtnMain.innerHTML = '<span style="font-size: 1.25rem;">🎨</span><span>프롬프트대로 이미지 생성하기</span>';
      }
    }
  });

  // ✅ 비어있는 소제목만 이미지 생성 버튼
  const generateRemainingImagesBtn = document.getElementById('generate-remaining-images-btn') as HTMLButtonElement;
  if (generateRemainingImagesBtn) {
    generateRemainingImagesBtn.addEventListener('click', async () => {
      const headings = getCurrentImageHeadings();
      if (headings.length === 0) {
        alert('먼저 소제목을 분석해주세요.');
        return;
      }

      // ✅ 버그 수정: ImageManager 기반으로 비어있는 소제목 감지 (DOM 대신)
      const emptyHeadings = headings.filter((h: any) => {
        const headingTitle = String(h?.title || h?.heading || '').trim();
        if (!headingTitle) return false;

        try {
          const resolvedKey = ImageManager.resolveHeadingKey(headingTitle);
          const primary = ImageManager.getImage(resolvedKey);
          const key = String(getStableImageKey(primary) || '').trim();
          if (!primary || !key) return true;

          const list = ImageManager.getImages(resolvedKey) || [];
          if (!Array.isArray(list) || list.length === 0) return true;

          return false;
        } catch {
          return true;
        }
      });

      if (emptyHeadings.length === 0) {
        alert('✅ 모든 소제목에 이미지가 배치되어 있습니다!');
        return;
      }

      const selectedSource = document.querySelector('.image-source-btn.selected') as HTMLButtonElement;
      const imageSource = selectedSource?.dataset.source || 'nano-banana-pro';

      try {
        generateRemainingImagesBtn.disabled = true;
        generateRemainingImagesBtn.innerHTML = '<span>🔄</span><span>생성 중...</span>';

        aiProgressModal.show('비어있는 소제목 이미지 생성 중...', {
          autoAnimate: false,
          icon: '✨',
          initialLog: '⏳ 비어있는 소제목에 이미지 생성을 시작합니다...',
        });
        showImagesProgress(0, '비어있는 소제목 이미지 생성 시작...', `${emptyHeadings.length}개 소제목 대상`);

        appendLog(`🎨 비어있는 ${emptyHeadings.length}개 소제목에 이미지 생성 시작...`, 'images-log-output');
        aiProgressModal.addLog(`🎨 비어있는 ${emptyHeadings.length}개 소제목에 이미지 생성 시작...`);

        for (let i = 0; i < emptyHeadings.length; i++) {
          const heading = emptyHeadings[i];
          const originalIndex = headings.findIndex((h: any) => h.title === heading.title);

          appendLog(`📸 [${i + 1}/${emptyHeadings.length}] "${heading.title}" 이미지 생성 중...`, 'images-log-output');
          const p = Math.floor((i / Math.max(1, emptyHeadings.length)) * 100);
          showImagesProgress(p, `이미지 생성 중... (${i + 1}/${emptyHeadings.length})`, String(heading.title || ''));
          aiProgressModal.update(p, `이미지 생성 중... (${i + 1}/${emptyHeadings.length})`);
          aiProgressModal.addLog(`📸 [${i + 1}/${emptyHeadings.length}] ${String(heading.title || '').trim()} 생성 중...`);

          await regenerateSingleImageForHeading(originalIndex, heading.title, heading.prompt);
        }

        // ✅ 영어 프롬프트 이미지 미리보기 업데이트
        const allImages = (window as any).imageManagementGeneratedImages || [];
        updatePromptItemsWithImages(allImages);

        appendLog(`✅ ${emptyHeadings.length}개 이미지 생성 완료!`, 'images-log-output');
        alert(`✅ ${emptyHeadings.length}개의 비어있는 소제목에 이미지가 생성되었습니다!`);

        showImagesProgress(100, '✅ 이미지 생성 완료!', `${emptyHeadings.length}개 완료`);
        aiProgressModal.complete(true, {
          successTitle: '이미지 생성 완료!',
          successIcon: '✅',
          successLog: `✅ ${emptyHeadings.length}개 이미지 생성 완료!`,
        });

      } catch (error) {
        appendLog(`❌ 이미지 생성 실패: ${(error as Error).message}`, 'images-log-output');
        alert(`❌ 이미지 생성 실패: ${(error as Error).message}`);
        aiProgressModal.complete(false, {
          failureTitle: '이미지 생성 실패',
          failureIcon: '❌',
          failureLog: `❌ 이미지 생성 실패: ${(error as Error).message}`,
        });
      } finally {
        generateRemainingImagesBtn.disabled = false;
        generateRemainingImagesBtn.innerHTML = '<span style="font-size: 1.25rem;">✨</span><span>비어있는 소제목만 이미지 생성</span>';
      }
    });
  }

  // ✅ 비어있는 소제목만 이미지 수집 버튼
  const collectRemainingImagesBtn = document.getElementById('collect-remaining-images-btn') as HTMLButtonElement;
  if (collectRemainingImagesBtn) {
    collectRemainingImagesBtn.addEventListener('click', async () => {
      const headings = getCurrentImageHeadings();
      if (headings.length === 0) {
        alert('먼저 소제목을 분석해주세요.');
        return;
      }

      // ✅ 버그 수정: ImageManager 기반으로 비어있는 소제목 감지 (DOM 대신)
      const emptyHeadings = headings.filter((h: any) => {
        const headingTitle = String(h?.title || h?.heading || '').trim();
        if (!headingTitle) return false;

        try {
          const resolvedKey = ImageManager.resolveHeadingKey(headingTitle);
          const primary = ImageManager.getImage(resolvedKey);
          const key = String(getStableImageKey(primary) || '').trim();
          if (!primary || !key) return true;

          const list = ImageManager.getImages(resolvedKey) || [];
          if (!Array.isArray(list) || list.length === 0) return true;

          return false;
        } catch {
          return true;
        }
      });

      if (emptyHeadings.length === 0) {
        alert('✅ 모든 소제목에 이미지가 배치되어 있습니다!');
        return;
      }

      // 검색어 가져오기
      let searchKeyword = (document.getElementById('image-title') as HTMLInputElement)?.value?.trim() || '';
      if (!searchKeyword) {
        searchKeyword = (document.getElementById('unified-generated-title') as HTMLInputElement)?.value?.trim() ||
          (document.getElementById('unified-title') as HTMLInputElement)?.value?.trim() || '';
      }

      if (!searchKeyword) {
        alert('⚠️ 이미지 수집을 위한 제목/키워드를 입력해주세요.');
        return;
      }

      try {
        collectRemainingImagesBtn.disabled = true;
        collectRemainingImagesBtn.innerHTML = '<span>🔄</span><span>수집 중...</span>';

        aiProgressModal.show('비어있는 소제목 이미지 수집 중...', {
          autoAnimate: false,
          icon: '🔍',
          initialLog: '⏳ 네이버 이미지 수집을 시작합니다...',
        });
        showImagesProgress(0, '이미지 수집 시작...', `${emptyHeadings.length}개 소제목 대상`);

        appendLog(`🔍 비어있는 ${emptyHeadings.length}개 소제목에 이미지 수집 시작...`, 'images-log-output');
        aiProgressModal.addLog(`🔍 비어있는 ${emptyHeadings.length}개 소제목에 이미지 수집 시작...`);

        // 네이버 이미지 검색
        showImagesProgress(10, '네이버 이미지 검색 중...', searchKeyword.substring(0, 40));
        aiProgressModal.update(10, '네이버 이미지 검색 중...');
        const result = await window.api.searchNaverImages(searchKeyword);

        if (result.success && result.images && result.images.length > 0) {
          // 비어있는 소제목에 이미지 배치
          const imagesToUse = result.images.slice(0, emptyHeadings.length);

          for (let i = 0; i < Math.min(imagesToUse.length, emptyHeadings.length); i++) {
            const heading = emptyHeadings[i];
            const image = imagesToUse[i];
            const originalIndex = headings.findIndex((h: any) => h.title === heading.title);

            const p = Math.floor(((i + 1) / Math.max(1, Math.min(imagesToUse.length, emptyHeadings.length))) * 90);
            showImagesProgress(p, `이미지 배치 중... (${i + 1}/${Math.min(imagesToUse.length, emptyHeadings.length)})`, String(heading.title || ''));
            aiProgressModal.update(p, `이미지 배치 중... (${i + 1}/${Math.min(imagesToUse.length, emptyHeadings.length)})`);
            aiProgressModal.addLog(`✅ [${i + 1}/${Math.min(imagesToUse.length, emptyHeadings.length)}] ${String(heading.title || '').trim()} 배치`);

            // ✅ 안전한 HTML 이스케이프
            const safeTitle = escapeHtml(heading.title || '');
            const safePrompt = escapeHtml(heading.prompt || '');
            const imageUrl = image.thumbnail || image.url || '';

            // 이미지 미리보기 업데이트
            const promptItem = document.querySelector(`.prompt-item[data-index="${originalIndex + 1}"]`);
            if (promptItem) {
              const imageContainer = promptItem.querySelector('.generated-image');
              if (imageContainer) {
                imageContainer.innerHTML = `
                  <img src="${imageUrl}" 
                       style="width: 100%; height: 100%; object-fit: cover; border-radius: 6px;"
                       onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23ddd%22 width=%22100%22 height=%22100%22/%3E%3Ctext x=%2250%22 y=%2250%22 text-anchor=%22middle%22 fill=%22%23999%22%3E로드 실패%3C/text%3E%3C/svg%3E'">
                  <div style="position: absolute; bottom: 0; left: 0; right: 0; padding: 0.5rem; background: linear-gradient(transparent, rgba(0,0,0,0.8)); display: flex; gap: 0.5rem; justify-content: center;">
                    <button type="button" class="select-local-image-btn" data-heading-index="${originalIndex}" style="padding: 0.25rem 0.5rem; background: #8b5cf6; color: white; border: none; border-radius: 4px; font-size: 0.75rem; cursor: pointer;">📁</button>
                    <button type="button" class="regenerate-single-image-btn" data-heading-index="${originalIndex}" style="padding: 0.25rem 0.5rem; background: #3b82f6; color: white; border: none; border-radius: 4px; font-size: 0.75rem; cursor: pointer;">🔄</button>
                    <button type="button" class="remove-heading-image-btn" data-heading-index="${originalIndex}" style="padding: 0.25rem 0.5rem; background: #ef4444; color: white; border: none; border-radius: 4px; font-size: 0.75rem; cursor: pointer;">🗑️</button>
                  </div>
                `;
                (imageContainer as HTMLElement).style.position = 'relative';

                ensurePromptCardRemoveButtons();
                ensurePromptCardRemoveHandler();
              }
            }

            // ImageManager에 등록
            ImageManager.setImage(heading.title, {
              heading: heading.title,
              filePath: image.url || image.thumbnail,
              previewDataUrl: image.thumbnail || image.url,
              provider: 'naver',
              url: image.url
            });
          }

          // ✅ 영어 프롬프트 이미지 미리보기 업데이트
          const allImages = (window as any).imageManagementGeneratedImages || [];
          updatePromptItemsWithImages(allImages);

          appendLog(`✅ ${Math.min(imagesToUse.length, emptyHeadings.length)}개 이미지 수집 완료!`, 'images-log-output');
          alert(`✅ ${Math.min(imagesToUse.length, emptyHeadings.length)}개의 이미지를 수집하여 배치했습니다!`);

          showImagesProgress(100, '✅ 이미지 수집 완료!', `${Math.min(imagesToUse.length, emptyHeadings.length)}개 배치 완료`);
          aiProgressModal.complete(true, {
            successTitle: '이미지 수집 완료!',
            successIcon: '✅',
            successLog: `✅ ${Math.min(imagesToUse.length, emptyHeadings.length)}개 이미지 수집 완료!`,
          });
        } else {
          throw new Error(result.message || '이미지를 찾을 수 없습니다.');
        }

      } catch (error) {
        appendLog(`❌ 이미지 수집 실패: ${(error as Error).message}`, 'images-log-output');
        alert(`❌ 이미지 수집 실패: ${(error as Error).message}`);
        aiProgressModal.complete(false, {
          failureTitle: '이미지 수집 실패',
          failureIcon: '❌',
          failureLog: `❌ 이미지 수집 실패: ${(error as Error).message}`,
        });
      } finally {
        collectRemainingImagesBtn.disabled = false;
        collectRemainingImagesBtn.innerHTML = '<span style="font-size: 1.25rem;">🔍</span><span>비어있는 소제목만 이미지 수집</span>';
      }
    });
  }

  // ✅ 쇼핑몰 이미지 수집 버튼 이벤트
  const shoppingCollectBtn = document.getElementById('shopping-collect-save-btn') as HTMLButtonElement;
  const shoppingUrlInput = document.getElementById('shopping-url-input') as HTMLInputElement;
  const shoppingCollectResult = document.getElementById('shopping-collect-result') as HTMLDivElement;
  const shoppingCollectContent = document.getElementById('shopping-collect-content') as HTMLDivElement;

  if (shoppingCollectBtn && shoppingUrlInput) {
    shoppingCollectBtn.addEventListener('click', async () => {
      const shoppingUrl = shoppingUrlInput.value.trim();

      if (!shoppingUrl) {
        alert('쇼핑몰 URL을 입력해주세요.');
        return;
      }

      try {
        shoppingCollectBtn.disabled = true;
        shoppingCollectBtn.innerHTML = '<span>🔄</span><span>수집 중...</span>';

        appendLog(`🛒 쇼핑몰 이미지 수집 시작: ${shoppingUrl}`, 'images-log-output');

        // IPC를 통해 쇼핑몰 이미지 수집 요청
        const result = await window.api.collectImagesFromShopping(shoppingUrl);

        if (result.success && result.images && result.images.length > 0) {
          // ✅ 전체 수집된 이미지 개수 알림
          const totalCollected = result.images.length;
          appendLog(`🎉 쇼핑몰에서 총 ${totalCollected}개의 이미지를 수집했습니다!`, 'images-log-output');
          toastManager.info(`🛒 총 ${totalCollected}개 쇼핑몰 이미지 수집 완료!`);

          // ✅ 소제목 정보 가져오기
          const currentHeadings = getCurrentImageHeadings();

          // ✅ 소제목 개수 확인 - 소제목이 있으면 소제목 개수만큼, 없으면 5개 기본
          const targetCount = currentHeadings.length > 0 ? currentHeadings.length : 5;
          appendLog(`📊 소제목 ${currentHeadings.length}개 감지 → ${targetCount}개 이미지 소제목에 배치`, 'images-log-output');

          // ✅ 수집된 이미지를 소제목에 맞게 배치 (소제목 개수만큼만!)
          const collectedImages = result.images.slice(0, targetCount).map((img: any, idx: number) => ({
            heading: currentHeadings[idx]?.title || `소제목 ${idx + 1}`,
            filePath: img.url || img.filePath,
            url: img.url || img.filePath,
            previewDataUrl: img.url || img.filePath,
            prompt: img.alt || '쇼핑몰 제품 이미지',
            provider: 'shopping',
            headingIndex: idx
          }));

          appendLog(`🖼️ 쇼핑몰 이미지 ${collectedImages.length}개가 소제목에 매칭됨`, 'images-log-output');

          // ✅ 나머지 이미지 (소제목에 배치되지 않은 이미지)
          const remainingImages = result.images.slice(targetCount);
          const remainingCount = remainingImages.length;

          if (remainingCount > 0) {
            appendLog(`📦 나머지 ${remainingCount}개 이미지를 추가 보관합니다...`, 'images-log-output');
          }

          // ✅ 전체 이미지 (배치된 이미지 + 나머지 이미지) 로컬에 저장
          // ✅ result.images는 문자열 배열 또는 객체 배열일 수 있음
          const allImagesToSave = result.images.map((img: any, idx: number) => ({
            url: typeof img === 'string' ? img : (img.url || img.filePath || img.link || img.thumbnail || ''),
            heading: idx < targetCount
              ? (currentHeadings[idx]?.title || `소제목 ${idx + 1}`)
              : `예비 이미지 ${idx - targetCount + 1}`
          }));

          appendLog(`💾 전체 ${allImagesToSave.length}개 이미지를 로컬 폴더에 저장 중...`, 'images-log-output');

          // ✅ [2026-01-21] 폴더명을 글 제목 또는 제품명으로 생성 (특수문자 제거)
          const blogTitle = (document.getElementById('unified-generated-title') as HTMLInputElement)?.value?.trim() ||
            (document.getElementById('unified-title') as HTMLInputElement)?.value?.trim() ||
            (result as any).productName || (result as any).name || '';
          const sanitizedFolderName = blogTitle
            .replace(/[<>:"/\\|?*]/g, '')  // 경로 불가 문자 제거
            .replace(/\s+/g, ' ')           // 연속 공백 제거
            .trim()
            .substring(0, 50) || '쇼핑몰_' + new Date().getTime();  // 50자 제한, 폴백

          const saveResult = await window.api.downloadAndSaveMultipleImages(
            allImagesToSave,
            sanitizedFolderName
          );

          // 저장된 경로로 이미지 업데이트
          if (saveResult.success && saveResult.savedImages) {
            collectedImages.forEach((img, idx) => {
              const savedImg = saveResult.savedImages[idx];
              if (savedImg?.filePath) {
                // ✅ 로컬 경로로 모든 URL 필드 업데이트 (외부 URL은 로드 실패함)
                const localPath = savedImg.filePath;
                img.filePath = localPath;
                img.url = localPath;
                img.previewDataUrl = localPath;
                (img as any).savedToLocal = savedImg.savedToLocal ?? true;
              }
            });

            const savedCount = saveResult.savedImages.filter((i: any) => i && i.filePath).length;
            appendLog(`💾 ${savedCount}개 이미지 로컬 저장 완료!`, 'images-log-output');

            if (saveResult.folderPath) {
              appendLog(`📁 저장 위치: ${saveResult.folderPath}`, 'images-log-output');
            }

            // ✅ 나머지 이미지 정보 표시
            if (remainingCount > 0) {
              appendLog(`✨ 소제목에 ${collectedImages.length}개 배치 + 예비 ${remainingCount}개 저장됨`, 'images-log-output');
              appendLog(`💡 팁: 예비 이미지를 사용하려면 소제목 옆 📁 버튼을 눌러 변경하세요!`, 'images-log-output');
            }
          }

          // ✅ 전역 변수에 설정 (기존 이미지 대체)
          generatedImages = collectedImages;
          (window as any).imageManagementGeneratedImages = collectedImages;

          // ✅✅ [신규] currentStructuredContent.images에도 저장 (쇼핑커넥트 참조 이미지용)
          if (currentStructuredContent) {
            (currentStructuredContent as any).images = collectedImages;
            (window as any).currentStructuredContent = currentStructuredContent;
            console.log(`[Renderer] ✅ currentStructuredContent.images에 ${collectedImages.length}개 수집 이미지 저장됨`);
          }

          // ✅ ImageManager에 이미지 등록 (발행 시 매칭을 위해 필수!)
          collectedImages.forEach((img: any) => {
            if (img.heading) {
              ImageManager.setImage(img.heading, {
                ...img,
                timestamp: Date.now()
              });
              console.log(`[ImageManager] 쇼핑몰 이미지 등록: "${img.heading}" → ${img.filePath?.substring(0, 50)}...`);
            }
          });
          appendLog(`🔗 ImageManager에 ${collectedImages.length}개 이미지 등록 완료 (발행 시 소제목과 자동 매칭)`, 'images-log-output');

          // ✅ 그리드에 이미지 표시
          displayGeneratedImages(collectedImages);

          // ✅ 소제목 미리보기에도 이미지 배치
          updatePromptItemsWithImages(collectedImages);

          // ✅ 예비 이미지 빠른 교체 썸네일 업데이트
          updateReserveImagesThumbnails();

          // 결과 표시
          if (shoppingCollectResult && shoppingCollectContent) {
            shoppingCollectResult.style.display = 'block';
            shoppingCollectContent.innerHTML = `✅ ${collectedImages.length}개의 이미지가 로컬에 저장되고 소제목에 배치되었습니다!`;
          }

          appendLog(`✅ ${collectedImages.length}개의 쇼핑몰 이미지 수집 및 저장 완료!`, 'images-log-output');
          toastManager.success(`✅ ${collectedImages.length}개의 이미지가 로컬에 저장되고 소제목에 배치되었습니다!`);
        } else {
          throw new Error(result.message || '이미지를 찾을 수 없습니다.');
        }
      } catch (error) {
        const errorMessage = (error as Error).message;
        appendLog(`❌ 쇼핑몰 이미지 수집 실패: ${errorMessage}`, 'images-log-output');

        if (shoppingCollectResult && shoppingCollectContent) {
          shoppingCollectResult.style.display = 'block';
          shoppingCollectContent.innerHTML = `❌ 수집 실패: ${errorMessage}`;
        }

        alert(`❌ 쇼핑몰 이미지 수집에 실패했습니다.\n\n오류: ${errorMessage}`);
      } finally {
        shoppingCollectBtn.disabled = false;
        shoppingCollectBtn.innerHTML = '<span>🛒</span><span>쇼핑몰 이미지 수집 및 저장</span>';
      }
    });
  }

  // ✅ AI 자동 수집 및 저장하기 버튼 (네이버 이미지 검색 API 활용)
  const aiAutoCollectBtn = document.getElementById('ai-auto-collect-save-btn') as HTMLButtonElement;

  if (aiAutoCollectBtn) {
    aiAutoCollectBtn.addEventListener('click', async () => {
      // 제목 또는 키워드 가져오기
      const imageTitleInputLocal = document.getElementById('image-title') as HTMLInputElement;
      let searchKeyword = imageTitleInputLocal?.value?.trim() || '';

      // 제목이 없으면 통합탭에서 가져오기
      if (!searchKeyword) {
        searchKeyword = (document.getElementById('unified-generated-title') as HTMLInputElement)?.value?.trim() ||
          (document.getElementById('unified-title') as HTMLInputElement)?.value?.trim() || '';
      }

      if (!searchKeyword) {
        alert('⚠️ 제목이나 키워드를 입력해주세요.\n\n이미지 관리탭의 제목 필드 또는 스마트 자동 발행 탭의 제목을 입력하세요.');
        return;
      }

      // ✅ 실시간 정보로 수집하기 체크박스 확인
      const realtimeCrawlCheckbox = document.getElementById('image-realtime-crawl') as HTMLInputElement;
      const useRealtimeCrawl = realtimeCrawlCheckbox?.checked ?? true;

      // ✅ 이 버튼은 무조건 네이버 API로만 이미지 수집 (AI 이미지 생성은 별도 버튼에서 처리)

      try {
        aiAutoCollectBtn.disabled = true;
        aiAutoCollectBtn.innerHTML = '<span>🔄</span><span>네이버 이미지 수집 중...</span>';

        let result: any;

        // ✅ AI 자동 수집 버튼은 무조건 네이버 API로만 이미지 수집 (AI 이미지 생성은 별도 기능)
        appendLog(`🔍 네이버 API로 이미지 50개 수집 시작: "${searchKeyword}"`, 'images-log-output');

        // ✅ [100점 개선] AI 자동 수집 - 소제목별 개별 검색 + URL 이미지 우선 + Gemini 문맥 분석
        appendLog(`🚀 [100점 모드] AI 스마트 이미지 수집 시작: "${searchKeyword}"`, 'images-log-output');

        // ✅ 소제목 정보 가져오기
        const currentHeadings = getCurrentImageHeadings();
        const targetCount = currentHeadings.length > 0 ? currentHeadings.length : 5;
        appendLog(`📊 소제목 ${currentHeadings.length}개 감지`, 'images-log-output');

        // ✅ 핵심 주제 추출 (폴백용)
        let coreSubject = searchKeyword.split(' ')[0];
        try {
          const coreResult = await (window.api as any).extractCoreSubject(searchKeyword);
          if (coreResult.success && coreResult.subject) {
            coreSubject = coreResult.subject;
            appendLog(`🎯 핵심 주제 추출: "${coreSubject}"`, 'images-log-output');
          }
        } catch (err) {
          console.warn('[AI 수집] 핵심 주제 추출 실패, 폴백 사용');
        }

        // ✅ URL 입력 확인 (통합탭 또는 이미지탭)
        const sourceUrlInput = document.getElementById('unified-source-url') as HTMLInputElement ||
          document.getElementById('image-source-url') as HTMLInputElement;
        const sourceUrl = sourceUrlInput?.value?.trim() || '';

        let urlImages: string[] = [];

        // ✅ 1단계: URL 이미지 크롤링 (있는 경우) → 1번 소제목(썸네일)에 배치
        if (sourceUrl && (sourceUrl.startsWith('http://') || sourceUrl.startsWith('https://'))) {
          appendLog(`🔗 URL에서 이미지 크롤링 중: ${sourceUrl.substring(0, 50)}...`, 'images-log-output');
          try {
            const crawlResult = await (window.api as any).crawlImagesFromUrl(sourceUrl);
            if (crawlResult.success && crawlResult.images && crawlResult.images.length > 0) {
              urlImages = crawlResult.images;
              appendLog(`✅ URL에서 ${urlImages.length}개 이미지 발견!`, 'images-log-output');
            }
          } catch (err) {
            appendLog(`⚠️ URL 크롤링 실패: ${(err as Error).message}`, 'images-log-output');
          }
        }

        // ✅ [100점 최종] 2단계: 배치 검색어 최적화 (Gemini 1회 호출)
        const headingTitles = currentHeadings.map((h: any) => h.title || `소제목 ${currentHeadings.indexOf(h) + 1}`);
        let optimizedQueries: Array<{ heading: string; optimizedQuery: string; broaderQuery: string }> = [];

        try {
          appendLog(`🧠 Gemini 배치 검색어 최적화 중... (API 호출 1회)`, 'images-log-output');
          const batchResult = await (window.api as any).batchOptimizeSearchQueries(searchKeyword, headingTitles);
          if (batchResult.success && batchResult.results) {
            optimizedQueries = batchResult.results;
            appendLog(`✅ ${optimizedQueries.length}개 소제목 검색어 최적화 완료!`, 'images-log-output');
          }
        } catch (err) {
          console.warn('[AI 수집] 배치 최적화 실패, 기본 키워드 사용');
        }

        // 폴백: 최적화 실패 시 기본 쿼리 생성
        if (optimizedQueries.length === 0) {
          optimizedQueries = headingTitles.map((h: string) => ({
            heading: h,
            optimizedQuery: h,
            broaderQuery: coreSubject
          }));
        }

        // ✅ [100점 최종] 3단계: 병렬 이미지 검색 (Promise.all)
        appendLog(`⚡ 병렬 이미지 검색 시작 (${targetCount}개 동시)...`, 'images-log-output');

        const searchPromises = optimizedQueries.slice(0, targetCount).map(async (q, i) => {
          const heading = q.heading;

          // 1번 소제목(썸네일)이고 URL 이미지가 있으면 URL 이미지 우선 사용
          if (i === 0 && urlImages.length > 0) {
            return {
              heading,
              filePath: urlImages[0],
              url: urlImages[0],
              previewDataUrl: urlImages[0],
              prompt: '썸네일 (URL)',
              provider: 'url',
              headingIndex: i,
              success: true
            };
          }

          // 네이버 검색 (3단계 폴백)
          let searchResult = await window.api.searchNaverImages(q.optimizedQuery);

          if (!searchResult.success || !searchResult.images || searchResult.images.length === 0) {
            searchResult = await window.api.searchNaverImages(q.broaderQuery);
          }

          if (!searchResult.success || !searchResult.images || searchResult.images.length === 0) {
            searchResult = await window.api.searchNaverImages(coreSubject);
          }

          if (searchResult.success && searchResult.images && searchResult.images.length > 0) {
            // ✅ [100점] 품질 필터: 해상도 400x300 이상만 선택
            const qualityImages = searchResult.images.filter((img: any) => {
              const w = parseInt(img.sizewidth || img.width || '0', 10);
              const h = parseInt(img.sizeheight || img.height || '0', 10);
              return (w >= 400 && h >= 300) || (w === 0 && h === 0);
            });

            const targetImages = qualityImages.length > 0 ? qualityImages : searchResult.images;
            const selectedImage = targetImages[i % targetImages.length] || targetImages[0];

            // ✅ [100점 개선] 예비 이미지 5개 추가 수집 (폴더 저장용)
            const backupImages: any[] = [];
            for (let j = 1; j <= 5 && j < targetImages.length; j++) {
              const backupImg = targetImages[(i + j) % targetImages.length];
              if (backupImg && (backupImg.url || backupImg.link) !== (selectedImage.url || selectedImage.link)) {
                backupImages.push({
                  url: backupImg.url || backupImg.link,
                  heading: `${heading} (예비${j})`
                });
              }
            }

            return {
              heading,
              filePath: selectedImage.url || selectedImage.link,
              url: selectedImage.url || selectedImage.link,
              previewDataUrl: selectedImage.thumbnail || selectedImage.url,
              prompt: q.optimizedQuery,
              provider: 'naver',
              headingIndex: i,
              success: true,
              backupImages // ✅ 예비 이미지 배열
            };
          }

          // URL 이미지 폴백
          if (urlImages.length > i) {
            return {
              heading,
              filePath: urlImages[i],
              url: urlImages[i],
              previewDataUrl: urlImages[i],
              prompt: 'URL 이미지',
              provider: 'url',
              headingIndex: i,
              success: true
            };
          }

          return { heading, headingIndex: i, success: false };
        });

        const searchResults = await Promise.all(searchPromises);
        const collectedImages: any[] = searchResults.filter((r: any) => r.success);

        // 로그 출력
        searchResults.forEach((r: any, i: number) => {
          if (r.success) {
            appendLog(`   ✅ [${i + 1}] "${r.heading}" → ${r.provider} 이미지`, 'images-log-output');
          } else {
            appendLog(`   ⚠️ [${i + 1}] "${r.heading}" → 이미지 없음`, 'images-log-output');
          }
        });

        if (collectedImages.length > 0) {
          appendLog(`🎉 총 ${collectedImages.length}개 이미지 수집 완료!`, 'images-log-output');
          toastManager.info(`🖼️ ${collectedImages.length}개 스마트 이미지 수집 완료!`);

          // ✅ 이미지를 로컬 폴더에 저장 (메인 이미지)
          const allImagesToSave = collectedImages.map((img: any) => ({
            url: img.url,
            heading: img.heading
          }));

          // ✅ [100점 개선] 예비 이미지도 폴더에 저장 (UI에는 표시 안 함)
          let backupCount = 0;
          collectedImages.forEach((img: any) => {
            if (img.backupImages && Array.isArray(img.backupImages)) {
              img.backupImages.forEach((backup: any) => {
                allImagesToSave.push(backup);
                backupCount++;
              });
            }
          });

          if (backupCount > 0) {
            appendLog(`📂 예비 이미지 ${backupCount}개도 함께 저장 (폴더 전용)`, 'images-log-output');
          }

          appendLog(`💾 ${allImagesToSave.length}개 이미지를 로컬 폴더에 저장 중...`, 'images-log-output');
          const saveResult = await window.api.downloadAndSaveMultipleImages(
            allImagesToSave,
            searchKeyword
          );

          // 저장된 경로로 이미지 업데이트 (heading 기반 매칭)
          if (saveResult.success && saveResult.savedImages) {
            // ✅ heading 기반으로 매칭 (다운로드 실패 시 인덱스 어긋남 방지)
            const savedMap = new Map(
              saveResult.savedImages
                .filter((s: any) => s && s.heading && s.filePath)
                .map((s: any) => [s.heading, s.filePath])
            );

            collectedImages.forEach((img: any) => {
              const savedPath = savedMap.get(img.heading);
              if (savedPath) {
                img.filePath = savedPath;
                img.url = savedPath;
                img.previewDataUrl = savedPath;
                (img as any).savedToLocal = true;
              }
              // ✅ 저장 실패 시 원본 URL 유지 (이미 설정된 url 사용)
            });

            const savedCount = saveResult.savedImages.filter((i: any) => i && i.filePath).length;
            appendLog(`💾 ${savedCount}개 이미지 로컬 저장 완료!`, 'images-log-output');
            if (saveResult.folderPath) {
              appendLog(`📁 저장 위치: ${saveResult.folderPath}`, 'images-log-output');
            }

            // ✅ 일부 이미지 저장 실패 알림
            const failedCount = collectedImages.length - savedCount;
            if (failedCount > 0) {
              appendLog(`⚠️ ${failedCount}개 이미지는 원본 URL로 표시됩니다 (다운로드 실패)`, 'images-log-output');
            }
          }

          // ✅ 전역 변수에 설정
          generatedImages = collectedImages as any[];
          (window as any).imageManagementGeneratedImages = collectedImages;

          // ✅ ImageManager에 등록
          collectedImages.forEach((img: any) => {
            if (img.heading) {
              ImageManager.setImage(img.heading, {
                ...img,
                timestamp: Date.now()
              });
            }
          });
          appendLog(`🔗 ImageManager에 ${collectedImages.length}개 이미지 등록 완료`, 'images-log-output');

          // ✅ UI 업데이트
          displayGeneratedImages(collectedImages);
          updatePromptItemsWithImages(collectedImages);
          updateReserveImagesThumbnails();

          appendLog(`✅ [100점 모드] 스마트 이미지 수집 완료!`, 'images-log-output');
          toastManager.success(`✅ ${collectedImages.length}개의 이미지가 소제목별로 배치되었습니다!`);
        } else {
          throw new Error(result.message || '이미지를 찾을 수 없습니다.');
        }
      } catch (error) {
        const errorMessage = (error as Error).message;
        appendLog(`❌ 네이버 이미지 수집 실패: ${errorMessage}`, 'images-log-output');
        alert(`❌ 이미지 수집에 실패했습니다.\n\n오류: ${errorMessage}\n\n네이버 API 키가 설정되어 있는지 확인해주세요.`);
      } finally {
        aiAutoCollectBtn.disabled = false;
        aiAutoCollectBtn.innerHTML = '<span>🤖</span><span>AI 자동 수집 및 저장하기</span>';
      }
    });
  }
}

// ✅ 수집된 이미지 표시 함수
function displayCollectedImages(images: any[]): void {
  const previewContainer = document.getElementById('images-preview-grid') ||
    document.getElementById('generated-images-preview') ||
    document.querySelector('.generated-images-grid');

  if (!previewContainer) {
    console.log('[Images] 미리보기 컨테이너를 찾을 수 없습니다.');
    return;
  }

  // 기존 이미지 유지하면서 추가
  images.filter(img => img).forEach((img, idx) => {
    if (!img) return;
    const imageDiv = document.createElement('div');
    imageDiv.className = 'collected-image-item';
    imageDiv.style.cssText = `
      position: relative;
      border-radius: 8px;
      overflow: hidden;
      aspect-ratio: 1;
      background: var(--bg-tertiary);
      cursor: pointer;
    `;

    imageDiv.innerHTML = `
      <img src="${toFileUrlMaybe(img.previewDataUrl || img.url || img.filePath || '')}" alt="${img.heading || ''}" 
           style="width: 100%; height: 100%; object-fit: cover;"
           onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23ddd%22 width=%22100%22 height=%22100%22/%3E%3Ctext x=%2250%22 y=%2250%22 text-anchor=%22middle%22 fill=%22%23999%22%3E이미지%3C/text%3E%3C/svg%3E'">
      <div style="position: absolute; bottom: 0; left: 0; right: 0; padding: 0.5rem; background: linear-gradient(transparent, rgba(0,0,0,0.8)); color: white; font-size: 0.75rem;">
        ${img.heading}
      </div>
      <button class="select-image-btn" data-image-index="${idx}" style="position: absolute; top: 0.25rem; right: 0.25rem; width: 24px; height: 24px; border-radius: 50%; background: var(--primary); color: white; border: none; cursor: pointer; font-size: 0.75rem;">✓</button>
    `;

    previewContainer.appendChild(imageDiv);
  });

  appendLog(`📸 ${images.length}개 이미지가 미리보기에 추가되었습니다.`, 'images-log-output');
}

// 소제목에서 영어 프롬프트 생성
function extractHeadingsFromContent(content: string): any[] {
  const headings = content.split('\n').filter(line => line.trim().startsWith('## ')).map(line => line.trim().substring(3));

  return headings.map(heading => ({
    title: heading,
    prompt: getManualEnglishPromptOverrideForHeading(heading) || generateEnglishPromptForHeadingSync(heading)
  }));
}

// ✅ [2026-01-25 모듈화] 프롬프트 오버라이드 함수들
// → ./utils/promptOverrideUtils.js로 이동됨 (상단 import 참조)
// - getManualEnglishPromptOverridesStore
// - getManualEnglishPromptOverrideForHeading
// - setManualEnglishPromptOverrideForHeading
// - clearManualEnglishPromptOverrideForHeading

// 영어 프롬프트 생성 (동적 번역 적용) - ✅ 구체적인 이미지 프롬프트 생성
function generateEnglishPromptForHeadingSync(heading: string): string {
  // ✅ 1단계: 프롬프트 정리
  let cleanPrompt = heading
    .replace(/【[^】]*】/g, '') // 【...】 괄호와 그 안의 내용 제거
    .replace(/\[[^\]]*\]/g, '') // [...] 괄호와 그 안의 내용 제거
    .replace(/^\s*\d+[\.\s\)]*/, '') // 시작 부분의 숫자와 점(1. 2.) 제거
    .replace(/[\u{1F300}-\u{1F9FF}]/gu, '') // 이모지 제거
    .replace(/[?,!]/g, '') // 물음표, 느낌표 제거
    .replace(/\s+/g, ' ')
    .trim();

  // 만약 정제 후 비어있다면 원본 사용 (최후의 보루)
  if (!cleanPrompt) cleanPrompt = heading.trim();

  // ✅ 소제목 패턴 감지 및 구체적 프롬프트 생성
  const patterns: Array<{ pattern: RegExp; prompt: (match: RegExpMatchArray) => string }> = [
    // 개인정보/보안 관련
    { pattern: /개인정보.*유출|유출.*개인정보|정보.*유출/, prompt: () => 'digital data leak security breach, hacker computer screen, cybersecurity concept, dramatic lighting, 4k' },
    { pattern: /해킹|사이버.*공격/, prompt: () => 'hacker in dark room, computer screens with code, cybersecurity attack, dramatic blue light, 4k' },
    { pattern: /보안|보호|방지/, prompt: () => 'digital security shield, protection concept, lock and data, professional tech, 4k' },

    // 정부/정책 관련
    { pattern: /정부.*대책|정부.*노력|정부.*대응/, prompt: () => 'government officials meeting, policy discussion, official building, professional setting, 4k' },
    { pattern: /정책|법안|규제/, prompt: () => 'legal documents, policy papers, government seal, professional office, 4k' },

    // 피해/영향 관련
    { pattern: /피해.*예방|2차.*피해|추가.*피해/, prompt: () => 'protection shield concept, safety measure, warning prevention, professional infographic style, 4k' },
    { pattern: /피해|손실|손해/, prompt: () => 'worried person checking phone, concerned expression, modern setting, realistic, 4k' },

    // 뉴스/속보 관련
    { pattern: /속보|긴급|충격|발표/, prompt: () => 'breaking news concept, news studio, urgent announcement, professional media, 4k' },
    { pattern: /뉴스|소식|보도/, prompt: () => 'news broadcast studio, professional journalism, media coverage, 4k' },

    // 쇼핑몰/이커머스 관련
    { pattern: /쿠팡|배달|이커머스|온라인.*쇼핑/, prompt: () => 'e-commerce delivery concept, online shopping, packages and smartphone, modern, 4k' },
    { pattern: /스마트스토어|네이버.*쇼핑|쇼핑몰/, prompt: () => 'online marketplace concept, shopping cart and products, e-commerce, modern design, 4k' },

    // 건강/의료 관련
    { pattern: /건강.*팁|건강.*관리|건강.*비결/, prompt: () => 'healthy lifestyle concept, fitness and nutrition, fresh vegetables, bright positive mood, 4k' },
    { pattern: /병원|진료|치료/, prompt: () => 'modern hospital interior, healthcare concept, medical equipment, clean professional, 4k' },
    { pattern: /운동|피트니스|헬스/, prompt: () => 'fitness workout concept, gym equipment, healthy person exercising, energetic, 4k' },

    // 음식/요리 관련
    { pattern: /레시피|요리.*방법|만들기/, prompt: () => 'cooking preparation, kitchen scene, fresh ingredients, appetizing food photography, 4k' },
    { pattern: /맛집|식당|음식점/, prompt: () => 'restaurant interior, delicious food served, dining experience, warm lighting, 4k' },
    { pattern: /아침.*식사|저녁.*식사|점심/, prompt: () => 'delicious meal setting, food photography, fresh ingredients, appetizing, 4k' },

    // 연예/스포츠 관련 (인물 중심)
    { pattern: /배우|연예인|가수|아이돌|스타|활동/, prompt: (match: any) => `famous Korean celebrity ${match[0]}, professional K-star photography, detailed facial features, realistic likeness, 8k` },
    { pattern: /결혼|열애|열애설|발표/, prompt: () => 'Korean celebrity news, romantic and elegant atmosphere, happy celebrity couple concept, professional photography, 16:9' },
    { pattern: /근황|모습|일상/, prompt: () => 'Korean celebrity lifestyle, natural candid photography, high-end editorial style, real-life resemblance, 4k' },

    // 여행/관광 관련
    { pattern: /여행.*팁|여행.*추천|여행지/, prompt: () => 'travel destination scenery, tourism concept, beautiful landscape, vacation mood, 4k' },
    { pattern: /호텔|숙소|리조트/, prompt: () => 'luxury hotel interior, travel accommodation, comfortable room, elegant, 4k' },

    // 기술/IT 관련
    { pattern: /AI|인공지능|머신러닝/, prompt: () => 'artificial intelligence concept, futuristic technology, neural network visualization, modern tech, 4k' },
    { pattern: /스마트폰|모바일|앱/, prompt: () => 'smartphone technology concept, mobile app interface, modern device, clean design, 4k' },

    // 금융/경제 관련
    { pattern: /투자|주식|재테크/, prompt: () => 'investment concept, stock market chart, financial growth, professional business, 4k' },
    { pattern: /경제|금융|은행/, prompt: () => 'business finance concept, money and charts, professional economy, 4k' },

    // 교육/학습 관련
    { pattern: /공부.*방법|학습.*팁|교육/, prompt: () => 'education learning concept, books and study materials, student studying, bright atmosphere, 4k' },

    // 뷰티/패션 관련
    { pattern: /뷰티|화장|메이크업/, prompt: () => 'beauty cosmetics concept, makeup products, elegant skincare, professional photography, 4k' },
    { pattern: /패션|스타일|코디/, prompt: () => 'fashion style concept, trendy outfit, modern clothing, professional fashion photography, 4k' },

    // 부동산/인테리어 관련
    { pattern: /부동산|아파트|집/, prompt: () => 'modern apartment interior, real estate concept, beautiful home, bright living space, 4k' },
    { pattern: /인테리어|가구|꾸미기/, prompt: () => 'interior design concept, stylish home decor, modern furniture, aesthetic room, 4k' },

    // 자동차/교통 관련
    { pattern: /자동차|차량|드라이브/, prompt: () => 'modern car concept, automobile technology, sleek vehicle design, professional auto photography, 4k' },

    // 일반 질문 패턴
    { pattern: /어떻게|방법|팁/, prompt: () => 'helpful tips concept, how-to guide, step by step instruction, informative, 4k' },
    { pattern: /왜|이유|원인/, prompt: () => 'thinking person concept, question and answer, curious expression, analytical, 4k' },
    { pattern: /무엇|뭐|어떤/, prompt: () => 'information discovery concept, learning and research, knowledge exploration, 4k' },
  ];

  // 패턴 매칭
  for (const { pattern, prompt } of patterns) {
    const match = cleanPrompt.match(pattern);
    if (match) {
      console.log(`[EnglishPrompt] 패턴 매칭: "${cleanPrompt}" → 구체적 프롬프트 생성`);
      const base = prompt(match);
      const reviewAnchor = getReviewProductAnchor();
      if (reviewAnchor) {
        return `${base}, product review, hands-on real-world usage of ${reviewAnchor}, realistic tabletop scene, Korean hands/person (if a person appears), Korean lifestyle context, natural lighting, close-up detail, 4k`;
      }
      // 연예 카테고리인 경우 한국인 특성 추가
      const finalPrompt = base.includes('celebrity') || base.includes('K-star')
        ? `${base}, authentic Korean ethnicity, specific facial resemblance, realistic skin texture`
        : base;
      return finalPrompt;
    }
  }

  // ✅ 2단계: 한영 번역 사전 (imageGenerator.ts와 동일)
  const koreanToEnglish: Record<string, string> = {
    // 기본/일반
    '아침 식사': 'breakfast', '아침식사': 'breakfast', '아침': 'morning', '식사': 'meal',
    '건강': 'healthy', '건강한': 'healthy', '완성': 'complete', '팁': 'tips',
    '방법': 'method', '중요': 'important', '시작': 'start', '나만의': 'personal',
    '맞춤': 'customized', '추천': 'recommended',

    // 연령대
    '40대': 'middle aged', '30대': 'young adult', '50대': 'mature',
    '20대': 'young', '60대': 'senior',

    // 음식
    '메뉴': 'menu', '레시피': 'recipe', '요리': 'cooking', '음식': 'food',
    '영양': 'nutrition', '영양 가득한': 'nutritious', '가득한': 'full of',
    '단백질': 'protein', '채소': 'vegetables', '과일': 'fruits',
    '달걀': 'egg', '계란': 'egg', '우유': 'milk', '빵': 'bread',
    '샐러드': 'salad', '국수': 'noodles', '밥': 'rice', '고기': 'meat',
    '생선': 'fish', '치킨': 'chicken', '피자': 'pizza', '햄버거': 'hamburger',
    '커피': 'coffee', '차(음료)': 'tea', '주스': 'juice',
    '디저트': 'dessert', '케이크': 'cake',

    // 시간/속도
    '초간단': 'quick easy', '간단하면서도': 'simple', '5분': 'five minutes',
    '10분': 'ten minutes', '간단': 'simple', '빠른': 'fast', '느린': 'slow',
    '즉시': 'immediate', '지금': 'now', '오늘': 'today', '내일': 'tomorrow',
    '어제': 'yesterday', '주간': 'weekly', '월간': 'monthly', '연간': 'yearly',

    // 영화/엔터테인먼트
    '영화': 'movie film', '시상식': 'award ceremony', '레드카펫': 'red carpet',
    '영화제': 'film festival', '시상': 'award', '수상': 'award winning',
    '배우': 'actor actress', '연기자': 'actor', '감독': 'director',
    '제작': 'production', '촬영': 'filming shooting', '촬영 중': 'filming',
    '불참': 'absence', '참석': 'attendance', '포착': 'captured',
    '공개': 'public', '발표': 'announcement', '소식': 'news', '뉴스': 'news',
    '연예': 'entertainment', '연예계': 'entertainment industry',
    '스타': 'star celebrity', '아이돌': 'idol', '가수': 'singer',
    '그룹': 'group', '콘서트': 'concert', '공연': 'performance',
    '무대': 'stage', '드라마': 'drama', '시리즈': 'series',
    '프리미어': 'premiere', '개봉': 'release', '흥행': 'box office',
    '관객': 'audience', '평점': 'rating', '트레일러': 'trailer', '포스터': 'poster',

    // 스포츠
    '스포츠': 'sports', '축구': 'soccer football', '야구': 'baseball',
    '농구': 'basketball', '배구': 'volleyball', '테니스': 'tennis',
    '골프': 'golf', '수영': 'swimming', '달리기': 'running',
    '경기': 'game match', '경쟁': 'competition', '선수': 'player athlete',
    '팀': 'team', '우승': 'championship', '승리': 'victory win',
    '패배': 'defeat loss', '득점': 'score', '골': 'goal',
    '경기장': 'stadium', '올림픽': 'olympics', '월드컵': 'world cup',

    // 기술/IT
    '기술': 'technology', 'IT': 'IT', '컴퓨터': 'computer',
    '스마트폰': 'smartphone', '폰': 'phone', '태블릿': 'tablet',
    '노트북': 'laptop', '게임': 'game', '앱': 'app application',
    '소프트웨어': 'software', '하드웨어': 'hardware',
    '인공지능': 'artificial intelligence AI', 'AI': 'AI', '로봇': 'robot',
    '인터넷': 'internet', '웹': 'web', '사이트': 'site website',
    '프로그램': 'program', '개발': 'development', '코딩': 'coding',
    '프로그래밍': 'programming', '데이터': 'data', '정보': 'information',
    '보안': 'security', '해킹': 'hacking', '바이러스': 'virus',

    // 패션/뷰티
    '패션': 'fashion', '옷': 'clothes clothing', '의류': 'clothing',
    '스타일': 'style', '코디': 'coordination', '옷차림': 'outfit',
    '드레스': 'dress', '정장': 'suit', '신발': 'shoes', '가방': 'bag',
    '악세서리': 'accessories', '화장품': 'cosmetics', '뷰티': 'beauty',
    '메이크업': 'makeup', '스킨케어': 'skincare', '헤어': 'hair',
    '네일': 'nail', '향수': 'perfume', '브랜드': 'brand', '디자인': 'design',

    // 여행/관광
    '여행': 'travel tourism', '관광': 'tourism', '휴가': 'vacation holiday',
    '휴양': 'resort', '호텔': 'hotel', '리조트': 'resort', '해변': 'beach',
    '바다': 'sea ocean', '산': 'mountain', '숲': 'forest', '공원': 'park',
    '명소': 'attraction', '관광지': 'tourist spot', '랜드마크': 'landmark',
    '박물관': 'museum', '미술관': 'art gallery', '전시': 'exhibition',
    '축제': 'festival',

    // 건강/의료
    '의료': 'medical', '병원': 'hospital', '의사': 'doctor', '간병': 'nursing',
    '치료': 'treatment', '수술': 'surgery', '약': 'medicine',
    '건강검진': 'health checkup', '운동': 'exercise workout', '요가': 'yoga',
    '필라테스': 'pilates', '헬스': 'gym fitness', '다이어트': 'diet',
    '체중': 'weight', '비만': 'obesity', '스트레스': 'stress',
    '수면': 'sleep', '면역': 'immunity',

    // 교육/학습
    '교육': 'education', '학교': 'school', '대학': 'university college',
    '학생': 'student', '선생님': 'teacher', '공부': 'study', '학습': 'learning',
    '시험': 'exam test', '과제': 'assignment', '수업': 'class lesson',
    '강의': 'lecture', '책': 'book', '학원': 'academy', '과외': 'tutoring',
    '입시': 'entrance exam', '취업': 'employment', '면접': 'interview',

    // 부동산/인테리어
    '부동산': 'real estate', '집': 'house home', '아파트': 'apartment',
    '빌라': 'villa', '오피스텔': 'officetel', '인테리어': 'interior',
    '리모델링': 'remodeling', '가구': 'furniture', '침대': 'bed',
    '소파': 'sofa', '책상': 'desk', '의자': 'chair', '조명': 'lighting',
    '장식': 'decoration', '벽지': 'wallpaper', '바닥': 'floor',

    // 자동차/교통
    '자동차': 'car automobile', '차': 'car', '운전': 'driving', '도로': 'road',
    '고속도로': 'highway', '교통': 'traffic', '대중교통': 'public transportation',
    '지하철': 'subway metro', '버스': 'bus', '택시': 'taxi', '기차': 'train',
    '비행기': 'airplane', '공항': 'airport', '항구': 'port',

    // 쇼핑/구매
    '쇼핑': 'shopping', '구매': 'purchase buy', '판매': 'sale',
    '할인': 'discount', '마켓': 'market', '상점': 'store shop',
    '온라인': 'online', '오프라인': 'offline', '배송': 'delivery',
    '결제': 'payment', '카드': 'card', '현금': 'cash',

    // 날씨/계절
    '날씨': 'weather', '맑음': 'sunny', '비': 'rain', '눈': 'snow',
    '바람': 'wind', '구름': 'cloud', '봄': 'spring', '여름': 'summer',
    '가을': 'autumn fall', '겨울': 'winter', '계절': 'season',
    '온도': 'temperature', '더위': 'heat', '추위': 'cold',

    // 감정/상태
    '기쁨': 'joy happiness', '슬픔': 'sadness', '화': 'anger',
    '놀람': 'surprise', '두려움': 'fear', '사랑': 'love',
    '행복': 'happiness', '만족': 'satisfaction', '실망': 'disappointment',
    '걱정': 'worry', '안심': 'relief', '피곤': 'tired',
    '활기': 'energy', '편안': 'comfort',

    // 동물/자연
    '동물': 'animal', '강아지': 'puppy dog', '고양이': 'cat', '새': 'bird',
    '물고기': 'fish', '나무': 'tree', '꽃': 'flower', '풀': 'grass',
    '하늘': 'sky', '별': 'star', '달': 'moon', '자연': 'nature',
    '환경': 'environment',

    // 가족/인간관계
    '가족': 'family', '부모': 'parents', '아버지': 'father dad',
    '어머니': 'mother mom', '형제': 'siblings', '자매': 'sisters',
    '친구': 'friend', '동료': 'colleague', '이웃': 'neighbor',
    '사람': 'person people', '아이': 'child kid', '아기': 'baby',
    '청소년': 'teenager', '성인': 'adult', '노인': 'elderly',

    // 직업/일
    '직업': 'job occupation', '일': 'work job', '회사': 'company',
    '사무실': 'office', '회의': 'meeting', '프로젝트': 'project',
    '업무': 'work task', '업계': 'industry', '비즈니스': 'business',
    '경영': 'management', '마케팅': 'marketing', '영업': 'sales',
    '고객': 'customer client', '서비스': 'service',

    // 취미/여가
    '취미': 'hobby', '여가': 'leisure', '영화감상': 'movie watching',
    '음악': 'music', '노래': 'song singing', '춤': 'dance',
    '그림': 'drawing painting', '사진': 'photo photography',
    '글쓰기': 'writing', '원예': 'gardening', '수집': 'collecting',
    '만들기': 'making crafting',

    // 종교/철학
    '종교': 'religion', '신앙': 'faith', '기도': 'prayer', '예배': 'worship',
    '절': 'temple', '교회': 'church', '사원': 'temple', '철학': 'philosophy',
    '명상': 'meditation', '영성': 'spirituality',

    // 정치/사회
    '정치': 'politics', '정부': 'government', '국회': 'parliament',
    '선거': 'election', '정당': 'political party', '사회': 'society',
    '경제': 'economy', '금융': 'finance', '은행': 'bank', '주식': 'stock',
    '투자': 'investment', '세금': 'tax',

    // 이유/원인
    '이유': 'reason cause', '원인': 'cause', '결과': 'result',
    '영향': 'influence effect', '문제': 'problem issue', '해결': 'solution',
    '대책': 'measure', '방안': 'plan', '목적': 'purpose', '의도': 'intention',

    // 긴급/상황
    '급한': 'urgent', '긴급': 'emergency', '필수': 'essential',
    '필요': 'need', '당장': 'immediately', '바로': 'right away',
    '빨리': 'quickly', '서둘러': 'hurry',

    // 한국 고유명사
    '송혜교': 'actress', '청룡영화상': 'film awards', '청룡': 'film awards',

    // ✅ 추가: 자주 사용되는 단어들
    '개인정보': 'personal data privacy', '유출': 'data leak breach', '심각한': 'serious critical',
    '상황': 'situation', '어떤': 'what kind', '노력': 'effort', '하고': 'doing',
    '있나': 'is there', '얼마나': 'how much', '막기': 'prevent block', '위해': 'for in order to',
    '쿠팡': 'e-commerce delivery', '네이버': 'portal search', '카카오': 'messenger platform',
    '삼성': 'samsung electronics', 'LG': 'LG electronics', '현대': 'hyundai',
    '애플': 'apple technology', '구글': 'google tech', '마이크로소프트': 'microsoft',
    '테슬라': 'tesla electric car', '아마존': 'amazon marketplace',
    '비트코인': 'bitcoin cryptocurrency', '암호화폐': 'cryptocurrency',
    '주의': 'caution warning', '조심': 'careful caution', '경고': 'warning alert',
    '해결책': 'solution', '대응': 'response countermeasure', '조치': 'action measure',
    '확인': 'check confirm', '점검': 'inspection check', '검토': 'review examine',
    '분석': 'analysis', '조사': 'investigation research', '연구': 'research study',
    '발견': 'discovery finding', '출시': 'launch release',
    '업데이트': 'update', '변경': 'change modification', '개선': 'improvement',
    '성공': 'success', '실패': 'failure', '성장': 'growth',
    '하락': 'decline drop', '상승': 'rise increase', '증가': 'increase',
    '감소': 'decrease', '변화': 'change', '트렌드': 'trend',
    '인기': 'popular trending', '화제': 'hot topic', '논란': 'controversy',
    '비판': 'criticism', '칭찬': 'praise', '평가': 'evaluation review',
  };

  // ✅ 3단계: 번역 적용 (긴 단어부터)
  let englishQuery = cleanPrompt;
  const sortedEntries = Object.entries(koreanToEnglish).sort((a, b) => b[0].length - a[0].length);
  sortedEntries.forEach(([ko, en]) => {
    englishQuery = englishQuery.replace(new RegExp(ko, 'g'), en);
  });

  // ✅ 4단계: 불필요한 단어 제거
  englishQuery = englishQuery
    .replace(/\b(왜|어떻게|무엇을|어떤|이렇게|지금|바로|해보세요|만들기|습관|루틴)\b/g, '')
    .replace(/\s+/g, ' ')
    .trim();

  // ✅ 5단계: 영어 키워드만 추출
  const englishOnlyWords = englishQuery
    .split(/\s+/)
    .filter(word => {
      if (/[가-힣]/.test(word)) return false;
      return /^[a-zA-Z]{2,}$/.test(word);
    })
    .join(' ');

  // ✅ 6단계: 키워드가 없으면 일반 키워드 사용
  if (!englishOnlyWords || englishOnlyWords.split(/\s+/).length < 2) {
    const headingWords = heading
      .replace(/[^\w\s가-힣]/g, ' ')
      .split(/\s+/)
      .filter(w => w.length > 1)
      .slice(0, 3);

    const translatedHeading = headingWords
      .map(word => {
        for (const [ko, en] of sortedEntries) {
          if (word.includes(ko)) return en;
        }
        return null;
      })
      .filter(w => w !== null)
      .join(' ');

    if (translatedHeading) {
      englishQuery = translatedHeading;
    } else {
      englishQuery = 'people event celebration';
    }
  } else {
    englishQuery = englishOnlyWords;
  }

  // ✅ 7단계: 구체적인 이미지 프롬프트 생성 (소제목 내용 반영)
  const words = englishQuery.split(/\s+/).filter(w => w.length > 2);

  // 소제목에서 핵심 키워드 추출 (한글 포함)
  const koreanKeywords = heading
    .replace(/[^\w\s가-힣]/g, ' ')
    .split(/\s+/)
    .filter(w => w.length > 1)
    .slice(0, 5);

  // 키워드를 영어로 변환하여 추가
  const additionalKeywords: string[] = [];
  for (const word of koreanKeywords) {
    for (const [ko, en] of sortedEntries) {
      if (word.includes(ko) && !englishQuery.includes(en)) {
        additionalKeywords.push(en.split(' ')[0]); // 첫 번째 영어 단어만
        break;
      }
    }
  }

  // 기본 키워드와 추가 키워드 합치기
  let combinedQuery = englishQuery;
  if (additionalKeywords.length > 0) {
    combinedQuery = `${englishQuery} ${additionalKeywords.slice(0, 3).join(' ')}`;
  }

  // 품질 키워드 추가 - 실사 이미지 스타일 강조
  const qualityKeywords = 'ultra realistic photograph, photorealistic, professional photography, natural lighting, high detail, 4k resolution';

  // ✅ 8단계: 구체적인 프롬프트 생성 (충분한 설명 포함)
  const reviewAnchor = getReviewProductAnchor();
  const reviewCue = reviewAnchor
    ? `, product review, hands-on real-world usage of ${reviewAnchor}, realistic everyday environment, Korean hands/person (if a person appears), Korean lifestyle context, close-up detail`
    : '';
  const finalPrompt = `${combinedQuery}, ${qualityKeywords}${reviewCue}`;

  console.log(`[EnglishPrompt] 최종: "${heading}" → "${finalPrompt}"`);

  return finalPrompt || 'professional concept, ultra realistic photograph, 4k';
}

// ✅ 썸네일용 프롬프트 생성 (1번 소제목 - 제목 텍스트 포함)
function generateThumbnailPromptWithTitle(heading: string, blogTitle: string, basePromptOverride?: string): string {
  // 기본 배경 프롬프트 생성
  const basePrompt = String(basePromptOverride || '').trim() || generateEnglishPromptForHeadingSync(heading);

  // 썸네일용 프롬프트: 제목 텍스트를 포함한 4K 실사 배경
  const thumbnailPrompt = `${basePrompt.replace(/, 4k resolution/g, '')}, 
    with prominent Korean text overlay "${blogTitle}" in bold modern font, 
    eye-catching thumbnail design for blog, 
    text should be clearly readable and centered, 
    vibrant colors, high contrast, 
    professional blog thumbnail style, 
    ultra realistic 4k photograph background, 
    cinematic lighting, 
    perfect for Naver blog homepage exposure`;

  console.log(`[ThumbnailPrompt] 썸네일용 프롬프트 생성: "${heading}" → "${thumbnailPrompt.substring(0, 100)}..."`);

  return thumbnailPrompt;
}

// ✅ 인덱스 기반 프롬프트 생성 (1번 소제목 = 썸네일, 2번부터 = NEVER TEXT)
function generateImagePromptByIndex(heading: string, index: number, blogTitle?: string): string {
  const overridePrompt = getManualEnglishPromptOverrideForHeading(heading);
  if (index === 0 && blogTitle) {
    // 1번 소제목: 썸네일용 (제목 텍스트 포함)
    return generateThumbnailPromptWithTitle(heading, blogTitle, overridePrompt);
  } else {
    // 2번부터: NEVER TEXT 추가하여 텍스트 없는 이미지 생성
    const basePrompt = overridePrompt || generateEnglishPromptForHeadingSync(heading);
    const noTextPrompt = `${basePrompt}, NEVER include any text, letters, words, numbers, watermarks, or typography in the image, pure visual content only, clean image without any written elements`;

    console.log(`[ImagePrompt] ${index + 1}번 소제목 (NEVER TEXT): "${heading}" → "${noTextPrompt.substring(0, 80)}..."`);

    return noTextPrompt;
  }
}

// 소제목 자동 분석 함수 (반자동 모드용)
async function autoAnalyzeHeadings(structuredContent: any): Promise<void> {
  try {
    if (!structuredContent || !structuredContent.headings || structuredContent.headings.length === 0) {
      appendLog('⚠️ 소제목이 없어 분석을 건너뜁니다.');
      return;
    }

    // ✅ 서론, 소제목들, 마무리를 모두 포함한 통합 배열 생성
    const allSections: any[] = [];

    // 썸네일 추가 (introduction이 있는 경우)
    if (structuredContent.introduction) {
      allSections.push({
        title: '🖼️ 썸네일',
        content: structuredContent.introduction,
        isThumbnail: true,
        isIntro: true
      });
    }

    // 소제목들 추가
    structuredContent.headings.forEach((heading: any) => {
      allSections.push({
        title: heading.title || heading,
        content: heading.content || heading.summary || '',
        isHeading: true
      });
    });

    // 마무리 추가 (있는 경우)
    if (structuredContent.conclusion) {
      allSections.push({
        title: '📝 마무리',
        content: structuredContent.conclusion,
        isConclusion: true
      });
    }

    appendLog(`🔍 ${allSections.length}개 섹션 분석 시작... (서론: ${structuredContent.introduction ? '있음' : '없음'}, 마무리: ${structuredContent.conclusion ? '있음' : '없음'})`);

    // 소제목을 이미지 관리 탭 형식으로 변환
    const headings = allSections.map((section: any) => {
      const title = section.title;
      const override = getManualEnglishPromptOverrideForHeading(title);
      return {
        title,
        content: section.content,
        prompt: override || generateEnglishPromptForHeadingSync(title),
        isIntro: section.isIntro,
        isConclusion: section.isConclusion
      };
    });

    // 이미지 관리 탭에 소제목 표시
    displayImageHeadingsWithPrompts(headings);

    const imagesForUi = (() => {
      try {
        const all = ImageManager.getAllImages();
        if (Array.isArray(all) && all.length > 0) return all;
      } catch {
        // ignore
      }
      return Array.isArray(generatedImages) ? generatedImages : [];
    })();

    // 통합 탭의 이미지 미리보기도 업데이트
    if (structuredContent.headings) {
      updateUnifiedImagePreview(structuredContent.headings, imagesForUi);
    }

    // ✅ 생성된 이미지 그리드에도 표시
    displayGeneratedImages(imagesForUi);

    appendLog(`✅ ${headings.length}개 소제목 분석 완료!`);
  } catch (error) {
    appendLog(`❌ 소제목 자동 분석 실패: ${(error as Error).message}`);
    throw error;
  }
}

// 이미지 헤딩 표시
function displayImageHeadingsWithPrompts(headings: any[]): void {
  const promptsContainer = document.getElementById('prompts-container') as HTMLDivElement;
  const promptsPlaceholder = document.getElementById('prompts-placeholder') as HTMLDivElement;

  // ✅ 1번 이미지 제목 텍스트 포함 옵션: 4개 버튼 아래 전용 영역에 렌더
  const thumbnailOptionHost = document.getElementById('thumbnail-text-option-host') as HTMLDivElement | null;
  if (thumbnailOptionHost) {
    const existingChecked = (document.getElementById('thumbnail-text-option') as HTMLInputElement | null)?.checked ?? false;
    thumbnailOptionHost.style.display = 'block';
    thumbnailOptionHost.innerHTML = `
      <div id="thumbnail-text-option-container" style="
        background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(217, 119, 6, 0.05));
        border: 1px solid rgba(245, 158, 11, 0.3);
        border-radius: 12px;
        padding: 1rem;
        display: flex;
        align-items: center;
        gap: 0.75rem;
      ">
        <input type="checkbox" id="thumbnail-text-option" ${existingChecked ? 'checked' : ''} style="width: 20px; height: 20px; cursor: pointer; accent-color: #f59e0b;">
        <label for="thumbnail-text-option" style="cursor: pointer; font-weight: 600; color: var(--text-strong); display: flex; flex-direction: column; gap: 0.25rem;">
          <span>🖼️ 1번 이미지에 제목 텍스트 포함 (썸네일)</span>
          <span style="font-size: 0.8rem; color: var(--text-muted); font-weight: 400;">⚠️ AI가 한글을 정확히 렌더링하지 못할 수 있습니다. 체크 해제 시 모든 이미지가 텍스트 없이 생성됩니다.</span>
        </label>
      </div>
    `;
  }

  if (!promptsContainer || !promptsPlaceholder) return;

  if (headings.length === 0) {
    promptsContainer.style.display = 'none';
    promptsPlaceholder.style.display = 'block';
    promptsPlaceholder.innerHTML = '<div style="color: var(--text-muted); font-style: italic;">소제목이 발견되지 않았습니다.</div>';
    return;
  }

  const normalizedHeadings = (Array.isArray(headings) ? headings : []).map((h: any, index: number) => {
    const titleRaw = typeof h === 'string' ? String(h || '').trim() : String(h?.title || h || '').trim();
    const title = titleRaw || `소제목 ${index + 1}`;
    const override = getManualEnglishPromptOverrideForHeading(title);
    const promptRaw = typeof h === 'string' ? '' : String(h?.prompt || '').trim();
    const prompt = override || promptRaw || generateEnglishPromptForHeadingSync(title);
    const isConclusion = h?.isConclusion || title.includes('📝 마무리') || title.includes('마무리');
    return { title, prompt, isConclusion };
  });

  // ✅ [2026-01-21] 마무리 섹션은 UI에서 숨김 (AI 이미지 생성 제외와 일관성)
  const displayHeadings = normalizedHeadings.filter(h => !h.isConclusion);

  // ✅ 기존 프롬프트 아이템 모두 제거
  promptsContainer.innerHTML = '';

  // ✅ 각 소제목에 대한 프롬프트 아이템 동적 생성
  // ✅ 프롬프트 데이터는 글로벌 배열에 저장하여 data- 속성 문제 방지
  (window as any)._headingPrompts = normalizedHeadings.map((h) => h.prompt || '');
  (window as any)._headingTitles = normalizedHeadings.map((h) => h.title || '');

  displayHeadings.forEach((heading, index) => {
    // ✅ 안전한 HTML 이스케이프 적용
    const safeTitle = escapeHtml(heading.title || `소제목 ${index + 1}`);
    const safePrompt = escapeHtml(heading.prompt || '');

    const promptItem = document.createElement('div');
    promptItem.className = 'prompt-item';
    promptItem.setAttribute('data-index', `${index + 1}`);
    promptItem.style.cssText = `
      background: var(--bg-secondary);
      border: 1px solid var(--border-light);
      border-radius: 12px;
      padding: 1rem;
      transition: all 0.2s;
    `;

    promptItem.innerHTML = `
      <div style="display: flex; align-items: center; gap: 0.75rem; margin-bottom: 0.75rem;">
        <div style="width: 32px; height: 32px; border-radius: 50%; background: linear-gradient(135deg, var(--primary), var(--secondary)); display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 0.9rem;">${index + 1}</div>
        <div style="flex: 1;">
          <div class="heading-title-text" style="font-weight: 600; color: var(--text-strong); font-size: 0.95rem;">${safeTitle}</div>
        </div>
      </div>
      <div style="margin-bottom: 0.75rem;">
        <div style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 0.5rem;">📝 영어 프롬프트:</div>
        <div class="prompt-text" style="font-size: 0.9rem; color: var(--text-strong); padding: 0.5rem; background: var(--bg-tertiary); border-radius: 6px; font-family: monospace; word-break: break-word;">${safePrompt}</div>
        <div style="display:flex; gap:0.5rem; justify-content:flex-end; margin-top: 0.5rem;">
          <button type="button" class="edit-heading-prompt-btn" data-heading-index="${index}" style="padding: 0.35rem 0.65rem; background: rgba(59,130,246,0.16); color: var(--text-strong); border: 1px solid rgba(59,130,246,0.35); border-radius: 6px; font-size: 0.75rem; cursor: pointer;">✏️ 수정</button>
          <button type="button" class="reset-heading-prompt-btn" data-heading-index="${index}" style="padding: 0.35rem 0.65rem; background: rgba(239,68,68,0.12); color: var(--text-strong); border: 1px solid rgba(239,68,68,0.25); border-radius: 6px; font-size: 0.75rem; cursor: pointer;">↩️ 초기화</button>
        </div>
      </div>
      <div class="generated-images-container" data-heading-index="${index}" style="width: 100%; min-height: 200px; border: 2px dashed var(--border-color); border-radius: 8px; background: var(--bg-tertiary); overflow: hidden; padding: 0.75rem;">
        <div class="generated-image" style="width: 100%; aspect-ratio: 16 / 9; min-height: 220px; border-radius: 8px; overflow: hidden; display: flex; align-items: center; justify-content: center; margin-bottom: 0.75rem; border: 2px dashed var(--border-color); background: var(--bg-tertiary); position: relative;">
          <span style="color: var(--text-muted); font-size: 1.5rem;">🖼️</span>
        </div>
        <div class="images-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 0.5rem; margin-bottom: 0.75rem;">
          <!-- 이미지들이 여기에 동적으로 추가됨 -->
        </div>
        <div class="no-image-placeholder" style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 1rem; gap: 0.5rem;">
          <span style="color: var(--text-muted); font-size: 2rem;">🖼️</span>
          <span style="color: var(--text-muted); font-size: 0.85rem;">이미지 없음</span>
        </div>
        <!-- ✅ 예비 이미지 빠른 교체 영역 (썸네일만 표시) -->
        <div class="reserve-images-strip" data-heading-index="${index}" style="display: none; margin-bottom: 0.5rem; padding: 0.5rem; background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(217, 119, 6, 0.1)); border-radius: 8px; border: 1px solid rgba(245, 158, 11, 0.3);">
          <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
            <span style="color: #f59e0b; font-size: 0.75rem; font-weight: 600; white-space: nowrap;">⚡ 예비 이미지:</span>
            <div class="reserve-thumbs" style="display: flex; gap: 4px; flex-wrap: wrap;"></div>
          </div>
        </div>
        
        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; justify-content: center; margin-top: 0.5rem;">
          <button type="button" class="select-local-image-btn" data-heading-index="${index}" style="padding: 0.4rem 0.75rem; background: linear-gradient(135deg, #8b5cf6, #7c3aed); color: white; border: none; border-radius: 6px; font-size: 0.8rem; cursor: pointer; display: flex; align-items: center; gap: 0.25rem;" title="저장된 이미지에서 선택">
            🔄 변경
          </button>
          <button type="button" class="add-multiple-images-btn" data-heading-index="${index}" style="padding: 0.4rem 0.75rem; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 6px; font-size: 0.8rem; cursor: pointer; display: flex; align-items: center; gap: 0.25rem;" title="로컬 파일에서 이미지 추가">
            ➕ 추가
          </button>
          <button type="button" class="regenerate-single-image-btn" data-heading-index="${index}" style="padding: 0.4rem 0.75rem; background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; border: none; border-radius: 6px; font-size: 0.8rem; cursor: pointer; display: flex; align-items: center; gap: 0.25rem;" title="이미지 생성">
            🔄 생성
          </button>
          <button type="button" class="generate-heading-video-btn" data-heading-index="${index}" style="padding: 0.4rem 0.75rem; background: linear-gradient(135deg, #22c55e, #16a34a); color: white; border: none; border-radius: 6px; font-size: 0.8rem; cursor: pointer; display: flex; align-items: center; gap: 0.25rem;" title="AI 영상 생성">
            🎬 영상 생성
          </button>
          <button type="button" class="set-primary-image-btn" data-heading-index="${index}" style="padding: 0.4rem 0.75rem; background: linear-gradient(135deg, #f59e0b, #d97706); color: white; border: none; border-radius: 6px; font-size: 0.8rem; cursor: pointer; display: flex; align-items: center; gap: 0.25rem;" title="선택된 이미지를 대표 이미지로 지정">
            ⭐ 대표 지정
          </button>
          <button type="button" class="clear-heading-images-btn" data-heading-index="${index}" style="padding: 0.4rem 0.75rem; background: var(--bg-tertiary); color: var(--text-muted); border: 1px solid var(--border-light); border-radius: 6px; font-size: 0.8rem; cursor: pointer;" title="모든 이미지 제거">
            🗑️ 전체삭제
          </button>
        </div>
      </div>
    `;

    promptsContainer.appendChild(promptItem);
  });

  promptsContainer.style.display = 'grid';
  promptsPlaceholder.style.display = 'none';

  // ✅ 새로고침 버튼 표시
  const refreshPromptsBtn = document.getElementById('refresh-prompts-btn');
  if (refreshPromptsBtn) {
    refreshPromptsBtn.style.display = 'flex';
  }

  const setFirstHeadingThumbnailBtn = document.getElementById('set-first-heading-thumbnail-btn');
  if (setFirstHeadingThumbnailBtn) {
    setFirstHeadingThumbnailBtn.style.display = 'flex';
  }

  // ✅ 예비 이미지 빠른 교체 썸네일 업데이트
  if (typeof updateReserveImagesThumbnails === 'function') {
    updateReserveImagesThumbnails();
  }
  appendLog(`✅ ${displayHeadings.length}개의 소제목 미리보기를 표시했습니다.`);
}

function updateReserveImagesThumbnails(): void {
  document.querySelectorAll('.reserve-images-strip').forEach((strip) => {
    (strip as HTMLElement).style.display = 'none';
  });
}

function getHeadingSelectedImageKeyStore(): Record<string, string> {
  const w = window as any;
  if (!w.__headingSelectedImageKeys) w.__headingSelectedImageKeys = {};
  return w.__headingSelectedImageKeys;
}

function getHeadingSelectedImageKey(headingKey: string): string {
  const store = getHeadingSelectedImageKeyStore();
  return String(store[String(headingKey || '').trim()] || '').trim();
}

function setHeadingSelectedImageKey(headingKey: string, imageKey: string): void {
  const store = getHeadingSelectedImageKeyStore();
  const hk = String(headingKey || '').trim();
  if (!hk) return;
  store[hk] = String(imageKey || '').trim();
}

// ============================================
// 🎯 통합 이미지 이벤트 핸들러 (전역 이벤트 위임)
// ============================================
function initUnifiedImageEventHandlers(): void {
  // 이미 초기화되었으면 중복 방지
  if ((document.body as any).__unifiedImageHandlersInitialized) return;
  (document.body as any).__unifiedImageHandlersInitialized = true;

  console.log('[ImageManager] 통합 이미지 이벤트 핸들러 초기화');

  // ✅ 헬퍼 함수: headingIndex로 headingTitle 찾기
  const getHeadingTitleByIndex = (index: number): string => {
    const headings = ImageManager.headings;
    if (headings && headings[index]) {
      return typeof headings[index] === 'string' ? headings[index] : (headings[index].title || '');
    }
    return (window as any)._headingTitles?.[index] || `소제목 ${index + 1}`;
  };

  // ✅ 예비 이미지 우클릭 → 크게 보기
  document.body.addEventListener('contextmenu', (e) => {
    const target = e.target as HTMLElement;
    if (target.classList.contains('quick-replace-thumb')) {
      e.preventDefault();
      const imgSrc = (target as HTMLImageElement).src;
      if (imgSrc) {
        showImageModal(imgSrc);
      }
    }
  });

  // 전역 클릭 이벤트 위임
  document.body.addEventListener('click', (e) => {
    const target = e.target as HTMLElement;

    const setPrimaryBtn = (target.classList.contains('set-primary-image-btn') ? target : target.closest('.set-primary-image-btn')) as HTMLElement | null;
    if (setPrimaryBtn) {
      e.preventDefault();
      e.stopPropagation();
      const headingIndex = parseInt(String(setPrimaryBtn.dataset.headingIndex || '0'), 10);
      const headingTitle = String((window as any)._headingTitles?.[headingIndex] || '').trim() || getHeadingTitleByIndex(headingIndex);
      if (!headingTitle) return;
      const resolved = (() => {
        try {
          return ImageManager.resolveHeadingKey(headingTitle);
        } catch {
          return headingTitle;
        }
      })();
      const selectedKey = getHeadingSelectedImageKey(resolved);
      if (!selectedKey) {
        toastManager.warning('대표로 지정할 이미지가 선택되지 않았습니다. 먼저 썸네일을 선택하세요.');
        return;
      }
      try {
        ImageManager.setPrimaryImageByKey(headingTitle, selectedKey);
      } catch (err) {
        console.error('[ImageManager] setPrimaryImageByKey failed:', err);
      }
      return;
    }

    const bigPrevBtn = (target.classList.contains('big-preview-prev-btn') ? target : target.closest('.big-preview-prev-btn')) as HTMLElement | null;
    const bigNextBtn = (target.classList.contains('big-preview-next-btn') ? target : target.closest('.big-preview-next-btn')) as HTMLElement | null;
    const bigNavBtn = bigPrevBtn || bigNextBtn;
    if (bigNavBtn) {
      e.preventDefault();
      e.stopPropagation();
      const dir = bigPrevBtn ? -1 : 1;
      const headingIndex = parseInt(String(bigNavBtn.dataset.headingIndex || '0'), 10);
      const headingTitle = String(bigNavBtn.dataset.headingTitle || '').trim() || String((window as any)._headingTitles?.[headingIndex] || '').trim() || getHeadingTitleByIndex(headingIndex);
      if (!headingTitle) return;
      const resolved = (() => {
        try {
          return ImageManager.resolveHeadingKey(headingTitle);
        } catch {
          return headingTitle;
        }
      })();
      let list: any[] = [];
      try {
        list = ImageManager.getImages(resolved) || [];
      } catch {
        list = [];
      }
      if (!Array.isArray(list) || list.length === 0) return;
      const primaryKey = (() => {
        try {
          return getStableImageKey(ImageManager.getImage(resolved));
        } catch {
          return '';
        }
      })();
      const currentKey = getHeadingSelectedImageKey(resolved) || primaryKey || getStableImageKey(list[0]);
      let idx = list.findIndex((img: any) => getStableImageKey(img) === currentKey);
      if (idx < 0) idx = 0;
      const nextIdx = (idx + dir + list.length) % list.length;
      const nextKey = getStableImageKey(list[nextIdx]);
      if (nextKey) setHeadingSelectedImageKey(resolved, nextKey);
      try {
        updatePromptItemsWithImages(ImageManager.getAllImages());
      } catch {
      }
      return;
    }

    // ✅ 작은 그리드 썸네일 클릭 → 대표 이미지로 승격 + 큰 미리보기 동기화
    const gridItem = (target.classList.contains('grid-image-item') ? target : target.closest('.grid-image-item')) as HTMLElement | null;
    if (gridItem) {
      const isDelete = !!(target.classList.contains('remove-single-grid-image-btn') || target.closest('.remove-single-grid-image-btn'));
      if (!isDelete) {
        e.preventDefault();
        e.stopPropagation();
        const headingIndex = parseInt(String(gridItem.dataset.headingIndex || '0'), 10);
        const headingTitle = String(gridItem.dataset.headingTitle || '').trim() || getHeadingTitleByIndex(headingIndex);
        const key = String(gridItem.dataset.imageKey || '').trim() || getStableImageKey({ url: (gridItem.querySelector('img') as HTMLImageElement | null)?.src });
        if (headingTitle && key) {
          try {
            const resolved = (() => {
              try {
                return ImageManager.resolveHeadingKey(headingTitle);
              } catch {
                return headingTitle;
              }
            })();
            setHeadingSelectedImageKey(resolved, key);
            updatePromptItemsWithImages(ImageManager.getAllImages());
          } catch (err) {
            console.error('[ImageManager] thumbnail select failed:', err);
          }
        }
        return;
      }
    }

    // ✅ 0-1. 예비 이미지 빠른 교체 (썸네일 클릭) - 우클릭: 크게보기, 좌클릭: 교체
    if (target.classList.contains('quick-replace-thumb')) {
      e.preventDefault();
      e.stopPropagation();

      const headingIndex = parseInt(target.dataset.headingIndex || '0');
      const reserveIndex = parseInt(target.dataset.reserveIndex || '0');
      const headingTitle = target.dataset.headingTitle || getHeadingTitleByIndex(headingIndex);
      const imgSrc = (target as HTMLImageElement).src;

      console.log(`[QuickReplace] 클릭됨 - headingIndex: ${headingIndex}, reserveIndex: ${reserveIndex}, headingTitle: ${headingTitle}`);

      // 예비 이미지 가져오기
      const allImages = (window as any).imageManagementGeneratedImages || generatedImages || [];
      const headingsCount = ImageManager.headings?.length || 0;
      const reserveImages = allImages.slice(headingsCount);

      console.log(`[QuickReplace] 전체 이미지: ${allImages.length}, 소제목 수: ${headingsCount}, 예비 이미지: ${reserveImages.length}`);

      if (reserveImages[reserveIndex] && headingTitle) {
        const reserveImage = reserveImages[reserveIndex];

        // 현재 이미지와 예비 이미지 교체
        const currentImage = ImageManager.getImage(headingTitle);

        console.log(`[QuickReplace] 교체 시작 - 예비[${reserveIndex}] → "${headingTitle}"`);

        // 예비 이미지를 소제목에 배치
        ImageManager.setImage(headingTitle, {
          ...reserveImage,
          heading: headingTitle,
          headingIndex: headingIndex
        });

        // 현재 이미지를 예비로 이동 (교체된 위치에)
        if (currentImage) {
          const actualReserveIdx = headingsCount + reserveIndex;
          allImages[actualReserveIdx] = { ...currentImage, heading: `예비 이미지 ${reserveIndex + 1}`, headingIndex: -1 };
        }

        // 배치된 이미지 업데이트
        allImages[headingIndex] = { ...reserveImage, heading: headingTitle, headingIndex: headingIndex };

        (window as any).imageManagementGeneratedImages = allImages;
        syncGlobalImagesFromImageManager();
        updateReserveImagesThumbnails();

        toastManager.success(`⚡ ${headingIndex + 1}번 소제목 이미지 빠른 교체!`);
        appendLog(`⚡ [빠른 교체] ${headingIndex + 1}번 소제목 이미지 변경 완료`);
      } else {
        console.warn(`[QuickReplace] 교체 실패 - reserveImages[${reserveIndex}]: ${!!reserveImages[reserveIndex]}, headingTitle: ${headingTitle}`);
        // 예비 이미지가 없거나 headingTitle이 없으면 크게 보기
        if (imgSrc) {
          showImageModal(imgSrc);
        }
      }
      return;
    }

    // ✅ 0-2. 예비 이미지 바로 배치 버튼
    if (target.classList.contains('quick-assign-reserve-btn')) {
      e.preventDefault();
      e.stopPropagation();

      const headingIndex = parseInt(target.dataset.headingIndex || '0');
      const headingTitle = target.dataset.headingTitle || getHeadingTitleByIndex(headingIndex);

      // 예비 이미지 가져오기
      const allImages = (window as any).imageManagementGeneratedImages || generatedImages || [];
      const headingsCount = ImageManager.headings?.length || 0;
      const reserveImages = allImages.slice(headingsCount);

      if (reserveImages.length > 0 && headingTitle) {
        const reserveImage = reserveImages[0]; // 첫 번째 예비 이미지

        // 예비 이미지를 소제목에 배치
        ImageManager.setImage(headingTitle, reserveImage);

        // UI 동기화
        ImageManager.syncAllPreviews();
        displayGeneratedImages(allImages);

        toastManager.success(`⚡ ${headingIndex + 1}번 소제목에 예비 이미지 배치!`);
        appendLog(`⚡ [빠른 배치] ${headingIndex + 1}번 소제목에 예비 이미지 배치 완료`);
      }
      return;
    }

    // 1. 소제목 분석 미리보기 - 이미지 제거 버튼

    // 2. 소제목 분석 미리보기 - 이미지 재생성 버튼
    if (target.classList.contains('regenerate-image-btn')) {
      e.preventDefault();
      e.stopPropagation();

      // ✅ headingTitle 또는 headingIndex로 제목 찾기
      const headingIndex = parseInt(target.dataset.headingIndex || target.dataset.imageIndex || '0');
      const headingTitle = target.dataset.headingTitle || getHeadingTitleByIndex(headingIndex);
      const prompt = target.dataset.prompt || headingTitle;

      if (headingTitle) {
        appendLog(`🔄 "${headingTitle}" 이미지 재생성 시작...`);
        regenerateSingleImage(headingTitle, prompt);
      }
      return;
    }

    if (target.classList.contains('remove-heading-video-btn') || target.closest('.remove-heading-video-btn')) {
      e.preventDefault();
      e.stopPropagation();

      const btn = target.classList.contains('remove-heading-video-btn') ? target : (target.closest('.remove-heading-video-btn') as HTMLElement);
      const headingIndex = parseInt(btn?.dataset.headingIndex || '0');
      const headingTitle = btn?.dataset.headingTitle || getHeadingTitleByIndex(headingIndex);

      if (headingTitle && confirm(`"${headingTitle}" 소제목의 영상을 제거하시겠습니까?`)) {
        (async () => {
          try {
            await removeHeadingVideoByTitle(headingTitle);
          } catch (err) {
            toastManager.error(`소제목 영상 제거 오류: ${(err as Error).message}`);
          }
        })();
      }
      return;
    }

    if (target.classList.contains('regenerate-heading-video-btn') || target.closest('.regenerate-heading-video-btn')) {
      e.preventDefault();
      e.stopPropagation();

      const btn = target.classList.contains('regenerate-heading-video-btn') ? target : (target.closest('.regenerate-heading-video-btn') as HTMLElement);
      const headingIndex = parseInt(btn?.dataset.headingIndex || '0');
      const headingTitle = btn?.dataset.headingTitle || getHeadingTitleByIndex(headingIndex);

      if (headingTitle) {
        (async () => {
          try {
            await regenerateHeadingVideoByTitle(headingTitle);
          } catch (err) {
            toastManager.error(`소제목 영상 재생성 오류: ${(err as Error).message}`);
          }
        })();
      }
      return;
    }

    if (target.classList.contains('edit-heading-prompt-btn') || target.closest('.edit-heading-prompt-btn')) {
      e.preventDefault();
      e.stopPropagation();

      const btn = target.classList.contains('edit-heading-prompt-btn')
        ? target
        : (target.closest('.edit-heading-prompt-btn') as HTMLElement);
      const headingIndex = parseInt(btn?.dataset.headingIndex || '0');
      (window as any).showHeadingPromptEditModal(headingIndex);
      return;
    }

    if (target.classList.contains('reset-heading-prompt-btn') || target.closest('.reset-heading-prompt-btn')) {
      e.preventDefault();
      e.stopPropagation();

      const btn = target.classList.contains('reset-heading-prompt-btn')
        ? target
        : (target.closest('.reset-heading-prompt-btn') as HTMLElement);
      const headingIndex = parseInt(btn?.dataset.headingIndex || '0');
      const headingTitle =
        (window as any)._headingTitles?.[headingIndex] ||
        (document.querySelector(`.prompt-item[data-index="${headingIndex + 1}"] .heading-title-text`) as HTMLElement | null)?.textContent?.trim() ||
        `소제목 ${headingIndex + 1}`;

      clearManualEnglishPromptOverrideForHeading(String(headingTitle || '').trim());
      const autoPrompt = generateEnglishPromptForHeadingSync(String(headingTitle || '').trim());
      try {
        const hp = (window as any)._headingPrompts || [];
        hp[headingIndex] = autoPrompt;
        (window as any)._headingPrompts = hp;
      } catch {
        // ignore
      }

      const promptEl = document.querySelector(`.prompt-item[data-index="${headingIndex + 1}"] .prompt-text`) as HTMLElement | null;
      if (promptEl) {
        promptEl.textContent = autoPrompt;
      }
      toastManager.success('영어 프롬프트를 자동 생성값으로 초기화했습니다.');
      return;
    }

    // ✅ 2-0. 이미지가 있는 소제목 - 폴더에서 이미지 선택 버튼
    if (target.classList.contains('select-folder-image-btn') || target.closest('.select-folder-image-btn')) {
      e.preventDefault();
      e.stopPropagation();

      const btn = target.classList.contains('select-folder-image-btn') ? target : target.closest('.select-folder-image-btn') as HTMLElement;
      const headingIndex = parseInt(btn?.dataset.headingIndex || btn?.dataset.imageIndex || '0');
      const headingTitle = btn?.dataset.headingTitle || btn?.dataset.heading || getHeadingTitleByIndex(headingIndex);

      // ✅ 저장된 이미지에서 선택하는 모달 표시
      if (headingTitle) {
        selectLocalImageForHeading(headingIndex, headingTitle);
      } else {
        showSavedImagesForReplace(headingIndex);
      }
      return;
    }

    // ✅ 2-1. 빈 소제목 - 저장된 이미지에서 선택 버튼 (📁 폴더)
    if (target.classList.contains('select-local-image-btn') || target.closest('.select-local-image-btn')) {
      e.preventDefault();
      e.stopPropagation();

      const btn = target.classList.contains('select-local-image-btn') ? target : target.closest('.select-local-image-btn') as HTMLElement;
      const headingIndex = parseInt(btn?.dataset.headingIndex || '0');

      // ✅ 저장된 이미지에서 선택하는 모달 표시 (이미지 변경하기)
      showSavedImagesForReplace(headingIndex);
      return;
    }

    // ✅ 2-2. 빈 소제목 - 단일 이미지 생성 버튼
    if (target.classList.contains('regenerate-single-image-btn') || target.closest('.regenerate-single-image-btn')) {
      e.preventDefault();
      e.stopPropagation();

      const btn = target.classList.contains('regenerate-single-image-btn') ? target : target.closest('.regenerate-single-image-btn') as HTMLElement;
      const headingIndex = parseInt(btn?.dataset.headingIndex || '0');
      // ✅ 글로벌 배열에서 제목과 프롬프트 가져오기
      const headingTitle = String(
        (window as any)._headingTitles?.[headingIndex] ||
        (document.querySelector(`.prompt-item[data-index="${headingIndex + 1}"] .heading-title-text`) as HTMLElement | null)?.textContent?.trim() ||
        getHeadingTitleByIndex(headingIndex) ||
        ''
      ).trim();
      const headingPrompts = (window as any)._headingPrompts || [];
      let prompt = String(headingPrompts[headingIndex] || '').trim();
      if (!prompt) {
        prompt = String(
          (document.querySelector(`.prompt-item[data-index="${headingIndex + 1}"] .prompt-text`) as HTMLElement | null)?.textContent || ''
        ).trim();
      }

      if (!prompt) {
        toastManager.warning('해당 소제목의 영어 프롬프트가 없습니다. 먼저 프롬프트를 생성해주세요.');
        return;
      }

      if (!headingTitle) {
        toastManager.warning('소제목 제목을 찾을 수 없습니다. 먼저 소제목 분석/생성을 다시 실행해주세요.');
        return;
      }

      regenerateSingleImage(headingTitle, prompt);
      return;
    }

    if (target.classList.contains('undo-skip-btn') || target.closest('.undo-skip-btn')) {
      e.preventDefault();
      e.stopPropagation();

      const btn = target.classList.contains('undo-skip-btn') ? target : (target.closest('.undo-skip-btn') as HTMLElement);
      const headingIndex = parseInt(btn?.dataset.headingIndex || '0');
      const headingTitle = (window as any)._headingTitles?.[headingIndex] || getHeadingTitleByIndex(headingIndex);
      undoSkipHeadingImage(headingIndex, String(headingTitle || '').trim());
      return;
    }

    // ✅ 2-3. 빈 소제목 - 이미지 건너뛰기 버튼
    if (target.classList.contains('skip-heading-image-btn') || target.closest('.skip-heading-image-btn')) {
      e.preventDefault();
      e.stopPropagation();

      const btn = target.classList.contains('skip-heading-image-btn') ? target : target.closest('.skip-heading-image-btn') as HTMLElement;
      const headingIndex = parseInt(btn?.dataset.headingIndex || '0');
      // ✅ 글로벌 배열에서 제목 가져오기
      const headingTitle = (window as any)._headingTitles?.[headingIndex] || '';

      skipHeadingImage(headingIndex, headingTitle);
      return;
    }

    // ✅ 2-4. 여러 이미지 추가 버튼
    if (target.classList.contains('add-multiple-images-btn') || target.closest('.add-multiple-images-btn')) {
      e.preventDefault();
      e.stopPropagation();

      const btn = target.classList.contains('add-multiple-images-btn') ? target : target.closest('.add-multiple-images-btn') as HTMLElement;
      const headingIndex = parseInt(btn?.dataset.headingIndex || '0');
      // ✅ 글로벌 배열에서 제목 가져오기
      const headingTitle = String(
        (window as any)._headingTitles?.[headingIndex] ||
        (document.querySelector(`.prompt-item[data-index="${headingIndex + 1}"] .heading-title-text`) as HTMLElement | null)?.textContent?.trim() ||
        getHeadingTitleByIndex(headingIndex) ||
        ''
      ).trim();

      if (!headingTitle) {
        toastManager.warning('소제목 제목을 찾을 수 없습니다. 먼저 소제목 분석/생성을 다시 실행해주세요.');
        return;
      }

      addMultipleImagesToHeading(headingIndex, headingTitle);
      return;
    }

    // ✅ 2-5. 전체 이미지 삭제 버튼
    if (target.classList.contains('clear-heading-images-btn') || target.closest('.clear-heading-images-btn')) {
      e.preventDefault();
      e.stopPropagation();

      const btn = target.classList.contains('clear-heading-images-btn') ? target : target.closest('.clear-heading-images-btn') as HTMLElement;
      const headingIndex = parseInt(btn?.dataset.headingIndex || '0');
      // ✅ 글로벌 배열에서 제목 가져오기
      const headingTitle = (window as any)._headingTitles?.[headingIndex] || '';

      if (confirm(`"${headingTitle}" 소제목의 모든 이미지를 삭제하시겠습니까?`)) {
        clearHeadingImages(headingIndex, headingTitle);
      }
      return;
    }

    // ✅ 2-6. 개별 이미지 제거 버튼 (이미지 그리드 내)
    if (target.classList.contains('remove-single-grid-image-btn') || target.closest('.remove-single-grid-image-btn')) {
      e.preventDefault();
      e.stopPropagation();

      const btn = target.classList.contains('remove-single-grid-image-btn') ? target : target.closest('.remove-single-grid-image-btn') as HTMLElement;
      const headingIndex = parseInt(btn?.dataset.headingIndex || '0');
      const imageIndex = parseInt(btn?.dataset.imageIndex || '0');
      const gridItem = btn.closest('.grid-image-item') as HTMLElement | null;
      const headingTitle = String(gridItem?.dataset.headingTitle || btn?.dataset.headingTitle || '').trim();
      const imageKey = String(btn?.dataset.imageKey || gridItem?.dataset.imageKey || '').trim();

      removeSingleImageFromHeading(headingIndex, imageIndex, headingTitle, imageKey);
      return;
    }

    // 3. 생성된 이미지 미리보기 - 이미지 제거 버튼
    if (target.classList.contains('remove-generated-image-btn') || target.closest('.remove-generated-image-btn')) {
      e.preventDefault();
      e.stopPropagation();

      const btn = target.classList.contains('remove-generated-image-btn')
        ? target
        : (target.closest('.remove-generated-image-btn') as HTMLElement);
      const headingTitle = btn?.dataset.headingTitle;
      if (headingTitle) {
        if (confirm(`"${headingTitle}" 소제목의 이미지를 제거하시겠습니까?`)) {
          ImageManager.removeImage(headingTitle);
          try {
            (window as any).imageManagementGeneratedImages = ImageManager.getAllImages();
          } catch {
            // ignore
          }
          try {
            syncGlobalImagesFromImageManager();
          } catch {
            // ignore
          }
          toastManager.success(`✅ "${headingTitle}" 이미지 제거 완료!`);
        }
      }
      return;
    }

    // ✅ 2-7. 소제목별 AI 영상 생성 버튼
    if (target.classList.contains('generate-heading-video-btn') || target.closest('.generate-heading-video-btn')) {
      e.preventDefault();
      e.stopPropagation();

      const btn = target.classList.contains('generate-heading-video-btn') ? target : (target.closest('.generate-heading-video-btn') as HTMLElement);
      const headingIndex = parseInt(btn?.dataset.headingIndex || '0');
      const headingTitle = (window as any)._headingTitles?.[headingIndex] || getHeadingTitleByIndex(headingIndex);
      generateHeadingVideoForPrompt(headingIndex, headingTitle);
      return;
    }
  });
}

// 단일 이미지 재생성
async function regenerateSingleImage(headingTitle: string, prompt: string): Promise<void> {
  try {
    const resolvedHeadingTitle = String(headingTitle || '').trim();
    if (!resolvedHeadingTitle) {
      toastManager.warning('소제목 제목을 찾을 수 없습니다. 먼저 소제목 분석/생성을 다시 실행해주세요.');
      return;
    }

    const resolvedHeadingKey = (() => {
      try {
        return ImageManager.resolveHeadingKey(resolvedHeadingTitle);
      } catch {
        return resolvedHeadingTitle;
      }
    })();

    const selectedKey = (() => {
      try {
        return String(getHeadingSelectedImageKey(resolvedHeadingKey) || '').trim();
      } catch {
        return '';
      }
    })();

    const headingIndex = (() => {
      try {
        const hs = (ImageManager as any)?.headings;
        const list = Array.isArray(hs) ? hs : [];
        const idx = list.findIndex((h: any) => {
          const t = typeof h === 'string' ? String(h || '').trim() : String(h?.title || h || '').trim();
          return t === resolvedHeadingTitle;
        });
        if (idx >= 0) return idx;
      } catch {
        // ignore
      }
      try {
        const titles = (window as any)._headingTitles;
        if (Array.isArray(titles)) {
          const idx = titles.findIndex((t: any) => String(t || '').trim() === resolvedHeadingTitle);
          if (idx >= 0) return idx;
        }
      } catch {
        // ignore
      }
      return -1;
    })();

    toastManager.info(`🔄 "${resolvedHeadingTitle}" 이미지 재생성 중...`);

    const selectedSourceBtn = document.querySelector('.image-source-btn.selected') as HTMLButtonElement | null;
    const selectedSource = String(selectedSourceBtn?.dataset.source || '').trim();
    const provider = (selectedSource && selectedSource !== 'saved') ? selectedSource : 'nano-banana-pro';

    if (selectedSource === 'saved') {
      toastManager.warning('저장된 이미지는 생성할 수 없습니다. 다른 이미지 소스를 선택해주세요.');
      return;
    }

    const safePrompt = String(prompt || '').trim() || resolvedHeadingTitle;
    if (!safePrompt) {
      toastManager.warning('이미지 프롬프트가 비어있습니다. 먼저 프롬프트를 생성해주세요.');
      return;
    }

    const result = await (window as any).electronAPI.generateImages({
      provider,
      items: [{ heading: resolvedHeadingTitle, prompt: safePrompt }],
      regenerate: true,
      postId: currentPostId || undefined,
    });

    if (result.success && result.images && result.images.length > 0) {
      const newImage = result.images[0];

      const newImageObj: any = {
        heading: resolvedHeadingTitle,
        filePath: newImage.filePath,
        previewDataUrl: newImage.previewDataUrl,
        provider: newImage.provider,
        url: newImage.url || newImage.filePath,
        prompt,
        ...(headingIndex >= 0 ? { headingIndex } : {}),
        timestamp: Date.now(),
      };

      // ✅ 선택된 썸네일(추가 이미지) 교체 지원
      let replacedSelected = false;
      if (selectedKey) {
        try {
          const imgs = ImageManager.getImages(resolvedHeadingKey) || [];
          const idx = (imgs || []).findIndex((img: any) => getStableImageKey(img) === selectedKey);
          if (idx >= 0) {
            const cloned = Array.isArray(imgs) ? imgs.slice() : [];
            cloned[idx] = { ...newImageObj, heading: resolvedHeadingKey };
            ImageManager.imageMap.set(resolvedHeadingKey, cloned);
            ImageManager.unsetHeadings.delete(resolvedHeadingKey);
            try {
              ImageManager.syncGeneratedImagesArray();
            } catch {
              // ignore
            }
            try {
              ImageManager.syncAllPreviews();
            } catch {
              // ignore
            }
            replacedSelected = true;

            const newKey = String(getStableImageKey(cloned[idx]) || '').trim();
            if (newKey) {
              try {
                setHeadingSelectedImageKey(resolvedHeadingKey, newKey);
              } catch {
                // ignore
              }
            }
          }
        } catch {
          // ignore
        }
      }

      // 선택 이미지 교체가 아니면 기존대로 대표(0번) 교체
      if (!replacedSelected) {
        ImageManager.setImage(resolvedHeadingTitle, newImageObj);
        const newKey = String(getStableImageKey(newImageObj) || '').trim();
        if (newKey) {
          try {
            setHeadingSelectedImageKey(resolvedHeadingKey, newKey);
          } catch {
            // ignore
          }
        }
      }

      try {
        const allImagesAfter = ImageManager.getAllImages();
        (window as any).imageManagementGeneratedImages = allImagesAfter;
      } catch {
        // ignore
      }

      try {
        syncGlobalImagesFromImageManager();
      } catch {
        // ignore
      }

      try {
        const allImagesAfter = ImageManager.getAllImages();
        displayGeneratedImages(allImagesAfter);
        updatePromptItemsWithImages(allImagesAfter);
      } catch {
        // ignore
      }

      toastManager.success(`✅ "${resolvedHeadingTitle}" 이미지 재생성 완료!`);
    } else {
      throw new Error(result.message || '이미지 생성 실패');
    }
  } catch (error) {
    console.error('[ImageManager] 이미지 재생성 실패:', error);
    toastManager.error(`❌ 이미지 재생성 실패: ${(error as Error).message}`);
  }
}

// ✅ 빈 소제목에 로컬 이미지 선택 (폴더에서 불러오기 UI와 동일하게 변경)
async function selectLocalImageForHeading(headingIndex: number, headingTitle: string): Promise<void> {
  try {
    // ✅ 저장된 이미지 폴더 목록을 먼저 표시 (폴더에서 불러오기와 동일한 UI)
    let basePath = '';
    try {
      basePath = await getRequiredImageBasePath();
    } catch {
      basePath = '';
    }

    if (basePath) {
      const dirEntries = await window.api.readDirWithStats?.(basePath);
      const folders = dirEntries?.filter((entry: any) => entry.isDirectory) || [];

      if (folders.length > 0) {
        // 저장된 폴더가 있으면 폴더 선택 모달 표시
        showFolderSelectionForHeading(headingIndex, headingTitle, basePath, folders);
        return;
      }
    }

    // 저장된 폴더가 없으면 기존 파일 선택 다이얼로그 사용
    const result = await window.api.selectLocalImageFile();

    // ✅ 안전한 HTML 이스케이프
    const safeTitle = escapeHtml(headingTitle);

    if (result.success && result.filePath) {
      const imageUrl = result.previewDataUrl || result.filePath || '';
      // 이미지 미리보기 업데이트
      const promptItem = document.querySelector(`.prompt-item[data-index="${headingIndex + 1}"]`);
      if (promptItem) {
        const imageContainer = promptItem.querySelector('.generated-image');
        if (imageContainer) {
          imageContainer.innerHTML = `
            <img src="${imageUrl}" 
                 style="width: 100%; height: 100%; object-fit: cover; border-radius: 6px;"
                 onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23ddd%22 width=%22100%22 height=%22100%22/%3E%3Ctext x=%2250%22 y=%2250%22 text-anchor=%22middle%22 fill=%22%23999%22%3E로드 실패%3C/text%3E%3C/svg%3E'">
            <div style="position: absolute; bottom: 0; left: 0; right: 0; padding: 0.5rem; background: linear-gradient(transparent, rgba(0,0,0,0.8)); display: flex; gap: 0.5rem; justify-content: center;">
              <button type="button" class="select-local-image-btn" data-heading-index="${headingIndex}" style="padding: 0.25rem 0.5rem; background: #8b5cf6; color: white; border: none; border-radius: 4px; font-size: 0.75rem; cursor: pointer;">📁</button>
              <button type="button" class="regenerate-single-image-btn" data-heading-index="${headingIndex}" style="padding: 0.25rem 0.5rem; background: #3b82f6; color: white; border: none; border-radius: 4px; font-size: 0.75rem; cursor: pointer;">🔄</button>
              <button type="button" class="remove-heading-image-btn" data-heading-index="${headingIndex}" style="padding: 0.25rem 0.5rem; background: #ef4444; color: white; border: none; border-radius: 4px; font-size: 0.75rem; cursor: pointer;">🗑️</button>
            </div>
          `;
          (imageContainer as HTMLElement).style.position = 'relative';

          ensurePromptCardRemoveButtons();
          ensurePromptCardRemoveHandler();
        }
      }

      // ImageManager에 등록
      ImageManager.setImage(headingTitle, {
        heading: headingTitle,
        filePath: result.filePath,
        previewDataUrl: result.previewDataUrl || result.filePath,
        provider: 'local',
        url: result.filePath
      });

      try {
        (window as any).imageManagementGeneratedImages = ImageManager.getAllImages();
      } catch {
        // ignore
      }
      syncGlobalImagesFromImageManager();
      try {
        updatePromptItemsWithImages((window as any).imageManagementGeneratedImages || []);
      } catch {
        // ignore
      }

      appendLog(`✅ "${headingTitle}" 소제목에 로컬 이미지 배치 완료`, 'images-log-output');
      toastManager.success(`✅ 로컬 이미지 배치 완료!`);
    }
  } catch (error) {
    console.error('[Image] 로컬 이미지 선택 실패:', error);
    toastManager.error(`❌ 이미지 선택 실패: ${(error as Error).message}`);
  }
}

// ✅ 소제목용 폴더 선택 모달 (메인 폴더 선택과 동일한 리스트형 UI)
async function showFolderSelectionForHeading(
  headingIndex: number,
  headingTitle: string,
  basePath: string,
  folders: any[],
  mode: 'single' | 'multi' = 'single',
): Promise<void> {
  // 기존 모달 제거
  const existingModal = document.getElementById('folder-selection-modal');
  if (existingModal) existingModal.remove();

  const modal = document.createElement('div');
  modal.id = 'folder-selection-modal';
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.8); z-index: 10001;
    display: flex; align-items: center; justify-content: center;
  `;

  const safeHeadingTitle = escapeHtml(headingTitle);

  const sortedFolders = [...folders].sort((a: any, b: any) => {
    const at = Number(a?.mtime || 0);
    const bt = Number(b?.mtime || 0);
    return bt - at;
  });

  const renderFolderItem = (folder: any) => {
    const name = String(folder?.name || '').trim();
    const date = folder?.mtime ? new Date(folder.mtime) : null;
    const dateLabel = date ? `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}` : '';
    const titleLabel = name.replace(/^\d{4}-\d{2}-\d{2}_?/, '').trim() || name;
    return `
      <button type="button" class="folder-item" data-folder-name="${escapeHtml(name)}" style="width: 100%; padding: 0.9rem 1rem; background: linear-gradient(135deg, var(--bg-secondary), var(--bg-tertiary)); border: 2px solid var(--border-light); border-radius: 12px; cursor: pointer; transition: all 0.2s; text-align: left; display: flex; align-items: center; gap: 0.75rem;">
        <span style="font-size: 1.5rem; line-height: 1;">📂</span>
        <div style="min-width:0; flex: 1;">
          <div style="display:flex; align-items:center; gap: 0.5rem;">
            ${dateLabel ? `<span style="background: rgba(99, 102, 241, 0.2); color: var(--primary); padding: 2px 6px; border-radius: 6px; font-size: 0.75rem; font-weight: 700; white-space: nowrap;">${dateLabel}</span>` : ''}
            <span style="color: var(--text-strong); font-weight: 800; font-size: 0.95rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(titleLabel)}</span>
          </div>
          <div style="margin-top: 0.25rem; color: var(--text-muted); font-size: 0.78rem; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${escapeHtml(name)}</div>
        </div>
        <span style="color: var(--text-muted); font-weight: 900;">→</span>
      </button>
    `;
  };

  modal.innerHTML = `
    <div style="background: var(--bg-primary); border-radius: 16px; padding: 2rem; max-width: 900px; width: 90%; max-height: 85vh; overflow: hidden; box-shadow: 0 8px 32px rgba(0,0,0,0.5); position: relative; display: flex; flex-direction: column;">
      <button id="close-folder-modal" style="position: absolute; top: 1rem; right: 1rem; background: rgba(239, 68, 68, 0.9); color: white; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transition: all 0.2s; z-index: 1;" onmouseover="this.style.background='rgba(220, 38, 38, 1)'; this.style.transform='scale(1.1)';" onmouseout="this.style.background='rgba(239, 68, 68, 0.9)'; this.style.transform='scale(1)';">✕</button>
      <h2 style="margin: 0 0 1rem 0; color: var(--text-gold); font-size: 1.5rem; display: flex; align-items: center; gap: 0.5rem;">
        <span style="font-size: 1.75rem;">📁</span>
        <span>"${safeHeadingTitle}" 소제목에 배치할 이미지 폴더 선택</span>
        <span style="font-size: 0.85rem; color: var(--text-muted); font-weight: 400; margin-left: auto;">⬇️ 최신순</span>
      </h2>

      <div style="margin-bottom: 1rem; display: flex; gap: 0.5rem; align-items: center;">
        <div style="flex: 1; position: relative;">
          <input type="text" id="heading-folder-search-input" placeholder="폴더명 검색 (예: 바디프랜드, 2025-12-05)" style="width: 100%; padding: 0.6rem 0.75rem 0.6rem 2.25rem; background: var(--bg-tertiary); border: 2px solid var(--border-light); border-radius: 8px; color: var(--text-strong); font-size: 0.9rem;"/>
          <span style="position: absolute; left: 0.6rem; top: 50%; transform: translateY(-50%); font-size: 1rem;">🔍</span>
        </div>
        <span id="heading-folder-count-label" style="color: var(--text-muted); font-size: 0.8rem; white-space: nowrap;">${sortedFolders.length}개</span>
      </div>

      <div id="heading-folder-list" style="flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 0.6rem; padding: 0.25rem;">
        ${sortedFolders.map((f: any) => renderFolderItem(f)).join('')}
      </div>

      <div style="margin-top: 1rem; padding-top: 1rem; border-top: 2px solid var(--border-light); display: flex; justify-content: space-between; align-items: center; gap: 1rem;">
        <button id="select-file-directly" style="padding: 0.6rem 1.25rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 8px; cursor: pointer; font-weight: 600;">📄 파일에서 직접 선택</button>
        <button id="cancel-folder-modal" style="padding: 0.6rem 1.25rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 8px; cursor: pointer; font-weight: 600;">닫기</button>
      </div>
    </div>
  `;

  document.body.appendChild(modal);

  // 닫기 및 바깥 클릭
  modal.querySelector('#close-folder-modal')?.addEventListener('click', () => modal.remove());
  modal.querySelector('#cancel-folder-modal')?.addEventListener('click', () => modal.remove());
  modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });

  // 검색
  const searchInput = modal.querySelector('#heading-folder-search-input') as HTMLInputElement | null;
  const listEl = modal.querySelector('#heading-folder-list') as HTMLDivElement | null;
  const countEl = modal.querySelector('#heading-folder-count-label') as HTMLSpanElement | null;

  const applySearch = () => {
    if (!searchInput || !listEl || !countEl) return;
    const q = searchInput.value.toLowerCase().trim();
    const filtered = q === ''
      ? sortedFolders
      : sortedFolders.filter((f: any) => String(f?.name || '').toLowerCase().includes(q));
    listEl.innerHTML = filtered.map((f: any) => renderFolderItem(f)).join('');
    countEl.textContent = `${filtered.length}개`;
    attachFolderClickEvents();
  };

  const attachFolderClickEvents = () => {
    listEl?.querySelectorAll('.folder-item').forEach((item) => {
      item.addEventListener('click', async () => {
        const folderName = (item as HTMLElement).dataset.folderName || '';
        if (!folderName) return;
        modal.remove();
        const folderPath = `${basePath}/${folderName}`;
        const folderImages = await loadImagesFromFolderForHeading(folderPath);
        if (folderImages.length > 0) {
          if (mode === 'multi') {
            showMultipleImageSelectionModal(
              headingIndex,
              headingTitle,
              folderImages.map((img) => String(img.filePath || '')),
            );
          } else {
            showImageSelectionForHeading(headingIndex, headingTitle, folderImages, folderName);
          }
        } else {
          toastManager.error('이 폴더에서 이미지를 찾을 수 없습니다.');
        }
      });
    });
  };

  searchInput?.addEventListener('input', applySearch);
  attachFolderClickEvents();

  // 파일에서 직접 선택
  modal.querySelector('#select-file-directly')?.addEventListener('click', async () => {
    modal.remove();
    if (mode === 'multi' && typeof (window.api as any)?.showOpenDialog === 'function') {
      const pick = await (window.api as any).showOpenDialog({
        properties: ['openFile', 'multiSelections'],
        filters: [{ name: 'Images', extensions: ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp'] }],
      });
      const paths = Array.isArray(pick?.filePaths) ? pick.filePaths : [];
      if (!pick?.canceled && paths.length > 0) {
        addImagesToHeadingGrid(headingIndex, headingTitle, paths);
        appendLog(`✅ "${headingTitle}" 소제목에 ${paths.length}개 이미지 추가됨`, 'images-log-output');
        toastManager.success(`✅ ${paths.length}개 이미지 추가 완료!`);
      }
      return;
    }

    const result = await window.api.selectLocalImageFile();
    if (result.success && result.filePath) {
      applyImageToHeadingFromFolder(headingIndex, headingTitle, result.filePath, result.previewDataUrl || result.filePath);
    }
  });

  // 기존 hover 효과는 CSS 대신 item 스타일 자체에 남긴 상태 (리스트형에서도 자연스럽게 보임)
}

// ✅ 소제목용 폴더 내 이미지 로드
async function loadImagesFromFolderForHeading(folderPath: string): Promise<any[]> {
  try {
    const files = await window.api.readDirWithStats?.(folderPath);
    if (!files) return [];

    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
    const imageFiles = files.filter((file: any) =>
      !file.isDirectory &&
      imageExtensions.some(ext => file.name.toLowerCase().endsWith(ext))
    );

    return imageFiles.map((file: any) => ({
      filePath: `${folderPath}/${file.name}`,
      name: file.name,
      previewDataUrl: `file:///${folderPath.replace(/\\/g, '/')}/${file.name}`
    }));
  } catch (error) {
    console.error('폴더 이미지 로드 실패:', error);
    return [];
  }
}

// ✅ 소제목용 이미지 선택 모달 (폴더 내 이미지 표시)
function showImageSelectionForHeading(headingIndex: number, headingTitle: string, images: any[], folderName: string): void {
  const existingModal = document.getElementById('image-selection-modal');
  if (existingModal) existingModal.remove();

  const modal = document.createElement('div');
  modal.id = 'image-selection-modal';
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.8); z-index: 10002;
    display: flex; align-items: center; justify-content: center;
  `;

  const safeHeadingTitle = escapeHtml(headingTitle);
  const safeFolderName = escapeHtml(folderName);

  const selectedImages: Set<string> = new Set();

  modal.innerHTML = `
    <div style="background: var(--bg-primary); border-radius: 16px; padding: 2rem; max-width: 900px; width: 90%; max-height: 85vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <h2 style="margin: 0; color: var(--text-strong);">
          🖼️ "${safeHeadingTitle}" 소제목에 추가할 이미지 선택
        </h2>
        <button id="close-img-modal" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text-muted);">&times;</button>
      </div>
      <p style="color: var(--text-muted); margin-bottom: 1rem;">📁 ${safeFolderName} (${images.length}개 이미지) - 여러 개 선택 가능</p>
      
      <div id="images-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.75rem; margin-bottom: 1.5rem; max-height: 50vh; overflow-y: auto; padding: 0.5rem;">
        ${images.map((img, i) => `
          <div class="img-item" data-img-path="${escapeHtml(img.filePath)}" style="
            position: relative;
            aspect-ratio: 1;
            border-radius: 8px;
            overflow: hidden;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
          ">
            <img src="${img.previewDataUrl}" style="width: 100%; height: 100%; object-fit: cover;" 
                 onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23333%22 width=%22100%22 height=%22100%22/%3E%3C/svg%3E'">
            <div class="check-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(59, 130, 246, 0.5); display: none; align-items: center; justify-content: center;">
              <span style="font-size: 2rem;">✅</span>
            </div>
          </div>
        `).join('')}
      </div>
      
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span id="selected-count" style="color: var(--text-muted);">0개 선택됨</span>
        <div style="display: flex; gap: 0.75rem;">
          <button id="cancel-img-modal" style="padding: 0.75rem 1.5rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 8px; cursor: pointer;">취소</button>
          <button id="confirm-img-modal" style="padding: 0.75rem 1.5rem; background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">선택 완료</button>
        </div>
      </div>
    </div>
  `;

  document.body.appendChild(modal);

  // 이벤트 핸들러
  modal.querySelector('#close-img-modal')?.addEventListener('click', () => modal.remove());
  modal.querySelector('#cancel-img-modal')?.addEventListener('click', () => modal.remove());
  modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });

  // 이미지 선택 토글
  modal.querySelectorAll('.img-item').forEach(item => {
    item.addEventListener('click', () => {
      const imgPath = (item as HTMLElement).dataset.imgPath || '';
      const overlay = item.querySelector('.check-overlay') as HTMLElement;

      if (selectedImages.has(imgPath)) {
        selectedImages.delete(imgPath);
        (item as HTMLElement).style.borderColor = 'transparent';
        if (overlay) overlay.style.display = 'none';
      } else {
        selectedImages.add(imgPath);
        (item as HTMLElement).style.borderColor = '#3b82f6';
        if (overlay) overlay.style.display = 'flex';
      }

      const countEl = modal.querySelector('#selected-count');
      if (countEl) countEl.textContent = `${selectedImages.size}개 선택됨`;
    });
  });

  // 확인 버튼
  modal.querySelector('#confirm-img-modal')?.addEventListener('click', () => {
    if (selectedImages.size === 0) {
      alert('이미지를 선택해주세요.');
      return;
    }

    const imagesArray = Array.from(selectedImages);
    modal.remove();

    // 선택된 이미지들을 소제목에 추가
    addImagesToHeadingGrid(headingIndex, headingTitle, imagesArray);

    appendLog(`✅ "${headingTitle}" 소제목에 ${imagesArray.length}개 이미지 추가됨`, 'images-log-output');
    toastManager.success(`✅ ${imagesArray.length}개 이미지 추가 완료!`);
  });
}

// ✅ 이미지를 소제목에 적용 (단일 이미지용 - 폴더 선택 모달용)
function applyImageToHeadingFromFolder(headingIndex: number, headingTitle: string, filePath: string, previewUrl: string): void {
  const safeTitle = escapeHtml(headingTitle);

  const promptItem = document.querySelector(`.prompt-item[data-index="${headingIndex + 1}"]`);
  if (promptItem) {
    const container = promptItem.querySelector('.generated-images-container');
    if (container) {
      let grid = container.querySelector('.images-grid') as HTMLElement;
      const placeholder = container.querySelector('.no-image-placeholder') as HTMLElement;

      if (!grid) {
        grid = document.createElement('div');
        grid.className = 'images-grid';
        grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 0.5rem; margin-bottom: 0.75rem;';
        container.insertBefore(grid, container.firstChild);
      }

      if (placeholder) placeholder.style.display = 'none';

      const existingImages = grid.querySelectorAll('.grid-image-item')?.length || 0;
      const imageKey = toFileUrlMaybe(`file:///${String(filePath || '').replace(/\\/g, '/')}`);
      const imgItem = document.createElement('div');
      imgItem.className = 'grid-image-item';
      if (imageKey) imgItem.setAttribute('data-image-key', String(imageKey));
      imgItem.setAttribute('data-heading-index', String(headingIndex));
      imgItem.setAttribute('data-heading-title', String(headingTitle || ''));
      imgItem.style.cssText = 'position: relative; aspect-ratio: 1; border-radius: 6px; overflow: hidden;';
      imgItem.innerHTML = `
        <img src="file:///${filePath.replace(/\\/g, '/')}" style="width: 100%; height: 100%; object-fit: cover;" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23333%22 width=%22100%22 height=%22100%22/%3E%3C/svg%3E'">
        <button type="button" class="remove-single-grid-image-btn" data-heading-index="${headingIndex}" data-image-index="${existingImages}" data-heading-title="${safeTitle}" data-image-key="${escapeHtml(String(imageKey || ''))}" style="position: absolute; top: 4px; right: 4px; background: rgba(239,68,68,0.9); color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; font-size: 0.8rem;">✕</button>
      `;
      grid.appendChild(imgItem);
    }
  }

  // ImageManager에 추가
  ImageManager.addImage(headingTitle, {
    heading: headingTitle,
    filePath: filePath,
    url: `file:///${filePath.replace(/\\/g, '/')}`,
    previewDataUrl: previewUrl,
    provider: 'local',
    savedToLocal: true,
    headingIndex: headingIndex
  });

  const allImagesAfter = (() => {
    try {
      const all = ImageManager.getAllImages();
      return Array.isArray(all) ? all : [];
    } catch {
      return [];
    }
  })();
  (window as any).imageManagementGeneratedImages = allImagesAfter.length > 0 ? allImagesAfter : generatedImages;
  displayGeneratedImages(allImagesAfter.length > 0 ? allImagesAfter : generatedImages);

  appendLog(`✅ "${headingTitle}" 소제목에 이미지 추가됨`, 'images-log-output');
  toastManager.success(`✅ 이미지 추가 완료!`);
}

// ✅ 빈 소제목에 이미지 생성
async function regenerateSingleImageForHeading(headingIndex: number, headingTitle: string, prompt: string): Promise<void> {
  try {
    const resolvedHeadingTitle = String(headingTitle || '').trim() || getHeadingTitleByIndex(headingIndex) || `소제목 ${headingIndex + 1}`;
    toastManager.info(`🔄 "${resolvedHeadingTitle}" 이미지 생성 중...`);

    // 선택된 이미지 소스 확인
    const selectedSource = document.querySelector('.image-source-btn.selected') as HTMLButtonElement;
    const imageSource = selectedSource?.dataset.source || 'nano-banana-pro';

    // ✅ 블로그 제목 가져오기 (썸네일용)
    const blogTitle = (document.getElementById('unified-generated-title') as HTMLInputElement)?.value?.trim() ||
      (document.getElementById('unified-title') as HTMLInputElement)?.value?.trim() ||
      (document.getElementById('image-title') as HTMLInputElement)?.value?.trim() || '';

    // ✅ 인덱스 기반 프롬프트 생성 (1번=썸네일, 2번부터=NEVER TEXT)
    const finalPrompt = generateImagePromptByIndex(resolvedHeadingTitle, headingIndex, blogTitle);

    appendLog(`🎨 "${resolvedHeadingTitle}" 이미지 생성 시작 (${imageSource}, ${headingIndex === 0 ? '썸네일' : 'NEVER TEXT'})...`, 'images-log-output');

    let imageUrl: string;

    if (imageSource === 'dalle' || imageSource === 'imagen4') {
      imageUrl = await generateImagen4ImageLocal(finalPrompt);
    } else if (imageSource === 'pollinations' || imageSource === 'nano-banana-pro') {
      imageUrl = await generateNanoBananaProImage(finalPrompt);
    } else if (imageSource === 'prodia') {
      const imageResult = await generateImagesWithCostSafety({
        provider: 'prodia',
        items: [{ heading: resolvedHeadingTitle, prompt: finalPrompt }],
        postTitle: blogTitle,
        isFullAuto: true,
      });
      if (imageResult.success && imageResult.images && imageResult.images.length > 0) {
        imageUrl = imageResult.images[0].previewDataUrl || imageResult.images[0].filePath;
      } else {
        throw new Error(imageResult.message || 'Prodia 이미지 생성 실패');
      }
    } else if (imageSource === 'stability') {
      const stabilityModel = (document.getElementById('stability-model-select') as HTMLSelectElement)?.value || 'ultra';
      const imageResult = await generateImagesWithCostSafety({
        provider: 'stability',
        items: [{ heading: resolvedHeadingTitle, prompt: finalPrompt }],
        postTitle: blogTitle,
        isFullAuto: true,
        model: stabilityModel
      });
      if (imageResult.success && imageResult.images && imageResult.images.length > 0) {
        imageUrl = imageResult.images[0].previewDataUrl || imageResult.images[0].filePath;
      } else {
        throw new Error(imageResult.message || 'Stability AI 이미지 생성 실패');
      }
    } else if (imageSource === 'falai') {
      // ✅ Fal.ai: 전용 파라미터와 함께 호출
      const imageResult = await generateImagesWithCostSafety({
        provider: 'falai',
        items: [{ heading: resolvedHeadingTitle, prompt: finalPrompt }],
        postTitle: blogTitle,
        isFullAuto: true,
      });
      if (imageResult.success && imageResult.images && imageResult.images.length > 0) {
        imageUrl = imageResult.images[0].previewDataUrl || imageResult.images[0].filePath;
      } else {
        throw new Error(imageResult.message || 'Fal.ai 이미지 생성 실패');
      }
    } else if (imageSource === 'naver-search' || imageSource === 'naver') {
      // ✅ 네이버 이미지 검색: 사용자가 명시적으로 선택한 경우에만 사용
      imageUrl = await searchNaverImage(finalPrompt);
    } else {
      // ✅ [FIX] 기본값: 알 수 없는 이미지 소스는 nano-banana-pro 사용 (네이버 검색으로 폴백하지 않음)
      console.warn(`[ImageGen] 알 수 없는 이미지 소스 "${imageSource}", 기본 AI 이미지 생성기(nano-banana-pro) 사용`);
      imageUrl = await generateNanoBananaProImage(finalPrompt);
    }

    // ✅ 안전한 HTML 이스케이프
    const safeTitle = escapeHtml(resolvedHeadingTitle);
    const safePrompt = escapeHtml(prompt);

    // 이미지 미리보기 업데이트
    const promptItem = document.querySelector(`.prompt-item[data-index="${headingIndex + 1}"]`);
    if (promptItem) {
      const imageContainer = promptItem.querySelector('.generated-image');
      if (imageContainer) {
        imageContainer.innerHTML = `
          <img src="${imageUrl}" 
               style="width: 100%; height: 100%; object-fit: cover; border-radius: 6px;"
               onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23ddd%22 width=%22100%22 height=%22100%22/%3E%3Ctext x=%2250%22 y=%2250%22 text-anchor=%22middle%22 fill=%22%23999%22%3E로드 실패%3C/text%3E%3C/svg%3E'">
          <div style="position: absolute; bottom: 0; left: 0; right: 0; padding: 0.5rem; background: linear-gradient(transparent, rgba(0,0,0,0.8)); display: flex; gap: 0.5rem; justify-content: center;">
            <button type="button" class="select-local-image-btn" data-heading-index="${headingIndex}" style="padding: 0.25rem 0.5rem; background: #8b5cf6; color: white; border: none; border-radius: 4px; font-size: 0.75rem; cursor: pointer;">📁</button>
            <button type="button" class="regenerate-single-image-btn" data-heading-index="${headingIndex}" style="padding: 0.25rem 0.5rem; background: #3b82f6; color: white; border: none; border-radius: 4px; font-size: 0.75rem; cursor: pointer;">🔄</button>
            <button type="button" class="remove-heading-image-btn" data-heading-index="${headingIndex}" style="padding: 0.25rem 0.5rem; background: #ef4444; color: white; border: none; border-radius: 4px; font-size: 0.75rem; cursor: pointer;">🗑️</button>
          </div>
        `;
        (imageContainer as HTMLElement).style.position = 'relative';
      }
    }

    // ImageManager에 등록
    ImageManager.setImage(resolvedHeadingTitle, {
      heading: resolvedHeadingTitle,
      filePath: imageUrl,
      previewDataUrl: imageUrl,
      provider: imageSource,
      url: imageUrl,
      prompt
    });

    // 전역 변수에도 추가
    const existingImagesRaw = (window as any).imageManagementGeneratedImages;
    const existingImages = Array.isArray(existingImagesRaw) ? existingImagesRaw : [];
    const normalizedHeadingKey = (() => {
      try {
        return normalizeHeadingKeyForVideoCache(resolvedHeadingTitle);
      } catch {
        return '';
      }
    })();
    const filteredImages = existingImages.filter((img: any) => {
      const idx = Number(img?.headingIndex ?? -999);
      if (Number.isFinite(idx) && idx === headingIndex) return false;
      const h = String(img?.heading || '').trim();
      if (!h) return true;
      if (h === resolvedHeadingTitle) return false;
      if (normalizedHeadingKey) {
        try {
          return normalizeHeadingKeyForVideoCache(h) !== normalizedHeadingKey;
        } catch {
          return true;
        }
      }
      return true;
    });
    filteredImages.push({
      heading: resolvedHeadingTitle,
      filePath: imageUrl,
      url: imageUrl,
      previewDataUrl: imageUrl,
      provider: imageSource,
      prompt,
      headingIndex
    });
    (window as any).imageManagementGeneratedImages = filteredImages;

    appendLog(`✅ "${resolvedHeadingTitle}" 이미지 생성 완료!`, 'images-log-output');
    toastManager.success(`✅ 이미지 생성 완료!`);
  } catch (error) {
    console.error('[Image] 이미지 생성 실패:', error);
    appendLog(`❌ "${String(headingTitle || '').trim() || `소제목 ${headingIndex + 1}`}" 이미지 생성 실패: ${(error as Error).message}`, 'images-log-output');
    toastManager.error(`❌ 이미지 생성 실패: ${(error as Error).message}`);
  }
}

// ✅ 소제목 이미지 건너뛰기
function skipHeadingImage(headingIndex: number, headingTitle: string): void {
  // ✅ 안전한 HTML 이스케이프
  const safeTitle = escapeHtml(headingTitle);

  const promptItem = document.querySelector(`.prompt-item[data-index="${headingIndex + 1}"]`);
  if (promptItem) {
    const imageContainer = promptItem.querySelector('.generated-images-container') || promptItem.querySelector('.generated-image');
    if (imageContainer) {
      const placeholder = imageContainer.querySelector('.no-image-placeholder');
      if (placeholder) {
        (placeholder as HTMLElement).innerHTML = `
          <span style="color: var(--text-muted); font-size: 2rem;">⏭️</span>
          <span style="color: var(--text-muted); font-size: 0.85rem;">이미지 없이 진행</span>
          <button type="button" class="undo-skip-btn" data-heading-index="${headingIndex}" style="padding: 0.4rem 0.75rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 6px; font-size: 0.8rem; cursor: pointer;">
            ↩️ 되돌리기
          </button>
        `;
      }
    }
  }

  appendLog(`⏭️ "${headingTitle}" 소제목은 이미지 없이 진행됩니다.`, 'images-log-output');
}

function undoSkipHeadingImage(headingIndex: number, headingTitle: string): void {
  const promptItem = document.querySelector(`.prompt-item[data-index="${headingIndex + 1}"]`);
  if (promptItem) {
    const imageContainer = promptItem.querySelector('.generated-images-container') || promptItem.querySelector('.generated-image');
    if (imageContainer) {
      const placeholder = imageContainer.querySelector('.no-image-placeholder');
      if (placeholder) {
        (placeholder as HTMLElement).innerHTML = `
          <span style="color: var(--text-muted); font-size: 2rem;">🖼️</span>
          <span style="color: var(--text-muted); font-size: 0.85rem;">이미지 없음</span>
        `;
      }
    }
  }

  appendLog(`↩️ "${headingTitle}" 소제목의 이미지 건너뛰기를 되돌렸습니다.`, 'images-log-output');
}

// ✅ 소제목에 여러 이미지 추가
async function addMultipleImagesToHeading(headingIndex: number, headingTitle: string): Promise<void> {
  try {
    let basePath = '';
    try {
      basePath = await getRequiredImageBasePath();
    } catch {
      basePath = '';
    }

    if (basePath) {
      const dirEntries = await window.api.readDirWithStats?.(basePath);
      const folders = dirEntries?.filter((entry: any) => entry.isDirectory) || [];
      if (folders.length > 0) {
        await showFolderSelectionForHeading(headingIndex, headingTitle, basePath, folders, 'multi');
        return;
      }
    }

    // 폴더가 없으면 OS 파일 선택창(다중 선택)으로 폴백
    if (typeof (window.api as any)?.showOpenDialog === 'function') {
      const pick = await (window.api as any).showOpenDialog({
        properties: ['openFile', 'multiSelections'],
        filters: [{ name: 'Images', extensions: ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp'] }],
      });
      const paths = Array.isArray(pick?.filePaths) ? pick.filePaths : [];
      if (!pick?.canceled && paths.length > 0) {
        addImagesToHeadingGrid(headingIndex, headingTitle, paths);
        appendLog(`✅ "${headingTitle}" 소제목에 ${paths.length}개 이미지 추가됨`, 'images-log-output');
        toastManager.success(`✅ ${paths.length}개 이미지 추가 완료!`);
        return;
      }
    }

    // 최종 폴백: 기존 단일 파일 선택
    selectLocalImageForHeading(headingIndex, headingTitle);

  } catch (error) {
    console.error('[AddMultipleImages] 오류:', error);
    // 폴더 선택 실패 시 기존 로컬 이미지 선택 기능 사용
    selectLocalImageForHeading(headingIndex, headingTitle);
  }
}

// ✅ 여러 이미지 선택 모달
function showMultipleImageSelectionModal(headingIndex: number, headingTitle: string, images: string[]): void {
  // 기존 모달 제거
  const existingModal = document.getElementById('multiple-image-selection-modal');
  if (existingModal) existingModal.remove();

  const modal = document.createElement('div');
  modal.id = 'multiple-image-selection-modal';
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.8); z-index: 10001;
    display: flex; align-items: center; justify-content: center;
  `;

  const selectedImages: Set<string> = new Set();

  modal.innerHTML = `
    <div style="background: var(--bg-primary); border-radius: 12px; padding: 1.5rem; width: 90%; max-width: 800px; max-height: 80vh; overflow-y: auto;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <h3 style="margin: 0; color: var(--text-strong);">🖼️ "${headingTitle}" 소제목에 추가할 이미지 선택</h3>
        <button id="close-multi-img-modal" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text-muted);">&times;</button>
          </div>
      <p style="color: var(--text-muted); margin-bottom: 1rem;">여러 이미지를 선택하면 소제목에 모두 추가됩니다.</p>
      <div id="multi-images-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 0.75rem; margin-bottom: 1rem;"></div>
      <div style="display: flex; justify-content: space-between; align-items: center;">
        <span id="selected-count" style="color: var(--text-muted);">0개 선택됨</span>
        <div style="display: flex; gap: 0.75rem;">
          <button id="cancel-multi-img" style="padding: 0.75rem 1.5rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 8px; cursor: pointer;">취소</button>
          <button id="confirm-multi-img" style="padding: 0.75rem 1.5rem; background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">선택 완료</button>
        </div>
        </div>
      </div>
    `;

  document.body.appendChild(modal);

  // 이벤트 핸들러
  modal.querySelector('#close-multi-img-modal')?.addEventListener('click', () => modal.remove());
  modal.querySelector('#cancel-multi-img')?.addEventListener('click', () => modal.remove());
  modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });

  // 이미지 선택 토글
  const gridEl = modal.querySelector('#multi-images-grid') as HTMLElement | null;
  const renderBatchSize = 36;
  let renderIndex = 0;
  const safeFallback = "data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23333%22 width=%22100%22 height=%22100%22/%3E%3C/svg%3E";

  const attachItemHandlers = (item: HTMLElement) => {
    item.addEventListener('click', () => {
      const imgPath = item.getAttribute('data-img-path') || '';
      const overlay = item.querySelector('.check-overlay') as HTMLElement;

      if (selectedImages.has(imgPath)) {
        selectedImages.delete(imgPath);
        item.style.borderColor = 'transparent';
        if (overlay) overlay.style.display = 'none';
      } else {
        selectedImages.add(imgPath);
        item.style.borderColor = '#3b82f6';
        if (overlay) overlay.style.display = 'flex';
      }

      const countEl = modal.querySelector('#selected-count');
      if (countEl) countEl.textContent = `${selectedImages.size}개 선택됨`;
    });
  };

  const renderNextBatch = () => {
    if (!gridEl) return;
    const frag = document.createDocumentFragment();
    const end = Math.min(images.length, renderIndex + renderBatchSize);
    for (let i = renderIndex; i < end; i++) {
      const img = images[i];
      const item = document.createElement('div');
      item.className = 'multi-img-item';
      item.setAttribute('data-img-path', img);
      item.style.cssText = 'position: relative; aspect-ratio: 1; border-radius: 8px; overflow: hidden; border: 3px solid transparent; cursor: pointer; transition: all 0.2s;';
      const src = `file:///${img.replace(/\\/g, '/')}`;
      item.innerHTML = `
        <img src="${src}" loading="lazy" decoding="async" style="width: 100%; height: 100%; object-fit: cover;" onerror="this.src='${safeFallback}'">
        <div class="check-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(59, 130, 246, 0.5); display: none; align-items: center; justify-content: center;">
          <span style="font-size: 2rem;">✅</span>
        </div>
      `;
      attachItemHandlers(item);
      frag.appendChild(item);
    }
    gridEl.appendChild(frag);
    renderIndex = end;
    if (renderIndex < images.length) {
      requestAnimationFrame(renderNextBatch);
    }
  };

  requestAnimationFrame(renderNextBatch);

  // 확인 버튼
  modal.querySelector('#confirm-multi-img')?.addEventListener('click', async () => {
    if (selectedImages.size === 0) {
      alert('이미지를 선택해주세요.');
      return;
    }

    // 선택된 이미지들을 소제목에 추가
    const imagesArray = Array.from(selectedImages);
    addImagesToHeadingGrid(headingIndex, headingTitle, imagesArray);

    modal.remove();
    appendLog(`✅ "${headingTitle}" 소제목에 ${imagesArray.length}개 이미지 추가됨`, 'images-log-output');
    toastManager.success(`✅ ${imagesArray.length}개 이미지 추가 완료!`);
  });
}

// ✅ 소제목 이미지 그리드에 이미지 추가
function addImagesToHeadingGrid(headingIndex: number, headingTitle: string, imagePaths: string[]): void {
  // ✅ 안전한 HTML 이스케이프
  const safeTitle = escapeHtml(headingTitle);

  console.log(`[addImagesToHeadingGrid] headingIndex: ${headingIndex}, headingTitle: "${headingTitle}", imagePaths: ${imagePaths.length}개`);

  const promptItem = document.querySelector(`.prompt-item[data-index="${headingIndex + 1}"]`);
  if (!promptItem) {
    console.warn(`[addImagesToHeadingGrid] promptItem을 찾을 수 없음: data-index="${headingIndex + 1}"`);
    return;
  }

  const container = promptItem.querySelector('.generated-images-container');
  if (!container) {
    console.warn(`[addImagesToHeadingGrid] container를 찾을 수 없음`);
    return;
  }

  let grid = container.querySelector('.images-grid') as HTMLElement;
  const placeholder = container.querySelector('.no-image-placeholder') as HTMLElement;

  // ✅ images-grid가 없으면 생성
  if (!grid) {
    console.log(`[addImagesToHeadingGrid] images-grid가 없어서 생성`);
    grid = document.createElement('div');
    grid.className = 'images-grid';
    grid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 0.5rem; margin-bottom: 0.75rem;';
    container.insertBefore(grid, container.firstChild);
  }

  if (placeholder) placeholder.style.display = 'none';

  // 기존 이미지 수 확인
  const existingImages = grid?.querySelectorAll('.grid-image-item')?.length || 0;

  imagePaths.forEach((imgPath, i) => {
    const imgIndex = existingImages + i;
    const imageKey = toFileUrlMaybe(`file:///${String(imgPath || '').replace(/\\/g, '/')}`);
    const imgItem = document.createElement('div');
    imgItem.className = 'grid-image-item';
    if (imageKey) imgItem.setAttribute('data-image-key', imageKey);
    imgItem.setAttribute('data-heading-index', String(headingIndex));
    imgItem.setAttribute('data-heading-title', String(headingTitle || ''));
    imgItem.style.cssText = 'position: relative; aspect-ratio: 1; border-radius: 6px; overflow: hidden; cursor: pointer; border: 2px solid transparent; transition: all 0.15s;';
    imgItem.innerHTML = `
      <img src="file:///${imgPath.replace(/\\/g, '/')}" style="width: 100%; height: 100%; object-fit: cover;" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Crect fill=%22%23333%22 width=%22100%22 height=%22100%22/%3E%3C/svg%3E'">
      <button type="button" class="remove-single-grid-image-btn" data-heading-index="${headingIndex}" data-image-index="${imgIndex}" data-heading-title="${safeTitle}" data-image-key="${escapeHtml(imageKey)}" style="position: absolute; top: 4px; right: 4px; background: rgba(239,68,68,0.9); color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; font-size: 0.8rem;">✕</button>
    `;
    grid?.appendChild(imgItem);

    console.log(`[addImagesToHeadingGrid] 이미지 추가됨: ${imgPath.substring(imgPath.length - 30)}`);

    // ✅ ImageManager에 추가 (setImage 대신 addImage 사용 - 여러 이미지 지원)
    ImageManager.addImage(headingTitle, {
      heading: headingTitle,
      filePath: imgPath,
      url: `file:///${imgPath.replace(/\\/g, '/')}`,
      previewDataUrl: `file:///${imgPath.replace(/\\/g, '/')}`,
      provider: 'local',
      savedToLocal: true,
      headingIndex: headingIndex,
      imageIndex: imgIndex
    });
  });

  try {
    (window as any).imageManagementGeneratedImages = ImageManager.getAllImages();
  } catch {
    // ignore
  }
  syncGlobalImagesFromImageManager();
  console.log(`[addImagesToHeadingGrid] 완료: 총 ${ImageManager.getAllImages().length}개 이미지`);
}

// ✅ 소제목의 모든 이미지 삭제
function clearHeadingImages(headingIndex: number, headingTitle: string): void {
  const promptItem = document.querySelector(`.prompt-item[data-index="${headingIndex + 1}"]`);
  if (!promptItem) return;

  const container = promptItem.querySelector('.generated-images-container');
  if (!container) return;

  const grid = container.querySelector('.images-grid') as HTMLElement;
  const placeholder = container.querySelector('.no-image-placeholder') as HTMLElement;

  if (grid) grid.innerHTML = '';
  if (placeholder) {
    placeholder.style.display = 'flex';
    placeholder.innerHTML = `
      <span style="color: var(--text-muted); font-size: 2rem;">🖼️</span>
      <span style="color: var(--text-muted); font-size: 0.85rem;">이미지 없음</span>
    `;
  }

  // ImageManager에서 제거
  ImageManager.removeImage(headingTitle);

  appendLog(`🗑️ "${headingTitle}" 소제목의 모든 이미지가 삭제되었습니다.`, 'images-log-output');
}

// ✅ 소제목의 개별 이미지 제거
function removeSingleImageFromHeading(headingIndex: number, imageIndex: number, headingTitle: string, imageKey?: string): void {
  const promptItem = document.querySelector(`.prompt-item[data-index="${headingIndex + 1}"]`);
  if (!promptItem) return;

  const container = promptItem.querySelector('.generated-images-container');
  if (!container) return;

  const grid = container.querySelector('.images-grid') as HTMLElement | null;
  const placeholder = container.querySelector('.no-image-placeholder') as HTMLElement | null;

  if (!grid) return;

  try {
    pushImageHistorySnapshot('removeSingleImageFromHeading');
  } catch {
    // ignore
  }

  let removedSrc: string | null = null;
  const key = String(imageKey || '').trim();

  let targetItem: HTMLElement | null = null;
  if (key) {
    const items = Array.from(grid.querySelectorAll('.grid-image-item')) as HTMLElement[];
    targetItem = items.find((it) => String((it as any)?.dataset?.imageKey || '').trim() === key) || null;
  }

  if (!targetItem) {
    // 클릭된 버튼의 data-image-index로 실제 DOM 아이템 찾기
    const btnSelector = `.remove-single-grid-image-btn[data-image-index="${imageIndex}"]`;
    const btnEl = grid.querySelector(btnSelector) as HTMLElement | null;
    if (btnEl) {
      targetItem = btnEl.closest('.grid-image-item') as HTMLElement | null;
    }
  }

  // 폴백: 인덱스로 접근 (이전 데이터와의 호환성)
  if (!targetItem) {
    const imageItems = grid.querySelectorAll('.grid-image-item');
    if (imageItems && imageItems[imageIndex]) {
      targetItem = imageItems[imageIndex] as HTMLElement;
    }
  }

  if (targetItem) {
    const imgEl = targetItem.querySelector('img') as HTMLImageElement | null;
    if (imgEl && imgEl.src) {
      removedSrc = imgEl.src;
    }
    targetItem.remove();
  }

  // 남은 이미지가 없으면 placeholder 표시
  const remainingImages = grid.querySelectorAll('.grid-image-item')?.length || 0;
  if (remainingImages === 0 && placeholder) {
    placeholder.style.display = 'flex';
    placeholder.innerHTML = `
      <span style="color: var(--text-muted); font-size: 2rem;">🖼️</span>
      <span style="color: var(--text-muted); font-size: 0.85rem;">이미지 없음</span>
    `;
  }

  // ImageManager에서도 동일한 이미지 제거 (예비 이미지 자동 승격 방지)
  try {
    const titleKey = (() => {
      const raw = String(headingTitle || '').trim();
      const fallback = String((window as any)._headingTitles?.[headingIndex] || '').trim() || getHeadingTitleByIndex(headingIndex);
      const candidate = raw || fallback;
      if (!candidate) return '';
      try {
        return ImageManager.resolveHeadingKey(candidate);
      } catch {
        return candidate;
      }
    })();

    if (titleKey) {
      const imagesForHeading = ImageManager.getImages(titleKey);
      let targetIdx = -1;

      if (key) {
        targetIdx = imagesForHeading.findIndex((img: any) => getStableImageKey(img) === key);
      }

      if (removedSrc) {
        const normalizedRemoved = toFileUrlMaybe(String(removedSrc || '').trim());
        if (targetIdx < 0) {
          targetIdx = imagesForHeading.findIndex((img: any) => {
            const raw = img?.url || img?.filePath || img?.previewDataUrl || '';
            const norm = toFileUrlMaybe(String(raw || '').trim());
            return norm === normalizedRemoved;
          });
        }
      }

      // 매칭 실패 시 전달받은 imageIndex를 폴백으로 사용
      if (targetIdx < 0) {
        targetIdx = imageIndex;
      }

      if (targetIdx >= 0 && targetIdx < imagesForHeading.length) {
        ImageManager.removeImageAtIndex(titleKey, targetIdx);
      }
    }

    // 전역 이미지 배열도 동기화 (예비 이미지 포함)
    try {
      const allImagesAfter = ImageManager.getAllImages();
      (window as any).imageManagementGeneratedImages = allImagesAfter;
    } catch {
      // ignore
    }
  } catch (error) {
    console.error('[ImageManager] 개별 이미지 제거 동기화 실패:', error);
  }

  appendLog(`❌ "${headingTitle}" 소제목에서 이미지 1개 제거됨`, 'images-log-output');
  syncGlobalImagesFromImageManager();
}

// 현재 이미지 헤딩 가져오기
function getCurrentImageHeadings(): any[] {
  const headings: any[] = [];
  const promptItems = document.querySelectorAll('#prompts-container .prompt-item:not([style*="display: none"])');

  promptItems.forEach((item, index) => {
    const headingTitleText = item.querySelector('.heading-title-text') as HTMLDivElement;
    const promptText = item.querySelector('.prompt-text') as HTMLDivElement;

    const promptValue = String(promptText?.textContent || '').trim();
    const titleValue = String(headingTitleText?.textContent || `소제목 ${index + 1}`).trim();
    if (promptValue) {
      headings.push({
        title: titleValue,
        prompt: promptValue,
        index
      });
    }
  });

  return headings;
}

// 생성된 이미지 표시
function displayGeneratedImages(images: any[]): void {
  const promptsContainer = document.getElementById('prompts-container') as HTMLDivElement;
  const generatedImagesGrid = document.getElementById('generated-images-grid') as HTMLDivElement;

  if (!generatedImagesGrid) return;

  const passedImages = Array.isArray(images) ? images : [];
  const imagesFromManager = ImageManager.getAllImages();
  const sourceImages = passedImages.length > 0
    ? passedImages
    : ((imagesFromManager && imagesFromManager.length > 0) ? imagesFromManager : []);

  // ✅ null/undefined 이미지 필터링
  const validImages = (sourceImages || []).filter(img => img !== null && img !== undefined);

  // ✅ 디버그: 이미지 배열 내용 출력
  console.log('[DEBUG] displayGeneratedImages 호출됨, validImages:', validImages.length);
  if (validImages && validImages.length > 0) {
    validImages.forEach((img, idx) => {
      console.log(`[DEBUG] validImages[${idx}]:`, {
        heading: img?.heading,
        prompt: img?.prompt,
        url: (img?.url || '').substring(0, 50),
      });
    });
  }

  // ✅ 이미지가 없으면 안내 메시지 표시
  if (!validImages || validImages.length === 0) {
    generatedImagesGrid.style.display = 'flex';
    generatedImagesGrid.style.alignItems = 'center';
    generatedImagesGrid.style.justifyContent = 'center';
    generatedImagesGrid.innerHTML = `
      <div style="text-align: center; padding: 2rem; color: var(--text-muted);">
        <div style="font-size: 3rem; margin-bottom: 1rem;">🖼️</div>
        <div style="font-size: 1rem; margin-bottom: 0.5rem;">이미지가 없습니다</div>
        <div style="font-size: 0.85rem;">이미지 소스를 선택하고 "이미지 생성하기"를 클릭하거나<br>"폴더에서 불러오기"로 이미지를 추가하세요</div>
      </div>
    `;
    return;
  }

  // ✅ 이미지 미리보기 그리드에 표시 (개선된 버전)
  if (generatedImagesGrid && validImages.length > 0) {
    // 그리드 스타일 강제 적용
    generatedImagesGrid.style.display = 'grid';
    generatedImagesGrid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(180px, 1fr))';
    generatedImagesGrid.style.gap = '1rem';

    // ✅ 안전한 HTML 이스케이프 함수
    const escapeHtml = (str: string): string => {
      if (!str) return '';
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    };

    generatedImagesGrid.innerHTML = validImages.map((image, index) => {
      const headingRaw = image.heading || `소제목 ${index + 1}`;
      const heading = escapeHtml(headingRaw);
      // ✅ prompt가 없으면 heading을 기본값으로 사용 (폴더에서 불러온 이미지, 백업 등)
      const prompt = escapeHtml(image.prompt || image.heading || `이미지 ${index + 1}`);
      const imageRaw = image.url || image.filePath || image.previewDataUrl || '';
      const imageUrl = toFileUrlMaybe(String(imageRaw || '').trim());
      // ✅ 이 소제목에 영상이 세팅되어 있는지 확인 (캐시 기반)
      const getFromCache3 = (window as any).getHeadingVideoPreviewFromCache || getHeadingVideoPreviewFromCache;
      const videoEntry = getFromCache3(String(headingRaw || ''));
      const hasVideo = !!(videoEntry && videoEntry.url);
      const videoBadgeHtml = hasVideo
        ? `<div style="margin-top: 2px; display: flex; align-items: center; gap: 6px;"><span style="font-size: 0.65rem; color: #22c55e; font-weight: 600; white-space: nowrap;">🎞 영상 세팅됨</span><button type="button" class="remove-heading-video-btn" data-heading-index="${index}" data-heading-title="${heading}" style="padding: 2px 6px; background: rgba(239, 68, 68, 0.9); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.65rem; font-weight: 700;" title="영상 해제">해제</button></div>`
        : '';

      // ✅ GIF(영상에서 변환된 이미지)는 썸네일 우상단에 항상 보이는 X 버튼 추가
      const isGifFromVideo = String(image?.provider || '') === 'gif-from-video';
      const gifDeleteButtonHtml = isGifFromVideo
        ? `<button 
              type="button" 
              class="remove-image-btn gif-remove-btn" 
              data-image-index="${index}"
              style="position: absolute; top: 6px; right: 6px; z-index: 12; width: 24px; height: 24px; border-radius: 999px; border: none; background: rgba(239,68,68,0.95); color: #fff; font-size: 0.8rem; cursor: pointer; box-shadow: 0 2px 6px rgba(0,0,0,0.35);">
              ✕
           </button>`
        : '';
      return `
        <div class="generated-image-item" data-image-index="${index}" style="position: relative; background: var(--bg-secondary); border-radius: 12px; overflow: hidden; border: 2px solid var(--border-light); cursor: pointer; transition: all 0.3s ease; max-width: 220px; box-shadow: none;">
          <div style="position: relative; width: 100%; aspect-ratio: 1/1; overflow: hidden;">
            ${gifDeleteButtonHtml}
            <img src="${imageUrl}" alt="${heading}" 
                 style="width: 100%; height: 100%; object-fit: cover; transition: transform 0.3s ease;"
                 onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22%3E%3Crect width=%22100%22 height=%22100%22 fill=%22%232d2d2d%22/%3E%3Ctext x=%2250%22 y=%2250%22 text-anchor=%22middle%22 dominant-baseline=%22middle%22 fill=%22%23666%22 font-size=%228%22%3E이미지 로드 실패%3C/text%3E%3C/svg%3E';">
            <!-- 호버 오버레이 (6개 버튼) -->
            <div class="image-item-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient(135deg, rgba(0,0,0,0.85), rgba(0,0,0,0.75)); display: none; flex-direction: column; align-items: center; justify-content: center; gap: 5px; padding: 8px; box-sizing: border-box;">
              <button type="button" class="view-image-btn" data-image-url="${imageUrl}" data-image-index="${index}" style="width: 100%; padding: 5px 8px; background: linear-gradient(135deg, #6366f1, #4f46e5); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.7rem; font-weight: 600;">🔍 크게 보기</button>
              <button type="button" class="assign-to-heading-btn" data-image-index="${index}" style="width: 100%; padding: 5px 8px; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.7rem; font-weight: 600;">📍 소제목에 배치</button>
              <button type="button" class="regenerate-single-image-btn" data-image-index="${index}" style="width: 100%; padding: 5px 8px; background: linear-gradient(135deg, #3b82f6, #2563eb); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.7rem; font-weight: 600;">🔄 재생성</button>
              <button type="button" class="regenerate-ai-image-btn" data-image-index="${index}" style="width: 100%; padding: 5px 8px; background: linear-gradient(135deg, #8b5cf6, #7c3aed); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.7rem; font-weight: 600;">🤖 AI 이미지 생성</button>
              <button type="button" class="replace-with-saved-btn" data-image-index="${index}" style="width: 100%; padding: 5px 8px; background: linear-gradient(135deg, #f59e0b, #d97706); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.7rem; font-weight: 600;">📁 저장된 이미지</button>
              <button type="button" class="remove-image-btn" data-image-index="${index}" style="width: 100%; padding: 5px 8px; background: linear-gradient(135deg, #ef4444, #dc2626); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.7rem; font-weight: 600;">❌ 제거</button>
            </div>
            <!-- 선택 체크마크 -->
            <div class="image-selected-badge" style="position: absolute; top: 8px; right: 8px; width: 24px; height: 24px; background: var(--primary); border-radius: 50%; display: none; align-items: center; justify-content: center; color: white; font-size: 14px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">✓</div>
          </div>
          <div style="padding: 8px;">
            <div style="font-weight: 600; color: var(--text-strong); font-size: 0.75rem; margin-bottom: 2px; word-break: break-word; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${heading}">${heading}</div>
            <div style="font-size: 0.65rem; color: var(--text-muted); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${prompt}">${prompt}</div>
            ${videoBadgeHtml}
          </div>
        </div>
      `;
    }).join('');

    // 호버 시 오버레이 표시 + 이미지 확대 효과
    generatedImagesGrid.querySelectorAll('.generated-image-item').forEach(item => {
      item.addEventListener('mouseenter', () => {
        const overlay = item.querySelector('.image-item-overlay') as HTMLElement;
        const img = item.querySelector('img') as HTMLImageElement;
        if (overlay) overlay.style.display = 'flex';
        if (img) img.style.transform = 'scale(1.05)';
        (item as HTMLElement).style.borderColor = 'var(--primary)';
        (item as HTMLElement).style.boxShadow = '0 8px 24px rgba(59, 130, 246, 0.4)';
        (item as HTMLElement).style.transform = 'translateY(-4px)';
      });
      item.addEventListener('mouseleave', () => {
        const overlay = item.querySelector('.image-item-overlay') as HTMLElement;
        const img = item.querySelector('img') as HTMLImageElement;
        if (overlay) overlay.style.display = 'none';
        if (img) img.style.transform = 'scale(1)';
        (item as HTMLElement).style.borderColor = 'var(--border-light)';
        (item as HTMLElement).style.boxShadow = 'none';
        (item as HTMLElement).style.transform = 'translateY(0)';
      });
    });

    // ✅ 소제목에 배치하기 버튼
    generatedImagesGrid.querySelectorAll('.assign-to-heading-btn').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const index = parseInt((e.target as HTMLElement).getAttribute('data-image-index') || '0');
        const image = validImages[index];
        if (image) {
          await showHeadingSelectionModalV2(image, index);
        }
      });
    });

    // ✅ AI 이미지 새로 생성 버튼
    generatedImagesGrid.querySelectorAll('.regenerate-ai-image-btn').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const index = parseInt((e.target as HTMLElement).getAttribute('data-image-index') || '0');
        const image = validImages[index];
        const heading = image?.heading || `소제목 ${index + 1}`;
        await regenerateWithNewAI(index, heading);
      });
    });

    // ✅ 저장된 이미지로 교체 버튼
    generatedImagesGrid.querySelectorAll('.replace-with-saved-btn').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const index = parseInt((e.target as HTMLElement).getAttribute('data-image-index') || '0');
        const image = validImages[index];

        let targetHeadingIndex = Number(image?.headingIndex ?? -1);
        if (!Number.isFinite(targetHeadingIndex) || targetHeadingIndex < 0) {
          const headingTitle = String(image?.heading || '').trim();
          if (headingTitle) {
            try {
              const norm = normalizeHeadingKeyForVideoCache(headingTitle);
              const hs = (ImageManager as any)?.headings;
              const list = Array.isArray(hs) ? hs : [];
              const found = list.findIndex((it: any) => {
                const t = typeof it === 'string' ? String(it || '').trim() : String(it?.title || it || '').trim();
                if (!t) return false;
                if (t === headingTitle) return true;
                try {
                  return normalizeHeadingKeyForVideoCache(t) === norm;
                } catch {
                  return false;
                }
              });
              if (found >= 0) targetHeadingIndex = found;
            } catch {
              // ignore
            }
          }
        }

        if (!Number.isFinite(targetHeadingIndex) || targetHeadingIndex < 0) {
          toastManager.warning('교체할 소제목을 찾을 수 없습니다. 먼저 소제목 분석/생성을 다시 실행해주세요.');
          return;
        }

        await showSavedImagesForReplace(targetHeadingIndex);
      });
    });

    // ✅ 제거 버튼 (그리드 미리보기용)
    generatedImagesGrid.querySelectorAll('.remove-image-btn').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const el = (e.currentTarget as HTMLElement | null) || (btn as HTMLElement);
        const idxAttr = el?.getAttribute('data-image-index');
        const index = parseInt(String(idxAttr || '0'), 10);

        if (Number.isNaN(index) || index < 0 || index >= validImages.length) return;

        if (confirm('이 이미지를 제거하시겠습니까?\n\n💡 하이브리드 모드: 일부 이미지만 남기고 나머지는 AI가 자동 생성합니다!')) {
          const image = validImages[index];

          try {
            pushImageHistorySnapshot('displayGeneratedImages.remove-image-btn');
          } catch {
            // ignore
          }

          // ✅ 1) ImageManager에서 해당 소제목의 해당 이미지 1개만 제거
          if (image?.heading) {
            try {
              const headingTitle = String(image.heading || '').trim();
              const titleKey =
                headingTitle ||
                (window as any)._headingTitles?.[image.headingIndex ?? index] ||
                ((ImageManager.headings as any)?.[image.headingIndex ?? index]?.title || '');

              if (titleKey) {
                const imagesForHeading = ImageManager.getImages(titleKey);
                let targetIdx = -1;

                // URL 기반으로 정확히 일치하는 이미지 찾기 (gif 포함)
                const rawRemoved = image?.url || image?.filePath || image?.previewDataUrl || '';
                const normalizedRemoved = toFileUrlMaybe(String(rawRemoved || '').trim());

                targetIdx = imagesForHeading.findIndex((img: any) => {
                  const raw = img?.url || img?.filePath || img?.previewDataUrl || '';
                  const norm = toFileUrlMaybe(String(raw || '').trim());
                  return norm === normalizedRemoved;
                });

                // 폴백: image.imageIndex 또는 0번
                if (targetIdx < 0 && typeof image.imageIndex === 'number') {
                  targetIdx = image.imageIndex;
                }
                if (targetIdx < 0) {
                  targetIdx = 0;
                }

                if (targetIdx >= 0 && targetIdx < imagesForHeading.length) {
                  ImageManager.removeImageAtIndex(titleKey, targetIdx);
                }
              }
            } catch (err) {
              console.error('[ImageManager] 생성된 이미지 그리드 제거 동기화 실패:', err);
            }
          } else {
            // heading이 없는 순수 예비 이미지일 경우: 전역 배열에서만 제거
            generatedImages.splice(index, 1);
          }

          // ✅ 2) 전역 배열 및 UI 동기화 (예비 이미지 포함)
          const allImages = ImageManager.getAllImages();
          (window as any).imageManagementGeneratedImages = allImages;
          syncGlobalImagesFromImageManager();

          toastManager.success(`✅ 이미지가 제거되었습니다! (남은 이미지: ${generatedImages.length}개)`);
          appendLog(`❌ [${index + 1}] 이미지 제거 완료`);

          if (generatedImages.length === 0) {
            appendLog(`⚠️ 모든 이미지가 제거되었습니다. 발행 시 새로 생성됩니다.`);
          } else {
            appendLog(`💡 하이브리드 모드 활성화: ${generatedImages.length}개는 사용, 나머지는 AI 생성`);
          }
        }
      });
    });

    // 크게보기 버튼
    generatedImagesGrid.querySelectorAll('.view-image-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const imageUrl = (e.target as HTMLElement).getAttribute('data-image-url');
        if (!imageUrl) return;
        const index = parseInt((e.target as HTMLElement).getAttribute('data-image-index') || '0', 10);
        const image = validImages[index];
        const headingTitle = String(image?.heading || '').trim();
        if (headingTitle) {
          showHeadingImagesModal(encodeURIComponent(headingTitle), encodeURIComponent(String(imageUrl || '').trim()));
          return;
        }
        showImageModal(imageUrl);
      });
    });

    // 재생성 버튼 (그리드 미리보기용)
    generatedImagesGrid.querySelectorAll('.regenerate-single-image-btn').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        e.stopPropagation();
        const index = parseInt((e.target as HTMLElement).getAttribute('data-image-index') || '0');
        const image = validImages[index];
        const prompt = image?.prompt || image?.heading || `이미지 ${index + 1}`;
        const heading = image?.heading || `소제목 ${index + 1}`;
        const promptItem = promptsContainer?.querySelector(`.prompt-item[data-index="${index + 1}"]`) as HTMLDivElement;

        // 그리드 미리보기에서 재생성
        await regenerateImageFromGrid(index, prompt, heading, promptItem);
      });
    });

    // ✅ 이미지 아이템 더블클릭 시 크게 보기
    generatedImagesGrid.querySelectorAll('.generated-image-item').forEach((item, index) => {
      item.addEventListener('dblclick', () => {
        const image = validImages[index];
        const imageRaw = image?.url || image?.filePath || image?.previewDataUrl || '';
        const imageUrl = toFileUrlMaybe(String(imageRaw || '').trim());
        if (imageUrl) {
          const headingTitle = String(image?.heading || '').trim();
          if (headingTitle) {
            showHeadingImagesModal(encodeURIComponent(headingTitle), encodeURIComponent(String(imageUrl || '').trim()));
            return;
          }
          showImageModal(imageUrl);
        }
      });
    });
  }

  // 각 이미지별로 해당 프롬프트 아이템에도 표시 (기존 기능 유지)
  validImages.forEach((image, index) => {
    const promptItem = promptsContainer.querySelector(`.prompt-item[data-index="${index + 1}"]`) as HTMLDivElement;
    if (promptItem) {
      const generatedImageDiv = promptItem.querySelector('.generated-image') as HTMLDivElement;
      if (generatedImageDiv) {
        // 이미지와 재생성 버튼을 포함한 컨테이너 (data-prompt/data-heading 제거, index만 사용)
        const safeAlt = escapeHtml(image.prompt || image.heading || '');
        const imageRaw = image.url || image.filePath || image.previewDataUrl || '';
        const imageUrl = toFileUrlMaybe(String(imageRaw || '').trim());

        generatedImageDiv.innerHTML = `
          <div style="position: relative; width: 100%; height: 100%;">
            <img src="${imageUrl}" alt="${safeAlt}" 
                 style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px; cursor: pointer;"
                 onclick="showHeadingImagesModal('${encodeURIComponent(String(image.heading || '').trim() || `소제목 ${index + 1}`)}','${encodeURIComponent(String(imageUrl || '').trim())}')"
                 title="클릭하면 크게 보기">
            <div style="position: absolute; top: 8px; right: 8px; display: flex; gap: 0.5rem; z-index: 10;">
              <button class="select-folder-image-btn" 
                      data-image-index="${index}"
                      style="background: rgba(139, 92, 246, 0.9); color: white; border: none; border-radius: 6px; padding: 8px 12px; cursor: pointer; font-size: 0.875rem; font-weight: 600; box-shadow: 0 2px 8px rgba(0,0,0,0.2); transition: all 0.2s;"
                      onmouseover="this.style.background='rgba(139, 92, 246, 1)'; this.style.transform='scale(1.05)'"
                      onmouseout="this.style.background='rgba(139, 92, 246, 0.9)'; this.style.transform='scale(1)'"
                      title="폴더에서 이미지 선택">
                📁
              </button>
              <button class="regenerate-image-btn" 
                      data-image-index="${index}"
                      style="background: rgba(59, 130, 246, 0.9); color: white; border: none; border-radius: 6px; padding: 8px 12px; cursor: pointer; font-size: 0.875rem; font-weight: 600; box-shadow: 0 2px 8px rgba(0,0,0,0.2); transition: all 0.2s;"
                      onmouseover="this.style.background='rgba(59, 130, 246, 1)'; this.style.transform='scale(1.05)'"
                      onmouseout="this.style.background='rgba(59, 130, 246, 0.9)'; this.style.transform='scale(1)'"
                      title="이 이미지 다시 생성하기">
                🔄
              </button>
              <button class="remove-image-from-preview-btn" 
                      data-image-index="${index}"
                      style="background: rgba(239, 68, 68, 0.9); color: white; border: none; border-radius: 6px; padding: 8px 12px; cursor: pointer; font-size: 0.875rem; font-weight: 600; box-shadow: 0 2px 8px rgba(0,0,0,0.2); transition: all 0.2s;"
                      onmouseover="this.style.background='rgba(239, 68, 68, 1)'; this.style.transform='scale(1.05)'"
                      onmouseout="this.style.background='rgba(239, 68, 68, 0.9)'; this.style.transform='scale(1)'"
                      title="이 이미지 제거하기">
                ❌
              </button>
            </div>
          </div>
        `;
        generatedImageDiv.style.border = '2px solid var(--primary)';
        generatedImageDiv.style.background = 'transparent';
        generatedImageDiv.style.boxShadow = '0 4px 12px rgba(59, 130, 246, 0.3)';

        // ✅ 이벤트 리스너는 이벤트 위임으로 처리됨 (displayGeneratedImages 함수 하단 참조)
      }
    }
  });

  // 생성된 이미지 섹션 표시
  const generatedImagesSection = document.getElementById('generated-images-section') as HTMLDivElement;
  if (generatedImagesSection) {
    generatedImagesSection.style.display = 'block';
  }

  // ✅ 이벤트 위임: promptsContainer에 클릭 이벤트 등록 (중복 방지를 위해 기존 리스너 제거)
  const existingHandler = (promptsContainer as any)._imageButtonsHandler;
  if (existingHandler) {
    promptsContainer.removeEventListener('click', existingHandler);
  }

  const imageButtonsHandler = async (e: Event) => {
    const target = e.target as HTMLElement;

    // 제거 버튼 클릭 (영어 프롬프트 미리보기 내 이미지)
    if (target.classList.contains('remove-image-from-preview-btn') || target.closest('.remove-image-from-preview-btn')) {
      e.stopPropagation();
      const btn = target.classList.contains('remove-image-from-preview-btn') ? target : target.closest('.remove-image-from-preview-btn') as HTMLElement;
      if (!btn) return;

      const index = parseInt(btn.getAttribute('data-image-index') || '0');

      console.log('[디버그] 제거 버튼 클릭됨, index:', index);

      if (confirm('이 이미지를 제거하시겠습니까?\n\n💡 하이브리드 모드: 일부 이미지만 남기고 나머지는 AI가 자동 생성합니다!')) {
        const promptItem = promptsContainer.querySelector(`.prompt-item[data-index="${index + 1}"]`) as HTMLDivElement;
        const headingTitle = (promptItem?.querySelector('.heading-title-text')?.textContent || `소제목 ${index + 1}`).trim();

        try {
          pushImageHistorySnapshot('remove-image-from-preview-btn');
        } catch {
          // ignore
        }

        // 해당 소제목의 이미지들 중에서, 현재 프리뷰에 표시된 이미지 1개만 제거
        try {
          const titleKey = headingTitle;
          const imagesForHeading = ImageManager.getImages(titleKey);

          let targetIdx = -1;

          const currentImgEl = (promptItem?.querySelector('.images-grid img') || promptItem?.querySelector('.generated-image img')) as HTMLImageElement | null;
          if (currentImgEl && currentImgEl.src) {
            const normalizedRemoved = toFileUrlMaybe(String(currentImgEl.src || '').trim());
            targetIdx = imagesForHeading.findIndex((img: any) => {
              const raw = img?.url || img?.filePath || img?.previewDataUrl || '';
              const norm = toFileUrlMaybe(String(raw || '').trim());
              return norm === normalizedRemoved;
            });
          }

          if (targetIdx < 0) {
            targetIdx = 0;
          }

          if (targetIdx >= 0 && targetIdx < imagesForHeading.length) {
            ImageManager.removeImageAtIndex(titleKey, targetIdx);
          }
        } catch (err) {
          console.error('[ImageManager] remove-image-from-preview-btn 동기화 실패:', err);
        }

        const allImages = ImageManager.getAllImages();
        (window as any).imageManagementGeneratedImages = allImages;
        syncGlobalImagesFromImageManager();

        toastManager.success(`✅ 이미지가 제거되었습니다! (남은 이미지: ${generatedImages.length}개)`);
        appendLog(`❌ "${headingTitle}" 이미지 제거 완료`);

        if (generatedImages.length === 0) {
          appendLog(`⚠️ 모든 이미지가 제거되었습니다. 발행 시 새로 생성됩니다.`);
        } else {
          appendLog(`💡 하이브리드 모드 활성화: ${generatedImages.length}개는 사용, 나머지는 AI 생성`);
        }
      }
    }

    // 재생성 버튼 클릭
    if (target.classList.contains('regenerate-image-btn') || target.closest('.regenerate-image-btn')) {
      e.stopPropagation();
      const btn = target.classList.contains('regenerate-image-btn') ? target : target.closest('.regenerate-image-btn') as HTMLElement;
      if (!btn) return;

      const index = parseInt(btn.getAttribute('data-image-index') || '0');
      const promptItem = promptsContainer.querySelector(`.prompt-item[data-index="${index + 1}"]`) as HTMLDivElement;
      const headingTitle = (promptItem?.querySelector('.heading-title-text')?.textContent || `소제목 ${index + 1}`).trim();
      const image = ImageManager.getImage(headingTitle) as any;
      const prompt = image?.prompt || headingTitle || `이미지 ${index + 1}`;
      const heading = headingTitle;

      console.log('[디버그] 재생성 버튼 클릭됨, index:', index, 'heading:', heading, 'prompt:', prompt);

      if (promptItem) {
        await regenerateSingleImageWithPromptItem(index, prompt, heading, promptItem);

        const updatedImage = (generatedImages as any[])[index];
        if (updatedImage && headingTitle) {
          ImageManager.setImage(headingTitle, { ...updatedImage, heading: headingTitle });
          const allImages = ImageManager.getAllImages();
          (window as any).imageManagementGeneratedImages = allImages;
          syncGlobalImagesFromImageManager();
        }
      }
    }
  };

  // 핸들러 참조 저장 (중복 방지)
  (promptsContainer as any)._imageButtonsHandler = imageButtonsHandler;
  promptsContainer.addEventListener('click', imageButtonsHandler);
}

// ✅ 미리보기에서 선택한 이미지 사용하기 (소제목 선택)
async function useSelectedImageFromPreview(image: any, index: number): Promise<void> {
  try {
    // 소제목 목록 가져오기
    const structuredContent = currentStructuredContent || (window as any).currentStructuredContent;
    let headings: any[] = [];

    if (structuredContent && structuredContent.headings) {
      headings = structuredContent.headings;
    } else {
      // 프롬프트 컨테이너에서 소제목 가져오기
      const promptsContainer = document.getElementById('prompts-container') as HTMLDivElement;
      if (promptsContainer) {
        const promptItems = promptsContainer.querySelectorAll('.prompt-item');
        promptItems.forEach((item, idx) => {
          const headingTitle = item.querySelector('.heading-title-text')?.textContent || '';
          if (headingTitle) {
            headings.push({
              title: headingTitle,
              index: idx
            });
          }
        });
      }
    }

    if (headings.length === 0) {
      alert('소제목이 없습니다. 먼저 소제목을 분석해주세요.');
      return;
    }

    // 소제목 선택 모달 표시
    showHeadingSelectionModal(image, index, headings);
  } catch (error) {
    console.error('이미지 선택 실패:', error);
    alert(`이미지 선택에 실패했습니다: ${(error as Error).message}`);
  }
}

// ✅ 소제목 선택 모달
function showHeadingSelectionModal(image: any, imageIndex: number, headings: any[]): void {
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.7); z-index: 10000; display: flex;
    align-items: center; justify-content: center; padding: 2rem;
  `;

  modal.innerHTML = `
    <div style="background: var(--bg-primary); border-radius: 12px; padding: 2rem; max-width: 600px; max-height: 90vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.3); position: relative;">
      <button type="button" class="close-heading-modal-btn" style="position: absolute; top: 1rem; right: 1rem; background: rgba(239, 68, 68, 0.9); color: white; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; font-size: 1.5rem; display: flex; align-items: center; justify-content: center; font-weight: bold; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transition: all 0.2s;" onmouseover="this.style.background='rgba(220, 38, 38, 1)'; this.style.transform='scale(1.1)';" onmouseout="this.style.background='rgba(239, 68, 68, 0.9)'; this.style.transform='scale(1)';">✕</button>
      <h2 style="margin: 0 0 1rem 0; color: var(--text-strong); font-size: 1.5rem;">📝 소제목 선택</h2>
      <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 1.5rem;">
        이 이미지를 사용할 소제목을 선택해주세요.
      </div>
      
      <!-- 이미지 미리보기 -->
      <div style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border-light);">
        <div style="font-size: 0.875rem; color: var(--text-muted); margin-bottom: 0.5rem;">선택한 이미지</div>
        <div style="width: 100%; max-height: 420px; border-radius: 8px; overflow: hidden; background: var(--bg-tertiary); margin-bottom: 0.5rem; display: flex; align-items: center; justify-content: center;">
          <img src="${toFileUrlMaybe(image.url || image.filePath || image.previewDataUrl || '')}" alt="이미지 미리보기" style="max-width: 100%; max-height: 100%; object-fit: contain;" onerror="this.style.display='none'; this.parentElement.innerHTML='<div style=\\'width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: var(--text-muted);\\'>이미지 로드 실패</div>';">
        </div>
        <div style="font-size: 0.75rem; color: var(--text-muted);">
          ${image.heading ? `원래 소제목: ${image.heading}` : `이미지 ${imageIndex + 1}`}
        </div>
      </div>
      
      <!-- 소제목 목록 -->
      <div style="display: flex; flex-direction: column; gap: 0.75rem; max-height: 40vh; overflow-y: auto; margin-bottom: 1.5rem;">
        ${headings.map((heading, idx) => {
    const headingTitle = heading.title || heading.heading || `소제목 ${idx + 1}`;
    const headingIndex = heading.index !== undefined ? heading.index : idx;
    return `
            <label style="display: flex; align-items: center; gap: 0.75rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; border: 2px solid var(--border-light); cursor: pointer; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--primary)'; this.style.background='rgba(59, 130, 246, 0.1)'" onmouseout="this.style.borderColor='var(--border-light)'; this.style.background='var(--bg-secondary)'">
              <input type="radio" name="heading-selection" value="${headingIndex}" class="heading-radio" style="width: 20px; height: 20px; cursor: pointer;" ${idx === imageIndex ? 'checked' : ''}>
              <div style="flex: 1;">
                <div style="font-weight: 600; color: var(--text-strong); margin-bottom: 0.25rem;">${headingTitle}</div>
                <div style="font-size: 0.75rem; color: var(--text-muted);">소제목 ${idx + 1}</div>
              </div>
            </label>
          `;
  }).join('')}
      </div>
      
      <div style="display: flex; gap: 0.5rem;">
        <button type="button" class="confirm-heading-selection-btn" style="flex: 1; padding: 0.75rem; background: var(--primary); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">✅ 선택 완료</button>
        <button type="button" class="close-heading-modal-btn" style="flex: 1; padding: 0.75rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 8px; cursor: pointer; font-weight: 600;">취소</button>
      </div>
    </div>
  `;

  document.body.appendChild(modal);

  // 선택 완료
  modal.querySelector('.confirm-heading-selection-btn')?.addEventListener('click', () => {
    const selectedRadio = modal.querySelector('.heading-radio:checked') as HTMLInputElement;
    if (!selectedRadio) {
      alert('소제목을 선택해주세요.');
      return;
    }

    const selectedIndex = parseInt(selectedRadio.value);
    const selectedHeading = headings[selectedIndex];
    const headingTitle = selectedHeading?.title || selectedHeading?.heading || `소제목 ${selectedIndex + 1}`;

    modal.remove();
    applyImageToHeading(image, headingTitle, selectedIndex);
  });

  // 닫기
  modal.querySelectorAll('.close-heading-modal-btn').forEach(btn => {
    btn.addEventListener('click', () => modal.remove());
  });

  modal.addEventListener('click', (e) => {
    if (e.target === modal) modal.remove();
  });
}

// ✅ 선택한 소제목에 이미지 적용
async function applyImageToHeading(image: any, headingTitle: string, headingIndex: number): Promise<void> {
  try {
    const imageUrl = image.url || image.filePath || '';

    appendLog(`✅ "${headingTitle}" 소제목에 이미지가 적용되었습니다.`);

    const candidate = {
      heading: headingTitle,
      filePath: image.filePath || imageUrl,
      previewDataUrl: image.previewDataUrl || imageUrl,
      provider: image.provider || 'local',
      url: imageUrl,
      savedToLocal: Boolean(image.savedToLocal),
      headingIndex: headingIndex,
    } as any;

    try {
      ImageManager.setImage(headingTitle, candidate);
    } catch {
      // ignore
    }

    try {
      syncGlobalImagesFromImageManager();
    } catch {
      // ignore
    }

    try {
      const all = ImageManager.getAllImages();
      updateUnifiedImagePreview((window as any)?.currentStructuredContent?.headings || [], all);
    } catch {
      // ignore
    }

    alert(`✅ 이미지가 선택되었습니다!\n\n소제목: ${headingTitle}\n\n이제 발행 시 이 이미지가 사용됩니다.`);
  } catch (error) {
    console.error('이미지 적용 실패:', error);
    alert(`이미지 적용에 실패했습니다: ${(error as Error).message}`);
  }
}

// ✅ 그리드 미리보기에서 이미지 재생성
async function regenerateImageFromGrid(imageIndex: number, prompt: string, heading: string, promptItem: HTMLDivElement | null): Promise<void> {
  const generatedImagesGrid = document.getElementById('generated-images-grid') as HTMLDivElement;

  // ✅ 이미지 소스 버튼에서 선택된 소스 가져오기
  const selectedImageSourceBtn = document.querySelector('.image-source-btn.selected') as HTMLButtonElement;
  if (!selectedImageSourceBtn) {
    alert('이미지 생성 소스를 선택해주세요.');
    return;
  }

  try {
    const imageSource = String(selectedImageSourceBtn.dataset.source || '').trim();
    appendLog(`🔄 "${heading}" 이미지 재생성 중... (다른 이미지 선택)`, 'images-log-output');

    // 재생성 시 다른 이미지를 선택하기 위해 재생성 플래그 전달
    let newImageUrl: string;

    if (imageSource === 'dalle' || imageSource === 'imagen4') {
      newImageUrl = await generateImagen4ImageLocal(prompt);
    } else if (imageSource === 'pollinations' || imageSource === 'nano-banana-pro') {
      newImageUrl = await generateNanoBananaProImage(prompt, true);
    } else if (imageSource === 'stability') {
      // ✅ Stability AI 직접 연동 (Imagen4 폴백 제거)
      const stabilityModel = (document.getElementById('stability-model-select') as HTMLSelectElement)?.value || 'ultra';
      const imageResult = await generateImagesWithCostSafety({
        provider: 'stability',
        items: [{ heading: heading, prompt }],
        regenerate: true,
        model: stabilityModel,
      });
      if (imageResult.success && imageResult.images && imageResult.images.length > 0) {
        newImageUrl = imageResult.images[0].previewDataUrl || imageResult.images[0].filePath;
      } else {
        throw new Error(imageResult.message || 'Stability AI 이미지 생성 실패');
      }
    } else if (imageSource === 'prodia') {
      // ✅ Prodia 이미지 생성 (Stability와 동일한 패턴)
      const imageResult = await generateImagesWithCostSafety({
        provider: 'prodia',
        items: [{ heading: heading, prompt }],
        regenerate: true,
      });
      if (imageResult.success && imageResult.images && imageResult.images.length > 0) {
        newImageUrl = imageResult.images[0].previewDataUrl || imageResult.images[0].filePath;
      } else {
        throw new Error(imageResult.message || 'Prodia 이미지 생성 실패');
      }

    } else {
      // Pexels 재생성 시 다른 이미지 선택 (재생성 플래그 전달)
      newImageUrl = await searchNaverImage(prompt, true); // true = 재생성 모드
    }

    // 그리드 미리보기 업데이트
    if (generatedImagesGrid) {
      const imageItem = generatedImagesGrid.querySelector(`.generated-image-item[data-image-index="${imageIndex}"]`) as HTMLDivElement;
      if (imageItem) {
        const img = imageItem.querySelector('img');
        if (img) {
          img.src = newImageUrl;
          img.onerror = function () {
            this.src = 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22%3E%3Crect width=%22100%22 height=%22100%22 fill=%22%23ddd%22/%3E%3Ctext x=%2250%22 y=%2250%22 text-anchor=%22middle%22 dominant-baseline=%22middle%22 fill=%22%23999%22%3E이미지 로드 실패%3C/text%3E%3C/svg%3E';
          };
        }
      }
    }

    // 프롬프트 아이템도 업데이트
    if (promptItem) {
      const generatedImageDiv = promptItem.querySelector('.generated-image') as HTMLDivElement;
      if (generatedImageDiv) {
        generatedImageDiv.innerHTML = `
          <div style="position: relative; width: 100%; height: 100%;">
            <img src="${newImageUrl}" alt="${escapeHtml(prompt || heading || '')}" 
                 style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px; cursor: pointer;"
                 onclick="showHeadingImagesModal('${encodeURIComponent(String(heading || '').trim())}','${encodeURIComponent(String(newImageUrl || '').trim())}')"
                 title="클릭하면 크게 보기">
            <button class="regenerate-image-btn" 
                    data-image-index="${imageIndex}"
                    style="position: absolute; top: 8px; right: 8px; background: rgba(59, 130, 246, 0.9); color: white; border: none; border-radius: 6px; padding: 8px 12px; cursor: pointer; font-size: 0.875rem; font-weight: 600; box-shadow: 0 2px 8px rgba(0,0,0,0.2); transition: all 0.2s; z-index: 10;"
                    onmouseover="this.style.background='rgba(59, 130, 246, 1)'; this.style.transform='scale(1.05)'"
                    onmouseout="this.style.background='rgba(59, 130, 246, 0.9)'; this.style.transform='scale(1)'"
                    title="이 이미지 다시 생성하기">
              🔄 재생성
            </button>
          </div>
        `;

        // 재생성 버튼 이벤트 리스너 다시 추가
        const newRegenerateBtn = generatedImageDiv.querySelector('.regenerate-image-btn') as HTMLButtonElement;
        if (newRegenerateBtn) {
          newRegenerateBtn.addEventListener('click', async (e) => {
            e.stopPropagation();
            await regenerateSingleImageWithPromptItem(imageIndex, prompt, heading, promptItem);
          });
        }
      }
    }

    // 전역 이미지 배열 업데이트
    if ((window as any).imageManagementGeneratedImages) {
      (window as any).imageManagementGeneratedImages = (window as any).imageManagementGeneratedImages.map((img: any, idx: number) => {
        if (idx === imageIndex) {
          return {
            heading: heading,
            filePath: newImageUrl,
            url: newImageUrl,
            previewDataUrl: newImageUrl,
            prompt: prompt,
            headingIndex: imageIndex
          };
        }
        return img;
      });
    }

    appendLog(`✅ "${heading}" 이미지 재생성 완료! (새로운 이미지)`, 'images-log-output');
    toastManager.success(`"${heading}" 이미지가 재생성되었습니다.`);

  } catch (error) {
    appendLog(`❌ "${heading}" 이미지 재생성 실패: ${(error as Error).message}`, 'images-log-output');
    toastManager.error(`이미지 재생성 실패: ${(error as Error).message}`);
  }
}

// 단일 이미지 재생성 (promptItem 기반 - 기존 코드용)
async function regenerateSingleImageWithPromptItem(imageIndex: number, prompt: string, heading: string, promptItem: HTMLDivElement): Promise<void> {
  const regenerateBtn = promptItem.querySelector('.regenerate-image-btn') as HTMLButtonElement;
  const generatedImageDiv = promptItem.querySelector('.generated-image') as HTMLDivElement;
  const selectedBtn = (document.querySelector('.image-source-btn.selected') || document.querySelector('.unified-img-source-btn.selected')) as HTMLButtonElement;
  if (!regenerateBtn || !generatedImageDiv || !selectedBtn) return;

  // 버튼 비활성화 및 로딩 상태
  regenerateBtn.disabled = true;
  regenerateBtn.textContent = '🔄 생성 중...';
  regenerateBtn.style.opacity = '0.7';
  regenerateBtn.style.cursor = 'not-allowed';

  // 이미지 영역에 로딩 표시
  const originalContent = generatedImageDiv.innerHTML;
  generatedImageDiv.innerHTML = `
    <div style="position: relative; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: var(--bg-tertiary); border-radius: 8px;">
      <div style="text-align: center;">
        <div style="font-size: 2rem; margin-bottom: 0.5rem;">🔄</div>
        <div style="font-size: 0.875rem; color: var(--text-muted);">이미지 재생성 중...</div>
      </div>
    </div>
  `;

  try {
    const selectedBtn = (document.querySelector('.image-source-btn.selected') || document.querySelector('.unified-img-source-btn.selected')) as HTMLButtonElement;
    const imageSource = selectedBtn?.dataset.source as 'dalle' | 'pexels' | 'pollinations' | 'stability' | 'prodia';
    appendLog(`🔄 "${heading}" 이미지 재생성 중 (${imageSource || '기본'})...`, 'images-log-output');

    let newImageUrl: string;

    if (imageSource === 'dalle') {
      newImageUrl = await generateImagen4ImageLocal(prompt);
    } else if (imageSource === 'pollinations') {
      newImageUrl = await generateNanoBananaProImage(prompt);
    } else if (imageSource === 'prodia') {
      // ✅ Prodia AI 재생성 지원 추가
      const imageResult = await generateImagesWithCostSafety({
        provider: 'prodia',
        items: [{ heading: heading, prompt: prompt }],
        regenerate: true,
      });
      if (imageResult.success && imageResult.images && imageResult.images.length > 0) {
        newImageUrl = imageResult.images[0].previewDataUrl || imageResult.images[0].filePath;
      } else {
        throw new Error(imageResult.message || 'Prodia AI 이미지 생성 실패');
      }
    } else if (imageSource === 'stability') {
      const stabilityModel = (document.getElementById('stability-model-select') as HTMLSelectElement)?.value || 'ultra';
      const imageResult = await generateImagesWithCostSafety({
        provider: 'stability',
        items: [{ heading: heading, prompt }],
        regenerate: true,
        model: stabilityModel,
      });
      if (imageResult.success && imageResult.images && imageResult.images.length > 0) {
        newImageUrl = imageResult.images[0].previewDataUrl || imageResult.images[0].filePath;
      } else {
        throw new Error(imageResult.message || 'Stability AI 이미지 생성 실패');
      }
    } else {
      newImageUrl = await searchNaverImage(prompt);
    }

    // 새 이미지로 업데이트
    const newImage = {
      url: newImageUrl,
      prompt: prompt,
      heading: heading,
      index: imageIndex
    };

    // 이미지 표시 업데이트
    generatedImageDiv.innerHTML = `
      <div style="position: relative; width: 100%; height: 100%;">
        <img src="${newImageUrl}" alt="${prompt || heading}" 
             style="width: 100%; height: 100%; object-fit: cover; border-radius: 8px; cursor: pointer;"
             onclick="window.open('${newImageUrl}', '_blank')"
             title="클릭하면 새 창에서 크게 보기">
        <button class="regenerate-image-btn" 
                data-image-index="${imageIndex}"
                style="position: absolute; top: 8px; right: 8px; background: rgba(59, 130, 246, 0.9); color: white; border: none; border-radius: 6px; padding: 8px 12px; cursor: pointer; font-size: 0.875rem; font-weight: 600; box-shadow: 0 2px 8px rgba(0,0,0,0.2); transition: all 0.2s; z-index: 10;"
                onmouseover="this.style.background='rgba(59, 130, 246, 1)'; this.style.transform='scale(1.05)'"
                onmouseout="this.style.background='rgba(59, 130, 246, 0.9)'; this.style.transform='scale(1)'"
                title="이 이미지 다시 생성하기">
          🔄 재생성
        </button>
      </div>
    `;

    // 재생성 버튼 이벤트 리스너 다시 추가
    const newRegenerateBtn = generatedImageDiv.querySelector('.regenerate-image-btn') as HTMLButtonElement;
    if (newRegenerateBtn) {
      newRegenerateBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        await regenerateSingleImageWithPromptItem(imageIndex, prompt, heading, promptItem);
      });
    }

    // 전역 이미지 배열 업데이트
    const currentHeadings = getCurrentImageHeadings();
    if ((window as any).imageManagementGeneratedImages) {
      (window as any).imageManagementGeneratedImages = (window as any).imageManagementGeneratedImages.map((img: any, idx: number) => {
        if (idx === imageIndex) {
          return {
            heading: heading,
            filePath: newImageUrl,
            url: newImageUrl,
            prompt: prompt,
            headingIndex: imageIndex
          };
        }
        return img;
      });
    }

    appendLog(`✅ "${heading}" 이미지 재생성 완료!`, 'images-log-output');
    toastManager.success(`"${heading}" 이미지가 재생성되었습니다.`);

  } catch (error) {
    appendLog(`❌ "${heading}" 이미지 재생성 실패: ${(error as Error).message}`, 'images-log-output');
    toastManager.error(`이미지 재생성 실패: ${(error as Error).message}`);

    // 원래 이미지로 복원
    generatedImageDiv.innerHTML = originalContent;

    // 재생성 버튼 이벤트 리스너 다시 추가
    const restoreRegenerateBtn = generatedImageDiv.querySelector('.regenerate-image-btn') as HTMLButtonElement;
    if (restoreRegenerateBtn) {
      restoreRegenerateBtn.addEventListener('click', async (e) => {
        e.stopPropagation();
        await regenerateSingleImageWithPromptItem(imageIndex, prompt, heading, promptItem);
      });
    }
  } finally {
    // 버튼 상태 복원
    const finalRegenerateBtn = generatedImageDiv.querySelector('.regenerate-image-btn') as HTMLButtonElement;
    if (finalRegenerateBtn) {
      finalRegenerateBtn.disabled = false;
      finalRegenerateBtn.textContent = '🔄 재생성';
      finalRegenerateBtn.style.opacity = '1';
      finalRegenerateBtn.style.cursor = 'pointer';
    }
  }
}

// 네이버 이미지 검색
async function searchNaverImage(prompt: string, isRegenerate: boolean = false): Promise<string> {
  const response = await window.api.generateImages({
    provider: 'naver',
    items: [{ heading: 'image', prompt: prompt }],
    regenerate: isRegenerate
  });
  if (!response.success || !response.images || response.images.length === 0) {
    throw new Error(response.message || '네이버 이미지 검색 실패');
  }
  return response.images[0].filePath;
}

function resolveReferenceImageForHeading(headingTitle: string): { referenceImagePath?: string; referenceImageUrl?: string } {
  const title = String(headingTitle || '').trim();
  if (!title) return {};

  let img: any = null;
  try {
    img = ImageManager.getImage(title);
  } catch {
    img = null;
  }
  if (!img) return {};

  const rawFilePath = String(img.filePath || '').trim();
  const rawUrl = String(img.url || img.previewDataUrl || '').trim();

  const toLocal = (p: string): string => {
    const raw = String(p || '').trim();
    if (!raw) return '';
    if (/^file:\/\//i.test(raw)) {
      return raw.replace(/^file:\/\//i, '').replace(/^\/+/, '');
    }
    return raw;
  };

  const local = toLocal(rawFilePath) || toLocal(rawUrl);
  if (local && !/^https?:\/\//i.test(local)) {
    return { referenceImagePath: local };
  }
  if (rawUrl && /^https?:\/\//i.test(rawUrl)) {
    return { referenceImageUrl: rawUrl };
  }
  if (rawFilePath && /^https?:\/\//i.test(rawFilePath)) {
    return { referenceImageUrl: rawFilePath };
  }
  return {};
}

const autoReferenceCacheByUrl = new Map<string, { filePath: string; updatedAt: number }>();

function getAutoReferenceSourceUrlCandidate(): string {
  const tryGet = (id: string): string => {
    const el = document.getElementById(id) as HTMLInputElement | null;
    return String(el?.value || '').trim();
  };

  const directShopping = tryGet('shopping-url-input');
  if (directShopping) return directShopping;

  const maUrl = tryGet('ma-setting-url');
  if (maUrl) return maUrl;

  const continuousUrl = tryGet('continuous-url-input');
  if (continuousUrl) return continuousUrl;

  try {
    const unifiedContainer = document.getElementById('unified-url-fields-container') as HTMLElement | null;
    if (unifiedContainer) {
      const inputs = unifiedContainer.querySelectorAll('input.unified-url-input') as NodeListOf<HTMLInputElement>;
      for (const input of Array.from(inputs)) {
        const v = String(input?.value || '').trim();
        if (v) return v;
      }
    }
  } catch {
  }

  try {
    const urlFieldsContainer = document.getElementById('url-fields-container') as HTMLElement | null;
    if (urlFieldsContainer) {
      const inputs = urlFieldsContainer.querySelectorAll('input.url-field-input') as NodeListOf<HTMLInputElement>;
      for (const input of Array.from(inputs)) {
        const v = String(input?.value || '').trim();
        if (v) return v;
      }
    }
  } catch {
  }

  try {
    const fullAuto = document.getElementById('full-auto-url-fields-container') as HTMLElement | null;
    if (fullAuto) {
      const inputs = fullAuto.querySelectorAll('input.url-field-input') as NodeListOf<HTMLInputElement>;
      for (const input of Array.from(inputs)) {
        const v = String(input?.value || '').trim();
        if (v) return v;
      }
    }
  } catch {
  }

  return '';
}

async function resolveReferenceImageForHeadingAsync(headingTitle: string): Promise<{ referenceImagePath?: string; referenceImageUrl?: string }> {
  const direct = resolveReferenceImageForHeading(headingTitle);
  if (direct.referenceImagePath || direct.referenceImageUrl) return direct;

  const sourceUrl = getAutoReferenceSourceUrlCandidate();
  if (!sourceUrl || !/^https?:\/\//i.test(sourceUrl)) return {};

  // cache hit
  const cached = autoReferenceCacheByUrl.get(sourceUrl);
  if (cached?.filePath) {
    return { referenceImagePath: cached.filePath };
  }

  // 1) 쇼핑몰 URL에서 대표 이미지 1장 자동 수집
  if (typeof (window.api as any)?.collectImagesFromShopping !== 'function') return {};

  try {
    const result = await (window.api as any).collectImagesFromShopping(sourceUrl);
    const images = Array.isArray(result?.images) ? result.images : [];
    const first = images.length > 0 ? String(images[0] || '').trim() : '';
    if (!first) return {};

    // 2) 가능하면 로컬 저장해서 referenceImagePath로 사용 (가장 안정적)
    if (typeof (window.api as any)?.downloadAndSaveImage === 'function') {
      const postTitle = String((window as any).currentStructuredContent?.selectedTitle || currentStructuredContent?.selectedTitle || '').trim();
      const postId = currentPostId || undefined;
      const saveRes = await (window.api as any).downloadAndSaveImage(first, String(headingTitle || 'ref').trim() || 'ref', postTitle || undefined, postId);
      if (saveRes?.success) {
        const savedPath = String(saveRes?.filePath || saveRes?.savedToLocal || '').trim();
        if (savedPath) {
          autoReferenceCacheByUrl.set(sourceUrl, { filePath: savedPath, updatedAt: Date.now() });
          return { referenceImagePath: savedPath };
        }
      }
    }

    // 3) 저장 실패 시 원격 URL을 그대로 참조로 사용
    autoReferenceCacheByUrl.set(sourceUrl, { filePath: first, updatedAt: Date.now() });
    return { referenceImageUrl: first };
  } catch {
    return {};
  }
}

// ✅ Imagen 4 (Google) 이미지 생성
async function generateImagen4ImageLocal(prompt: string, isRegenerate: boolean = false): Promise<string> {
  const response = await generateImagesWithCostSafety({
    provider: 'imagen4',
    items: [{ heading: 'image', prompt: prompt }],
    regenerate: isRegenerate
  });
  if (!response.success || !response.images || response.images.length === 0) {
    throw new Error(response.message || 'Imagen 4 이미지 생성 실패');
  }
  return response.images[0].filePath;
}

// ✅ 나노 바나나 프로 이미지 생성 (Gemini 3 기반, NEVER TEXT 적용)
async function generateNanoBananaProImage(prompt: string, headingOrRegenerate?: string | boolean, isRegenerate: boolean = false): Promise<string> {
  // 오버로드 처리: heading이 string이면 heading으로, boolean이면 isRegenerate로 처리
  let heading = 'image';
  let regenerate = isRegenerate;

  if (typeof headingOrRegenerate === 'string') {
    heading = headingOrRegenerate;
  } else if (typeof headingOrRegenerate === 'boolean') {
    regenerate = headingOrRegenerate;
  }
  const ref = heading ? await resolveReferenceImageForHeadingAsync(heading) : {};
  const response = await generateImagesWithCostSafety({
    provider: 'nano-banana-pro',
    items: [{ heading: heading || 'image', prompt: prompt, ...ref }],
    regenerate
  });
  if (!response.success || !response.images || response.images.length === 0) {
    throw new Error(response.message || '나노 바나나 프로 이미지 생성 실패');
  }
  return response.images[0].previewDataUrl || response.images[0].filePath;
}

// ✅ Imagen 4 이미지 생성 (Google Imagen 4, NEVER TEXT 적용)
async function generateImagen4Image(prompt: string, heading: string, isRegenerate: boolean = false): Promise<string> {
  const response = await generateImagesWithCostSafety({
    provider: 'imagen4',
    items: [{ heading: heading || 'image', prompt: prompt }],
    regenerate: isRegenerate
  });
  if (!response.success || !response.images || response.images.length === 0) {
    throw new Error(response.message || 'Imagen 4 이미지 생성 실패');
  }
  return response.images[0].previewDataUrl || response.images[0].filePath;
}

// 빠른 액션 함수들
function switchToUnifiedTab() {
  const tabButton = document.querySelector('[data-tab="unified"]') as HTMLButtonElement;
  if (tabButton) {
    tabButton.click();
  }
}

function switchToImageTab() {
  const tabButton = document.querySelector('[data-tab="images"]') as HTMLButtonElement;
  if (tabButton) {
    tabButton.click();
  }
}

function switchToScheduleTab() {
  const tabButton = document.querySelector('[data-tab="schedule"]') as HTMLButtonElement;
  if (tabButton) {
    tabButton.click();
  }
}

// 메인 대시보드 초기화
function initDashboard() {
  // 시계 업데이트
  updateClock();
  setInterval(updateClock, 1000);

  // 대시보드 통계 업데이트
  updateDashboardStats();

  // 최근 활동 초기화
  initRecentActivity();

  // 달력 초기화
  initDashboardCalendar();

  // ✅ 썸네일 텍스트 옵션 동기화 초기화
  initThumbnailTextSync();
}

/**
 * ✅ 썸네일 텍스트 옵션 체크박스 동기화
 */
function initThumbnailTextSync(): void {
  const syncGroup = [
    'thumbnail-text-option', // 스마트 자동발행 탭
    'continuous-include-thumbnail-text' // 연속 발행 탭
  ];

  syncGroup.forEach(id => {
    const el = document.getElementById(id) as HTMLInputElement;
    if (!el) return;

    el.addEventListener('change', () => {
      const isChecked = el.checked;
      syncGroup.forEach(targetId => {
        const targetEl = document.getElementById(targetId) as HTMLInputElement;
        if (targetEl && targetEl !== el) {
          targetEl.checked = isChecked;
        }
      });
      console.log(`[ThumbnailSync] 옵션 변경: ${isChecked ? 'ON' : 'OFF'}`);
    });
  });
}

// 시계 업데이트
function updateClock() {
  const now = new Date();
  const timeElement = document.getElementById('current-time');
  const dateElement = document.getElementById('current-date');

  if (timeElement) {
    timeElement.textContent = now.toLocaleTimeString('ko-KR', {
      hour12: false,
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
  }

  if (dateElement) {
    const year = now.getFullYear();
    const month = now.getMonth() + 1;
    const day = now.getDate();
    const dayOfWeek = ['일', '월', '화', '수', '목', '금', '토'][now.getDay()];

    dateElement.textContent = `${year}년 ${month}월 ${day}일 ${dayOfWeek}요일`;
  }
}

// 대시보드 통계 업데이트
function updateDashboardStats() {
  // 오늘의 통계 (임시 데이터)
  const todayPosts = document.getElementById('today-posts');
  const todayImages = document.getElementById('today-images');
  const todayViews = document.getElementById('today-views');

  if (todayPosts) todayPosts.textContent = '0';
  if (todayImages) todayImages.textContent = '0';
  if (todayViews) todayViews.textContent = '0';

  // 실제로는 localStorage나 config에서 데이터를 가져와야 함
}

// 최근 활동 초기화
function initRecentActivity() {
  const activityList = document.getElementById('recent-activity');
  if (!activityList) return;

  // 초기 활동 추가
  addRecentActivity('🚀 앱이 시작되었습니다', '방금 전');
}

// 최근 활동 추가
function addRecentActivity(title: string, time: string) {
  const activityList = document.getElementById('recent-activity');
  if (!activityList) return;

  const activityItem = document.createElement('div');
  activityItem.className = 'activity-item';
  activityItem.innerHTML = `
    <div class="activity-icon">📝</div>
    <div class="activity-content">
      <div class="activity-title">${title}</div>
      <div class="activity-time">${time}</div>
    </div>
  `;

  // 기존 활동들을 아래로 밀고 새 활동을 위에 추가
  const firstChild = activityList.firstChild;
  activityList.insertBefore(activityItem, firstChild);

  // 최대 10개까지만 유지
  while (activityList.children.length > 10) {
    activityList.removeChild(activityList.lastChild!);
  }
}

// 대시보드 달력 초기화
function initDashboardCalendar() {
  // 달력 위젯은 기존 코드에서 이미 초기화됨
}

// 탭 전환 초기화
function initTabSwitching() {
  const tabButtons = document.querySelectorAll('.tab-button');
  const appContainer = document.querySelector('.app-container') as HTMLElement | null;

  // ✅ 내부 탭 (app-container 안에 있음) vs 외부 탭 (app-container 밖에 있음)
  const internalTabs = ['main', 'unified'];
  const externalTabs = ['image-tools', 'images', 'schedule', 'analytics'];

  tabButtons.forEach(button => {
    button.addEventListener('click', () => {
      const targetTab = button.getAttribute('data-tab');
      if (!targetTab) return;

      // 모든 탭 버튼에서 active 클래스 제거
      tabButtons.forEach(btn => {
        btn.classList.remove('active');
        btn.setAttribute('aria-selected', 'false');
      });

      // 클릭된 버튼에 active 클래스 추가
      button.classList.add('active');
      button.setAttribute('aria-selected', 'true');

      // 모든 탭 패널 숨기기
      const tabPanels = document.querySelectorAll('.tab-panel');
      tabPanels.forEach(panel => {
        panel.classList.remove('active');
        (panel as HTMLElement).style.display = 'none';
      });

      // 대상 탭 패널 표시
      const targetPanel = document.getElementById(`tab-${targetTab}`);
      if (targetPanel) {
        targetPanel.classList.add('active');
        (targetPanel as HTMLElement).style.display = 'block';
      }

      // ✅ unified 탭 전용 섹션 토글 (조건부 표시 섹션은 제외)
      const unifiedOnlySections = document.querySelectorAll('[id^="unified-only-"]');
      const excludedSections = ['unified-only-progress-container', 'unified-only-preview-section', 'unified-only-semi-auto-section'];
      unifiedOnlySections.forEach(section => {
        const sectionId = section.id;
        // 조건부 표시 섹션은 자동으로 표시하지 않음
        if (excludedSections.includes(sectionId)) return;
        (section as HTMLElement).style.display = targetTab === 'unified' ? 'block' : 'none';
      });

      // ✅ app-container의 min-height 조절 (외부 탭 전환 시 빈 공간 제거)
      // display:none 대신 min-height만 0으로 설정하여 헤더/탭버튼은 유지
      if (appContainer) {
        const isExternalTab = externalTabs.includes(targetTab);
        if (isExternalTab) {
          // 외부 탭: min-height를 0으로 설정 (빈 공간 제거)
          appContainer.style.minHeight = '0';
          appContainer.style.height = 'auto';
        } else {
          // 내부 탭: 원래 min-height 복원
          appContainer.style.minHeight = '';
          appContainer.style.height = '';
        }
      }

      // 페이지 스크롤을 맨 위로
      window.scrollTo(0, 0);
    });
  });

  // ✅ 페이지 로드 시 현재 active 탭에 맞게 unified-only 섹션 및 app-container 토글
  const activeTab = document.querySelector('.tab-button.active')?.getAttribute('data-tab');
  const unifiedOnlySectionsInit = document.querySelectorAll('[id^="unified-only-"]');
  const excludedSectionsInit = ['unified-only-progress-container', 'unified-only-preview-section', 'unified-only-semi-auto-section'];
  unifiedOnlySectionsInit.forEach(section => {
    const sectionId = section.id;
    // 조건부 표시 섹션은 자동으로 표시하지 않음
    if (excludedSectionsInit.includes(sectionId)) return;
    (section as HTMLElement).style.display = activeTab === 'unified' ? 'block' : 'none';
  });

  // 초기 로드 시 외부 탭이면 app-container min-height 조절
  if (appContainer && activeTab && externalTabs.includes(activeTab)) {
    appContainer.style.minHeight = '0';
    appContainer.style.height = 'auto';
  }
}

// ============================================
// API 키 발급 가이드 모달
// ============================================
function initApiGuideModal(): void {
  const apiGuideModal = document.getElementById('api-guide-modal');
  const apiGuideBtns = document.querySelectorAll('.api-guide-btn');
  const closeApiGuideBtns = document.querySelectorAll('[data-close-api-guide]');
  const apiGuideOpenSiteBtn = document.getElementById('api-guide-open-site-btn') as HTMLButtonElement;

  // API 키별 가이드 내용
  const apiGuides: Record<string, { title: string; content: string; url: string }> = {
    gemini: {
      title: '📖 Gemini API 키 발급 가이드 (완전 초보자용)',
      url: 'https://aistudio.google.com/apikey',
      content: `
        <div style="line-height: 1.8; color: var(--text-strong);">
          <h3 style="color: var(--primary); margin-bottom: 1rem;">🎯 Gemini API 키란?</h3>
          <p style="margin-bottom: 1rem;">Gemini는 Google의 AI 모델입니다. 이 키를 발급받으면 AI로 글을 자동 생성할 수 있습니다.</p>
          
          <h3 style="color: var(--primary); margin-bottom: 1rem;">📝 발급 방법 (단계별)</h3>
          <ol style="padding-left: 1.5rem; margin-bottom: 1rem;">
            <li style="margin-bottom: 0.75rem;">
              <strong>1단계: Google 계정으로 로그인</strong><br>
              Google 계정이 필요합니다. Gmail 계정이 있으면 됩니다.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>2단계: AI Studio 접속</strong><br>
              아래 "사이트로 이동" 버튼을 클릭하거나, 브라우저에서 <code style="background: var(--bg-tertiary); padding: 0.25rem 0.5rem; border-radius: 4px;">https://aistudio.google.com/apikey</code> 를 입력하세요.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>3단계: API 키 생성</strong><br>
              화면에서 "Create API Key" 또는 "API 키 만들기" 버튼을 클릭하세요.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>4단계: 프로젝트 선택</strong><br>
              새 프로젝트를 만들거나 기존 프로젝트를 선택하세요. 처음이면 "새 프로젝트 만들기"를 선택하세요.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>5단계: API 키 복사</strong><br>
              생성된 API 키가 화면에 표시됩니다. <strong style="color: var(--primary);">이 키를 복사</strong>하세요! (나중에 다시 볼 수 없으니 꼭 복사하세요)
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>6단계: 여기에 붙여넣기</strong><br>
              복사한 API 키를 환경설정의 "Gemini API Key" 입력창에 붙여넣으세요.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>7단계: 저장</strong><br>
              환경설정 하단의 "저장" 버튼을 클릭하세요.
            </li>
          </ol>
          
          <div style="background: rgba(212, 175, 55, 0.1); border: 2px solid rgba(212, 175, 55, 0.3); border-radius: 8px; padding: 1rem; margin: 1rem 0;">
            <h4 style="color: #D4AF37; margin-bottom: 0.5rem;">💰 비용 안내</h4>
            <p style="margin: 0;">Gemini API는 <strong>Google 정책/계정 설정에 따라 무료 티어 또는 과금</strong>이 적용될 수 있습니다. 사용 전 Google 콘솔에서 결제/할당량 설정을 확인해주세요.</p>
          </div>
          
          <div style="background: rgba(59, 130, 246, 0.1); border: 2px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 1rem; margin: 1rem 0;">
            <h4 style="color: var(--primary); margin-bottom: 0.5rem;">💡 팁</h4>
            <ul style="padding-left: 1.5rem; margin: 0;">
              <li>API 키는 비밀번호처럼 중요합니다. 다른 사람에게 공유하지 마세요.</li>
              <li>API 키가 노출되면 AI Studio에서 삭제하고 새로 발급받으세요.</li>
              <li>발급 후 바로 사용할 수 있습니다. 별도 승인 절차는 없습니다.</li>
            </ul>
          </div>
        </div>
      `
    },
    openai: {
      title: '📖 OpenAI API 키 발급 가이드 (완전 초보자용)',
      url: 'https://platform.openai.com/api-keys',
      content: `
        <div style="line-height: 1.8; color: var(--text-strong);">
          <h3 style="color: var(--primary); margin-bottom: 1rem;">🎯 OpenAI API 키란?</h3>
          <p style="margin-bottom: 1rem;">OpenAI는 ChatGPT를 만든 회사입니다. 이 키를 발급받으면 고품질 AI 글을 생성할 수 있습니다.</p>
          
          <h3 style="color: var(--primary); margin-bottom: 1rem;">📝 발급 방법 (단계별)</h3>
          <ol style="padding-left: 1.5rem; margin-bottom: 1rem;">
            <li style="margin-bottom: 0.75rem;">
              <strong>1단계: OpenAI 계정 만들기</strong><br>
              <a href="https://platform.openai.com/signup" target="_blank" style="color: var(--primary); text-decoration: underline;">OpenAI 플랫폼</a>에서 계정을 만드세요. 이메일 주소와 비밀번호가 필요합니다.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>2단계: 결제 정보 등록</strong><br>
              OpenAI는 유료 서비스입니다. 신용카드나 체크카드를 등록해야 합니다. (최소 $5 충전 필요)
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>3단계: API 키 페이지 접속</strong><br>
              아래 "사이트로 이동" 버튼을 클릭하거나, 로그인 후 왼쪽 메뉴에서 "API keys"를 클릭하세요.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>4단계: 새 API 키 생성</strong><br>
              "Create new secret key" 또는 "새 비밀 키 만들기" 버튼을 클릭하세요.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>5단계: 이름 지정 (선택)</strong><br>
              API 키에 이름을 붙일 수 있습니다. 예: "블로그 자동화"
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>6단계: API 키 복사</strong><br>
              생성된 API 키가 화면에 표시됩니다. <strong style="color: var(--primary);">이 키를 즉시 복사</strong>하세요! (다시 볼 수 없습니다)
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>7단계: 여기에 붙여넣기</strong><br>
              복사한 API 키를 환경설정의 "OpenAI API Key" 입력창에 붙여넣으세요.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>8단계: 저장</strong><br>
              환경설정 하단의 "저장" 버튼을 클릭하세요.
            </li>
          </ol>
          
          <div style="background: rgba(239, 68, 68, 0.1); border: 2px solid rgba(239, 68, 68, 0.3); border-radius: 8px; padding: 1rem; margin: 1rem 0;">
            <h4 style="color: #EF4444; margin-bottom: 0.5rem;">💰 비용 안내</h4>
            <p style="margin: 0;">OpenAI API는 <strong>유료 서비스</strong>입니다. 사용한 만큼 비용이 청구됩니다. 글 1개 생성 시 약 $0.01~0.03 정도 소요됩니다. 사용량은 OpenAI 대시보드에서 확인할 수 있습니다.</p>
          </div>
          
          <div style="background: rgba(59, 130, 246, 0.1); border: 2px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 1rem; margin: 1rem 0;">
            <h4 style="color: var(--primary); margin-bottom: 0.5rem;">💡 팁</h4>
            <ul style="padding-left: 1.5rem; margin: 0;">
              <li>사용량을 제한하여 예상치 못한 비용을 방지할 수 있습니다.</li>
              <li>API 키는 절대 공유하지 마세요. 노출되면 즉시 삭제하고 새로 발급받으세요.</li>
              <li>OpenAI는 무료 크레딧을 제공하는 경우가 있습니다. 프로모션을 확인하세요.</li>
            </ul>
          </div>
        </div>
      `
    },
    claude: {
      title: '📖 Claude API 키 발급 가이드 (완전 초보자용)',
      url: 'https://console.anthropic.com/settings/keys',
      content: `
        <div style="line-height: 1.8; color: var(--text-strong);">
          <h3 style="color: var(--primary); margin-bottom: 1rem;">🎯 Claude API 키란?</h3>
          <p style="margin-bottom: 1rem;">Claude는 Anthropic의 AI 모델입니다. 고품질 글 생성에 특화되어 있습니다.</p>
          
          <h3 style="color: var(--primary); margin-bottom: 1rem;">📝 발급 방법 (단계별)</h3>
          <ol style="padding-left: 1.5rem; margin-bottom: 1rem;">
            <li style="margin-bottom: 0.75rem;">
              <strong>1단계: Anthropic 계정 만들기</strong><br>
              <a href="https://console.anthropic.com/signup" target="_blank" style="color: var(--primary); text-decoration: underline;">Anthropic Console</a>에서 계정을 만드세요.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>2단계: 결제 정보 등록</strong><br>
              Claude API는 유료 서비스입니다. 신용카드를 등록해야 합니다.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>3단계: API 키 페이지 접속</strong><br>
              아래 "사이트로 이동" 버튼을 클릭하거나, 로그인 후 "API Keys" 메뉴를 클릭하세요.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>4단계: 새 API 키 생성</strong><br>
              "Create Key" 또는 "키 만들기" 버튼을 클릭하세요.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>5단계: 이름 지정</strong><br>
              API 키에 이름을 붙일 수 있습니다. 예: "블로그 자동화"
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>6단계: API 키 복사</strong><br>
              생성된 API 키를 <strong style="color: var(--primary);">즉시 복사</strong>하세요! (다시 볼 수 없습니다)
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>7단계: 여기에 붙여넣기</strong><br>
              복사한 API 키를 환경설정의 "Claude API Key" 입력창에 붙여넣으세요.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>8단계: 저장</strong><br>
              환경설정 하단의 "저장" 버튼을 클릭하세요.
            </li>
          </ol>
          
          <div style="background: rgba(239, 68, 68, 0.1); border: 2px solid rgba(239, 68, 68, 0.3); border-radius: 8px; padding: 1rem; margin: 1rem 0;">
            <h4 style="color: #EF4444; margin-bottom: 0.5rem;">💰 비용 안내</h4>
            <p style="margin: 0;">Claude API는 <strong>유료 서비스</strong>입니다. 사용한 만큼 비용이 청구됩니다.</p>
          </div>
        </div>
      `
    },
    pexels: {
      title: '📖 Pexels API 키 발급 가이드 (완전 초보자용)',
      url: 'https://www.pexels.com/api/',
      content: `
        <div style="line-height: 1.8; color: var(--text-strong);">
          <h3 style="color: var(--primary); margin-bottom: 1rem;">🎯 Pexels API 키란?</h3>
          <p style="margin-bottom: 1rem;">Pexels는 무료 고품질 사진을 제공하는 사이트입니다. 이 키를 발급받으면 블로그 글에 이미지를 자동으로 삽입할 수 있습니다.</p>
          
          <h3 style="color: var(--primary); margin-bottom: 1rem;">📝 발급 방법 (단계별)</h3>
          <ol style="padding-left: 1.5rem; margin-bottom: 1rem;">
            <li style="margin-bottom: 0.75rem;">
              <strong>1단계: Pexels 계정 만들기</strong><br>
              <a href="https://www.pexels.com/join" target="_blank" style="color: var(--primary); text-decoration: underline;">Pexels</a>에서 무료 계정을 만드세요. 이메일 주소만 있으면 됩니다.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>2단계: API 페이지 접속</strong><br>
              아래 "사이트로 이동" 버튼을 클릭하거나, 로그인 후 <a href="https://www.pexels.com/api/" target="_blank" style="color: var(--primary); text-decoration: underline;">https://www.pexels.com/api/</a> 로 이동하세요.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>3단계: API 키 생성</strong><br>
              "Get Started" 또는 "시작하기" 버튼을 클릭하세요.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>4단계: 애플리케이션 정보 입력</strong><br>
              애플리케이션 이름을 입력하세요. 예: "블로그 자동화"
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>5단계: API 키 복사</strong><br>
              생성된 API 키가 화면에 표시됩니다. <strong style="color: var(--primary);">이 키를 복사</strong>하세요!
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>6단계: 여기에 붙여넣기</strong><br>
              복사한 API 키를 환경설정의 "Pexels API Key" 입력창에 붙여넣으세요.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>7단계: 저장</strong><br>
              환경설정 하단의 "저장" 버튼을 클릭하세요.
            </li>
          </ol>
          
          <div style="background: rgba(16, 185, 129, 0.1); border: 2px solid rgba(16, 185, 129, 0.3); border-radius: 8px; padding: 1rem; margin: 1rem 0;">
            <h4 style="color: #10B981; margin-bottom: 0.5rem;">💰 비용 안내</h4>
            <p style="margin: 0;">Pexels API는 <strong>일반적으로 무료</strong>로 사용할 수 있으며, 사용량 제한이 있습니다. 자세한 조건은 Pexels 정책을 확인해주세요.</p>
          </div>
          
          <div style="background: rgba(59, 130, 246, 0.1); border: 2px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 1rem; margin: 1rem 0;">
            <h4 style="color: var(--primary); margin-bottom: 0.5rem;">💡 팁</h4>
            <ul style="padding-left: 1.5rem; margin: 0;">
              <li>Pexels의 모든 이미지는 무료로 사용 가능합니다.</li>
              <li>이미지 저작권 걱정 없이 사용할 수 있습니다.</li>
              <li>시간당 200회 요청 제한이 있습니다. (충분합니다)</li>
            </ul>
          </div>
        </div>
      `
    },
    prodia: {
      title: '📖 Prodia Token 발급 가이드 (이미지 생성)',
      url: 'https://app.prodia.com/api',
      content: `
        <div style="line-height: 1.8; color: var(--text-strong);">
          <h3 style="color: var(--primary); margin-bottom: 1rem;">🎯 Prodia Token이란?</h3>
          <p style="margin-bottom: 1rem;">Prodia는 빠르고 가성비 좋은 이미지 생성 API입니다. Prodia Token을 발급받아 환경설정에 입력하면 <strong>Prodia AI 이미지 생성</strong>을 사용할 수 있습니다.</p>

          <h3 style="color: var(--primary); margin-bottom: 1rem;">📝 발급 방법 (단계별)</h3>
          <ol style="padding-left: 1.5rem; margin-bottom: 1rem;">
            <li style="margin-bottom: 0.75rem;"><strong>1단계: Prodia 접속</strong><br>
              아래 "사이트로 이동" 버튼을 클릭해 <a href="https://app.prodia.com/api" target="_blank" style="color: var(--primary); text-decoration: underline;">Prodia API 페이지</a>로 이동하세요.</li>
            <li style="margin-bottom: 0.75rem;"><strong>2단계: 로그인/가입</strong><br>
              Prodia 계정으로 로그인하거나 새로 가입하세요.</li>
            <li style="margin-bottom: 0.75rem;"><strong>3단계: Token 생성</strong><br>
              API 페이지에서 Token을 생성/복사하세요.</li>
            <li style="margin-bottom: 0.75rem;"><strong>4단계: 환경설정에 입력</strong><br>
              환경설정 → "Prodia API Token" 입력창에 붙여넣고 "저장"을 누르세요.</li>
          </ol>

          <div style="background: rgba(239, 68, 68, 0.08); border: 2px solid rgba(239, 68, 68, 0.2); border-radius: 8px; padding: 1rem; margin: 1rem 0;">
            <h4 style="color: #EF4444; margin-bottom: 0.5rem;">💰 비용 안내</h4>
            <p style="margin: 0;">Prodia는 <strong>1,000회 이후부터 $0.0025</strong> 수준으로 저렴합니다. (정확한 과금/무료 정책은 Prodia 정책 및 계정 설정을 확인해주세요)</p>
          </div>

          <div style="background: rgba(59, 130, 246, 0.1); border: 2px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 1rem; margin: 1rem 0;">
            <h4 style="color: var(--primary); margin-bottom: 0.5rem;">📚 참고 문서</h4>
            <ul style="padding-left: 1.5rem; margin: 0;">
              <li><a href="https://docs.prodia.com/guides/generating-images/" target="_blank" style="color: var(--primary); text-decoration: underline;">이미지 생성 가이드</a></li>
              <li><a href="https://docs.prodia.com/guides/generating-videos/" target="_blank" style="color: var(--primary); text-decoration: underline;">영상 생성 가이드</a></li>
            </ul>
          </div>
        </div>
      `
    },
    stability: {
      title: '📖 Stability AI API 키 발급 가이드 (고품질 실사/영상)',
      url: 'https://key.stablediffusionapi.com/',
      content: `
        <div style="line-height: 1.8; color: var(--text-strong);">
          <h3 style="color: #3b82f6; margin-bottom: 1rem;">🎯 Stability AI API 키란?</h3>
          <p style="margin-bottom: 1rem;">Stability AI는 현존 최고 수준의 실사 이미지 생성 및 영상 생성 모델을 제공합니다.</p>
          
          <h3 style="color: #3b82f6; margin-bottom: 1rem;">📝 발급 방법 (단계별)</h3>
          <ol style="padding-left: 1.5rem; margin-bottom: 1rem;">
            <li style="margin-bottom: 0.75rem;">
              <strong>1단계: Stability AI 계정 가입</strong><br>
              <a href="https://dreamstudio.ai/" target="_blank" style="color: #3b82f6; text-decoration: underline;">DreamStudio</a> 또는 <a href="https://platform.stability.ai/" target="_blank" style="color: #3b82f6; text-decoration: underline;">Stability Platform</a>에서 가입하세요.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>2단계: 결제 정보 및 크레딧 구매</strong><br>
              Stability AI는 종량제(크레딧) 방식입니다. 최소 $10 단위로 충전하여 사용할 수 있습니다.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>3단계: API 키 관리 페이지 접속</strong><br>
              아래 "사이트로 이동" 버튼을 클릭하거나 <a href="https://platform.stability.ai/account/keys" target="_blank" style="color: #3b82f6; text-decoration: underline;">계정 키 페이지</a>로 이동하세요.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>4단계: 새 API 키 생성</strong><br>
              "Create API Key" 버튼을 클릭하여 새 키를 발급받으세요.
            </li>
            <li style="margin-bottom: 0.75rem;">
              <strong>5단계: 키 복사 및 입력</strong><br>
              발급된 키를 복사하여 환경설정의 <strong>Stability AI API 키</strong> 칸에 붙여넣으세요.
            </li>
          </ol>
          
          <div style="background: rgba(59, 130, 246, 0.1); border: 2px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 1rem; margin: 1rem 0;">
            <h4 style="color: #3b82f6; margin-bottom: 0.5rem;">💰 비용 안내</h4>
            <p style="margin: 0;"><strong>Ultra 이미지</strong>: 장당 약 130원 | <strong>SVD 영상</strong>: 편당 약 270원 수준입니다. (크레딧 단가 기준)</p>
          </div>
        </div>
      `
    }
  };

  // 가이드 버튼 클릭 이벤트
  apiGuideBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const apiType = btn.getAttribute('data-api');
      if (apiType && apiGuides[apiType] && apiGuideModal) {
        const guide = apiGuides[apiType];
        const titleEl = document.getElementById('api-guide-title');
        const contentEl = document.getElementById('api-guide-content');

        if (titleEl) titleEl.textContent = guide.title;
        if (contentEl) contentEl.innerHTML = guide.content;

        // 사이트로 이동 버튼
        if (apiGuideOpenSiteBtn) {
          apiGuideOpenSiteBtn.onclick = () => {
            window.api.openExternalUrl(guide.url);
          };
        }

        // 모달 표시
        apiGuideModal.style.display = 'flex';
        apiGuideModal.setAttribute('aria-hidden', 'false');
      }
    });
  });

  // 모달 닫기
  closeApiGuideBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      if (apiGuideModal) {
        apiGuideModal.style.display = 'none';
        apiGuideModal.setAttribute('aria-hidden', 'true');
      }
    });
  });

  // 모달 배경 클릭 시 닫기
  if (apiGuideModal) {
    apiGuideModal.addEventListener('click', (e) => {
      if (e.target === apiGuideModal) {
        apiGuideModal.style.display = 'none';
        apiGuideModal.setAttribute('aria-hidden', 'true');
      }
    });
  }

  // ✅ Stability AI 발급 바로가기 버튼
  const stabilityIssuanceBtn = document.getElementById('stability-api-issuance-btn');
  if (stabilityIssuanceBtn) {
    stabilityIssuanceBtn.addEventListener('click', () => {
      window.open('https://platform.stability.ai/account/keys', '_blank');
    });
  }
}

// ============================================
// 사용 가이드 모달
// ============================================
function initUserGuideModal(): void {
  const userGuideModal = document.getElementById('user-guide-modal') as HTMLDivElement;
  const userGuideBtn = document.getElementById('user-guide-btn') as HTMLButtonElement;
  const closeUserGuideBtns = document.querySelectorAll('[data-close-user-guide]');
  const guideTabBtns = document.querySelectorAll('.guide-tab-btn');
  const guideContent = document.getElementById('user-guide-content');

  // 사용 가이드 내용 (2025년 12월 최신 버전)
  const guideContents: Record<string, string> = {
    start: `
      <div style="line-height: 1.8; color: var(--text-strong);">
        <h3 style="color: var(--primary); margin-bottom: 1rem; font-size: 1.3rem;">🎉 Better Life Naver 사용 가이드</h3>
        <p style="margin-bottom: 1.5rem; font-size: 1.1rem;">AI 기반 네이버 블로그 자동화 프로그램입니다. 10분 안에 시작할 수 있습니다!</p>
        
        <div style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(6, 182, 212, 0.1)); border: 2px solid var(--primary); border-radius: 12px; padding: 1.5rem; margin-bottom: 1.5rem;">
          <h4 style="color: var(--primary); margin-bottom: 1rem;">🚀 빠른 시작 (5단계)</h4>
          <ol style="padding-left: 1.5rem; margin: 0;">
            <li style="margin-bottom: 1rem;">
              <strong>1단계: API 키 발급</strong><br>
              <span style="color: var(--text-muted);">우측 <strong>⚙️ 환경 설정</strong> 버튼 클릭 → 각 API 키 옆의 "📖 가이드" 버튼으로 발급 방법 확인</span>
            </li>
            <li style="margin-bottom: 1rem;">
              <strong>2단계: API 키 입력 및 저장</strong><br>
              <span style="color: var(--text-muted);">발급받은 API 키를 입력창에 붙여넣고 <strong>"저장"</strong> 버튼 클릭 (앱 재시작해도 유지됨)</span>
            </li>
            <li style="margin-bottom: 1rem;">
              <strong>3단계: 네이버 계정 입력</strong><br>
              <span style="color: var(--text-muted);"><strong>🚀 스마트 자동 발행</strong> 탭에서 네이버 아이디/비밀번호 입력 후 "기억하기" 체크</span>
            </li>
            <li style="margin-bottom: 1rem;">
              <strong>4단계: 콘텐츠 생성</strong><br>
              <span style="color: var(--text-muted);">URL 또는 키워드 입력 → 카테고리 선택 → <strong>"⚡ 풀오토 발행"</strong> 또는 <strong>"🔧 반자동 발행"</strong> 클릭</span>
            </li>
            <li style="margin-bottom: 1rem;">
              <strong>5단계: 완료!</strong><br>
              <span style="color: var(--text-muted);">AI가 글 생성 → 이미지 삽입 → 네이버 블로그 자동 발행까지 완료!</span>
            </li>
          </ol>
        </div>
        
        <div style="background: rgba(212, 175, 55, 0.1); border: 2px solid rgba(212, 175, 55, 0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
          <h4 style="color: #D4AF37; margin-bottom: 0.5rem;">💡 추천 시작 방법</h4>
          <p style="margin: 0;">처음 사용하시는 분은 <strong>반자동 발행</strong>을 추천합니다. 생성된 글을 확인하고 수정할 수 있어 안전합니다!</p>
        </div>
        
        <div style="background: rgba(6, 182, 212, 0.1); border: 2px solid rgba(6, 182, 212, 0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
          <h4 style="color: #06b6d4; margin-bottom: 0.5rem;">🆕 주요 기능</h4>
          <ul style="padding-left: 1.5rem; margin: 0; font-size: 0.9rem;">
            <li><strong>📊 분석 도구</strong> - 키워드 경쟁도 분석, 경쟁 블로그 분석, 제목 A/B 테스트</li>
            <li><strong>🎨 이미지 도구</strong> - AI 이미지 생성, 썸네일 자동 생성</li>
            <li><strong>📅 스케줄 관리</strong> - 예약 발행, 연속 발행</li>
            <li><strong>🔗 외부유입</strong> - 외부 링크 자동 삽입</li>
          </ul>
        </div>
        
        <div style="background: rgba(59, 130, 246, 0.1); border: 2px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 1rem;">
          <h4 style="color: var(--primary); margin-bottom: 0.5rem;">❓ 자주 묻는 질문</h4>
          <ul style="padding-left: 1.5rem; margin: 0;">
            <li><strong>Q: 어떤 API 키가 필수인가요?</strong><br>A: <strong>Gemini API 키 하나만</strong> 있으면 됩니다! 글 생성 + 이미지 생성 모두 가능합니다.</li>
            <li><strong>Q: 비용이 얼마나 드나요?</strong><br>A: Gemini API는 <strong>Google 정책/계정 설정에 따라 무료 티어 또는 과금</strong>이 적용될 수 있습니다. 사용 전 Google 콘솔에서 결제/할당량 설정을 확인해주세요.</li>
            <li><strong>Q: 네이버 계정 정보가 안전한가요?</strong><br>A: 네, 모든 정보는 로컬 PC에만 저장되며 외부로 전송되지 않습니다.</li>
          </ul>
        </div>
      </div>
    `,
    api: `
      <div style="line-height: 1.8; color: var(--text-strong);">
        <h3 style="color: var(--primary); margin-bottom: 1rem; font-size: 1.3rem;">🔑 API 키 발급 가이드</h3>
        
        <div style="background: linear-gradient(135deg, rgba(212, 175, 55, 0.15), rgba(255, 215, 0, 0.1)); border: 2px solid rgba(212, 175, 55, 0.5); border-radius: 12px; padding: 1.5rem; margin-bottom: 1.5rem;">
          <h4 style="color: #D4AF37; margin-bottom: 1rem; font-size: 1.2rem;">🔑 Gemini API 키 (필수, 이것만 있으면 됨!)</h4>
          <ul style="padding-left: 1.5rem; margin: 0;">
            <li><strong>무료 티어(정책/계정 설정에 따라 다름)</strong> - 일일/월간 할당량은 Google 정책에 따릅니다</li>
            <li><strong>글 생성</strong> - Gemini 2.0 Flash (빠르고 안정적)</li>
            <li><strong>이미지 생성</strong> - 나노 바나나 프로 (Gemini 3) / Imagen 4</li>
          </ul>
          <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(212, 175, 55, 0.2); border-radius: 8px;">
            <strong>발급 방법:</strong> <a href="https://aistudio.google.com/apikey" target="_blank" style="color: #D4AF37;">aistudio.google.com/apikey</a> → Google 로그인 → "Create API Key" 클릭
          </div>
        </div>
        
        <div style="background: rgba(6, 182, 212, 0.1); border: 2px solid rgba(6, 182, 212, 0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem;">
          <h4 style="color: #06b6d4; margin-bottom: 0.5rem;">📊 네이버 API 키 (선택, 분석 기능용)</h4>
          <ul style="padding-left: 1.5rem; margin: 0;">
            <li><strong>네이버 검색 API</strong> - 🆓 무료, 크롤링 성공률 향상</li>
            <li><strong>네이버 키워드 도구 API</strong> - 🆓 무료, 정확한 검색량 분석</li>
          </ul>
        </div>
        
        <div style="background: rgba(59, 130, 246, 0.1); border: 2px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 1rem;">
          <h4 style="color: var(--primary); margin-bottom: 0.5rem;">💡 발급 팁</h4>
          <ul style="padding-left: 1.5rem; margin: 0;">
            <li><strong>Gemini API 키 하나만</strong> 발급받으면 모든 기능을 사용할 수 있습니다!</li>
            <li>API 키는 비밀번호처럼 중요합니다. 절대 공유하지 마세요.</li>
            <li>발급 후 바로 사용할 수 있습니다. 별도 승인 절차는 없습니다.</li>
            <li>API 키를 입력한 후 반드시 "저장" 버튼을 클릭하세요.</li>
          </ul>
        </div>
      </div>
    `,
    'full-auto': `
      <div style="line-height: 1.8; color: var(--text-strong);">
        <h3 style="color: var(--primary); margin-bottom: 1rem; font-size: 1.3rem;">⚡ 풀오토 발행 사용법</h3>
        <p style="margin-bottom: 1.5rem;">풀오토 발행은 URL이나 키워드만 입력하면 AI가 자동으로 글을 생성하고 이미지를 삽입한 후 네이버 블로그에 발행하는 완전 자동 기능입니다.</p>
        
        <h4 style="color: var(--primary); margin: 1.5rem 0 1rem 0;">📝 사용 방법 (단계별)</h4>
        <ol style="padding-left: 1.5rem; margin-bottom: 1.5rem;">
          <li style="margin-bottom: 1rem;">
            <strong>1단계: 네이버 계정 입력</strong><br>
            <span style="color: var(--text-muted);">메인 화면 상단의 "네이버 아이디"와 "비밀번호"를 입력하세요. "기억하기"를 체크하면 다음에 자동으로 입력됩니다.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>2단계: 콘텐츠 소스 선택</strong><br>
            <span style="color: var(--text-muted);">두 가지 방법 중 하나를 선택하세요:</span>
            <ul style="padding-left: 1.5rem; margin-top: 0.5rem; color: var(--text-muted);">
              <li><strong>URL 입력:</strong> 네이버 블로그 URL을 입력하면 해당 글을 참고하여 새 글을 생성합니다.</li>
              <li><strong>키워드 입력:</strong> 제목과 키워드를 입력하면 해당 주제로 글을 생성합니다.</li>
            </ul>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>3단계: 이미지 소스 선택</strong><br>
            <span style="color: var(--text-muted);">"이미지 소스"에서 <strong>나노 바나나 프로</strong> 또는 <strong>Imagen 4</strong>를 선택하세요. (Gemini API 키 사용 / 과금 가능)</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>4단계: 발행 모드 선택</strong><br>
            <span style="color: var(--text-muted);">"발행 방식"에서 즉시발행, 임시저장, 예약발행 중 선택하세요.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>5단계: 풀오토 발행 시작</strong><br>
            <span style="color: var(--text-muted);">"⚡ 풀오토 발행" 버튼을 클릭하세요. AI가 자동으로 모든 작업을 수행합니다!</span>
          </li>
        </ol>
        
        <div style="background: rgba(239, 68, 68, 0.1); border: 2px solid rgba(239, 68, 68, 0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
          <h4 style="color: #EF4444; margin-bottom: 0.5rem;">⚠️ 주의사항</h4>
          <ul style="padding-left: 1.5rem; margin: 0;">
            <li>풀오토 발행은 생성된 글을 확인하지 않고 바로 발행합니다.</li>
            <li>처음 사용자는 반자동 발행을 먼저 사용해보세요.</li>
            <li>발행 전에 생성된 콘텐츠를 확인하고 싶다면 반자동 발행을 사용하세요.</li>
          </ul>
        </div>
        
        <div style="background: rgba(16, 185, 129, 0.1); border: 2px solid rgba(16, 185, 129, 0.3); border-radius: 8px; padding: 1rem;">
          <h4 style="color: #10B981; margin-bottom: 0.5rem;">💡 풀오토 발행의 장점</h4>
          <ul style="padding-left: 1.5rem; margin: 0;">
            <li>한 번의 클릭으로 모든 작업이 자동으로 완료됩니다.</li>
            <li>시간을 크게 절약할 수 있습니다.</li>
            <li>여러 글을 연속으로 발행할 때 유용합니다.</li>
          </ul>
        </div>
      </div>
    `,
    'semi-auto': `
      <div style="line-height: 1.8; color: var(--text-strong);">
        <h3 style="color: var(--primary); margin-bottom: 1rem; font-size: 1.3rem;">🔧 반자동 발행 사용법</h3>
        <p style="margin-bottom: 1.5rem;">반자동 발행은 AI가 글을 생성한 후, 사용자가 확인하고 수정한 다음 발행하는 방식입니다. 처음 사용자에게 추천합니다!</p>
        
        <h4 style="color: var(--primary); margin: 1.5rem 0 1rem 0;">📝 사용 방법 (단계별)</h4>
        <ol style="padding-left: 1.5rem; margin-bottom: 1.5rem;">
          <li style="margin-bottom: 1rem;">
            <strong>1단계: 콘텐츠 생성</strong><br>
            <span style="color: var(--text-muted);">URL을 입력하거나 제목/키워드를 입력한 후 "✏️ 키워드,제목으로 AI 글 생성하기" 버튼을 클릭하세요.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>2단계: 생성된 글 확인</strong><br>
            <span style="color: var(--text-muted);">AI가 생성한 제목, 본문, 해시태그를 확인하세요. 필요하면 수정할 수 있습니다.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>3단계: 이미지 생성 (선택)</strong><br>
            <span style="color: var(--text-muted);">"이미지 관리" 탭으로 이동하여 "소제목 분석" 버튼을 클릭하면 각 소제목에 맞는 이미지를 자동으로 생성합니다.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>4단계: 이미지 확인 및 수정</strong><br>
            <span style="color: var(--text-muted);">생성된 이미지를 확인하고, 마음에 들지 않으면 "재생성" 버튼을 클릭하여 다시 생성할 수 있습니다.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>5단계: 발행</strong><br>
            <span style="color: var(--text-muted);">모든 내용을 확인한 후 "🔧 반자동 발행" 버튼을 클릭하면 네이버 블로그에 발행됩니다.</span>
          </li>
        </ol>
        
        <div style="background: rgba(16, 185, 129, 0.1); border: 2px solid rgba(16, 185, 129, 0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
          <h4 style="color: #10B981; margin-bottom: 0.5rem;">✅ 반자동 발행의 장점</h4>
          <ul style="padding-left: 1.5rem; margin: 0;">
            <li>생성된 글을 확인하고 수정할 수 있어 안전합니다.</li>
            <li>이미지를 선택적으로 생성하고 관리할 수 있습니다.</li>
            <li>발행 전에 최종 확인이 가능합니다.</li>
            <li>처음 사용자에게 가장 추천하는 방식입니다!</li>
          </ul>
        </div>
        
        <div style="background: rgba(59, 130, 246, 0.1); border: 2px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 1rem;">
          <h4 style="color: var(--primary); margin-bottom: 0.5rem;">💡 활용 팁</h4>
          <ul style="padding-left: 1.5rem; margin: 0;">
            <li>생성된 글의 톤이나 스타일을 수정하고 싶다면 "페러프레이징 모드"를 사용하세요.</li>
            <li>이미지가 마음에 들지 않으면 "재생성" 버튼을 여러 번 클릭하여 다른 이미지를 생성할 수 있습니다.</li>
            <li>생성된 글은 "생성된 글 목록"에 저장되므로 나중에 다시 불러와서 사용할 수 있습니다.</li>
          </ul>
        </div>
      </div>
    `,
    images: `
      <div style="line-height: 1.8; color: var(--text-strong);">
        <h3 style="color: var(--primary); margin-bottom: 1rem; font-size: 1.3rem;">🖼️ 이미지 관리 사용법</h3>
        <p style="margin-bottom: 1.5rem;">이미지 관리 탭에서는 소제목에 맞는 이미지를 생성하고 관리할 수 있습니다.</p>
        
        <h4 style="color: var(--primary); margin: 1.5rem 0 1rem 0;">📝 사용 방법 (단계별)</h4>
        <ol style="padding-left: 1.5rem; margin-bottom: 1.5rem;">
          <li style="margin-bottom: 1rem;">
            <strong>1단계: 소제목 분석</strong><br>
            <span style="color: var(--text-muted);">먼저 "통합" 탭에서 글을 생성하거나, 제목을 입력한 후 "이미지 관리" 탭으로 이동하세요.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>2단계: 소제목 분석 버튼 클릭</strong><br>
            <span style="color: var(--text-muted);">"이미지 관리" 탭에서 "소제목 분석" 버튼을 클릭하면 제목을 기반으로 소제목들이 자동으로 분석됩니다.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>3단계: 이미지 소스 선택</strong><br>
            <span style="color: var(--text-muted);">"이미지 소스"에서 DALL-E 3 또는 Pexels를 선택하세요. Pexels는 무료입니다.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>4단계: 이미지 생성</strong><br>
            <span style="color: var(--text-muted);">"이미지 생성 시작" 버튼을 클릭하면 각 소제목에 맞는 이미지가 자동으로 생성됩니다.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>5단계: 이미지 확인 및 수정</strong><br>
            <span style="color: var(--text-muted);">생성된 이미지를 확인하고, 마음에 들지 않으면 "재생성" 버튼을 클릭하세요.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>6단계: 이미지 선택 및 적용</strong><br>
            <span style="color: var(--text-muted);">이미지 위에 마우스를 올리면 "사용하기" 버튼이 나타납니다. 클릭하면 해당 소제목에 이미지가 적용됩니다.</span>
          </li>
        </ol>
        
        <div style="background: rgba(59, 130, 246, 0.1); border: 2px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
          <h4 style="color: var(--primary); margin-bottom: 0.5rem;">🔄 이미지 재생성 기능</h4>
          <p style="margin: 0;">생성된 이미지가 마음에 들지 않으면 "재생성" 버튼을 클릭하면 다른 이미지가 생성됩니다. 여러 번 시도할 수 있습니다!</p>
        </div>
        
        <div style="background: rgba(16, 185, 129, 0.1); border: 2px solid rgba(16, 185, 129, 0.3); border-radius: 8px; padding: 1rem;">
          <h4 style="color: #10B981; margin-bottom: 0.5rem;">💡 이미지 재사용 기능</h4>
          <p style="margin: 0;">"생성된 글 목록"에서 "🖼️ 이미지 재사용" 버튼을 클릭하면 이전에 생성한 이미지를 다시 사용할 수 있습니다. 시간과 비용을 절약할 수 있습니다!</p>
        </div>
      </div>
    `,
    schedule: `
      <div style="line-height: 1.8; color: var(--text-strong);">
        <h3 style="color: var(--primary); margin-bottom: 1rem; font-size: 1.3rem;">⏰ 예약 발행 사용법</h3>
        <p style="margin-bottom: 1.5rem;">예약 발행 기능을 사용하면 원하는 날짜와 시간에 자동으로 블로그 글이 발행됩니다.</p>
        
        <h4 style="color: var(--primary); margin: 1.5rem 0 1rem 0;">📝 사용 방법 (단계별)</h4>
        <ol style="padding-left: 1.5rem; margin-bottom: 1.5rem;">
          <li style="margin-bottom: 1rem;">
            <strong>1단계: 발행 방식 선택</strong><br>
            <span style="color: var(--text-muted);">"발행 방식" 드롭다운에서 "예약발행"을 선택하세요.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>2단계: 날짜 및 시간 선택</strong><br>
            <span style="color: var(--text-muted);">"예약 시간" 입력 필드가 나타나면 클릭하여 달력을 열고 원하는 날짜와 시간을 선택하세요.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>3단계: 확인 버튼 클릭</strong><br>
            <span style="color: var(--text-muted);">날짜와 시간을 선택한 후 "✅ 확인" 버튼을 클릭하여 예약을 확정하세요.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>4단계: 발행 시작</strong><br>
            <span style="color: var(--text-muted);">"풀오토 발행" 또는 "반자동 발행" 버튼을 클릭하면 예약된 시간에 자동으로 발행됩니다.</span>
          </li>
        </ol>
        
        <div style="background: rgba(212, 175, 55, 0.1); border: 2px solid rgba(212, 175, 55, 0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
          <h4 style="color: #D4AF37; margin-bottom: 0.5rem;">⏰ 예약 시간 제한</h4>
          <ul style="padding-left: 1.5rem; margin: 0;">
            <li>예약 시간은 현재 시간보다 이후여야 합니다.</li>
            <li>최소 1분 후부터 예약할 수 있습니다.</li>
            <li>예약된 글은 "스케줄 관리" 탭에서 확인할 수 있습니다.</li>
          </ul>
        </div>
        
        <div style="background: rgba(59, 130, 246, 0.1); border: 2px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 1rem;">
          <h4 style="color: var(--primary); margin-bottom: 0.5rem;">💡 활용 팁</h4>
          <ul style="padding-left: 1.5rem; margin: 0;">
            <li>여러 글을 미리 작성하여 예약 발행하면 시간을 효율적으로 관리할 수 있습니다.</li>
            <li>특정 시간대에 발행하면 조회수가 높아질 수 있습니다.</li>
            <li>예약된 글은 "스케줄 관리" 탭에서 수정하거나 취소할 수 있습니다.</li>
          </ul>
        </div>
      </div>
    `,
    dashboard: `
      <div style="line-height: 1.8; color: var(--text-strong);">
        <h3 style="color: var(--primary); margin-bottom: 1rem; font-size: 1.3rem;">🏠 메인 대시보드 사용법</h3>
        <p style="margin-bottom: 1.5rem;">메인 대시보드는 블로그 자동화 현황을 한눈에 확인할 수 있는 대시보드입니다.</p>
        
        <h4 style="color: var(--primary); margin: 1.5rem 0 1rem 0;">📊 주요 기능</h4>
        <ol style="padding-left: 1.5rem; margin-bottom: 1.5rem;">
          <li style="margin-bottom: 1rem;">
            <strong>🕐 현재 시간 표시</strong><br>
            <span style="color: var(--text-muted);">실시간으로 현재 시간과 날짜를 표시합니다. 블로그 발행 시간을 확인할 때 유용합니다.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>📅 블로그 일정 달력</strong><br>
            <span style="color: var(--text-muted);">예약 발행된 블로그 글의 일정을 달력으로 확인할 수 있습니다. 언제 어떤 글이 발행되는지 한눈에 볼 수 있습니다.</span>
          </li>
        </ol>
        
        <div style="background: rgba(59, 130, 246, 0.1); border: 2px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
          <h4 style="color: var(--primary); margin-bottom: 0.5rem;">💡 활용 방법</h4>
          <ul style="padding-left: 1.5rem; margin: 0;">
            <li>앱을 실행하면 자동으로 메인 대시보드가 표시됩니다.</li>
            <li>달력에서 예약된 발행 일정을 확인할 수 있습니다.</li>
            <li>현재 시간을 확인하여 발행 시간을 계획할 수 있습니다.</li>
          </ul>
        </div>
        
        <div style="background: rgba(16, 185, 129, 0.1); border: 2px solid rgba(16, 185, 129, 0.3); border-radius: 8px; padding: 1rem;">
          <h4 style="color: #10B981; margin-bottom: 0.5rem;">📝 팁</h4>
          <ul style="padding-left: 1.5rem; margin: 0;">
            <li>달력에서 날짜를 클릭하면 해당 날짜의 예약 발행 목록을 볼 수 있습니다.</li>
            <li>시간은 실시간으로 업데이트되므로 정확한 발행 시간을 확인할 수 있습니다.</li>
          </ul>
        </div>
      </div>
    `,
    'smart-auto': `
      <div style="line-height: 1.8; color: var(--text-strong);">
        <h3 style="color: var(--primary); margin-bottom: 1rem; font-size: 1.3rem;">🚀 스마트 자동 발행 탭 사용법</h3>
        <p style="margin-bottom: 1.5rem;">스마트 자동 발행 탭은 AI를 활용하여 블로그 글을 자동으로 생성하고 발행하는 핵심 기능입니다.</p>
        
        <h4 style="color: var(--primary); margin: 1.5rem 0 1rem 0;">📝 주요 기능</h4>
        <ol style="padding-left: 1.5rem; margin-bottom: 1.5rem;">
          <li style="margin-bottom: 1rem;">
            <strong>🔐 네이버 계정 정보</strong><br>
            <span style="color: var(--text-muted);">네이버 아이디와 비밀번호를 입력하세요. "기억하기"를 체크하면 다음에 자동으로 입력됩니다. <strong style="color: var(--primary);">체크박스를 체크하고 입력하면 앱을 껐다 켜도 저장됩니다!</strong></span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>📝 콘텐츠 입력</strong><br>
            <span style="color: var(--text-muted);">두 가지 방법으로 콘텐츠를 입력할 수 있습니다:</span>
            <ul style="padding-left: 1.5rem; margin-top: 0.5rem; color: var(--text-muted);">
              <li><strong>URL 입력:</strong> 네이버 블로그 URL을 입력하면 해당 글을 참고하여 새 글을 생성합니다.</li>
              <li><strong>키워드 입력:</strong> 제목과 키워드를 입력하면 해당 주제로 글을 생성합니다.</li>
            </ul>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>🤖 AI 모델 선택</strong><br>
            <span style="color: var(--text-muted);">Gemini(정책/계정 설정에 따라 무료 티어 또는 과금), OpenAI(유료), Claude(유료) 중에서 선택할 수 있습니다.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>🎨 이미지 소스 선택</strong><br>
            <span style="color: var(--text-muted);">DALL-E 3(유료) 또는 Pexels(일반적으로 무료)를 선택할 수 있습니다.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>📤 발행 모드 선택</strong><br>
            <span style="color: var(--text-muted);">즉시발행, 임시저장, 예약발행 중 선택할 수 있습니다.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>⚡ 풀오토 발행 / 🔧 반자동 발행</strong><br>
            <span style="color: var(--text-muted);">풀오토는 자동으로 모든 작업을 수행하고, 반자동은 생성된 글을 확인한 후 발행합니다.</span>
          </li>
        </ol>
        
        <div style="background: rgba(212, 175, 55, 0.1); border: 2px solid rgba(212, 175, 55, 0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
          <h4 style="color: #D4AF37; margin-bottom: 0.5rem;">💾 네이버 계정 저장 기능</h4>
          <p style="margin: 0;"><strong>중요:</strong> "기억하기" 체크박스를 체크하고 네이버 아이디와 비밀번호를 입력하면, 앱을 껐다 켜도 자동으로 입력됩니다. 체크박스를 해제하면 저장되지 않습니다.</p>
        </div>
        
        <div style="background: rgba(16, 185, 129, 0.1); border: 2px solid rgba(16, 185, 129, 0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
          <h4 style="color: #10B981; margin-bottom: 0.5rem;">✅ 생성된 글 목록</h4>
          <p style="margin: 0;">생성된 글은 자동으로 "생성된 글 목록"에 저장됩니다. 나중에 다시 불러와서 수정하거나 재발행할 수 있습니다.</p>
        </div>
        
        <div style="background: rgba(59, 130, 246, 0.1); border: 2px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 1rem;">
          <h4 style="color: var(--primary); margin-bottom: 0.5rem;">💡 활용 팁</h4>
          <ul style="padding-left: 1.5rem; margin: 0;">
            <li>처음 사용자는 반자동 발행을 추천합니다. 생성된 글을 확인하고 수정할 수 있어 안전합니다.</li>
            <li>여러 글을 연속으로 발행하려면 "연속 발행" 기능을 사용하세요.</li>
            <li>생성된 글은 "페러프레이징 모드"로 글의 퀄리티를 개선할 수 있습니다.</li>
          </ul>
        </div>
      </div>
    `,
    'image-tab': `
      <div style="line-height: 1.8; color: var(--text-strong);">
        <h3 style="color: var(--primary); margin-bottom: 1rem; font-size: 1.3rem;">🖼️ 이미지 관리 탭 사용법</h3>
        <p style="margin-bottom: 1.5rem;">이미지 관리 탭에서는 블로그 글에 삽입할 이미지를 생성하고 관리할 수 있습니다.</p>
        
        <h4 style="color: var(--primary); margin: 1.5rem 0 1rem 0;">📝 사용 방법 (단계별)</h4>
        <ol style="padding-left: 1.5rem; margin-bottom: 1.5rem;">
          <li style="margin-bottom: 1rem;">
            <strong>1단계: 제목 입력</strong><br>
            <span style="color: var(--text-muted);">"제목" 입력 필드에 블로그 글 제목을 입력하세요. 또는 "스마트 자동 발행" 탭에서 생성한 제목이 자동으로 입력됩니다.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>2단계: 이미지 소스 선택</strong><br>
            <span style="color: var(--text-muted);">DALL-E 3(유료) 또는 Pexels(일반적으로 무료) 중에서 선택하세요. Pexels는 보통 무료로 사용 가능하여 추천합니다.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>3단계: 소제목 분석</strong><br>
            <span style="color: var(--text-muted);">"소제목 분석하기" 버튼을 클릭하면 제목을 기반으로 소제목들이 자동으로 분석되고, 각 소제목에 대한 영어 프롬프트가 생성됩니다.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>4단계: 이미지 생성</strong><br>
            <span style="color: var(--text-muted);">"이미지 생성 시작" 버튼을 클릭하면 각 소제목에 맞는 이미지가 자동으로 생성됩니다. 진행 상황이 표시됩니다.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>5단계: 이미지 확인 및 수정</strong><br>
            <span style="color: var(--text-muted);">생성된 이미지를 확인하세요. 마음에 들지 않으면 각 이미지의 "재생성" 버튼을 클릭하여 다시 생성할 수 있습니다.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>6단계: 이미지 선택 및 적용</strong><br>
            <span style="color: var(--text-muted);">이미지 위에 마우스를 올리면 "사용하기" 버튼이 나타납니다. 클릭하면 해당 소제목에 이미지가 적용됩니다.</span>
          </li>
        </ol>
        
        <div style="background: rgba(139, 92, 246, 0.1); border: 2px solid rgba(139, 92, 246, 0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
          <h4 style="color: #8b5cf6; margin-bottom: 0.5rem;">🔄 이미지 재생성 기능</h4>
          <p style="margin: 0;">생성된 이미지가 마음에 들지 않으면 "재생성" 버튼을 클릭하면 다른 이미지가 생성됩니다. 여러 번 시도할 수 있습니다!</p>
        </div>
        
        <div style="background: rgba(16, 185, 129, 0.1); border: 2px solid rgba(16, 185, 129, 0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
          <h4 style="color: #10B981; margin-bottom: 0.5rem;">🖼️ 이미지 재사용 기능</h4>
          <p style="margin: 0;">"생성된 글 목록"에서 "🖼️ 이미지 재사용" 버튼을 클릭하면 이전에 생성한 이미지를 다시 사용할 수 있습니다. 시간과 비용을 절약할 수 있습니다!</p>
        </div>
        
        <div style="background: rgba(59, 130, 246, 0.1); border: 2px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 1rem;">
          <h4 style="color: var(--primary); margin-bottom: 0.5rem;">💡 활용 팁</h4>
          <ul style="padding-left: 1.5rem; margin: 0;">
            <li>소제목 분석은 "스마트 자동 발행" 탭에서 생성한 제목을 자동으로 사용합니다.</li>
            <li>이미지는 각 소제목에 맞게 최적화된 영어 프롬프트로 생성됩니다.</li>
            <li>생성된 이미지는 자동으로 저장되므로 나중에 다시 사용할 수 있습니다.</li>
            <li>이미지 위에 마우스를 올리면 "크게보기" 버튼으로 전체 화면에서 확인할 수 있습니다.</li>
          </ul>
        </div>
      </div>
    `,
    'schedule-tab': `
      <div style="line-height: 1.8; color: var(--text-strong);">
        <h3 style="color: var(--primary); margin-bottom: 1rem; font-size: 1.3rem;">📅 스케줄 관리 탭 사용법</h3>
        <p style="margin-bottom: 1.5rem;">스케줄 관리 탭에서는 예약 발행된 블로그 글들을 확인하고 관리할 수 있습니다.</p>
        
        <h4 style="color: var(--primary); margin: 1.5rem 0 1rem 0;">📊 주요 기능</h4>
        <ol style="padding-left: 1.5rem; margin-bottom: 1.5rem;">
          <li style="margin-bottom: 1rem;">
            <strong>📈 스케줄 통계</strong><br>
            <span style="color: var(--text-muted);">예약된 글, 완료된 글, 실패한 글의 개수를 한눈에 확인할 수 있습니다.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>📋 예약 발행 목록</strong><br>
            <span style="color: var(--text-muted);">예약 발행된 모든 글의 목록을 확인할 수 있습니다. 각 글의 제목, 예약 시간, 상태 등을 볼 수 있습니다.</span>
          </li>
          <li style="margin-bottom: 1rem;">
            <strong>🔄 새로고침</strong><br>
            <span style="color: var(--text-muted);">"새로고침" 버튼을 클릭하면 최신 예약 발행 목록을 불러옵니다.</span>
          </li>
        </ol>
        
        <div style="background: rgba(212, 175, 55, 0.1); border: 2px solid rgba(212, 175, 55, 0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
          <h4 style="color: #D4AF37; margin-bottom: 0.5rem;">⏰ 예약 발행 상태</h4>
          <ul style="padding-left: 1.5rem; margin: 0;">
            <li><strong>예약됨:</strong> 아직 발행되지 않은 예약된 글입니다.</li>
            <li><strong>완료됨:</strong> 예약된 시간에 성공적으로 발행된 글입니다.</li>
            <li><strong>실패:</strong> 발행 중 오류가 발생한 글입니다.</li>
          </ul>
        </div>
        
        <div style="background: rgba(16, 185, 129, 0.1); border: 2px solid rgba(16, 185, 129, 0.3); border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
          <h4 style="color: #10B981; margin-bottom: 0.5rem;">📝 예약 발행 설정 방법</h4>
          <p style="margin: 0;">"스마트 자동 발행" 탭에서 "발행 방식"을 "예약발행"으로 선택하고 날짜와 시간을 설정한 후 발행하면, 여기에서 확인할 수 있습니다.</p>
        </div>
        
        <div style="background: rgba(59, 130, 246, 0.1); border: 2px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 1rem;">
          <h4 style="color: var(--primary); margin-bottom: 0.5rem;">💡 활용 팁</h4>
          <ul style="padding-left: 1.5rem; margin: 0;">
            <li>예약 발행 목록을 정기적으로 확인하여 발행 상태를 모니터링하세요.</li>
            <li>실패한 글은 원인을 확인한 후 다시 발행할 수 있습니다.</li>
            <li>여러 글을 미리 작성하여 예약 발행하면 시간을 효율적으로 관리할 수 있습니다.</li>
          </ul>
        </div>
      </div>
    `
  };

  // 사용 가이드 버튼 클릭
  if (userGuideBtn) {
    userGuideBtn.addEventListener('click', () => {
      if (userGuideModal && guideContent) {
        // 첫 번째 탭(시작하기) 내용 표시
        guideContent.innerHTML = guideContents.start;
        userGuideModal.style.display = 'flex';
        userGuideModal.setAttribute('aria-hidden', 'false');
      }
    });
  }

  // 탭 전환
  guideTabBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const tab = btn.getAttribute('data-tab');

      // 모든 탭 버튼 스타일 초기화
      guideTabBtns.forEach(b => {
        b.classList.remove('active');
        (b as HTMLElement).style.background = 'var(--bg-tertiary)';
        (b as HTMLElement).style.color = 'var(--text-strong)';
        (b as HTMLElement).style.borderColor = 'var(--border-light)';
      });

      // 선택된 탭 버튼 강조
      btn.classList.add('active');
      (btn as HTMLElement).style.background = 'var(--primary)';
      (btn as HTMLElement).style.color = 'white';
      (btn as HTMLElement).style.borderColor = 'var(--primary)';

      // 해당 탭 내용 표시
      if (tab && guideContent && guideContents[tab]) {
        guideContent.innerHTML = guideContents[tab];
      }
    });
  });

  // 모달 닫기
  closeUserGuideBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      if (userGuideModal) {
        userGuideModal.style.display = 'none';
        userGuideModal.setAttribute('aria-hidden', 'true');
      }
    });
  });

  // 모달 배경 클릭 시 닫기
  if (userGuideModal) {
    userGuideModal.addEventListener('click', (e) => {
      if (e.target === userGuideModal) {
        userGuideModal.style.display = 'none';
        userGuideModal.setAttribute('aria-hidden', 'true');
      }
    });
  }

  // ✅ 분석 도구 버튼 클릭 - 분석 도구 탭으로 이동
  const analyticsBtn = document.getElementById('analytics-btn');
  if (analyticsBtn) {
    analyticsBtn.addEventListener('click', () => {
      // 분석 도구 탭 패널 표시
      const analyticsTab = document.getElementById('tab-analytics');
      const allTabs = document.querySelectorAll('.tab-panel');
      const allTabButtons = document.querySelectorAll('.tab-button');

      // 모든 탭 숨기기
      allTabs.forEach(tab => {
        tab.classList.remove('active');
        (tab as HTMLElement).style.display = 'none';
      });

      // 모든 탭 버튼 비활성화
      allTabButtons.forEach(btn => {
        btn.classList.remove('active');
        btn.setAttribute('aria-selected', 'false');
      });

      // 분석 도구 탭 표시
      if (analyticsTab) {
        analyticsTab.classList.add('active');
        (analyticsTab as HTMLElement).style.display = 'block';
        analyticsTab.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }

      appendLog('📊 분석 도구 탭으로 이동했습니다.');
    });
  }

  // ✅ 사용법 버튼 클릭 - 사용법 탭으로 이동
  const tutorialsBtn = document.getElementById('tutorials-btn');
  if (tutorialsBtn) {
    tutorialsBtn.addEventListener('click', () => {
      // 사용법 탭 패널 표시
      const tutorialsTab = document.getElementById('tab-tutorials');
      const allTabs = document.querySelectorAll('.tab-panel');
      const allTabButtons = document.querySelectorAll('.tab-button');

      // 모든 탭 숨기기
      allTabs.forEach(tab => {
        tab.classList.remove('active');
        (tab as HTMLElement).style.display = 'none';
      });

      // 모든 탭 버튼 비활성화
      allTabButtons.forEach(btn => {
        btn.classList.remove('active');
        btn.setAttribute('aria-selected', 'false');
      });

      // 사용법 탭 표시
      if (tutorialsTab) {
        tutorialsTab.classList.add('active');
        (tutorialsTab as HTMLElement).style.display = 'block';
        tutorialsTab.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }

      appendLog('📹 사용법 탭으로 이동했습니다.');
    });
  }
}

// ============================================
// 📹 사용법 영상 탭 초기화
// ============================================
interface TutorialVideo {
  id: string;
  title: string;
  description: string;
  filePath: string;
  uploadedAt: string;
}

// 관리자 모드 확인 (비밀 키 조합: Ctrl + Shift + A)
let isAdminMode = false;

function initTutorialsTab(): void {
  console.log('[Tutorials] 사용법 탭 초기화');

  // index.html에 동일 id가 2군데(tab-tutorials / tools-tab-tutorials) 존재할 수 있어서
  // 반드시 컨테이너를 기준으로 querySelector를 수행합니다.
  const roots = [
    document.getElementById('tab-tutorials'),
    document.getElementById('tools-tab-tutorials'),
  ].filter(Boolean) as HTMLElement[];

  const toggleAdminSections = (enabled: boolean) => {
    roots.forEach((root) => {
      const section = root.querySelector('#admin-video-upload') as HTMLElement | null;
      if (section) section.style.display = enabled ? 'block' : 'none';
    });
  };

  // 관리자 모드 토글
  // - Shift + Z → Shift + X
  // - Ctrl + Shift + A
  let adminKeySequence: string[] = [];
  const ADMIN_KEY_SEQUENCE = ['z', 'x'];

  document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'a') {
      isAdminMode = !isAdminMode;
      toggleAdminSections(isAdminMode);

      // ✅ 관리자 모드 변경 시 영상 목록 리렌더링 (삭제 버튼 갱신)
      loadTutorialVideos();

      console.log(`[Tutorials] 관리자 모드: ${isAdminMode ? '활성화' : '비활성화'}`);
      if (isAdminMode) {
        alert('🔐 관리자 모드가 활성화되었습니다.\n영상 업로드가 가능합니다.');
      }
      adminKeySequence = [];
      return;
    }

    // Shift 키가 눌린 상태에서 Z, X 순서로 입력
    if (e.shiftKey && (e.key.toLowerCase() === 'z' || e.key.toLowerCase() === 'x')) {
      adminKeySequence.push(e.key.toLowerCase());

      // 시퀀스가 너무 길어지면 초기화
      if (adminKeySequence.length > 2) {
        adminKeySequence = [e.key.toLowerCase()];
      }

      // Z, X 순서로 입력되면 관리자 모드 토글
      if (adminKeySequence.length === 2 &&
        adminKeySequence[0] === 'z' &&
        adminKeySequence[1] === 'x') {
        isAdminMode = !isAdminMode;
        toggleAdminSections(isAdminMode);

        // ✅ 관리자 모드 변경 시 영상 목록 리렌더링 (삭제 버튼 갱신)
        loadTutorialVideos();

        console.log(`[Tutorials] 관리자 모드: ${isAdminMode ? '활성화' : '비활성화'}`);

        if (isAdminMode) {
          alert('🔐 관리자 모드가 활성화되었습니다.\n영상 업로드가 가능합니다.');
        }

        adminKeySequence = []; // 시퀀스 초기화
      }

      // 2초 후 시퀀스 초기화
      setTimeout(() => {
        adminKeySequence = [];
      }, 2000);
    }
  });

  // 영상 업로드 버튼 (각 탭/패널별로 연결)
  roots.forEach((root) => {
    const uploadVideoBtn = root.querySelector('#upload-video-btn') as HTMLButtonElement | null;
    const videoTitleInput = root.querySelector('#video-title-input') as HTMLInputElement | null;
    const videoDescriptionInput = root.querySelector('#video-description-input') as HTMLInputElement | null;

    if (!uploadVideoBtn) return;
    if (uploadVideoBtn.hasAttribute('data-listener-added')) return;
    uploadVideoBtn.setAttribute('data-listener-added', 'true');

    uploadVideoBtn.addEventListener('click', async () => {
      if (!isAdminMode) {
        alert('⚠️ 관리자 권한이 필요합니다.');
        return;
      }

      const title = String(videoTitleInput?.value || '').trim();
      if (!title) {
        alert('영상 제목을 입력해주세요.');
        return;
      }

      try {
        // 파일 선택 다이얼로그
        if (!window.api.selectVideoFile) {
          alert('영상 파일 선택 기능을 사용할 수 없습니다.');
          return;
        }
        const result = await window.api.selectVideoFile();
        if (result && result.filePath) {
          const video: TutorialVideo = {
            id: `video_${Date.now()}`,
            title: title,
            description: String(videoDescriptionInput?.value || '').trim(),
            filePath: result.filePath,
            uploadedAt: new Date().toISOString(),
          };

          await saveTutorialVideo(video);
          await loadTutorialVideos();

          if (videoTitleInput) videoTitleInput.value = '';
          if (videoDescriptionInput) videoDescriptionInput.value = '';

          alert(`✅ "${title}" 영상이 등록되었습니다!`);
        }
      } catch (error) {
        console.error('[Tutorials] 영상 업로드 실패:', error);
        alert('영상 업로드에 실패했습니다.');
      }
    });
  });

  // 저장된 영상 목록 로드
  loadTutorialVideos();
}

// 영상 저장
async function saveTutorialVideo(video: TutorialVideo): Promise<void> {
  try {
    const existingVideos = await loadTutorialVideosData();
    existingVideos.push(video);

    if (window.api && window.api.saveConfig) {
      const config = await window.api.getConfig();
      (config as any).tutorialVideos = existingVideos;
      await window.api.saveConfig(config);
    }
  } catch (error) {
    console.error('[Tutorials] 영상 저장 실패:', error);
  }
}

// 영상 목록 데이터 로드
async function loadTutorialVideosData(): Promise<TutorialVideo[]> {
  try {
    console.log('[Tutorials] loadTutorialVideosData 호출됨');

    // ✅ getConfig API 사용 (안정적)
    if (window.api && window.api.getConfig) {
      console.log('[Tutorials] getConfig API 호출');
      const config = await window.api.getConfig();
      const videos = (config as any).tutorialVideos || [];
      console.log('[Tutorials] 영상 수:', videos.length);
      return videos;
    }
    console.log('[Tutorials] window.api 없음');
    return [];
  } catch (error) {
    console.error('[Tutorials] 영상 데이터 로드 실패:', error);
    return [];
  }
}

// 영상 목록 UI 로드
async function loadTutorialVideos(): Promise<void> {
  console.log('[Tutorials] ========== loadTutorialVideos 시작 ==========');
  const tutorialsContainer = document.getElementById('tutorials-list-container');
  const noTutorialsMessage = document.getElementById('no-tutorials-message');

  console.log('[Tutorials] 컨테이너:', tutorialsContainer ? '찾음' : '없음');
  console.log('[Tutorials] 메시지 요소:', noTutorialsMessage ? '찾음' : '없음');

  if (!tutorialsContainer) {
    console.error('[Tutorials] tutorials-list-container를 찾을 수 없음');
    return;
  }

  try {
    console.log('[Tutorials] loadTutorialVideosData 호출 전');
    const videos = await loadTutorialVideosData();
    console.log('[Tutorials] loadTutorialVideosData 완료, 영상 수:', videos.length);
    console.log('[Tutorials] 영상 데이터:', JSON.stringify(videos.slice(0, 2)));

    if (videos.length === 0) {
      if (noTutorialsMessage) noTutorialsMessage.style.display = 'block';
      return;
    }

    if (noTutorialsMessage) noTutorialsMessage.style.display = 'none';

    // 기존 영상 카드 제거 (메시지 제외)
    const existingCards = tutorialsContainer.querySelectorAll('.tutorial-video-card');
    existingCards.forEach(card => card.remove());

    // 영상 카드 생성
    videos.forEach((video, index) => {
      const card = document.createElement('div');
      card.className = 'tutorial-video-card';
      card.style.cssText = `
        background: var(--bg-secondary);
        border-radius: 12px;
        overflow: hidden;
        border: 1px solid var(--border-light);
        transition: all 0.3s;
      `;

      const uploadDate = new Date(video.uploadedAt).toLocaleDateString('ko-KR');

      card.innerHTML = `
        <div style="position: relative; aspect-ratio: 16/9; background: #000;">
          <video 
            id="tutorial-video-${index}" 
            style="width: 100%; height: 100%; object-fit: contain;"
            controls
            preload="metadata"
          >
            <source src="file://${video.filePath.replace(/\\/g, '/')}" type="video/mp4">
            브라우저가 비디오를 지원하지 않습니다.
          </video>
        </div>
        <div style="padding: 1rem;">
          <div style="font-weight: 700; color: var(--text-strong); font-size: 1.1rem; margin-bottom: 0.5rem;">${video.title}</div>
          ${video.description ? `<div style="color: var(--text-muted); font-size: 0.9rem; margin-bottom: 0.75rem; line-height: 1.5;">${video.description}</div>` : ''}
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <div style="font-size: 0.8rem; color: var(--text-muted);">📅 ${uploadDate}</div>
            ${isAdminMode ? `
              <button type="button" class="delete-tutorial-btn" data-video-id="${video.id}" style="padding: 0.4rem 0.8rem; background: rgba(239, 68, 68, 0.1); color: #ef4444; border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 6px; font-size: 0.8rem; cursor: pointer;">
                🗑️ 삭제
              </button>
            ` : ''}
          </div>
        </div>
      `;

      // 호버 효과
      card.addEventListener('mouseenter', () => {
        card.style.transform = 'translateY(-4px)';
        card.style.boxShadow = '0 8px 24px rgba(0, 0, 0, 0.15)';
      });
      card.addEventListener('mouseleave', () => {
        card.style.transform = 'translateY(0)';
        card.style.boxShadow = 'none';
      });

      tutorialsContainer.appendChild(card);
    });

    // 삭제 버튼 이벤트 연결 (관리자 모드에서만)
    if (isAdminMode) {
      document.querySelectorAll('.delete-tutorial-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          const videoId = (e.currentTarget as HTMLElement).getAttribute('data-video-id');
          if (videoId && confirm('정말 이 영상을 삭제하시겠습니까?')) {
            await deleteTutorialVideo(videoId);
            loadTutorialVideos();
          }
        });
      });
    }

  } catch (error) {
    console.error('[Tutorials] 영상 목록 로드 실패:', error);
  }
}

// 영상 삭제
async function deleteTutorialVideo(videoId: string): Promise<void> {
  try {
    const videos = await loadTutorialVideosData();
    const filteredVideos = videos.filter(v => v.id !== videoId);

    if (window.api && window.api.saveConfig) {
      const config = await window.api.getConfig();
      (config as any).tutorialVideos = filteredVideos;
      await window.api.saveConfig(config);
    }
  } catch (error) {
    console.error('[Tutorials] 영상 삭제 실패:', error);
  }
}

// DOMContentLoaded에서 사용법 탭 초기화 호출
document.addEventListener('DOMContentLoaded', () => {
  initTutorialsTab();
});

// ✅ 소제목 선택 모달 표시 (이미지를 특정 소제목에 배치) - 개선 버전
async function showHeadingSelectionModalV2(image: any, currentIndex: number): Promise<void> {
  const promptsContainer = document.getElementById('prompts-container') as HTMLDivElement;
  if (!promptsContainer) {
    toastManager.error('소제목 분석이 먼저 필요합니다.');
    return;
  }

  const promptItems = promptsContainer.querySelectorAll('.prompt-item');
  if (promptItems.length === 0) {
    toastManager.error('소제목이 없습니다. 먼저 소제목 분석을 해주세요.');
    return;
  }

  // 모달 생성
  const modal = document.createElement('div');
  modal.id = 'heading-selection-modal';
  modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; align-items: center; justify-content: center; z-index: 10000;';

  let headingsHtml = '';
  promptItems.forEach((item, idx) => {
    const headingText = item.querySelector('.heading-title-text')?.textContent || `소제목 ${idx + 1}`;
    headingsHtml += `
      <button type="button" class="heading-select-btn" data-heading-index="${idx}" style="padding: 1rem; background: var(--bg-secondary); border: 2px solid var(--border-light); border-radius: 8px; cursor: pointer; text-align: left; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--primary)'; this.style.background='rgba(59, 130, 246, 0.1)';" onmouseout="this.style.borderColor='var(--border-light)'; this.style.background='var(--bg-secondary)';">
        <div style="font-weight: 600; color: var(--text-strong); margin-bottom: 0.25rem;">${idx + 1}. ${headingText}</div>
      </button>
    `;
  });

  modal.innerHTML = `
    <div style="background: var(--bg-primary); border-radius: 16px; padding: 2rem; max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
        <h3 style="margin: 0; color: var(--text-strong);">📍 이미지를 배치할 소제목 선택</h3>
        <button type="button" id="close-heading-modal" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text-muted);">×</button>
          </div>
      <div style="margin-bottom: 1rem; padding: 0.75rem; background: rgba(59, 130, 246, 0.1); border-radius: 8px;">
        <img src="${toFileUrlMaybe(image.url || image.filePath || image.previewDataUrl || '')}" style="width: 100%; max-height: 150px; object-fit: contain; border-radius: 8px;">
        </div>
      <div style="display: flex; flex-direction: column; gap: 0.75rem;">
        ${headingsHtml}
        </div>
      </div>
    `;

  document.body.appendChild(modal);

  // 닫기 버튼
  modal.querySelector('#close-heading-modal')?.addEventListener('click', () => modal.remove());
  modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });

  // 소제목 선택 버튼
  modal.querySelectorAll('.heading-select-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
      const targetIndex = parseInt(btn.getAttribute('data-heading-index') || '0');

      const targetPromptItem = promptItems[targetIndex] as HTMLElement | undefined;
      const targetHeadingTitle = (targetPromptItem?.querySelector('.heading-title-text')?.textContent || `소제목 ${targetIndex + 1}`).trim();
      const sourceHeadingTitle = (image?.heading || '').trim();

      const targetExisting = ImageManager.getImage(targetHeadingTitle);

      if (sourceHeadingTitle && sourceHeadingTitle !== targetHeadingTitle) {
        if (targetExisting) {
          ImageManager.setImage(sourceHeadingTitle, { ...targetExisting, heading: sourceHeadingTitle });
        } else {
          ImageManager.removeImage(sourceHeadingTitle);
        }
      }

      ImageManager.setImage(targetHeadingTitle, { ...image, heading: targetHeadingTitle });

      const allImages = ImageManager.getAllImages();
      (window as any).imageManagementGeneratedImages = allImages;
      syncGlobalImagesFromImageManager();

      toastManager.success(`✅ ${targetIndex + 1}번 소제목에 이미지를 배치했습니다.`);
      modal.remove();
    });
  });
}

// ✅ AI 이미지 새로 생성 (폴백 체인: Nano Banana Pro → Imagen 4 → Naver)
async function regenerateWithNewAI(index: number, heading: string): Promise<void> {
  try {
    toastManager.info('🤖 AI 이미지를 새로 생성 중...');
    appendLog(`🤖 [${index + 1}] ${heading} - AI 이미지 새로 생성 중...`);

    // 영어 프롬프트 생성
    const englishPrompt = generateEnglishPromptForHeadingSync(heading);

    let newImageUrl: string | null = null;
    let successProvider = '';

    // 0. 현재 선택된 엔진 우선 시도
    const selectedBtn = document.querySelector('.image-source-btn.selected') as HTMLButtonElement;
    const selectedSource = selectedBtn?.dataset.source;
    if (selectedSource && selectedSource !== 'naver') {
      try {
        appendLog(`[${index + 1}] 선택된 엔진(${selectedSource})으로 우선 시도 중...`);
        if (selectedSource === 'stability') {
          const stabilityModel = (document.getElementById('stability-model-select') as HTMLSelectElement)?.value || 'ultra';
          const res = await generateImagesWithCostSafety({
            provider: 'stability',
            items: [{ heading, prompt: englishPrompt }],
            regenerate: true,
            model: stabilityModel
          });
          if (res.success && res.images?.[0]) {
            newImageUrl = res.images[0].previewDataUrl || res.images[0].filePath;
            successProvider = 'stability';
          }
        } else if (selectedSource === 'prodia') {
          const res = await generateImagesWithCostSafety({
            provider: 'prodia',
            items: [{ heading, prompt: englishPrompt }],
            regenerate: true
          });
          if (res.success && res.images?.[0]) {
            newImageUrl = res.images[0].previewDataUrl || res.images[0].filePath;
            successProvider = 'prodia';
          }
        } else if (selectedSource === 'imagen4') {
          newImageUrl = await generateImagen4ImageLocal(englishPrompt, true);
          successProvider = 'imagen4';
        } else if (selectedSource === 'falai') {
          const res = await generateImagesWithCostSafety({
            provider: 'falai',
            items: [{ heading, prompt: englishPrompt }],
            regenerate: true
          });
          if (res.success && res.images?.[0]) {
            newImageUrl = res.images[0].previewDataUrl || res.images[0].filePath;
            successProvider = 'falai';
          }
        } else if (selectedSource === 'nano-banana-pro' || selectedSource === 'pollinations') {
          newImageUrl = await generateNanoBananaProImage(englishPrompt, true);
          successProvider = 'nano-banana-pro';
        }

        if (newImageUrl) {
          appendLog(`✅ [${index + 1}] 선택된 엔진(${successProvider})으로 성공!`);
        }
      } catch (e) {
        appendLog(`⚠️ [${index + 1}] 선택된 엔진 시도 실패, 폴백 체인으로 전환...`);
      }
    }

    // 1. Nano Banana Pro (Gemini 기반, 무료)
    try {
      appendLog(`[${index + 1}] Nano Banana Pro 시도 중...`);
      newImageUrl = await generateNanoBananaProImage(englishPrompt, true);
      if (newImageUrl) {
        successProvider = 'nano-banana-pro';
        appendLog(`✅ [${index + 1}] Nano Banana Pro 성공!`);
      }
    } catch (e) {
      console.log('[Image] Nano Banana Pro 실패, 다음 시도...');
    }

    // 2. Imagen 4 (Google, 고품질)
    if (!newImageUrl) {
      try {
        appendLog(`[${index + 1}] Imagen 4 시도 중...`);
        newImageUrl = await generateImagen4ImageLocal(englishPrompt, true);
        if (newImageUrl) {
          successProvider = 'imagen4';
          appendLog(`✅ [${index + 1}] Imagen 4 성공!`);
        }
      } catch (e) {
        console.log('[Image] Imagen 4 실패, 다음 시도...');
      }
    }

    // 3. Naver 이미지 검색 (폴백)
    if (!newImageUrl) {
      try {
        appendLog(`[${index + 1}] Naver 이미지 검색 시도 중...`);
        newImageUrl = await searchNaverImage(englishPrompt, true);
        if (newImageUrl) {
          successProvider = 'naver';
          appendLog(`✅ [${index + 1}] Naver 이미지 검색 성공!`);
        }
      } catch (e) {
        console.log('[Image] Naver 이미지 검색 실패');
      }
    }

    if (newImageUrl) {
      const newImage = {
        url: newImageUrl,
        previewDataUrl: newImageUrl,
        filePath: newImageUrl,
        heading,
        prompt: englishPrompt,
        provider: successProvider
      };

      ImageManager.setImage(heading, newImage);

      const allImages = ImageManager.getAllImages();
      (window as any).imageManagementGeneratedImages = allImages;
      syncGlobalImagesFromImageManager();

      toastManager.success(`✅ AI 이미지 생성 완료! (${successProvider})`);
      appendLog(`✅ [${index + 1}] AI 이미지 생성 완료 (${successProvider})`);
    } else {
      throw new Error('모든 이미지 생성 방법 실패');
    }
  } catch (error) {
    console.error('[Image] AI 이미지 생성 실패:', error);
    toastManager.error('❌ 모든 이미지 소스에서 생성에 실패했습니다.');
    appendLog(`❌ [${index + 1}] 이미지 생성 실패 - 모든 소스 실패`);
  }
}

// ✅ 저장된 이미지로 교체 모달
async function showSavedImagesForReplace(targetIndex: number): Promise<void> {
  try {
    const normalizeTargetHeadingIndex = (idx: number): number => {
      const rawIdx = Number.isFinite(idx) ? idx : 0;
      const hs = (ImageManager as any)?.headings;
      const headingsLen = Array.isArray(hs) ? hs.length : 0;
      if (headingsLen > 0 && rawIdx >= headingsLen) {
        const all = (window as any).imageManagementGeneratedImages || generatedImages || [];
        const img = Array.isArray(all) ? all[rawIdx] : null;
        const byIdx = Number(img?.headingIndex ?? -1);
        if (Number.isFinite(byIdx) && byIdx >= 0) return byIdx;

        const h = String(img?.heading || '').trim();
        if (h) {
          try {
            const norm = normalizeHeadingKeyForVideoCache(h);
            const list = Array.isArray(hs) ? hs : [];
            const found = list.findIndex((it: any) => {
              const t = typeof it === 'string' ? String(it || '').trim() : String(it?.title || it || '').trim();
              if (!t) return false;
              if (t === h) return true;
              try {
                return normalizeHeadingKeyForVideoCache(t) === norm;
              } catch {
                return false;
              }
            });
            if (found >= 0) return found;
          } catch {
            // ignore
          }
        }
      }
      return rawIdx;
    };

    const normalizedIndex = normalizeTargetHeadingIndex(targetIndex);
    await showFolderSelectionModal({
      onFolderSelected: async (folderName: string) => {
        await showLocalImagePickerForReplace(folderName, normalizedIndex);
      },
    });
  } catch (error) {
    console.error('[Image] 저장된 이미지 로드 실패:', error);
    toastManager.error('저장된 이미지를 불러오는데 실패했습니다.');
  }
}

async function showLocalImagePickerForReplace(folderName: string, targetIndex: number): Promise<void> {
  try {
    if (!window.api.getUserHomeDir || !window.api.readDir || !window.api.checkFileExists) {
      toastManager.error('파일 시스템 API를 사용할 수 없습니다.');
      return;
    }

    const resolveHeadingTitleByIndex = (index: number): string => {
      return String(getHeadingTitleByIndex(index) || '').trim();
    };

    const basePath = await getRequiredImageBasePath();

    const folderPath = `${basePath}/${folderName}`.replace(/\\/g, '/');
    const exists = await window.api.checkFileExists(folderPath);
    if (!exists) {
      toastManager.error('선택한 폴더가 존재하지 않습니다.');
      return;
    }

    const files = await window.api.readDir(folderPath);
    const imageFiles = (files || []).filter((f: string) => /\.(jpg|jpeg|png|gif|webp)$/i.test(String(f || '')));
    if (imageFiles.length === 0) {
      toastManager.warning('선택한 폴더에 이미지가 없습니다.');
      return;
    }

    const modal = document.createElement('div');
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.75); z-index: 10000; display: flex;
      align-items: center; justify-content: center; padding: 2rem;
    `;

    const gridHtml = imageFiles
      .map((file: string) => {
        const filePath = `${folderPath}/${file}`.replace(/\\/g, '/');
        const fileUrl = toFileUrlMaybe(filePath);
        return `
          <button type="button" class="replace-image-pick" data-file-path="${escapeHtml(filePath)}" data-file-url="${escapeHtml(fileUrl)}" data-file-name="${escapeHtml(file)}" style="border: 2px solid var(--border-light); border-radius: 12px; overflow: hidden; padding: 0; cursor: pointer; background: var(--bg-secondary); text-align: left;">
            <div style="aspect-ratio: 1/1; background: var(--bg-tertiary); overflow: hidden;">
              <img src="${fileUrl}" alt="${escapeHtml(file)}" style="width: 100%; height: 100%; object-fit: cover; display:block;" onerror="this.style.display='none';">
            </div>
            <div style="padding: 0.5rem; font-size: 0.75rem; color: var(--text-muted); word-break: break-all;">${escapeHtml(file)}</div>
          </button>
        `;
      })
      .join('');

    modal.innerHTML = `
      <div style="background: var(--bg-primary); border-radius: 16px; padding: 1.5rem; max-width: 1100px; width: 92%; max-height: 85vh; overflow: hidden; display: flex; flex-direction: column;">
        <div style="display:flex; align-items:center; justify-content: space-between; gap: 0.75rem; margin-bottom: 1rem;">
          <div style="min-width:0;">
            <div style="font-weight: 900; color: var(--text-strong);">📁 ${escapeHtml(folderName)} 이미지 선택</div>
            <div style="font-size: 0.8rem; color: var(--text-muted);">이미지를 클릭하면 해당 소제목 이미지가 즉시 교체됩니다.</div>
          </div>
          <div style="display:flex; gap: 0.5rem; align-items:center;">
            <button type="button" class="back-to-folder-select" style="padding: 0.6rem 0.9rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 10px; cursor: pointer; font-weight: 800;">← 폴더</button>
            <button type="button" class="close-modal-btn" style="padding: 0.6rem 0.9rem; background: rgba(239, 68, 68, 0.15); color: #ef4444; border: 1px solid rgba(239, 68, 68, 0.4); border-radius: 10px; cursor: pointer; font-weight: 900;">닫기</button>
          </div>
        </div>
        <div style="flex: 1; overflow-y: auto; padding: 0.25rem;">
          <div style="display:grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 0.75rem;">
            ${gridHtml}
          </div>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    modal.querySelector('.close-modal-btn')?.addEventListener('click', () => modal.remove());
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.remove();
    });
    modal.querySelector('.back-to-folder-select')?.addEventListener('click', async () => {
      modal.remove();
      await showSavedImagesForReplace(targetIndex);
    });

    modal.querySelectorAll('.replace-image-pick').forEach((btn) => {
      btn.addEventListener('click', () => {
        const filePath = String((btn as HTMLElement).getAttribute('data-file-path') || '').trim();
        const fileUrl = String((btn as HTMLElement).getAttribute('data-file-url') || '').trim();
        const fileName = String((btn as HTMLElement).getAttribute('data-file-name') || '').trim();
        if (!filePath && !fileUrl) return;

        const currentHeading = resolveHeadingTitleByIndex(targetIndex);
        if (!currentHeading) {
          toastManager.error('소제목 제목을 찾을 수 없습니다. 먼저 소제목 분석/생성을 다시 실행해주세요.');
          return;
        }
        const updatedImage = {
          heading: currentHeading,
          filePath: filePath || fileUrl,
          url: filePath || fileUrl,
          previewDataUrl: fileUrl || filePath,
          provider: 'local',
          savedToLocal: true,
          prompt: fileName || currentHeading,
          timestamp: Date.now(),
        };

        ImageManager.setImage(currentHeading, updatedImage);
        try {
          syncGlobalImagesFromImageManager();
        } catch {
          // ignore
        }

        const allImagesAfter = (() => {
          try {
            const all = ImageManager.getAllImages();
            return Array.isArray(all) ? all : [];
          } catch {
            return [];
          }
        })();

        (window as any).imageManagementGeneratedImages = allImagesAfter.length > 0 ? allImagesAfter : generatedImages;
        displayGeneratedImages(allImagesAfter.length > 0 ? allImagesAfter : generatedImages);
        updatePromptItemsWithImages(allImagesAfter.length > 0 ? allImagesAfter : generatedImages);
        ImageManager.syncAllPreviews();
        toastManager.success('✅ 이미지가 교체되었습니다.');
        modal.remove();
      });
    });
  } catch (e) {
    console.error('[ReplacePicker] 실패:', e);
    toastManager.error(`이미지 불러오기 실패: ${(e as Error).message}`);
  }
}

// ✅ 폴더 내 이미지 목록 표시 (교체용)
async function showFolderImagesForReplace(images: any[], targetIndex: number, modal: HTMLElement): Promise<void> {
  try {
    if (!images || images.length === 0) {
      toastManager.error('폴더에 이미지가 없습니다.');
      return;
    }

    const imagesGrid = images.map((img: any, idx: number) => {
      const imgRaw = img?.previewDataUrl || img?.url || img?.filePath || '';
      const imgUrl = toFileUrlMaybe(String(imgRaw || '').trim());
      if (!imgUrl) return '';
      return `
        <div class="folder-image-item" data-image-index="${idx}" style="position: relative; border-radius: 8px; overflow: hidden; cursor: pointer; border: 2px solid transparent; transition: all 0.2s;" onmouseover="this.style.borderColor='var(--primary)'; this.style.transform='scale(1.05)';" onmouseout="this.style.borderColor='transparent'; this.style.transform='scale(1)';">
          <img src="${imgUrl}" style="width: 100%; aspect-ratio: 1/1; object-fit: cover;" onerror="this.parentElement.style.display='none'">
        </div>
      `;
    }).filter(Boolean).join('');

    const container = modal.querySelector('#saved-folders-list') as HTMLElement;
    if (container) {
      container.innerHTML = `
        <button type="button" id="back-to-folders" style="padding: 0.5rem 1rem; background: var(--bg-secondary); border: 1px solid var(--border-light); border-radius: 6px; cursor: pointer; color: var(--text-strong); margin-bottom: 1rem;">← 폴더 목록으로</button>
        <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 0.75rem;">
          ${imagesGrid}
        </div>
      `;

      // 뒤로가기 버튼
      container.querySelector('#back-to-folders')?.addEventListener('click', async () => {
        modal.remove();
        await showSavedImagesForReplace(targetIndex);
      });

      // 이미지 선택
      container.querySelectorAll('.folder-image-item').forEach((item, idx) => {
        item.addEventListener('click', () => {
          const selectedImage = images[idx];
          if (selectedImage) {
            const currentHeading = String(getHeadingTitleByIndex(targetIndex) || '').trim();
            if (!currentHeading) {
              toastManager.error('소제목 제목을 찾을 수 없습니다. 먼저 소제목 분석/생성을 다시 실행해주세요.');
              return;
            }
            const updatedImage = {
              ...selectedImage,
              heading: currentHeading,
              prompt: selectedImage.prompt || currentHeading, // ✅ prompt도 유지
              timestamp: Date.now()
            };

            // ✅ ImageManager에도 업데이트 (발행 시 정확한 이미지 사용을 위해 필수!)
            ImageManager.setImage(currentHeading, updatedImage);
            console.log(`[ImageManager] 이미지 교체: "${currentHeading}" → ${updatedImage.filePath?.substring(0, 50)}...`);

            // ✅ 전역 변수도 업데이트
            try {
              syncGlobalImagesFromImageManager();
            } catch {
              // ignore
            }

            const allImagesAfter = (() => {
              try {
                const all = ImageManager.getAllImages();
                return Array.isArray(all) ? all : [];
              } catch {
                return [];
              }
            })();

            (window as any).imageManagementGeneratedImages = allImagesAfter.length > 0 ? allImagesAfter : generatedImages;

            displayGeneratedImages(allImagesAfter.length > 0 ? allImagesAfter : generatedImages);
            updatePromptItemsWithImages(allImagesAfter.length > 0 ? allImagesAfter : generatedImages);

            toastManager.success(`✅ 이미지가 교체되었습니다.`);
            modal.remove();
          }
        });
      });
    }
  } catch (error) {
    console.error('[Image] 폴더 이미지 로드 실패:', error);
    toastManager.error('이미지를 불러오는데 실패했습니다.');
  }
}

function ensurePromptCardRemoveButtons(): void {
  const promptsContainer = document.getElementById('prompts-container') as HTMLDivElement | null;
  if (!promptsContainer) return;

  const promptItems = Array.from(promptsContainer.querySelectorAll('.prompt-item')) as HTMLDivElement[];
  promptItems.forEach((promptItem) => {
    const indexStr = String(promptItem.getAttribute('data-index') || '').trim();
    const index0 = indexStr ? Math.max(0, Number(indexStr) - 1) : 0;

    const generatedImageDiv = promptItem.querySelector('.generated-image') as HTMLElement | null;
    if (!generatedImageDiv) return;

    const hasVideo = !!generatedImageDiv.querySelector('video');
    if (hasVideo) return;

    const imgEl = generatedImageDiv.querySelector('img') as HTMLImageElement | null;
    if (!imgEl) return;

    const existingBtn = generatedImageDiv.querySelector('.remove-image-from-preview-btn') as HTMLElement | null;
    if (existingBtn) return;

    generatedImageDiv.style.position = 'relative';

    const btn = document.createElement('button');
    btn.className = 'remove-image-from-preview-btn';
    btn.setAttribute('data-image-index', String(index0));
    btn.style.cssText = [
      'position:absolute',
      'top:10px',
      'right:10px',
      'z-index:9999',
      'width:44px',
      'height:44px',
      'border-radius:999px',
      'border:2px solid rgba(255,255,255,0.85)',
      'background:rgba(239,68,68,0.95)',
      'color:#fff',
      'font-weight:900',
      'font-size:20px',
      'cursor:pointer',
      'box-shadow:0 6px 18px rgba(0,0,0,0.35)'
    ].join(';');
    btn.textContent = '✕';
    generatedImageDiv.appendChild(btn);
  });
}

// ✅ 프롬프트 아이템에 이미지 업데이트
function updatePromptItemsWithImages(images: any[]): void {
  const promptsContainer = document.getElementById('prompts-container') as HTMLDivElement;
  if (!promptsContainer) {
    console.log('[updatePromptItemsWithImages] prompts-container를 찾을 수 없습니다');
    return;
  }

  // ✅ 컨테이너 표시
  promptsContainer.style.display = 'grid';

  const imagesFromManager = (() => {
    try {
      const from = ImageManager.getAllImages();
      return Array.isArray(from) ? from : [];
    } catch {
      return [];
    }
  })();

  const sourceImages = (imagesFromManager.length > 0) ? imagesFromManager : (images || []);

  console.log(`[updatePromptItemsWithImages] ${sourceImages.length}개 이미지 업데이트 시작`);

  const byHeading = new Map<string, any>();
  (sourceImages || []).forEach((img: any) => {
    const h = String(img?.heading || '').trim();
    if (h && !byHeading.has(h)) byHeading.set(h, img);
    try {
      const n = normalizeHeadingKeyForVideoCache(h);
      if (n && !byHeading.has(n)) byHeading.set(n, img);
    } catch {
      // ignore
    }
  });

  const promptItems = Array.from(promptsContainer.querySelectorAll('.prompt-item')) as HTMLDivElement[];
  for (const promptItem of promptItems) {
    const headingTitleEl = promptItem.querySelector('.heading-title-text') as HTMLElement | null;
    const headingTitle = String(headingTitleEl?.textContent || '').trim();
    const indexStr = String(promptItem.getAttribute('data-index') || '').trim();
    const index0 = indexStr ? Math.max(0, Number(indexStr) - 1) : 0;

    const resolvedHeadingKey = (() => {
      try {
        return ImageManager.resolveHeadingKey(headingTitle);
      } catch {
        return headingTitle;
      }
    })();

    const safeHeadingTitle = escapeHtml(headingTitle);
    let headingImages: any[] = [];
    let primaryImage: any = null;
    try {
      headingImages = ImageManager.getImages(resolvedHeadingKey) || [];
      primaryImage = ImageManager.getImage(resolvedHeadingKey);
    } catch {
      headingImages = [];
      primaryImage = null;
    }

    if (!headingImages || headingImages.length === 0) {
      // 폴백: 전달된 images 배열에서 heading 기준으로 추출
      const n = (() => {
        try {
          return normalizeHeadingKeyForVideoCache(headingTitle);
        } catch {
          return '';
        }
      })();
      headingImages = (sourceImages || []).filter((img: any) => {
        const h = String(img?.heading || '').trim();
        if (!h) return false;
        if (h === headingTitle) return true;
        if (n) {
          try {
            return normalizeHeadingKeyForVideoCache(h) === n;
          } catch {
            return false;
          }
        }
        return false;
      });
    }

    if (!primaryImage && headingImages.length > 0) {
      primaryImage = headingImages[0];
    }

    if (!primaryImage) {
      const imagesGrid = promptItem.querySelector('.images-grid') as HTMLDivElement;
      const noImagePlaceholder = promptItem.querySelector('.no-image-placeholder') as HTMLDivElement;
      if (imagesGrid) imagesGrid.innerHTML = '';
      if (noImagePlaceholder) noImagePlaceholder.style.display = 'flex';

      const generatedImageDiv = promptItem.querySelector('.generated-image') as HTMLDivElement | null;
      if (generatedImageDiv) {
        const hasVideo = !!generatedImageDiv.querySelector('video');
        if (!hasVideo) {
          generatedImageDiv.innerHTML = '<span style="color: var(--text-muted); font-size: 1.5rem;">🖼️</span>';
          generatedImageDiv.style.border = '2px dashed var(--border-color)';
          generatedImageDiv.style.background = 'var(--bg-tertiary)';
          generatedImageDiv.style.boxShadow = 'none';
        }
      }
      continue;
    }

    // ✅ .images-grid 찾기 (displayImageHeadingsWithPrompts에서 생성한 구조)
    const imagesGrid = promptItem.querySelector('.images-grid') as HTMLDivElement;
    const noImagePlaceholder = promptItem.querySelector('.no-image-placeholder') as HTMLDivElement;
    const generatedImageDiv = promptItem.querySelector('.generated-image') as HTMLDivElement | null;

    console.log(`[updatePromptItemsWithImages] 소제목 업데이트: imagesGrid=${!!imagesGrid}, image=${!!primaryImage}`);
    console.log(`[updatePromptItemsWithImages] 이미지 URL: ${(primaryImage.url || primaryImage.filePath || primaryImage.previewDataUrl || '').substring(0, 80)}...`);

    const primaryKey = getStableImageKey(primaryImage);
    const headingIndex = Number(primaryImage?.headingIndex ?? index0);

    const orderedImages = (() => {
      const list = Array.isArray(headingImages) ? headingImages : [];
      if (!primaryKey) return list;
      const primary = list.find((img: any) => getStableImageKey(img) === primaryKey);
      if (!primary) return list;
      const rest = list.filter((img: any) => getStableImageKey(img) !== primaryKey);
      return [primary, ...rest];
    })();

    const normalizedSelectedKey = (() => {
      const stored = getHeadingSelectedImageKey(resolvedHeadingKey);
      const storedKey = String(stored || '').trim();
      if (storedKey && (orderedImages || []).some((img: any) => getStableImageKey(img) === storedKey)) {
        return storedKey;
      }
      const fallback = String(primaryKey || '').trim() || String(getStableImageKey((orderedImages || [])[0]) || '').trim();
      if (fallback) {
        try {
          setHeadingSelectedImageKey(resolvedHeadingKey, fallback);
        } catch {
          // ignore
        }
      }
      return fallback;
    })();

    const selectedImage = (() => {
      const list = Array.isArray(orderedImages) ? orderedImages : [];
      if (normalizedSelectedKey) {
        const found = list.find((img: any) => getStableImageKey(img) === normalizedSelectedKey);
        if (found) return found;
      }
      return primaryImage;
    })();

    const selectedRaw = selectedImage?.url || selectedImage?.filePath || selectedImage?.previewDataUrl || '';
    const selectedUrl = toFileUrlMaybe(String(selectedRaw || '').trim());
    const isVideo = (() => {
      const u = String(selectedUrl || '').toLowerCase();
      return u.endsWith('.mp4') || u.endsWith('.webm') || u.endsWith('.mov') || u.endsWith('.m4v');
    })();

    if (generatedImageDiv) {
      const count = Array.isArray(orderedImages) ? orderedImages.length : 0;
      const currentIndex = (() => {
        if (!normalizedSelectedKey) return 0;
        const idx = (orderedImages || []).findIndex((img: any) => getStableImageKey(img) === normalizedSelectedKey);
        return idx >= 0 ? idx : 0;
      })();
      const disableNav = count <= 1;
      const isPrimarySelected = !!(normalizedSelectedKey && primaryKey && normalizedSelectedKey === primaryKey);

      generatedImageDiv.style.border = '1px solid var(--border-light)';
      generatedImageDiv.style.background = 'rgba(0,0,0,0.06)';
      generatedImageDiv.style.boxShadow = 'none';
      generatedImageDiv.style.position = 'relative';
      generatedImageDiv.style.cursor = 'pointer';

      generatedImageDiv.innerHTML = `
        <button type="button" class="big-preview-prev-btn" data-heading-index="${headingIndex}" data-heading-title="${escapeHtml(headingTitle)}" style="position:absolute; left: 10px; top: 50%; transform: translateY(-50%); z-index: 30; background: rgba(255,255,255,0.18); color: white; border: 1px solid rgba(255,255,255,0.28); border-radius: 12px; padding: 0.65rem 0.8rem; cursor: pointer; font-weight: 900; ${disableNav ? 'opacity:0.35; pointer-events:none;' : ''}">◀</button>
        <button type="button" class="big-preview-next-btn" data-heading-index="${headingIndex}" data-heading-title="${escapeHtml(headingTitle)}" style="position:absolute; right: 10px; top: 50%; transform: translateY(-50%); z-index: 30; background: rgba(255,255,255,0.18); color: white; border: 1px solid rgba(255,255,255,0.28); border-radius: 12px; padding: 0.65rem 0.8rem; cursor: pointer; font-weight: 900; ${disableNav ? 'opacity:0.35; pointer-events:none;' : ''}">▶</button>
        ${isPrimarySelected ? `<div style="position:absolute; left: 10px; top: 10px; z-index: 25; background: rgba(99,102,241,0.92); color: white; font-weight: 900; font-size: 0.75rem; padding: 0.3rem 0.5rem; border-radius: 999px;">대표</div>` : ''}
        <div style="position:absolute; right: 10px; bottom: 10px; z-index: 25; background: rgba(0,0,0,0.45); color: rgba(255,255,255,0.9); font-weight: 900; font-size: 0.75rem; padding: 0.3rem 0.5rem; border-radius: 999px;">${Math.min(count, currentIndex + 1)} / ${count}</div>
        ${isVideo ? `<video class="big-preview-media" src="${escapeHtml(selectedUrl)}" autoplay loop muted playsinline controls style="width: 100%; height: 100%; object-fit: cover;" ></video>` : `<img class="big-preview-media" src="${escapeHtml(selectedUrl)}" alt="${escapeHtml(headingTitle)}" style="width: 100%; height: 100%; object-fit: cover;" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22100%22 height=%22100%22%3E%3Ctext x=%2250%22 y=%2250%22 text-anchor=%22middle%22 dominant-baseline=%22middle%22 fill=%22%23999%22%3E이미지 로드 실패%3C/text%3E%3C/svg%3E';" />`}
      `;

      const mediaEl = generatedImageDiv.querySelector('.big-preview-media') as HTMLElement | null;
      if (mediaEl) {
        mediaEl.addEventListener('click', (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          try {
            showHeadingImagesModal(encodeURIComponent(headingTitle), selectedUrl);
          } catch {
            // ignore
          }
        });
      }
    }

    if (imagesGrid) {
      imagesGrid.innerHTML = '';

      (orderedImages || []).forEach((img: any, idx: number) => {
        const imgRaw = img?.url || img?.filePath || img?.previewDataUrl || '';
        const imgUrl = toFileUrlMaybe(String(imgRaw || '').trim());
        const key = getStableImageKey(img);
        const isPrimary = !!(key && primaryKey && key === primaryKey);
        const isSelected = !!(key && normalizedSelectedKey && key === normalizedSelectedKey);

        const item = document.createElement('div');
        item.className = 'grid-image-item';
        item.setAttribute('data-image-key', key);
        item.setAttribute('data-heading-index', String(headingIndex));
        item.setAttribute('data-heading-title', headingTitle);
        item.style.cssText = 'position: relative; aspect-ratio: 1; border-radius: 8px; overflow: hidden; cursor: pointer; border: 2px solid transparent; transition: all 0.15s;';
        if (isPrimary) {
          item.style.borderColor = 'var(--primary)';
          item.style.boxShadow = '0 0 0 2px rgba(99, 102, 241, 0.2)';
        }
        if (isSelected) {
          item.style.borderColor = '#22c55e';
          item.style.boxShadow = '0 0 0 2px rgba(34, 197, 94, 0.22)';
        }

        const imgEl = document.createElement('img');
        imgEl.src = imgUrl;
        imgEl.alt = headingTitle;
        imgEl.style.width = '100%';
        imgEl.style.height = '100%';
        imgEl.style.objectFit = 'cover';
        item.appendChild(imgEl);

        const checkWrap = document.createElement('div');
        checkWrap.style.cssText = 'position:absolute; left:6px; top:6px; z-index: 12; width: 22px; height: 22px; border-radius: 6px; background: rgba(0,0,0,0.35); display:flex; align-items:center; justify-content:center;';
        const check = document.createElement('input');
        check.type = 'checkbox';
        check.checked = isSelected;
        check.disabled = true;
        check.style.cssText = 'width:16px; height:16px; accent-color:#22c55e; pointer-events:none;';
        checkWrap.appendChild(check);
        item.appendChild(checkWrap);

        if (isPrimary) {
          const badge = document.createElement('div');
          badge.textContent = '대표';
          badge.style.cssText = 'position:absolute; left: 6px; bottom: 6px; z-index: 11; background: rgba(99,102,241,0.92); color: white; font-weight: 900; font-size: 0.7rem; padding: 0.25rem 0.45rem; border-radius: 999px;';
          item.appendChild(badge);
        }

        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'remove-single-grid-image-btn';
        removeBtn.setAttribute('data-heading-index', String(headingIndex));
        removeBtn.setAttribute('data-image-index', String(idx));
        removeBtn.setAttribute('data-heading-title', safeHeadingTitle);
        removeBtn.setAttribute('data-image-key', key);
        removeBtn.style.cssText = 'position: absolute; top: 6px; right: 6px; z-index: 10; background: rgba(239,68,68,0.9); color: white; border: none; border-radius: 50%; width: 26px; height: 26px; cursor: pointer; font-size: 0.8rem; line-height: 1;';
        removeBtn.textContent = '✕';
        item.appendChild(removeBtn);

        item.addEventListener('mouseenter', () => {
          if (isSelected) return;
          item.style.borderColor = 'rgba(34, 197, 94, 0.55)';
          item.style.transform = 'scale(1.02)';
        });
        item.addEventListener('mouseleave', () => {
          if (isSelected) return;
          if (isPrimary) item.style.borderColor = 'var(--primary)';
          else item.style.borderColor = 'transparent';
          item.style.transform = 'scale(1)';
        });

        imagesGrid.appendChild(item);
      });

      if (noImagePlaceholder) {
        noImagePlaceholder.style.display = 'none';
      }

      console.log(`[updatePromptItemsWithImages] 소제목에 이미지 배치 완료(썸네일): ${String(primaryImage?.heading || '').substring(0, 20)}...`);
    }
  }

  ensurePromptCardRemoveButtons();
  ensurePromptCardRemoveHandler();
}

// 발행 완료 시 썸네일 생성기 완전 초기화
function resetThumbnailGeneratorOnPublish(): void {
  try {
    if (thumbnailGenerator) {
      try {
        // 내부 상태 초기화를 위해 새 인스턴스로 교체
        thumbnailGenerator = new ThumbnailGenerator();
      } catch {
        // ignore
      }
    }

    const thumbPreview = document.getElementById('thumbnail-preview') as HTMLElement | null;
    if (thumbPreview) {
      thumbPreview.style.backgroundImage = 'none';
      thumbPreview.innerHTML = '<span style="color: var(--text-muted); font-size: 0.9rem;">썸네일 미리보기가 여기에 표시됩니다.</span>';
    }

    const thumbMainText = document.getElementById('thumb-main-text') as HTMLTextAreaElement | null;
    if (thumbMainText) thumbMainText.value = '';

    const thumbSubText = document.getElementById('thumb-sub-text') as HTMLTextAreaElement | null;
    if (thumbSubText) thumbSubText.value = '';

    const thumbFontSize = document.getElementById('thumb-font-size') as HTMLInputElement | null;
    if (thumbFontSize) thumbFontSize.value = '48';

    const thumbTextColor = document.getElementById('thumb-text-color') as HTMLInputElement | null;
    if (thumbTextColor) thumbTextColor.value = '#ffffff';

    const thumbBgColor = document.getElementById('thumb-bg-color') as HTMLInputElement | null;
    if (thumbBgColor) thumbBgColor.value = '#1a1a2e';

    const thumbOverlay = document.getElementById('thumb-overlay-enabled') as HTMLInputElement | null;
    if (thumbOverlay) thumbOverlay.checked = true;

    thumbnailBackgroundImage = null;
    thumbnailBackgroundDataUrl = null;

    console.log('[Thumbnail] 발행 후 썸네일 생성기 초기화 완료');
  } catch (e) {
    console.error('[Thumbnail] 발행 후 초기화 실패:', e);
  }
}

function showVideoModal(videoUrl: string, title?: string): void {
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.9); z-index: 10002; display: flex;
    align-items: center; justify-content: center; padding: 2rem;
    cursor: pointer;
  `;

  const safeTitle = escapeHtml(String(title || ''));
  modal.innerHTML = `
    <div style="position: relative; max-width: 92vw; width: min(720px, 92vw);">
      <button type="button" class="close-video-modal-btn" style="position: absolute; top: -2rem; right: 0; background: rgba(255,255,255,0.2); border: none; border-radius: 50%; width: 32px; height: 32px; cursor: pointer; font-size: 1.5rem; color: white; display: flex; align-items: center; justify-content: center;">×</button>
      ${safeTitle ? `<div style="color: rgba(255,255,255,0.85); font-weight: 700; margin-bottom: 0.5rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${safeTitle}</div>` : ''}
      <video src="${videoUrl}" controls autoplay loop muted playsinline style="width: 100%; aspect-ratio: 16 / 9; object-fit: cover; max-height: 78vh; border-radius: 10px; background: #000;"></video>
    </div>
  `;

  document.body.appendChild(modal);

  const closeBtn = modal.querySelector('.close-video-modal-btn');
  if (closeBtn) {
    closeBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      modal.remove();
    });
  }

  modal.addEventListener('click', (e) => {
    if (e.target === modal || (e.target as HTMLElement).classList.contains('close-video-modal-btn')) {
      modal.remove();
    }
  });

  const handleKeydown = (e: KeyboardEvent) => {
    if (e.key === 'Escape') {
      modal.remove();
      document.removeEventListener('keydown', handleKeydown);
    }
  };
  document.addEventListener('keydown', handleKeydown);
}

// 세 번째 DOMContentLoaded 리스너 제거 - 모든 초기화를 두 번째 리스너에서 처리

// ============================================
// ✅ [2026-01-20] 프리셋 썸네일 적용 헬퍼 함수
// 발행 모드별로 미리 세팅된 썸네일을 반환
// ============================================

/**
 * 발행 모드에 미리 세팅된 썸네일이 있으면 반환하고 1회성 사용 후 초기화
 * @param mode - 발행 모드 ('full-auto' | 'continuous' | 'ma-semi-auto' | 'ma-full-auto')
 * @returns forHeading: generatedImages[0]용, forThumbnail: thumbnailPath용 (쇼핑커넥트)
 */
function applyPresetThumbnailIfExists(mode: string): {
  forHeading?: any;      // generatedImages[0]에 주입할 이미지 객체
  forThumbnail?: string; // thumbnailPath에 주입할 base64 (쇼핑커넥트용)
  applied: boolean;
} {
  const presetThumbnails = (window as any).presetThumbnails;

  if (!presetThumbnails || !presetThumbnails[mode]) {
    console.log(`[PresetThumbnail] ${mode}: 미리 세팅된 썸네일 없음`);
    return { applied: false };
  }

  const thumbnail = presetThumbnails[mode];
  console.log(`[PresetThumbnail] ${mode}: 미리 세팅된 썸네일 발견!`, thumbnail);

  // 1회성 사용 후 초기화
  presetThumbnails[mode] = null;

  return {
    forHeading: thumbnail,
    forThumbnail: thumbnail.previewDataUrl || thumbnail.filePath,
    applied: true
  };
}

// ============================================
// 🎨 썸네일 생성기 (Thumbnail Generator)
// ============================================


class ThumbnailGenerator {
  private canvas: HTMLCanvasElement | null = null;
  private ctx: CanvasRenderingContext2D | null = null;
  private backgroundImage: HTMLImageElement | null = null;
  private stickers: Array<{ emoji: string; x: number; y: number; size: number }> = [];
  private isDragging = false;
  private dragTarget: 'text' | 'sticker' | 'background' | null = null;
  private dragIndex = -1;
  private textPosition = { x: 380, y: 200 }; // center by default
  private bgPos = { x: 0, y: 0 };
  private bgScale = 1.0;
  private lastMousePos = { x: 0, y: 0 };

  // 설정값들
  private settings = {
    mainText: '제목을 입력하세요',
    subText: '',
    fontFamily: "'Noto Sans KR', sans-serif",
    fontSize: 48,
    textColor: '#ffffff',
    textAlign: 'center' as CanvasTextAlign,
    textPosition: 'center', // top, center, bottom
    textShadow: true,
    textOutline: false,
    textHighlight: false,
    outlineColor: '#000000',
    outlineWidth: 2,
    highlightColor: '#ffff00',
    highlightOpacity: 50,
    bgColor: '#1a1a2e',
    overlayEnabled: false,  // ✅ 기본 비활성화 (배경 어두워지지 않음)
    overlayColor: '#000000',
    overlayOpacity: 0,  // ✅ 기본 투명도 0
    overlayType: 'solid',
    bgBlur: 0,
    bgBrightness: 0,
    aspectRatio: '1.91:1', // '1:1' or '1.91:1'
    bgMode: 'cover', // 'cover' or 'contain'
    bgZoomEnabled: true
  };

  constructor() {
    this.init();
  }

  public setMainText(text: string): void {
    this.settings.mainText = text || '';
    const mainTextInput = document.getElementById('thumb-main-text') as HTMLTextAreaElement;
    if (mainTextInput) {
      mainTextInput.value = this.settings.mainText;
    }
    this.render();
  }

  public setBackgroundFromUrl(url: string): Promise<void> {
    return new Promise((resolve, reject) => {
      if (!url) {
        reject(new Error('empty url'));
        return;
      }

      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.onload = () => {
        this.backgroundImage = img;
        this.render();
        resolve();
      };
      img.onerror = () => reject(new Error('background image load failed'));
      img.src = url;
    });
  }

  private init(): void {
    this.canvas = document.getElementById('thumbnail-canvas') as HTMLCanvasElement;
    if (!this.canvas) return;

    this.ctx = this.canvas.getContext('2d');
    this.setupEventListeners();
    this.render();
  }

  private setupEventListeners(): void {
    // 텍스트 입력
    const mainTextInput = document.getElementById('thumb-main-text') as HTMLTextAreaElement;
    const subTextInput = document.getElementById('thumb-sub-text') as HTMLInputElement;

    mainTextInput?.addEventListener('input', (e) => {
      this.settings.mainText = (e.target as HTMLTextAreaElement).value;
      this.render();
    });

    subTextInput?.addEventListener('input', (e) => {
      this.settings.subText = (e.target as HTMLInputElement).value;
      this.render();
    });

    // 폰트 설정
    const fontFamily = document.getElementById('thumb-font-family') as HTMLSelectElement;
    fontFamily?.addEventListener('change', (e) => {
      this.settings.fontFamily = (e.target as HTMLSelectElement).value;
      this.render();
    });

    // 폰트 크기
    const fontSize = document.getElementById('thumb-font-size') as HTMLInputElement;
    const fontSizeValue = document.getElementById('thumb-font-size-value') as HTMLSpanElement;
    fontSize?.addEventListener('input', (e) => {
      this.settings.fontSize = parseInt((e.target as HTMLInputElement).value);
      if (fontSizeValue) fontSizeValue.textContent = `${this.settings.fontSize}px`;
      this.render();
    });

    // 텍스트 색상
    const textColor = document.getElementById('thumb-text-color') as HTMLInputElement;
    textColor?.addEventListener('input', (e) => {
      this.settings.textColor = (e.target as HTMLInputElement).value;
      this.render();
    });

    // 텍스트 정렬
    const textAlign = document.getElementById('thumb-text-align') as HTMLSelectElement;
    textAlign?.addEventListener('change', (e) => {
      this.settings.textAlign = (e.target as HTMLSelectElement).value as CanvasTextAlign;
      this.render();
    });

    // 텍스트 효과
    const textShadow = document.getElementById('thumb-text-shadow') as HTMLInputElement;
    textShadow?.addEventListener('change', (e) => {
      this.settings.textShadow = (e.target as HTMLInputElement).checked;
      this.render();
    });

    const textOutline = document.getElementById('thumb-text-outline') as HTMLInputElement;
    const outlineSettings = document.getElementById('thumb-outline-settings') as HTMLDivElement;
    textOutline?.addEventListener('change', (e) => {
      this.settings.textOutline = (e.target as HTMLInputElement).checked;
      if (outlineSettings) outlineSettings.style.display = this.settings.textOutline ? 'block' : 'none';
      this.render();
    });

    const textHighlight = document.getElementById('thumb-text-highlight') as HTMLInputElement;
    const highlightSettings = document.getElementById('thumb-highlight-settings') as HTMLDivElement;
    textHighlight?.addEventListener('change', (e) => {
      this.settings.textHighlight = (e.target as HTMLInputElement).checked;
      if (highlightSettings) highlightSettings.style.display = this.settings.textHighlight ? 'block' : 'none';
      this.render();
    });

    // 외곽선 설정
    const outlineColor = document.getElementById('thumb-outline-color') as HTMLInputElement;
    outlineColor?.addEventListener('input', (e) => {
      this.settings.outlineColor = (e.target as HTMLInputElement).value;
      this.render();
    });

    const outlineWidth = document.getElementById('thumb-outline-width') as HTMLInputElement;
    outlineWidth?.addEventListener('input', (e) => {
      this.settings.outlineWidth = parseInt((e.target as HTMLInputElement).value);
      this.render();
    });

    // 형광펜 설정
    const highlightColor = document.getElementById('thumb-highlight-color') as HTMLInputElement;
    highlightColor?.addEventListener('input', (e) => {
      this.settings.highlightColor = (e.target as HTMLInputElement).value;
      this.render();
    });

    const highlightOpacity = document.getElementById('thumb-highlight-opacity') as HTMLInputElement;
    highlightOpacity?.addEventListener('input', (e) => {
      this.settings.highlightOpacity = parseInt((e.target as HTMLInputElement).value);
      this.render();
    });

    // 텍스트 위치 프리셋
    document.querySelectorAll('.thumb-position-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        document.querySelectorAll('.thumb-position-btn').forEach(b => {
          (b as HTMLElement).style.background = 'var(--bg-tertiary)';
          (b as HTMLElement).style.color = 'var(--text-muted)';
          (b as HTMLElement).style.borderColor = 'var(--border-medium)';
          b.classList.remove('selected');
        });
        (e.target as HTMLElement).style.background = 'var(--primary)';
        (e.target as HTMLElement).style.color = 'white';
        (e.target as HTMLElement).style.borderColor = 'var(--primary)';
        (e.target as HTMLElement).classList.add('selected');

        this.settings.textPosition = (e.target as HTMLElement).dataset.position || 'center';
        this.updateTextPosition();
        this.render();
      });
    });

    // 배경 색상
    const bgColor = document.getElementById('thumb-bg-color') as HTMLInputElement;
    bgColor?.addEventListener('input', (e) => {
      this.settings.bgColor = (e.target as HTMLInputElement).value;
      this.render();
    });

    // 배경 이미지 업로드
    const bgUploadBtn = document.getElementById('thumb-bg-upload-btn') as HTMLButtonElement;
    const bgFileInput = document.getElementById('thumb-bg-file-input') as HTMLInputElement;

    if (bgUploadBtn && bgUploadBtn.getAttribute('data-listener-added') !== 'true') {
      bgUploadBtn.setAttribute('data-listener-added', 'true');
      bgUploadBtn.addEventListener('click', () => bgFileInput?.click());
    }

    if (bgFileInput && bgFileInput.getAttribute('data-listener-added') !== 'true') {
      bgFileInput.setAttribute('data-listener-added', 'true');
      bgFileInput.addEventListener('change', (e) => {
        const file = (e.target as HTMLInputElement).files?.[0];
        if (file) this.loadBackgroundImage(file);
        try {
          (e.target as HTMLInputElement).value = '';
        } catch {
          // ignore
        }
      });
    }

    // 저장소에서 배경 선택
    const bgStorageBtn = document.getElementById('thumb-bg-storage-btn') as HTMLButtonElement;
    bgStorageBtn?.addEventListener('click', () => this.openStorageModal());

    // ✅ AI 배경 이미지 생성 (나노 바나나 프로 + NEVER TEXT 고정)
    const bgAiBtn = document.getElementById('thumb-bg-ai-btn') as HTMLButtonElement;
    const bgAiPrompt = document.getElementById('thumb-bg-ai-prompt') as HTMLInputElement;
    bgAiBtn?.addEventListener('click', async () => {
      const userPrompt = bgAiPrompt?.value?.trim() || 'beautiful abstract gradient background';
      // ✅ NEVER TEXT 프롬프트 고정 (텍스트 없는 깔끔한 배경)
      const prompt = `High quality background image: ${userPrompt}. CRITICAL: Do NOT include any text, words, letters, numbers, watermarks, or logos. Clean background only. No typography.`;

      try {
        bgAiBtn.disabled = true;
        bgAiBtn.innerHTML = '<span>🔄</span> 나노 바나나 프로로 생성중...';

        // ✅ 나노 바나나 프로 (Gemini) 사용
        const result = await generateImagesWithCostSafety({
          provider: 'nano-banana-pro',
          items: [{ heading: 'thumbnail-bg', prompt: prompt }],
          styleHint: 'background',
        });

        if (result.success && result.images && result.images.length > 0) {
          const imageData = result.images[0].previewDataUrl || result.images[0].filePath;

          if (imageData) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
              this.backgroundImage = img;
              this.render();
              toastManager.success('✅ 나노 바나나 프로로 배경 생성 완료!');
            };
            img.onerror = () => {
              toastManager.error('❌ 이미지 로드에 실패했습니다.');
            };
            img.src = imageData;
          } else {
            toastManager.error('❌ 이미지 데이터가 없습니다.');
          }
        } else {
          toastManager.error('❌ AI 배경 생성 실패: ' + (result.message || '알 수 없는 오류'));
        }
      } catch (error) {
        console.error('[Thumbnail] AI 배경 생성 실패:', error);
        toastManager.error('❌ AI 배경 생성 실패: ' + (error as Error).message);
      } finally {
        bgAiBtn.disabled = false;
        bgAiBtn.innerHTML = '<span>🍌</span> AI 생성 (나노 바나나)';
      }
    });

    // 오버레이 설정
    const overlayEnable = document.getElementById('thumb-overlay-enable') as HTMLInputElement;
    const overlaySettings = document.getElementById('thumb-overlay-settings') as HTMLDivElement;
    overlayEnable?.addEventListener('change', (e) => {
      this.settings.overlayEnabled = (e.target as HTMLInputElement).checked;
      if (overlaySettings) overlaySettings.style.display = this.settings.overlayEnabled ? 'block' : 'none';
      this.render();
    });

    const overlayColor = document.getElementById('thumb-overlay-color') as HTMLInputElement;
    overlayColor?.addEventListener('input', (e) => {
      this.settings.overlayColor = (e.target as HTMLInputElement).value;
      this.render();
    });

    const overlayOpacity = document.getElementById('thumb-overlay-opacity') as HTMLInputElement;
    const overlayOpacityValue = document.getElementById('thumb-overlay-opacity-value') as HTMLSpanElement;
    overlayOpacity?.addEventListener('input', (e) => {
      this.settings.overlayOpacity = parseInt((e.target as HTMLInputElement).value);
      if (overlayOpacityValue) overlayOpacityValue.textContent = String(this.settings.overlayOpacity);
      this.render();
    });

    const overlayType = document.getElementById('thumb-overlay-type') as HTMLSelectElement;
    overlayType?.addEventListener('change', (e) => {
      this.settings.overlayType = (e.target as HTMLSelectElement).value;
      this.render();
    });

    // 배경 효과
    const bgBlur = document.getElementById('thumb-bg-blur') as HTMLInputElement;
    const blurValue = document.getElementById('thumb-blur-value') as HTMLSpanElement;
    bgBlur?.addEventListener('input', (e) => {
      this.settings.bgBlur = parseInt((e.target as HTMLInputElement).value);
      if (blurValue) blurValue.textContent = String(this.settings.bgBlur);
      this.render();
    });

    const bgBrightness = document.getElementById('thumb-bg-brightness') as HTMLInputElement;
    const brightnessValue = document.getElementById('thumb-brightness-value') as HTMLSpanElement;
    bgBrightness?.addEventListener('input', (e) => {
      this.settings.bgBrightness = parseInt((e.target as HTMLInputElement).value);
      if (brightnessValue) brightnessValue.textContent = String(this.settings.bgBrightness);
      this.render();
    });

    // 종횡비 설정
    const aspectRatio = document.getElementById('thumb-aspect-ratio') as HTMLSelectElement;
    aspectRatio?.addEventListener('change', (e) => {
      this.settings.aspectRatio = (e.target as HTMLSelectElement).value;
      this.updateCanvasSize();
      this.render();
    });

    // 배경 모드 설정
    const bgMode = document.getElementById('thumb-bg-mode') as HTMLSelectElement;
    bgMode?.addEventListener('change', (e: Event) => {
      this.settings.bgMode = (e.target as HTMLSelectElement).value;
      this.render();
    });

    // 배경 줌(확대/축소) 활성화 설정
    const bgZoomEnable = document.getElementById('thumb-bg-zoom-enable') as HTMLInputElement;
    bgZoomEnable?.addEventListener('change', (e: Event) => {
      this.settings.bgZoomEnabled = (e.target as HTMLInputElement).checked;
    });

    // 스티커 버튼들
    document.querySelectorAll('.thumb-sticker-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const emoji = (e.target as HTMLElement).dataset.sticker || '⭐';
        this.addSticker(emoji);
      });
    });

    // 프리셋 버튼들
    document.querySelectorAll('.thumb-preset-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const preset = (e.target as HTMLElement).dataset.preset || 'modern';
        this.applyPreset(preset);
      });
    });

    // 액션 버튼들
    const resetBtn = document.getElementById('thumb-reset-btn') as HTMLButtonElement;
    resetBtn?.addEventListener('click', () => this.reset());

    const downloadBtn = document.getElementById('thumb-download-btn') as HTMLButtonElement;
    downloadBtn?.addEventListener('click', () => this.download());

    const applyBtn = document.getElementById('thumb-apply-btn') as HTMLButtonElement;
    applyBtn?.addEventListener('click', () => this.applyToPost());

    // 캔버스 드래그 이벤트
    this.canvas?.addEventListener('mousedown', (e) => this.onMouseDown(e));
    this.canvas?.addEventListener('mousemove', (e) => this.onMouseMove(e));
    this.canvas?.addEventListener('mouseup', () => this.onMouseUp());
    this.canvas?.addEventListener('mouseleave', () => this.onMouseUp());
    this.canvas?.addEventListener('wheel', (e) => this.onWheel(e), { passive: false });
  }

  private updateCanvasSize(): void {
    if (!this.canvas) return;

    const sizeTextEl = document.getElementById('thumb-canvas-size-text');

    if (this.settings.aspectRatio === '1:1') {
      this.canvas.width = 760;
      this.canvas.height = 760;
      this.canvas.style.width = '400px';  // ✅ 정사각형은 더 작게 표시
      this.canvas.style.height = '400px';
      if (sizeTextEl) sizeTextEl.textContent = '760×760';
      console.log('[ThumbnailGen] 캔버스 크기 변경: 1:1 (760x760)');
    } else {
      this.canvas.width = 760;
      this.canvas.height = 400;
      this.canvas.style.width = '100%';  // ✅ 와이드는 100% 표시
      this.canvas.style.height = 'auto';
      this.canvas.style.maxWidth = '760px';
      if (sizeTextEl) sizeTextEl.textContent = '760×400';
      console.log('[ThumbnailGen] 캔버스 크기 변경: 1.91:1 (760x400)');
    }

    // 위치 초기화 (옵션)
    this.updateTextPosition();
  }

  private updateTextPosition(): void {
    const canvas = this.canvas!;
    switch (this.settings.textPosition) {
      case 'top':
        this.textPosition.y = 80;
        break;
      case 'center':
        this.textPosition.y = canvas.height / 2;
        break;
      case 'bottom':
        this.textPosition.y = canvas.height - 80;
        break;
    }
  }

  private loadBackgroundImage(file: File): void {
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        this.backgroundImage = img;
        this.render();
      };
      img.src = e.target?.result as string;
    };
    reader.readAsDataURL(file);
  }

  private openStorageModal(): void {
    // ✅ 이미지 저장소 모달 - 영어 프롬프트 이미지, 생성된 이미지, 저장된 이미지 연동
    const generatedImages = (window as any).imageManagementGeneratedImages || [];
    const savedImages = ImageManager.getAllImages();

    // 이미지 목록 합치기
    const allImages: Array<{ src: string; label: string; source: string }> = [];

    // 1. 생성된 이미지 (영어 프롬프트 포함)
    generatedImages.forEach((img: any, idx: number) => {
      const src = img.previewDataUrl || img.filePath || img.url;
      if (src) {
        allImages.push({
          src,
          label: img.prompt || img.heading || `이미지 ${idx + 1}`,
          source: '생성됨'
        });
      }
    });

    // 2. 저장된 이미지 (ImageManager)
    Object.values(savedImages).forEach((img: any) => {
      const src = img.previewDataUrl || img.filePath || img.url;
      if (src && !allImages.find(i => i.src === src)) {
        allImages.push({
          src,
          label: img.heading || '저장된 이미지',
          source: '저장됨'
        });
      }
    });

    if (allImages.length === 0) {
      toastManager.warning('선택할 이미지가 없습니다. 먼저 이미지를 생성하거나 저장해주세요.');
      return;
    }

    // 모달 생성
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.style.cssText = 'display:flex;align-items:center;justify-content:center;position:fixed;inset:0;background:rgba(0,0,0,0.8);z-index:9999;';

    modal.innerHTML = `
      <div style="background:var(--bg-secondary);border-radius:16px;max-width:800px;width:90%;max-height:80vh;overflow:hidden;display:flex;flex-direction:column;">
        <div style="padding:20px;border-bottom:1px solid var(--border-light);display:flex;justify-content:space-between;align-items:center;">
          <h3 style="margin:0;color:var(--text-strong);font-size:18px;">🖼️ 배경 이미지 선택</h3>
          <button id="thumb-storage-close" style="background:none;border:none;color:var(--text-muted);font-size:24px;cursor:pointer;">&times;</button>
        </div>
        <div style="padding:20px;overflow-y:auto;flex:1;">
          <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:16px;">
            ${allImages.map((img, idx) => `
              <div class="thumb-storage-item" data-idx="${idx}" style="cursor:pointer;border-radius:12px;overflow:hidden;border:2px solid transparent;transition:all 0.2s;">
                <div style="position:relative;padding-bottom:75%;background:#1a1a2e;">
                  <img src="${img.src}" style="position:absolute;inset:0;width:100%;height:100%;object-fit:cover;" onerror="this.style.display='none'" />
                </div>
                <div style="padding:8px;background:var(--bg-tertiary);">
                  <div style="font-size:12px;color:var(--text-strong);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${img.label}</div>
                  <div style="font-size:10px;color:var(--text-muted);">${img.source}</div>
                </div>
              </div>
            `).join('')}
          </div>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    // 이벤트 리스너
    modal.querySelector('#thumb-storage-close')?.addEventListener('click', () => modal.remove());
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.remove();
    });

    // 이미지 선택
    modal.querySelectorAll('.thumb-storage-item').forEach(item => {
      item.addEventListener('mouseenter', () => {
        (item as HTMLElement).style.borderColor = 'var(--primary)';
        (item as HTMLElement).style.transform = 'scale(1.02)';
      });
      item.addEventListener('mouseleave', () => {
        (item as HTMLElement).style.borderColor = 'transparent';
        (item as HTMLElement).style.transform = 'scale(1)';
      });
      item.addEventListener('click', () => {
        const idx = parseInt((item as HTMLElement).dataset.idx || '0');
        const selectedImg = allImages[idx];
        if (selectedImg) {
          this.loadBackgroundFromUrl(selectedImg.src);
          modal.remove();
          toastManager.success(`배경 이미지가 적용되었습니다: ${selectedImg.label}`);
        }
      });
    });
  }

  // URL에서 배경 이미지 로드
  private loadBackgroundFromUrl(src: string): void {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      this.backgroundImage = img;
      this.render();
    };
    img.onerror = () => {
      toastManager.error('이미지를 불러올 수 없습니다.');
    };
    img.src = src;
  }

  // 외부에서 배경 이미지 설정 가능하도록 public 메서드 추가
  public setBackgroundImage(src: string): void {
    this.loadBackgroundFromUrl(src);
  }

  private addSticker(emoji: string): void {
    this.stickers.push({
      emoji,
      x: 380 + Math.random() * 100 - 50,
      y: 200 + Math.random() * 100 - 50,
      size: 48
    });
    this.render();
  }

  private applyPreset(preset: string): void {
    switch (preset) {
      case 'modern':
        this.settings.bgColor = '#1a1a2e';
        this.settings.textColor = '#ffffff';
        this.settings.overlayEnabled = true;
        this.settings.overlayColor = '#667eea';
        this.settings.overlayOpacity = 30;
        this.settings.overlayType = 'gradient-v';
        break;
      case 'minimal':
        this.settings.bgColor = '#f5f5f5';
        this.settings.textColor = '#333333';
        this.settings.overlayEnabled = false;
        this.settings.textShadow = false;
        break;
      case 'vibrant':
        this.settings.bgColor = '#ff416c';
        this.settings.textColor = '#ffffff';
        this.settings.overlayEnabled = true;
        this.settings.overlayColor = '#ff4b2b';
        this.settings.overlayOpacity = 50;
        this.settings.overlayType = 'gradient-h';
        break;
      case 'nature':
        this.settings.bgColor = '#11998e';
        this.settings.textColor = '#ffffff';
        this.settings.overlayEnabled = true;
        this.settings.overlayColor = '#38ef7d';
        this.settings.overlayOpacity = 40;
        this.settings.overlayType = 'gradient-v';
        break;
      case 'dark':
        this.settings.bgColor = '#232526';
        this.settings.textColor = '#ffffff';
        this.settings.overlayEnabled = true;
        this.settings.overlayColor = '#414345';
        this.settings.overlayOpacity = 60;
        this.settings.overlayType = 'gradient-v';
        break;
    }
    this.render();
    this.updateUI();
  }

  private updateUI(): void {
    // UI 요소들을 현재 설정값으로 업데이트
    (document.getElementById('thumb-bg-color') as HTMLInputElement).value = this.settings.bgColor;
    (document.getElementById('thumb-text-color') as HTMLInputElement).value = this.settings.textColor;
    (document.getElementById('thumb-overlay-enable') as HTMLInputElement).checked = this.settings.overlayEnabled;
    (document.getElementById('thumb-overlay-color') as HTMLInputElement).value = this.settings.overlayColor;
    (document.getElementById('thumb-overlay-opacity') as HTMLInputElement).value = String(this.settings.overlayOpacity);
    (document.getElementById('thumb-overlay-opacity-value') as HTMLSpanElement).textContent = String(this.settings.overlayOpacity);
    (document.getElementById('thumb-overlay-type') as HTMLSelectElement).value = this.settings.overlayType;
    (document.getElementById('thumb-text-shadow') as HTMLInputElement).checked = this.settings.textShadow;

    // 배경 줌 활성화 상태 업데이트
    const bgZoomEnable = document.getElementById('thumb-bg-zoom-enable') as HTMLInputElement;
    if (bgZoomEnable) bgZoomEnable.checked = this.settings.bgZoomEnabled;
  }

  private reset(): void {
    this.settings = {
      mainText: '제목을 입력하세요',
      subText: '',
      fontFamily: "'Noto Sans KR', sans-serif",
      fontSize: 48,
      textColor: '#ffffff',
      textAlign: 'center',
      textPosition: 'center',
      textShadow: true,
      textOutline: false,
      textHighlight: false,
      outlineColor: '#000000',
      outlineWidth: 2,
      highlightColor: '#ffff00',
      highlightOpacity: 50,
      bgColor: '#1a1a2e',
      overlayEnabled: true,
      overlayColor: '#000000',
      overlayOpacity: 40,
      overlayType: 'solid',
      bgBlur: 0,
      bgBrightness: 0,
      aspectRatio: '1.91:1',
      bgMode: 'cover',
      bgZoomEnabled: true
    };
    this.backgroundImage = null;
    this.stickers = [];
    this.textPosition = { x: 380, y: 200 };

    // UI 초기화
    (document.getElementById('thumb-main-text') as HTMLInputElement).value = this.settings.mainText;
    (document.getElementById('thumb-sub-text') as HTMLInputElement).value = '';
    this.updateUI();
    this.render();
    toastManager.success('썸네일이 초기화되었습니다.');
  }

  private download(): void {
    if (!this.canvas) return;

    const link = document.createElement('a');
    link.download = `thumbnail_${Date.now()}.png`;
    link.href = this.canvas.toDataURL('image/png');
    link.click();
    toastManager.success('썸네일이 다운로드되었습니다.');
  }

  private applyToPost(): void {
    if (!this.canvas) return;

    const base64 = this.canvas.toDataURL('image/png');

    // ✅ [2026-01-20] 적용 대상 드롭다운 확인
    const applyTarget = (document.getElementById('thumb-apply-target') as HTMLSelectElement)?.value || 'image-tab';
    console.log('[ThumbnailGen] 적용 대상:', applyTarget);

    const thumbnailImage = {
      heading: '썸네일',
      filePath: base64,
      previewDataUrl: base64,
      provider: 'thumbnail-generator',
      url: base64,
      headingIndex: 0
    };

    // ✅ 발행 모드별 썸네일 저장 (전역 상태)
    if (!(window as any).presetThumbnails) {
      (window as any).presetThumbnails = {
        'image-tab': null,
        'full-auto': null,
        'continuous': null,
        'ma-semi-auto': null,
        'ma-full-auto': null
      };
    }

    const modeLabels: Record<string, string> = {
      'image-tab': '🖼️ 이미지관리탭 (반자동)',
      'full-auto': '🤖 풀오토발행',
      'continuous': '🔄 연속발행',
      'ma-semi-auto': '👥 반자동 다중계정발행',
      'ma-full-auto': '🚀 풀오토 다중계정발행'
    };

    // 선택된 발행 모드에 썸네일 저장
    (window as any).presetThumbnails[applyTarget] = thumbnailImage;

    // ✅ image-tab인 경우 기존 로직 (1번 소제목에 즉시 적용)
    if (applyTarget === 'image-tab') {
      // 소제목 목록 가져오기 (ImageManager 우선)
      const headings = ImageManager.headings.length > 0
        ? ImageManager.headings
        : ((window as any).imageManagementHeadings || []);

      // 1번 소제목에 썸네일 적용 (무조건 1번에 배치)
      const firstHeadingTitle = resolveFirstHeadingTitleForThumbnail();
      thumbnailImage.heading = firstHeadingTitle;

      // ImageManager에 1번 소제목 이미지로 등록
      ImageManager.setImage(firstHeadingTitle, thumbnailImage);

      // generatedImages 배열 업데이트 (1번 위치에 강제 배치)
      let existingImages: any[] = [];
      if ((window as any).imageManagementGeneratedImages && (window as any).imageManagementGeneratedImages.length > 0) {
        existingImages = [...(window as any).imageManagementGeneratedImages];
      } else if ((window as any).generatedImages && (window as any).generatedImages.length > 0) {
        existingImages = [...(window as any).generatedImages];
      } else if (generatedImages && generatedImages.length > 0) {
        existingImages = [...generatedImages];
      }

      if (existingImages.length > 0) {
        existingImages[0] = thumbnailImage;
      } else {
        for (let i = 0; i < headings.length; i++) {
          if (i === 0) {
            existingImages.push(thumbnailImage);
          } else {
            existingImages.push(null);
          }
        }
      }

      // 전역 변수 업데이트
      generatedImages = existingImages;
      (window as any).imageManagementGeneratedImages = existingImages;

      // 대표사진(썸네일) 경로 설정
      (window as any).thumbnailPath = base64;
      (window as any).selectedThumbnailImage = thumbnailImage;

      // 모든 미리보기 동기화
      displayGeneratedImages(existingImages);
      ImageManager.syncAllPreviews();
      updatePromptItemsWithImages(existingImages);

      appendLog(`✅ 썸네일이 1번 소제목 "${firstHeadingTitle}"에 적용되었습니다!`);
      appendLog(`📷 대표사진으로 자동 등록됩니다.`);
      toastManager.success(`✅ 이미지관리탭 1번 소제목에 적용 + 대표사진 등록 완료!`);
    } else {
      // ✅ 다른 발행 모드 (풀오토/연속/다중계정) - 사전 세팅만 저장
      appendLog(`✅ ${modeLabels[applyTarget]}에 썸네일이 미리 세팅되었습니다.`);
      toastManager.success(`✅ ${modeLabels[applyTarget]}에 썸네일 미리 세팅 완료!`);
      toastManager.info(`💡 해당 발행 시작 시 자동으로 1번 소제목에 적용됩니다.`);

      // ✅ [2026-01-22 NEW] 풀오토/다중계정풀오토의 경우 setManualThumbnailForFullAuto 호출
      // 이렇게 하면 풀오토 발행 시 첫 번째 이미지(썸네일) 자동 생성을 건너뛰게 됨
      if (applyTarget === 'full-auto' || applyTarget === 'ma-full-auto') {
        const manualThumbnailWithFlag = {
          ...thumbnailImage,
          isManualThumbnail: true,
          source: 'thumbnail-generator',
          isThumbnail: true
        };

        // 전역 함수 호출하여 수동 썸네일 등록
        if (typeof (window as any).setManualThumbnailForFullAuto === 'function') {
          (window as any).setManualThumbnailForFullAuto(manualThumbnailWithFlag);
          appendLog(`🎨 수동 썸네일이 풀오토 발행용으로 등록되었습니다. (자동 생성 건너뛰기)`);
        } else {
          // 폴백: 직접 imageManagementGeneratedImages에 추가
          const existingImages = (window as any).imageManagementGeneratedImages || [];
          if (existingImages.length > 0 && (existingImages[0]?.isManualThumbnail || existingImages[0]?.source === 'thumbnail-generator')) {
            existingImages[0] = manualThumbnailWithFlag;
          } else {
            existingImages.unshift(manualThumbnailWithFlag);
          }
          (window as any).imageManagementGeneratedImages = existingImages;
          console.log('[ThumbnailGen] 수동 썸네일 등록 (폴백 로직)');
        }
      }
    }
  }

  // 마우스 이벤트 핸들러
  private onMouseDown(e: MouseEvent): void {
    const rect = this.canvas!.getBoundingClientRect();
    const scaleX = this.canvas!.width / rect.width;
    const scaleY = this.canvas!.height / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;

    this.lastMousePos = { x, y };

    // 스티커 클릭 체크
    for (let i = this.stickers.length - 1; i >= 0; i--) {
      const sticker = this.stickers[i];
      if (Math.abs(x - sticker.x) < sticker.size / 2 && Math.abs(y - sticker.y) < sticker.size / 2) {
        this.isDragging = true;
        this.dragTarget = 'sticker';
        this.dragIndex = i;
        return;
      }
    }

    // 텍스트 영역 클릭 체크
    if (Math.abs(x - this.textPosition.x) < 200 && Math.abs(y - this.textPosition.y) < 50) {
      this.isDragging = true;
      this.dragTarget = 'text';
      return;
    }

    // 아무것도 클릭하지 않았으면 배경 드래그
    if (this.backgroundImage) {
      this.isDragging = true;
      this.dragTarget = 'background';
    }
  }

  private onMouseMove(e: MouseEvent): void {
    if (!this.isDragging || !this.canvas) return;

    const rect = this.canvas.getBoundingClientRect();
    const scaleX = this.canvas.width / rect.width;
    const scaleY = this.canvas.height / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;

    const dx = x - this.lastMousePos.x;
    const dy = y - this.lastMousePos.y;

    if (this.dragTarget === 'text') {
      this.textPosition.x = x;
      this.textPosition.y = y;
    } else if (this.dragTarget === 'sticker' && this.dragIndex >= 0) {
      this.stickers[this.dragIndex].x = x;
      this.stickers[this.dragIndex].y = y;
    } else if (this.dragTarget === 'background') {
      this.bgPos.x += dx;
      this.bgPos.y += dy;
    }

    this.lastMousePos = { x, y };
    this.render();
  }

  private onMouseUp(): void {
    this.isDragging = false;
    this.dragTarget = null;
    this.dragIndex = -1;
  }

  private onWheel(e: WheelEvent): void {
    if (!this.backgroundImage || !this.canvas || !this.settings.bgZoomEnabled) return;
    e.preventDefault();

    const zoomSpeed = 0.001;
    const delta = -e.deltaY;
    const prevScale = this.bgScale;
    this.bgScale = Math.max(0.1, Math.min(10, this.bgScale + delta * zoomSpeed));

    // 마우스 위치 기준으로 줌인/아웃 (점진적 위치 보정)
    const rect = this.canvas.getBoundingClientRect();
    const scaleX = this.canvas.width / rect.width;
    const scaleY = this.canvas.height / rect.height;
    const mouseX = (e.clientX - rect.left) * scaleX;
    const mouseY = (e.clientY - rect.top) * scaleY;

    // 줌 중심점 보정 로직 (선택 사항)
    // this.bgPos.x -= (mouseX - this.bgPos.x) * (this.bgScale / prevScale - 1);
    // this.bgPos.y -= (mouseY - this.bgPos.y) * (this.bgScale / prevScale - 1);

    this.render();
  }

  render(): void {
    if (!this.ctx || !this.canvas) return;

    const ctx = this.ctx;
    const canvas = this.canvas;

    // 1. 배경 그리기
    if (this.backgroundImage) {
      // 이미지 배경
      ctx.save();

      // 밝기 필터
      if (this.settings.bgBrightness !== 0) {
        ctx.filter = `brightness(${100 + this.settings.bgBrightness}%)`;
      }

      const imgWidth = this.backgroundImage.width;
      const imgHeight = this.backgroundImage.height;
      const imgRatio = imgWidth / imgHeight;
      const canvasRatio = canvas.width / canvas.height;

      let drawWidth, drawHeight;

      if (this.settings.bgMode === 'cover') {
        if (imgRatio > canvasRatio) {
          drawHeight = canvas.height;
          drawWidth = drawHeight * imgRatio;
        } else {
          drawWidth = canvas.width;
          drawHeight = drawWidth / imgRatio;
        }
      } else { // 'contain'
        if (imgRatio > canvasRatio) {
          drawWidth = canvas.width;
          drawHeight = drawWidth / imgRatio;
        } else {
          drawHeight = canvas.height;
          drawWidth = drawHeight * imgRatio;
        }
      }

      // 기본 중앙 정렬 위치에 사용자 오프셋(bgPos)과 스케일(bgScale) 적용
      const centerX = (canvas.width - drawWidth * this.bgScale) / 2;
      const centerY = (canvas.height - drawHeight * this.bgScale) / 2;

      ctx.drawImage(
        this.backgroundImage,
        centerX + this.bgPos.x,
        centerY + this.bgPos.y,
        drawWidth * this.bgScale,
        drawHeight * this.bgScale
      );

      ctx.restore();
    } else {
      // 단색 배경
      ctx.fillStyle = this.settings.bgColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    // 2. 오버레이 그리기
    if (this.settings.overlayEnabled) {
      ctx.save();
      ctx.globalAlpha = this.settings.overlayOpacity / 100;

      if (this.settings.overlayType === 'solid') {
        ctx.fillStyle = this.settings.overlayColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      } else if (this.settings.overlayType === 'gradient-v') {
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, 'transparent');
        gradient.addColorStop(1, this.settings.overlayColor);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      } else if (this.settings.overlayType === 'gradient-h') {
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
        gradient.addColorStop(0, this.settings.overlayColor);
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      ctx.restore();
    }

    // 3. 텍스트 그리기
    ctx.save();
    ctx.textAlign = this.settings.textAlign;
    ctx.textBaseline = 'middle';

    // 메인 텍스트 (줄바꿈 지원)
    ctx.font = `bold ${this.settings.fontSize}px ${this.settings.fontFamily}`;

    let textX = this.textPosition.x;
    if (this.settings.textAlign === 'left') textX = 40;
    else if (this.settings.textAlign === 'right') textX = canvas.width - 40;

    // ✅ 줄바꿈 처리
    const lines = this.settings.mainText.split('\n');
    const lineHeight = this.settings.fontSize * 1.3; // 줄 간격
    const totalHeight = lines.length * lineHeight;
    const startY = this.textPosition.y - (totalHeight / 2) + (lineHeight / 2);

    // 형광펜 효과 (각 줄별로)
    if (this.settings.textHighlight && this.settings.mainText) {
      ctx.save();
      ctx.globalAlpha = this.settings.highlightOpacity / 100;
      ctx.fillStyle = this.settings.highlightColor;
      const padding = 10;

      lines.forEach((line, i) => {
        if (line.trim()) {
          const metrics = ctx.measureText(line);
          const lineY = startY + (i * lineHeight);
          let hlX = textX - metrics.width / 2 - padding;
          if (this.settings.textAlign === 'left') hlX = textX - padding;
          else if (this.settings.textAlign === 'right') hlX = textX - metrics.width - padding;
          ctx.fillRect(hlX, lineY - this.settings.fontSize / 2 - padding / 2, metrics.width + padding * 2, this.settings.fontSize + padding);
        }
      });
      ctx.restore();
    }

    // 그림자 효과
    if (this.settings.textShadow) {
      ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
      ctx.shadowBlur = 10;
      ctx.shadowOffsetX = 3;
      ctx.shadowOffsetY = 3;
    }

    // 외곽선 (각 줄별로)
    if (this.settings.textOutline) {
      ctx.strokeStyle = this.settings.outlineColor;
      ctx.lineWidth = this.settings.outlineWidth * 2;
      lines.forEach((line, i) => {
        ctx.strokeText(line, textX, startY + (i * lineHeight));
      });
    }

    // 메인 텍스트 (각 줄별로)
    ctx.fillStyle = this.settings.textColor;
    lines.forEach((line, i) => {
      ctx.fillText(line, textX, startY + (i * lineHeight));
    });

    // 서브 텍스트
    if (this.settings.subText) {
      ctx.shadowBlur = 5;
      ctx.font = `${Math.round(this.settings.fontSize * 0.5)}px ${this.settings.fontFamily}`;
      const subY = startY + (lines.length * lineHeight) + this.settings.fontSize * 0.3;
      ctx.fillText(this.settings.subText, textX, subY);
    }

    ctx.restore();

    // 4. 스티커 그리기
    this.stickers.forEach(sticker => {
      ctx.font = `${sticker.size}px serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(sticker.emoji, sticker.x, sticker.y);
    });
  }
}

// ============================================
// 🔄 이미지 변환기 (Image Converter)
// ============================================

class ImageConverter {
  private canvas: HTMLCanvasElement | null = null;
  private ctx: CanvasRenderingContext2D | null = null;
  private originalImage: HTMLImageElement | null = null;
  private originalCanvas: HTMLCanvasElement | null = null;
  private originalCtx: CanvasRenderingContext2D | null = null;
  private currentFormat = 'png';
  private currentQuality = 90;

  // 필터 설정
  private filters = {
    brightness: 0,
    contrast: 0,
    saturation: 0,
    sharpen: 0
  };

  constructor() {
    this.init();
  }

  private init(): void {
    this.canvas = document.getElementById('converter-canvas') as HTMLCanvasElement;
    if (!this.canvas) return;

    this.ctx = this.canvas.getContext('2d');
    this.originalCanvas = document.createElement('canvas');
    this.originalCtx = this.originalCanvas.getContext('2d');
    this.setupEventListeners();
  }

  private setupEventListeners(): void {
    // 파일 업로드
    const fileBtn = document.getElementById('converter-file-btn') as HTMLButtonElement;
    const fileInput = document.getElementById('converter-file-input') as HTMLInputElement;

    fileBtn?.addEventListener('click', () => fileInput?.click());
    fileInput?.addEventListener('change', (e) => {
      const file = (e.target as HTMLInputElement).files?.[0];
      if (file) this.loadImage(file);
    });

    // 드래그 앤 드롭
    const uploadZone = document.getElementById('converter-upload-zone') as HTMLDivElement;
    uploadZone?.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadZone.style.borderColor = 'var(--primary)';
      uploadZone.style.background = 'rgba(6, 182, 212, 0.1)';
    });
    uploadZone?.addEventListener('dragleave', () => {
      uploadZone.style.borderColor = 'var(--border-medium)';
      uploadZone.style.background = 'var(--bg-secondary)';
    });
    uploadZone?.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadZone.style.borderColor = 'var(--border-medium)';
      uploadZone.style.background = 'var(--bg-secondary)';
      const file = e.dataTransfer?.files[0];
      if (file && file.type.startsWith('image/')) {
        this.loadImage(file);
      }
    });

    // 저장소에서 선택
    const storageBtn = document.getElementById('converter-storage-btn') as HTMLButtonElement;
    storageBtn?.addEventListener('click', () => this.openStorageModal());

    // 탭 전환
    document.querySelectorAll('.converter-tab-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const tab = (e.target as HTMLElement).dataset.tab;
        this.switchTab(tab || 'format');
      });
    });

    // 포맷 버튼
    document.querySelectorAll('.format-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        document.querySelectorAll('.format-btn').forEach(b => {
          (b as HTMLElement).style.background = 'var(--bg-tertiary)';
          (b as HTMLElement).style.color = 'var(--text-strong)';
          (b as HTMLElement).style.border = '1px solid var(--border-medium)';
          b.classList.remove('selected');
        });
        (e.target as HTMLElement).style.background = 'var(--primary)';
        (e.target as HTMLElement).style.color = 'white';
        (e.target as HTMLElement).style.border = 'none';
        (e.target as HTMLElement).classList.add('selected');

        this.currentFormat = (e.target as HTMLElement).dataset.format || 'png';

        // 품질 슬라이더 표시/숨김
        const qualityContainer = document.getElementById('converter-quality-container') as HTMLDivElement;
        if (qualityContainer) {
          qualityContainer.style.display = this.currentFormat !== 'png' ? 'block' : 'none';
        }

        this.updateResultInfo();
      });
    });

    // 품질 슬라이더
    const qualitySlider = document.getElementById('converter-quality') as HTMLInputElement;
    const qualityValue = document.getElementById('converter-quality-value') as HTMLSpanElement;
    qualitySlider?.addEventListener('input', (e) => {
      this.currentQuality = parseInt((e.target as HTMLInputElement).value);
      if (qualityValue) qualityValue.textContent = String(this.currentQuality);
      this.updateResultInfo();
    });

    // 크기 조절 프리셋
    document.querySelectorAll('.resize-preset-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const width = parseInt((e.target as HTMLElement).dataset.width || '0');
        const height = parseInt((e.target as HTMLElement).dataset.height || '0');
        (document.getElementById('converter-width') as HTMLInputElement).value = String(width);
        (document.getElementById('converter-height') as HTMLInputElement).value = String(height);
      });
    });

    // 비율 유지
    const keepRatio = document.getElementById('converter-keep-ratio') as HTMLInputElement;
    const widthInput = document.getElementById('converter-width') as HTMLInputElement;
    const heightInput = document.getElementById('converter-height') as HTMLInputElement;

    widthInput?.addEventListener('input', () => {
      if (keepRatio?.checked && this.originalImage) {
        const ratio = this.originalImage.height / this.originalImage.width;
        heightInput.value = String(Math.round(parseInt(widthInput.value) * ratio));
      }
    });

    heightInput?.addEventListener('input', () => {
      if (keepRatio?.checked && this.originalImage) {
        const ratio = this.originalImage.width / this.originalImage.height;
        widthInput.value = String(Math.round(parseInt(heightInput.value) * ratio));
      }
    });

    // 크기 적용
    const applyResize = document.getElementById('converter-apply-resize') as HTMLButtonElement;
    applyResize?.addEventListener('click', () => this.applyResize());

    // 필터 슬라이더
    ['brightness', 'contrast', 'saturation', 'sharpen'].forEach(filter => {
      const slider = document.getElementById(`filter-${filter}`) as HTMLInputElement;
      const valueSpan = document.getElementById(`filter-${filter}-value`) as HTMLSpanElement;

      slider?.addEventListener('input', (e) => {
        (this.filters as any)[filter] = parseInt((e.target as HTMLInputElement).value);
        if (valueSpan) valueSpan.textContent = String((this.filters as any)[filter]);
        this.applyFilters();
      });
    });

    // 필터 프리셋
    document.querySelectorAll('.filter-preset-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        document.querySelectorAll('.filter-preset-btn').forEach(b => {
          (b as HTMLElement).style.background = 'var(--bg-tertiary)';
          (b as HTMLElement).style.color = 'var(--text-strong)';
          b.classList.remove('selected');
        });
        (e.target as HTMLElement).style.background = 'var(--primary)';
        (e.target as HTMLElement).style.color = 'white';
        (e.target as HTMLElement).classList.add('selected');

        this.applyFilterPreset((e.target as HTMLElement).dataset.filter || 'none');
      });
    });

    // 필터 초기화
    const filterReset = document.getElementById('filter-reset-btn') as HTMLButtonElement;
    filterReset?.addEventListener('click', () => this.resetFilters());

    // 자르기 적용
    const applyCrop = document.getElementById('converter-apply-crop') as HTMLButtonElement;
    applyCrop?.addEventListener('click', () => this.applyCrop());

    // ✅ 비율 변환 프리셋 버튼 (자르기 탭 내)
    document.querySelectorAll('.crop-ratio-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const ratioStr = (e.target as HTMLElement).dataset.ratio;
        if (ratioStr && this.originalImage) {
          this.applyRatioCrop(ratioStr);
        }
      });
    });

    // ✅ 비율 변환 탭 버튼 (별도 탭)
    document.querySelectorAll('.ratio-convert-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const target = e.currentTarget as HTMLElement;
        const ratioStr = target.dataset.ratio;
        if (ratioStr && this.canvas && this.canvas.width > 0) {
          this.applyRatioCrop(ratioStr);
        } else {
          toastManager.error('먼저 이미지를 로드해주세요.');
        }
      });
    });

    // AI 기능
    const removeBgBtn = document.getElementById('ai-remove-bg-btn') as HTMLButtonElement;
    removeBgBtn?.addEventListener('click', () => this.removeBackground());

    const upscaleBtn = document.getElementById('ai-upscale-btn') as HTMLButtonElement;
    upscaleBtn?.addEventListener('click', () => this.upscale());

    // 출력 버튼들
    const newBtn = document.getElementById('converter-new-btn') as HTMLButtonElement;
    newBtn?.addEventListener('click', () => this.reset());

    const insertBtn = document.getElementById('converter-insert-btn') as HTMLButtonElement;
    insertBtn?.addEventListener('click', () => this.insertToPost());

    const saveStorageBtn = document.getElementById('converter-save-storage-btn') as HTMLButtonElement;
    saveStorageBtn?.addEventListener('click', () => this.saveToStorage());

    const downloadBtn = document.getElementById('converter-download-btn') as HTMLButtonElement;
    downloadBtn?.addEventListener('click', () => this.download());
  }

  private loadImage(file: File): void {
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        this.originalImage = img;

        // 원본 캔버스에 저장
        this.originalCanvas!.width = img.width;
        this.originalCanvas!.height = img.height;
        this.originalCanvas!.getContext('2d')?.drawImage(img, 0, 0);

        // 편집 캔버스 설정
        this.canvas!.width = img.width;
        this.canvas!.height = img.height;
        this.ctx?.drawImage(img, 0, 0);

        // UI 업데이트
        this.showEditor();
        this.updateOriginalInfo();
        this.updateResultInfo();

        // 크기 입력 초기화
        (document.getElementById('converter-width') as HTMLInputElement).value = String(img.width);
        (document.getElementById('converter-height') as HTMLInputElement).value = String(img.height);
        (document.getElementById('crop-width') as HTMLInputElement).value = String(img.width);
        (document.getElementById('crop-height') as HTMLInputElement).value = String(img.height);
      };
      img.src = e.target?.result as string;

      // 원본 미리보기
      const originalImg = document.getElementById('converter-original-img') as HTMLImageElement;
      if (originalImg) originalImg.src = e.target?.result as string;
    };
    reader.readAsDataURL(file);
  }

  private showEditor(): void {
    const placeholder = document.getElementById('converter-upload-placeholder') as HTMLDivElement;
    const editor = document.getElementById('converter-editor') as HTMLDivElement;
    const uploadZone = document.getElementById('converter-upload-zone') as HTMLDivElement;

    if (placeholder) placeholder.style.display = 'none';
    if (editor) editor.style.display = 'block';
    if (uploadZone) {
      uploadZone.style.border = 'none';
      uploadZone.style.padding = '0';
      uploadZone.style.background = 'transparent';
    }
  }

  private updateOriginalInfo(): void {
    const info = document.getElementById('converter-original-info') as HTMLParagraphElement;
    if (info && this.originalImage) {
      info.textContent = `${this.originalImage.width} × ${this.originalImage.height}px`;
    }
  }

  private updateResultInfo(): void {
    const info = document.getElementById('converter-result-info') as HTMLParagraphElement;
    if (info && this.canvas) {
      const format = this.currentFormat.toUpperCase();
      const quality = this.currentFormat !== 'png' ? ` (품질: ${this.currentQuality}%)` : '';
      info.textContent = `${this.canvas.width} × ${this.canvas.height}px | ${format}${quality}`;
    }
  }

  private switchTab(tab: string): void {
    // 탭 버튼 스타일 변경
    document.querySelectorAll('.converter-tab-btn').forEach(btn => {
      if ((btn as HTMLElement).dataset.tab === tab) {
        (btn as HTMLElement).style.background = 'var(--primary)';
        (btn as HTMLElement).style.color = 'white';
        (btn as HTMLElement).style.border = 'none';
        btn.classList.add('active');
      } else {
        (btn as HTMLElement).style.background = 'var(--bg-tertiary)';
        (btn as HTMLElement).style.color = 'var(--text-strong)';
        (btn as HTMLElement).style.border = '1px solid var(--border-medium)';
        btn.classList.remove('active');
      }
    });

    // 탭 콘텐츠 전환
    document.querySelectorAll('.converter-tab-content').forEach(content => {
      (content as HTMLElement).style.display = 'none';
    });
    const activeContent = document.getElementById(`converter-tab-${tab}`) as HTMLDivElement;
    if (activeContent) activeContent.style.display = 'block';
  }

  private openStorageModal(): void {
    // ✅ 이미지 저장소 모달 - 영어 프롬프트 이미지, 생성된 이미지, 저장된 이미지 연동
    const generatedImages = (window as any).imageManagementGeneratedImages || [];
    const savedImages = ImageManager.getAllImages();

    // 이미지 목록 합치기
    const allImages: Array<{ src: string; label: string; source: string }> = [];

    // 1. 생성된 이미지 (영어 프롬프트 포함)
    generatedImages.forEach((img: any, idx: number) => {
      const src = img.previewDataUrl || img.filePath || img.url;
      if (src) {
        allImages.push({
          src,
          label: img.prompt || img.heading || `이미지 ${idx + 1}`,
          source: '생성됨'
        });
      }
    });

    // 2. 저장된 이미지 (ImageManager)
    Object.values(savedImages).forEach((img: any) => {
      const src = img.previewDataUrl || img.filePath || img.url;
      if (src && !allImages.find(i => i.src === src)) {
        allImages.push({
          src,
          label: img.heading || '저장된 이미지',
          source: '저장됨'
        });
      }
    });

    if (allImages.length === 0) {
      toastManager.warning('선택할 이미지가 없습니다. 먼저 이미지를 생성하거나 저장해주세요.');
      return;
    }

    // 모달 생성
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.style.cssText = 'display:flex;align-items:center;justify-content:center;position:fixed;inset:0;background:rgba(0,0,0,0.8);z-index:9999;';

    modal.innerHTML = `
      <div style="background:var(--bg-secondary);border-radius:16px;max-width:800px;width:90%;max-height:80vh;overflow:hidden;display:flex;flex-direction:column;">
        <div style="padding:20px;border-bottom:1px solid var(--border-light);display:flex;justify-content:space-between;align-items:center;">
          <h3 style="margin:0;color:var(--text-strong);font-size:18px;">🖼️ 이미지 선택</h3>
          <button id="converter-storage-close" style="background:none;border:none;color:var(--text-muted);font-size:24px;cursor:pointer;">&times;</button>
        </div>
        <div style="padding:20px;overflow-y:auto;flex:1;">
          <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:16px;">
            ${allImages.map((img, idx) => `
              <div class="converter-storage-item" data-idx="${idx}" style="cursor:pointer;border-radius:12px;overflow:hidden;border:2px solid transparent;transition:all 0.2s;">
                <div style="position:relative;padding-bottom:75%;background:#1a1a2e;">
                  <img src="${img.src}" style="position:absolute;inset:0;width:100%;height:100%;object-fit:cover;" onerror="this.style.display='none'" />
                </div>
                <div style="padding:8px;background:var(--bg-tertiary);">
                  <div style="font-size:12px;color:var(--text-strong);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${img.label}</div>
                  <div style="font-size:10px;color:var(--text-muted);">${img.source}</div>
                </div>
              </div>
            `).join('')}
          </div>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    // 이벤트 리스너
    modal.querySelector('#converter-storage-close')?.addEventListener('click', () => modal.remove());
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.remove();
    });

    // 이미지 선택
    modal.querySelectorAll('.converter-storage-item').forEach(item => {
      item.addEventListener('mouseenter', () => {
        (item as HTMLElement).style.borderColor = 'var(--primary)';
        (item as HTMLElement).style.transform = 'scale(1.02)';
      });
      item.addEventListener('mouseleave', () => {
        (item as HTMLElement).style.borderColor = 'transparent';
        (item as HTMLElement).style.transform = 'scale(1)';
      });
      item.addEventListener('click', () => {
        const idx = parseInt((item as HTMLElement).dataset.idx || '0');
        const selectedImg = allImages[idx];
        if (selectedImg) {
          this.loadImageFromUrl(selectedImg.src);
          modal.remove();
          toastManager.success(`이미지가 로드되었습니다: ${selectedImg.label}`);
        }
      });
    });
  }

  // URL에서 이미지 로드
  private loadImageFromUrl(src: string): void {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      this.originalImage = img;

      // 캔버스 크기 설정
      if (this.canvas && this.ctx && this.originalCanvas && this.originalCtx) {
        this.canvas.width = img.width;
        this.canvas.height = img.height;
        this.originalCanvas.width = img.width;
        this.originalCanvas.height = img.height;

        // 원본 캔버스에 그리기
        this.originalCtx.drawImage(img, 0, 0);

        // 결과 캔버스에도 그리기
        this.ctx.drawImage(img, 0, 0);

        // 크기 입력 필드 업데이트
        (document.getElementById('converter-width') as HTMLInputElement).value = String(img.width);
        (document.getElementById('converter-height') as HTMLInputElement).value = String(img.height);

        this.updateResultInfo();
      }
    };
    img.onerror = () => {
      toastManager.error('이미지를 불러올 수 없습니다.');
    };
    img.src = src;
  }

  private applyResize(): void {
    if (!this.originalImage || !this.canvas || !this.ctx) return;

    const width = parseInt((document.getElementById('converter-width') as HTMLInputElement).value);
    const height = parseInt((document.getElementById('converter-height') as HTMLInputElement).value);

    if (width <= 0 || height <= 0) {
      toastManager.error('올바른 크기를 입력해주세요.');
      return;
    }

    this.canvas.width = width;
    this.canvas.height = height;
    this.ctx.drawImage(this.originalCanvas!, 0, 0, width, height);
    this.applyFilters();
    this.updateResultInfo();
    toastManager.success(`크기가 ${width}×${height}px로 변경되었습니다.`);
  }

  private applyFilters(): void {
    if (!this.originalCanvas || !this.canvas || !this.ctx) return;

    // CSS 필터 문자열 생성
    const brightness = 100 + this.filters.brightness;
    const contrast = 100 + this.filters.contrast;
    const saturation = 100 + this.filters.saturation;

    this.ctx.filter = `brightness(${brightness}%) contrast(${contrast}%) saturate(${saturation}%)`;
    this.ctx.drawImage(this.originalCanvas, 0, 0, this.canvas.width, this.canvas.height);
    this.ctx.filter = 'none';
  }

  private applyFilterPreset(preset: string): void {
    switch (preset) {
      case 'none':
        this.filters = { brightness: 0, contrast: 0, saturation: 0, sharpen: 0 };
        break;
      case 'vivid':
        this.filters = { brightness: 5, contrast: 15, saturation: 20, sharpen: 20 };
        break;
      case 'soft':
        this.filters = { brightness: 10, contrast: -10, saturation: -10, sharpen: 0 };
        break;
      case 'grayscale':
        this.filters = { brightness: 0, contrast: 10, saturation: -100, sharpen: 0 };
        break;
      case 'sepia':
        this.filters = { brightness: 5, contrast: 0, saturation: -50, sharpen: 0 };
        break;
      case 'vintage':
        this.filters = { brightness: 10, contrast: -15, saturation: -30, sharpen: 0 };
        break;
    }

    // UI 업데이트
    ['brightness', 'contrast', 'saturation', 'sharpen'].forEach(filter => {
      const slider = document.getElementById(`filter-${filter}`) as HTMLInputElement;
      const valueSpan = document.getElementById(`filter-${filter}-value`) as HTMLSpanElement;
      if (slider) slider.value = String((this.filters as any)[filter]);
      if (valueSpan) valueSpan.textContent = String((this.filters as any)[filter]);
    });

    this.applyFilters();
  }

  private resetFilters(): void {
    this.applyFilterPreset('none');
    toastManager.success('필터가 초기화되었습니다.');
  }

  private applyCrop(): void {
    if (!this.canvas || !this.ctx) return;

    const x = parseInt((document.getElementById('crop-x') as HTMLInputElement).value);
    const y = parseInt((document.getElementById('crop-y') as HTMLInputElement).value);
    const width = parseInt((document.getElementById('crop-width') as HTMLInputElement).value);
    const height = parseInt((document.getElementById('crop-height') as HTMLInputElement).value);

    if (width <= 0 || height <= 0) {
      toastManager.error('올바른 크기를 입력해주세요.');
      return;
    }

    // 현재 캔버스에서 자르기
    const imageData = this.ctx.getImageData(x, y, width, height);
    this.canvas.width = width;
    this.canvas.height = height;
    this.ctx.putImageData(imageData, 0, 0);

    // 원본 캔버스도 업데이트
    this.originalCanvas!.width = width;
    this.originalCanvas!.height = height;
    this.originalCanvas!.getContext('2d')?.putImageData(imageData, 0, 0);

    this.updateResultInfo();
    toastManager.success('이미지가 잘렸습니다.');
  }

  // ✅ 비율 변환 프리셋 적용 (원본에서 시작, 이미지 꽉 채우기)
  private applyRatioCrop(ratioStr: string): void {
    if (!this.canvas || !this.ctx || !this.originalImage) {
      toastManager.error('먼저 이미지를 로드해주세요.');
      return;
    }

    // 비율 파싱
    const [wRatio, hRatio] = ratioStr.split(':').map(Number);
    if (!wRatio || !hRatio) return;

    const targetRatio = wRatio / hRatio;

    // ✅ 항상 원본 이미지에서 시작 (중첩 방지)
    const origWidth = this.originalImage.width;
    const origHeight = this.originalImage.height;

    // 새 캔버스 크기 계산 (원본 기준으로 비율에 맞게)
    let newWidth: number, newHeight: number;

    if (origWidth / origHeight > targetRatio) {
      // 원본이 더 넓음 → 너비 기준으로 높이 계산
      newWidth = origWidth;
      newHeight = Math.round(origWidth / targetRatio);
    } else {
      // 원본이 더 높음 → 높이 기준으로 너비 계산
      newHeight = origHeight;
      newWidth = Math.round(origHeight * targetRatio);
    }

    // 캔버스 크기 설정
    this.canvas.width = newWidth;
    this.canvas.height = newHeight;

    // ✅ 원본 이미지를 캔버스 전체에 꽉 채워서 그리기 (stretch)
    this.ctx.drawImage(this.originalImage, 0, 0, newWidth, newHeight);

    // 원본 캔버스도 업데이트
    this.originalCanvas!.width = newWidth;
    this.originalCanvas!.height = newHeight;
    const origCtx = this.originalCanvas!.getContext('2d');
    if (origCtx) {
      origCtx.drawImage(this.originalImage, 0, 0, newWidth, newHeight);
    }

    // 자르기 입력 필드 업데이트
    (document.getElementById('crop-x') as HTMLInputElement).value = '0';
    (document.getElementById('crop-y') as HTMLInputElement).value = '0';
    (document.getElementById('crop-width') as HTMLInputElement).value = String(newWidth);
    (document.getElementById('crop-height') as HTMLInputElement).value = String(newHeight);

    this.updateResultInfo();
    toastManager.success(`✅ ${ratioStr} 비율로 변환되었습니다.`);
  }

  private async removeBackground(): Promise<void> {
    if (!this.canvas || !this.ctx) {
      toastManager.error('이미지를 먼저 로드해주세요.');
      return;
    }

    const removeBgBtn = document.getElementById('ai-remove-bg-btn') as HTMLButtonElement;
    const originalText = removeBgBtn?.innerHTML || '';

    try {
      // 버튼 상태 변경
      if (removeBgBtn) {
        removeBgBtn.disabled = true;
        removeBgBtn.innerHTML = '⏳ 처리 중...';
      }

      toastManager.info('🤖 AI 배경 제거 중... (첫 실행 시 모델 다운로드로 시간이 걸릴 수 있습니다)');

      // Canvas를 Blob으로 변환
      const blob = await new Promise<Blob>((resolve, reject) => {
        this.canvas!.toBlob((b) => {
          if (b) resolve(b);
          else reject(new Error('Blob 변환 실패'));
        }, 'image/png');
      });

      // @imgly/background-removal 동적 import
      const { removeBackground } = await import('@imgly/background-removal');

      // 배경 제거 실행
      const resultBlob = await removeBackground(blob, {
        progress: (key: string, current: number, total: number) => {
          const percent = Math.round((current / total) * 100);
          if (removeBgBtn) {
            removeBgBtn.innerHTML = `⏳ ${key}: ${percent}%`;
          }
        }
      });

      // 결과를 Canvas에 적용
      const resultUrl = URL.createObjectURL(resultBlob);
      const resultImg = new Image();

      resultImg.onload = () => {
        if (!this.canvas || !this.ctx) return;

        // 캔버스 크기 유지
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.ctx.drawImage(resultImg, 0, 0, this.canvas.width, this.canvas.height);

        // 원본 캔버스도 업데이트
        const origCtx = this.originalCanvas?.getContext('2d');
        if (origCtx && this.originalCanvas) {
          origCtx.clearRect(0, 0, this.originalCanvas.width, this.originalCanvas.height);
          origCtx.drawImage(resultImg, 0, 0, this.originalCanvas.width, this.originalCanvas.height);
        }

        URL.revokeObjectURL(resultUrl);

        // 포맷을 PNG로 변경 (투명 배경 유지)
        this.currentFormat = 'png';
        document.querySelectorAll('.format-btn').forEach(btn => {
          if ((btn as HTMLElement).dataset.format === 'png') {
            (btn as HTMLElement).style.background = 'var(--primary)';
            (btn as HTMLElement).style.color = 'white';
            btn.classList.add('selected');
          } else {
            (btn as HTMLElement).style.background = 'var(--bg-tertiary)';
            (btn as HTMLElement).style.color = 'var(--text-strong)';
            btn.classList.remove('selected');
          }
        });

        this.updateResultInfo();
        toastManager.success('✅ 배경 제거 완료! (PNG 포맷으로 저장하면 투명 배경 유지)');

        if (removeBgBtn) {
          removeBgBtn.disabled = false;
          removeBgBtn.innerHTML = originalText;
        }
      };

      resultImg.onerror = () => {
        URL.revokeObjectURL(resultUrl);
        toastManager.error('결과 이미지 로드 실패');
        if (removeBgBtn) {
          removeBgBtn.disabled = false;
          removeBgBtn.innerHTML = originalText;
        }
      };

      resultImg.src = resultUrl;

    } catch (error) {
      console.error('배경 제거 오류:', error);
      toastManager.error(`배경 제거 실패: ${(error as Error).message}`);
      if (removeBgBtn) {
        removeBgBtn.disabled = false;
        removeBgBtn.innerHTML = originalText;
      }
    }
  }

  private async upscale(): Promise<void> {
    if (!this.canvas || !this.ctx || !this.originalCanvas) {
      toastManager.error('이미지를 먼저 로드해주세요.');
      return;
    }

    const upscaleBtn = document.getElementById('ai-upscale-btn') as HTMLButtonElement;
    const factorSelect = document.getElementById('ai-upscale-factor') as HTMLSelectElement;
    const factor = parseInt(factorSelect?.value || '2');
    const originalText = upscaleBtn?.innerHTML || '';

    try {
      if (upscaleBtn) {
        upscaleBtn.disabled = true;
        upscaleBtn.innerHTML = '⏳ 처리 중...';
      }

      toastManager.info(`🔬 ${factor}배 업스케일링 중... (고급 Lanczos 알고리즘 사용)`);

      const srcCanvas = this.originalCanvas;
      const srcWidth = srcCanvas.width;
      const srcHeight = srcCanvas.height;
      const dstWidth = srcWidth * factor;
      const dstHeight = srcHeight * factor;

      // 결과 캔버스 생성
      const dstCanvas = document.createElement('canvas');
      dstCanvas.width = dstWidth;
      dstCanvas.height = dstHeight;
      const dstCtx = dstCanvas.getContext('2d')!;

      // 고품질 이미지 스케일링 설정
      dstCtx.imageSmoothingEnabled = true;
      dstCtx.imageSmoothingQuality = 'high';

      // Lanczos 리샘플링 구현 (고급 업스케일링)
      const srcCtx = srcCanvas.getContext('2d')!;
      const srcData = srcCtx.getImageData(0, 0, srcWidth, srcHeight);
      const dstData = dstCtx.createImageData(dstWidth, dstHeight);

      // Lanczos kernel (a=3)
      const lanczos = (x: number): number => {
        if (x === 0) return 1;
        if (Math.abs(x) >= 3) return 0;
        const pix = Math.PI * x;
        return (Math.sin(pix) / pix) * (Math.sin(pix / 3) / (pix / 3));
      };

      // 업스케일링 처리 (청크 단위로 처리하여 UI 블로킹 방지)
      const processChunk = async (startY: number, endY: number): Promise<void> => {
        for (let dy = startY; dy < endY; dy++) {
          for (let dx = 0; dx < dstWidth; dx++) {
            const sx = dx / factor;
            const sy = dy / factor;

            let r = 0, g = 0, b = 0, a = 0, weight = 0;

            // Lanczos 3x3 kernel
            for (let ky = -2; ky <= 2; ky++) {
              for (let kx = -2; kx <= 2; kx++) {
                const px = Math.floor(sx) + kx;
                const py = Math.floor(sy) + ky;

                if (px >= 0 && px < srcWidth && py >= 0 && py < srcHeight) {
                  const w = lanczos(sx - px) * lanczos(sy - py);
                  const idx = (py * srcWidth + px) * 4;

                  r += srcData.data[idx] * w;
                  g += srcData.data[idx + 1] * w;
                  b += srcData.data[idx + 2] * w;
                  a += srcData.data[idx + 3] * w;
                  weight += w;
                }
              }
            }

            const dIdx = (dy * dstWidth + dx) * 4;
            if (weight > 0) {
              dstData.data[dIdx] = Math.min(255, Math.max(0, r / weight));
              dstData.data[dIdx + 1] = Math.min(255, Math.max(0, g / weight));
              dstData.data[dIdx + 2] = Math.min(255, Math.max(0, b / weight));
              dstData.data[dIdx + 3] = Math.min(255, Math.max(0, a / weight));
            }
          }
        }
      };

      // 청크 단위 처리
      const chunkSize = 50;
      for (let y = 0; y < dstHeight; y += chunkSize) {
        const endY = Math.min(y + chunkSize, dstHeight);
        await processChunk(y, endY);

        // 진행률 표시
        const progress = Math.round((y / dstHeight) * 100);
        if (upscaleBtn) {
          upscaleBtn.innerHTML = `⏳ ${progress}%`;
        }

        // UI 업데이트를 위한 짧은 대기
        await new Promise(r => setTimeout(r, 0));
      }

      // 결과 적용
      dstCtx.putImageData(dstData, 0, 0);

      // 선명도 향상 (Unsharp Mask)
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = dstWidth;
      tempCanvas.height = dstHeight;
      const tempCtx = tempCanvas.getContext('2d')!;

      // 블러 이미지 생성
      tempCtx.filter = 'blur(1px)';
      tempCtx.drawImage(dstCanvas, 0, 0);
      tempCtx.filter = 'none';

      const blurData = tempCtx.getImageData(0, 0, dstWidth, dstHeight);
      const sharpAmount = 0.5; // 선명도 강도

      for (let i = 0; i < dstData.data.length; i += 4) {
        dstData.data[i] = Math.min(255, Math.max(0, dstData.data[i] + (dstData.data[i] - blurData.data[i]) * sharpAmount));
        dstData.data[i + 1] = Math.min(255, Math.max(0, dstData.data[i + 1] + (dstData.data[i + 1] - blurData.data[i + 1]) * sharpAmount));
        dstData.data[i + 2] = Math.min(255, Math.max(0, dstData.data[i + 2] + (dstData.data[i + 2] - blurData.data[i + 2]) * sharpAmount));
      }

      dstCtx.putImageData(dstData, 0, 0);

      // 결과를 메인 캔버스에 적용
      this.canvas.width = dstWidth;
      this.canvas.height = dstHeight;
      this.ctx.drawImage(dstCanvas, 0, 0);

      // 원본 캔버스도 업데이트
      this.originalCanvas.width = dstWidth;
      this.originalCanvas.height = dstHeight;
      this.originalCanvas.getContext('2d')?.drawImage(dstCanvas, 0, 0);

      // 크기 입력 업데이트
      (document.getElementById('converter-width') as HTMLInputElement).value = String(dstWidth);
      (document.getElementById('converter-height') as HTMLInputElement).value = String(dstHeight);
      (document.getElementById('crop-width') as HTMLInputElement).value = String(dstWidth);
      (document.getElementById('crop-height') as HTMLInputElement).value = String(dstHeight);

      this.updateResultInfo();
      toastManager.success(`✅ ${factor}배 업스케일 완료! (${srcWidth}×${srcHeight} → ${dstWidth}×${dstHeight})`);

    } catch (error) {
      console.error('업스케일 오류:', error);
      toastManager.error(`업스케일 실패: ${(error as Error).message}`);
    } finally {
      if (upscaleBtn) {
        upscaleBtn.disabled = false;
        upscaleBtn.innerHTML = originalText;
      }
    }
  }

  private reset(): void {
    this.originalImage = null;
    this.filters = { brightness: 0, contrast: 0, saturation: 0, sharpen: 0 };

    const placeholder = document.getElementById('converter-upload-placeholder') as HTMLDivElement;
    const editor = document.getElementById('converter-editor') as HTMLDivElement;
    const uploadZone = document.getElementById('converter-upload-zone') as HTMLDivElement;

    if (placeholder) placeholder.style.display = 'block';
    if (editor) editor.style.display = 'none';
    if (uploadZone) {
      uploadZone.style.border = '2px dashed var(--border-medium)';
      uploadZone.style.padding = '2rem';
      uploadZone.style.background = 'var(--bg-secondary)';
    }

    // 필터 초기화
    this.resetFilters();

    toastManager.success('새 이미지를 선택해주세요.');
  }

  private insertToPost(): void {
    if (!this.canvas) return;

    const mimeType = `image/${this.currentFormat === 'jpeg' ? 'jpeg' : this.currentFormat}`;
    const quality = this.currentFormat !== 'png' ? this.currentQuality / 100 : undefined;
    const base64 = this.canvas.toDataURL(mimeType, quality);

    // ✅ 소제목 목록 가져오기 (ImageManager 우선)
    const headings = ImageManager.headings.length > 0
      ? ImageManager.headings
      : ((window as any).imageManagementHeadings || []);

    if (headings.length > 0) {
      // ✅ 소제목 선택 모달 표시
      this.showHeadingSelectionForInsert(base64, headings);
    } else {
      toastManager.info('소제목이 없어 저장소에 저장합니다.');
      this.saveToStorage();
    }
  }

  // ✅ 소제목 선택 모달 (이미지 변환기용)
  private showHeadingSelectionForInsert(imageBase64: string, headings: any[]): void {
    const modal = document.createElement('div');
    modal.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.8); z-index: 100000; display: flex;
      align-items: center; justify-content: center; padding: 2rem;
    `;

    modal.innerHTML = `
      <div style="background: var(--bg-primary); border-radius: 16px; max-width: 500px; width: 100%; max-height: 80vh; overflow: auto; padding: 2rem;">
        <h3 style="margin: 0 0 1rem 0; color: var(--text-strong); font-size: 1.25rem;">📍 이미지를 배치할 소제목 선택</h3>
        <div style="display: flex; flex-direction: column; gap: 0.5rem; margin-bottom: 1.5rem;">
          ${headings.map((h: any, i: number) => {
      const title = typeof h === 'string' ? h : (h.title || `소제목 ${i + 1}`);
      const hasImage = ImageManager.hasImage(title);
      return `
              <button type="button" class="heading-select-btn" data-index="${i}" 
                      style="padding: 0.75rem 1rem; background: ${hasImage ? 'linear-gradient(135deg, #10b981, #059669)' : 'var(--bg-tertiary)'}; 
                             color: ${hasImage ? 'white' : 'var(--text-strong)'}; border: 1px solid var(--border-light); border-radius: 8px; 
                             text-align: left; cursor: pointer; transition: all 0.2s;">
                ${hasImage ? '✅ ' : ''}${i + 1}. ${title}
              </button>
            `;
    }).join('')}
        </div>
        <div style="display: flex; gap: 0.5rem;">
          <button type="button" class="apply-btn" style="flex: 1; padding: 0.75rem; background: var(--primary); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">1번 소제목에 적용 (썸네일)</button>
          <button type="button" class="cancel-btn" style="padding: 0.75rem 1.5rem; background: var(--bg-tertiary); color: var(--text-strong); border: 1px solid var(--border-light); border-radius: 8px; cursor: pointer;">취소</button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    let selectedIndex = 0;

    // 소제목 버튼 클릭
    modal.querySelectorAll('.heading-select-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        selectedIndex = parseInt((btn as HTMLElement).dataset.index || '0');
        modal.querySelectorAll('.heading-select-btn').forEach(b => {
          (b as HTMLElement).style.borderColor = 'var(--border-light)';
          (b as HTMLElement).style.borderWidth = '1px';
        });
        (btn as HTMLElement).style.borderColor = 'var(--primary)';
        (btn as HTMLElement).style.borderWidth = '2px';
      });
    });

    // 적용 버튼 (1번 소제목에 적용)
    modal.querySelector('.apply-btn')?.addEventListener('click', () => {
      const targetHeading = headings[selectedIndex];
      const title = typeof targetHeading === 'string' ? targetHeading : (targetHeading?.title || `소제목 ${selectedIndex + 1}`);

      const newImage = {
        heading: title,
        filePath: imageBase64,
        previewDataUrl: imageBase64,
        provider: 'image-converter',
        url: imageBase64,
        headingIndex: selectedIndex
      };

      // ✅ ImageManager에 등록
      ImageManager.setImage(title, newImage);

      // ✅ generatedImages 업데이트
      const existingImages = [...((window as any).imageManagementGeneratedImages || generatedImages || [])];
      if (selectedIndex < existingImages.length) {
        existingImages[selectedIndex] = newImage;
      } else {
        existingImages.push(newImage);
      }

      generatedImages = existingImages;
      (window as any).imageManagementGeneratedImages = existingImages;

      // ✅ 1번 소제목이면 대표사진으로 등록
      if (selectedIndex === 0) {
        (window as any).thumbnailPath = imageBase64;
        (window as any).selectedThumbnailImage = newImage;
        appendLog(`📷 대표사진으로 자동 등록됩니다.`);
      }

      // ✅ 모든 미리보기 동기화
      displayGeneratedImages(existingImages);
      ImageManager.syncAllPreviews();

      appendLog(`✅ 이미지가 ${selectedIndex + 1}번 소제목 "${title}"에 적용되었습니다!`);
      toastManager.success(`✅ 이미지가 "${title}" 위치에 삽입되었습니다!`);
      modal.remove();
    });

    // 취소 버튼
    modal.querySelector('.cancel-btn')?.addEventListener('click', () => modal.remove());
    modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
  }

  private saveToStorage(): void {
    if (!this.canvas) return;

    const mimeType = `image/${this.currentFormat === 'jpeg' ? 'jpeg' : this.currentFormat}`;
    const quality = this.currentFormat !== 'png' ? this.currentQuality / 100 : undefined;
    const base64 = this.canvas.toDataURL(mimeType, quality);

    // 저장소에 저장 로직 (기존 이미지 라이브러리 활용)
    toastManager.success('이미지가 저장소에 저장되었습니다.');
  }

  private download(): void {
    if (!this.canvas) return;

    const mimeType = `image/${this.currentFormat === 'jpeg' ? 'jpeg' : this.currentFormat}`;
    const quality = this.currentFormat !== 'png' ? this.currentQuality / 100 : undefined;

    const link = document.createElement('a');
    link.download = `converted_${Date.now()}.${this.currentFormat === 'jpeg' ? 'jpg' : this.currentFormat}`;
    link.href = this.canvas.toDataURL(mimeType, quality);
    link.click();
    toastManager.success('이미지가 다운로드되었습니다.');
  }
}

// ============================================
// 썸네일 생성기 & 이미지 변환기 초기화
// ============================================

let thumbnailGenerator: ThumbnailGenerator | null = null;
let imageConverter: ImageConverter | null = null;

// 탭 전환 시 초기화
document.addEventListener('DOMContentLoaded', () => {
  // 기존 탭 전환 이벤트에 통합
  const tabButtons = document.querySelectorAll('.tab-button');
  tabButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const tab = (btn as HTMLElement).dataset.tab;

      // ✅ 스마트 자동 발행 탭 전용 섹션들 표시/숨김 제어
      const unifiedOnlySections = [
        'unified-semi-auto-section',      // 반자동 편집 영역
        'unified-only-posts-list',        // 생성된 글 목록
        'unified-only-log-section',       // 로그 & 진행상황
        'unified-only-image-engine',      // 이미지 엔진 선택
        'unified-only-publish-settings',  // 발행 설정
        'unified-preview-section',        // 콘텐츠 미리보기
      ];

      unifiedOnlySections.forEach(sectionId => {
        const section = document.getElementById(sectionId);
        if (section) {
          // 'unified' 탭(스마트 자동 발행)에서만 표시
          if (tab === 'unified') {
            // unified-semi-auto-section과 unified-only-posts-list, unified-only-log-section은 기본 표시
            if (sectionId === 'unified-semi-auto-section' ||
              sectionId === 'unified-only-posts-list' ||
              sectionId === 'unified-only-log-section') {
              section.style.display = 'block';
            }
            // 나머지는 기존 상태 유지 (none으로 시작했다가 필요 시 표시)
          } else {
            // 다른 탭에서는 모두 숨김
            section.style.display = 'none';
          }
        }
      });

      // ✅ 이미지 도구 탭 진입 시 썸네일 생성기 초기화 (기본 서브탭)
      if (tab === 'image-tools' && !thumbnailGenerator) {
        setTimeout(() => {
          thumbnailGenerator = new ThumbnailGenerator();
        }, 100);
      }
    });
  });

  // ✅ 이미지 도구 서브탭 전환 로직
  const subtabButtons = document.querySelectorAll('.image-tools-subtab');
  console.log('[ImageToolsSubtab] 서브탭 버튼 개수:', subtabButtons.length);

  subtabButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const subtab = (btn as HTMLElement).dataset.subtab;
      console.log('[ImageToolsSubtab] 서브탭 클릭:', subtab);

      // 버튼 스타일 업데이트
      subtabButtons.forEach(b => {
        const btnEl = b as HTMLElement;
        if (btnEl.dataset.subtab === subtab) {
          btnEl.style.background = 'var(--accent-primary)';
          btnEl.style.color = 'white';
          btnEl.classList.add('active');
        } else {
          btnEl.style.background = 'transparent';
          btnEl.style.color = 'var(--text-muted)';
          btnEl.classList.remove('active');
        }
      });

      // 서브패널 표시/숨김
      const thumbnailPanel = document.getElementById('subtab-thumbnail');
      const converterPanel = document.getElementById('subtab-converter');
      const shoppingBannerPanel = document.getElementById('subtab-shopping-banner');

      console.log('[ImageToolsSubtab] 패널 존재 여부:', {
        thumbnail: !!thumbnailPanel,
        converter: !!converterPanel,
        shoppingBanner: !!shoppingBannerPanel
      });

      // ✅ 모든 패널 숨기기
      if (thumbnailPanel) thumbnailPanel.style.display = 'none';
      if (converterPanel) converterPanel.style.display = 'none';
      if (shoppingBannerPanel) shoppingBannerPanel.style.display = 'none';

      if (subtab === 'thumbnail') {
        if (thumbnailPanel) thumbnailPanel.style.display = 'block';

        // 썸네일 생성기 초기화
        if (!thumbnailGenerator) {
          setTimeout(() => {
            thumbnailGenerator = new ThumbnailGenerator();
          }, 100);
        }
      } else if (subtab === 'converter') {
        if (converterPanel) converterPanel.style.display = 'block';

        // 이미지 변환기 초기화
        if (!imageConverter) {
          setTimeout(() => {
            imageConverter = new ImageConverter();
          }, 100);
        }
      } else if (subtab === 'shopping-banner') {
        console.log('[ImageToolsSubtab] 쇼핑커넥트 배너 패널 표시!');
        if (shoppingBannerPanel) {
          shoppingBannerPanel.style.display = 'block';
          console.log('[ImageToolsSubtab] shoppingBannerPanel.style.display =', shoppingBannerPanel.style.display);
        }

        // ✅ [2026-01-19] 쇼핑커넥트 배너 탭 전용 이벤트 리스너 초기화
        initShoppingBannerTab();
      }
    });
  });

  // ✅ 분석 도구 서브탭 전환 로직
  const analyticsSubtabButtons = document.querySelectorAll('.analytics-subtab');
  analyticsSubtabButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const subtab = (btn as HTMLElement).dataset.subtab;

      // 버튼 스타일 업데이트
      analyticsSubtabButtons.forEach(b => {
        const btnEl = b as HTMLElement;
        if (btnEl.dataset.subtab === subtab) {
          btnEl.style.background = 'var(--accent-primary)';
          btnEl.style.color = 'white';
          btnEl.classList.add('active');
        } else {
          btnEl.style.background = 'transparent';
          btnEl.style.color = 'var(--text-muted)';
          btnEl.classList.remove('active');
        }
      });

      // 서브패널 표시/숨김
      document.querySelectorAll('.analytics-subpanel').forEach(panel => {
        (panel as HTMLElement).style.display = 'none';
      });
      const targetPanel = document.getElementById(`subtab-${subtab}`);
      if (targetPanel) targetPanel.style.display = 'block';
    });
  });

  // ✅ 키워드 분석 버튼
  const analyzeKeywordBtn = document.getElementById('analyze-keyword-btn');
  analyzeKeywordBtn?.addEventListener('click', async () => {
    const input = document.getElementById('keyword-analysis-input') as HTMLInputElement;
    const keyword = input?.value.trim();
    if (!keyword) {
      toastManager.warning('키워드를 입력해주세요.');
      return;
    }

    analyzeKeywordBtn.textContent = '분석 중...';
    (analyzeKeywordBtn as HTMLButtonElement).disabled = true;

    try {
      const result = await (window as any).electronAPI.analyzeKeyword(keyword);
      if (result.success && result.analysis) {
        const analysis = result.analysis;
        const resultDiv = document.getElementById('keyword-analysis-result');
        const contentDiv = document.getElementById('keyword-result-content');

        // 추천도 한글 변환
        const recommendationLabels: Record<string, string> = {
          'excellent': '🌟 매우 좋음',
          'good': '✅ 좋음',
          'moderate': '⚠️ 보통',
          'difficult': '❌ 어려움',
          'avoid': '🚫 피하세요'
        };
        const recommendationColors: Record<string, string> = {
          'excellent': '#10b981',
          'good': '#22c55e',
          'moderate': '#f59e0b',
          'difficult': '#ef4444',
          'avoid': '#dc2626'
        };

        if (resultDiv && contentDiv) {
          resultDiv.style.display = 'block';
          contentDiv.innerHTML = `
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
              <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px; text-align: center;">
                <div style="font-size: 0.85rem; color: var(--text-muted);">기회 점수</div>
                <div style="font-size: 1.5rem; font-weight: 700; color: ${analysis.opportunity >= 70 ? '#10b981' : analysis.opportunity >= 40 ? '#f59e0b' : '#ef4444'};">${analysis.opportunity || 0}</div>
              </div>
              <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px; text-align: center;">
                <div style="font-size: 0.85rem; color: var(--text-muted);">난이도</div>
                <div style="font-size: 1.5rem; font-weight: 700; color: ${analysis.difficulty >= 70 ? '#ef4444' : analysis.difficulty >= 40 ? '#f59e0b' : '#10b981'};">${analysis.difficulty || 0}</div>
              </div>
              <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px; text-align: center;">
                <div style="font-size: 0.85rem; color: var(--text-muted);">블로그 결과</div>
                <div style="font-size: 1.2rem; font-weight: 700; color: var(--text-strong);">${analysis.blogCount?.toLocaleString() || '-'}</div>
              </div>
              <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px; text-align: center;">
                <div style="font-size: 0.85rem; color: var(--text-muted);">추천도</div>
                <div style="font-size: 1rem; font-weight: 600; color: ${recommendationColors[analysis.recommendation] || 'var(--primary)'};">${recommendationLabels[analysis.recommendation] || analysis.recommendation || '-'}</div>
              </div>
            </div>
            ${analysis.reasons && analysis.reasons.length > 0 ? `
            <div style="padding: 1rem; background: var(--bg-tertiary); border-radius: 8px; margin-bottom: 1rem;">
              <strong>💡 분석 이유:</strong>
              <ul style="margin: 0.5rem 0 0 0; padding-left: 1.25rem; color: var(--text-muted);">
                ${analysis.reasons.map((r: string) => `<li>${r}</li>`).join('')}
              </ul>
            </div>
            ` : ''}
            ${analysis.suggestions && analysis.suggestions.length > 0 ? `
            <div style="padding: 1rem; background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(5, 150, 105, 0.05)); border-radius: 8px; margin-bottom: 1rem;">
              <strong style="color: #10b981;">📝 제안:</strong>
              <ul style="margin: 0.5rem 0 0 0; padding-left: 1.25rem; color: var(--text-muted);">
                ${analysis.suggestions.map((s: string) => `<li>${s}</li>`).join('')}
              </ul>
            </div>
            ` : ''}
            ${analysis.relatedKeywords && analysis.relatedKeywords.length > 0 ? `
            <div style="padding: 1rem; background: var(--bg-tertiary); border-radius: 8px;">
              <strong>🔗 연관 키워드:</strong>
              <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 0.5rem;">
                ${analysis.relatedKeywords.map((kw: string) => `<span style="padding: 0.25rem 0.75rem; background: var(--bg-secondary); border-radius: 20px; font-size: 0.85rem; color: var(--text-strong);">${kw}</span>`).join('')}
              </div>
            </div>
            ` : ''}
          `;
        }
        toastManager.success('키워드 분석 완료!');
      } else {
        toastManager.error(result.message || '분석 실패');
      }
    } catch (error) {
      console.error('[KeywordAnalysis] 오류:', error);
      toastManager.error('분석 중 오류 발생: ' + (error as Error).message);
    } finally {
      analyzeKeywordBtn.textContent = '🔍 분석하기';
      (analyzeKeywordBtn as HTMLButtonElement).disabled = false;
    }
  });

  // ✅ 블루오션 키워드 찾기
  const findBlueoceanBtn = document.getElementById('find-blueocean-btn');
  findBlueoceanBtn?.addEventListener('click', async () => {
    const input = document.getElementById('keyword-analysis-input') as HTMLInputElement;
    const keyword = input?.value.trim();
    if (!keyword) {
      toastManager.warning('기준 키워드를 입력해주세요.');
      return;
    }

    findBlueoceanBtn.textContent = '검색 중...';
    (findBlueoceanBtn as HTMLButtonElement).disabled = true;

    try {
      const result = await (window as any).electronAPI.findBlueOceanKeywords(keyword, 5);
      if (result.success && result.keywords) {
        const resultDiv = document.getElementById('keyword-analysis-result');
        const contentDiv = document.getElementById('keyword-result-content');

        if (resultDiv && contentDiv) {
          resultDiv.style.display = 'block';
          contentDiv.innerHTML = `
            <h5 style="margin: 0 0 1rem 0; color: var(--text-strong);">🌊 블루오션 키워드 추천</h5>
            <div style="display: flex; flex-direction: column; gap: 0.75rem;">
              ${result.keywords.map((kw: any) => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px;">
                  <span style="font-weight: 600; color: var(--text-strong);">${kw.keyword}</span>
                  <span style="font-size: 0.85rem; color: ${kw.score >= 70 ? '#10b981' : '#f59e0b'};">점수: ${kw.score}</span>
                </div>
              `).join('')}
            </div>
          `;
        }
        toastManager.success('블루오션 키워드 검색 완료!');
      } else {
        toastManager.error(result.message || '검색 실패');
      }
    } catch (error) {
      console.error('[BlueOcean] 오류:', error);
      toastManager.error('검색 중 오류 발생: ' + (error as Error).message);
    } finally {
      findBlueoceanBtn.textContent = '🌊 블루오션 키워드 찾기';
      (findBlueoceanBtn as HTMLButtonElement).disabled = false;
    }
  });

  // ✅ 자동 블루오션 키워드 발견 (입력 없이) - 진행률 바 포함
  const discoverBlueoceanBtn = document.getElementById('discover-blueocean-btn');
  discoverBlueoceanBtn?.addEventListener('click', async () => {
    discoverBlueoceanBtn.textContent = '🔍 발견 중...';
    (discoverBlueoceanBtn as HTMLButtonElement).disabled = true;

    // 진행률 UI 표시
    const resultDiv = document.getElementById('keyword-analysis-result');
    const contentDiv = document.getElementById('keyword-result-content');

    if (resultDiv && contentDiv) {
      resultDiv.style.display = 'block';
      contentDiv.innerHTML = `
        <div id="blueocean-progress-container" style="padding: 1.5rem;">
          <h5 style="margin: 0 0 1rem 0; color: var(--text-strong);">🔍 블루오션 키워드 자동 발견 중...</h5>
          
          <div style="margin-bottom: 1.5rem;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
              <span id="blueocean-progress-text" style="font-size: 0.85rem; color: var(--text-muted);">트렌드 키워드 수집 중...</span>
              <span id="blueocean-progress-percent" style="font-size: 0.85rem; font-weight: 600; color: #f59e0b;">0%</span>
            </div>
            <div style="height: 8px; background: var(--bg-tertiary); border-radius: 4px; overflow: hidden;">
              <div id="blueocean-progress-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #f59e0b, #d97706); border-radius: 4px; transition: width 0.3s ease;"></div>
            </div>
          </div>
          
          <div id="blueocean-log-container" style="background: var(--bg-tertiary); border-radius: 8px; padding: 1rem; max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 0.8rem;">
            <div class="log-item" style="color: var(--text-muted);">⏳ 네이버 트렌드 키워드 수집 시작...</div>
          </div>
        </div>
      `;
    }

    // 진행률 업데이트 함수
    const updateBlueProgress = (percent: number, text: string, logMessage?: string) => {
      const progressBar = document.getElementById('blueocean-progress-bar');
      const progressText = document.getElementById('blueocean-progress-text');
      const progressPercent = document.getElementById('blueocean-progress-percent');
      const logContainer = document.getElementById('blueocean-log-container');

      if (progressBar) progressBar.style.width = `${percent}%`;
      if (progressText) progressText.textContent = text;
      if (progressPercent) progressPercent.textContent = `${percent}%`;
      if (logContainer && logMessage) {
        const logItem = document.createElement('div');
        logItem.className = 'log-item';
        logItem.style.color = 'var(--text-muted)';
        logItem.style.marginTop = '0.25rem';
        logItem.textContent = logMessage;
        logContainer.appendChild(logItem);
        logContainer.scrollTop = logContainer.scrollHeight;
      }
    };

    // 진행률 애니메이션
    let progress = 0;
    const logMessages = [
      '📊 네이버 쇼핑 트렌드 수집 중...',
      '📈 데이터랩 인기 키워드 분석 중...',
      '🔍 연관 키워드 검색 중...',
      '📉 검색량/문서량 비교 중...',
      '⭐ 블루오션 점수 계산 중...',
    ];
    let logIndex = 0;

    const progressInterval = setInterval(() => {
      if (progress < 85) {
        progress += 3;
        if (progress % 15 === 0 && logIndex < logMessages.length) {
          updateBlueProgress(progress, logMessages[logIndex], `✅ ${logMessages[logIndex].replace('...', ' 완료')}`);
          logIndex++;
        } else {
          updateBlueProgress(progress, '분석 진행 중...');
        }
      }
    }, 600);

    try {
      const result = await (window as any).electronAPI.discoverBlueOceanKeywords(10);

      clearInterval(progressInterval);
      updateBlueProgress(100, '완료!', '🎉 블루오션 키워드 발견 완료!');

      if (result.success && result.keywords && result.keywords.length > 0) {
        const resultDiv = document.getElementById('keyword-analysis-result');
        const contentDiv = document.getElementById('keyword-result-content');

        if (resultDiv && contentDiv) {
          resultDiv.style.display = 'block';
          contentDiv.innerHTML = `
            <h5 style="margin: 0 0 1rem 0; color: var(--text-strong);">🔥 자동 발견 블루오션 키워드 (트렌드 기반)</h5>
            <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 1rem;">검색량 높고 문서량 낮은 키워드를 자동으로 찾았습니다.</p>
            <div style="display: flex; flex-direction: column; gap: 0.75rem;">
              ${result.keywords.map((kw: any) => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px; cursor: pointer;" onclick="document.getElementById('keyword-analysis-input').value='${kw.keyword}'">
                  <div>
                    <span style="font-weight: 600; color: var(--text-strong);">${kw.keyword}</span>
                    <span style="font-size: 0.75rem; color: var(--text-muted); margin-left: 0.5rem;">${kw.searchVolume} / ${kw.competition}</span>
                  </div>
                  <div style="text-align: right;">
                    <span style="font-size: 0.85rem; color: ${kw.score >= 70 ? '#10b981' : '#f59e0b'}; font-weight: 600;">점수: ${kw.score}</span>
                    <div style="font-size: 0.7rem; color: var(--text-muted);">${kw.reason || ''}</div>
                  </div>
                </div>
              `).join('')}
            </div>
            <p style="font-size: 0.75rem; color: var(--text-muted); margin-top: 1rem;">💡 키워드를 클릭하면 입력창에 자동 입력됩니다.</p>
          `;
        }
        toastManager.success(`블루오션 키워드 ${result.keywords.length}개 자동 발견!`);
      } else {
        toastManager.warning(result.message || '발견된 블루오션 키워드가 없습니다.');
      }
    } catch (error) {
      console.error('[DiscoverBlueOcean] 오류:', error);
      toastManager.error('자동 발견 중 오류 발생: ' + (error as Error).message);
    } finally {
      discoverBlueoceanBtn.textContent = '🔍 자동 발견 (입력 없이)';
      (discoverBlueoceanBtn as HTMLButtonElement).disabled = false;
    }
  });

  // ✅ 단일 카테고리 황금키워드 발견 (사용자 선택)
  const discoverGoldenBtn = document.getElementById('discover-golden-btn');
  const goldenCategorySelect = document.getElementById('golden-category-select') as HTMLSelectElement;

  discoverGoldenBtn?.addEventListener('click', async () => {
    const selectedCategory = goldenCategorySelect?.value || 'restaurant';
    const categoryNames: Record<string, string> = {
      // 엔터테인먼트·예술
      literature: '📚 문학·책', movie: '🎬 영화', art: '🎨 미술·디자인',
      performance: '🎭 공연·전시', music: '🎵 음악', drama: '📺 드라마',
      celebrity: '⭐ 스타·연예인', cartoon: '🎌 만화·애니', broadcast: '📡 방송',
      // 생활·노하우·쇼핑
      daily: '💭 일상·생각', parenting: '👶 육아·결혼', pet: '🐶 반려동물',
      photo: '🖼️ 좋은글·이미지', fashion: '👗 패션·미용', interior: '🏠 인테리어·DIY',
      cooking: '🍳 요리·레시피', product: '📦 상품리뷰', gardening: '🌱 원예·재배',
      // 취미·여가·여행
      game: '🎮 게임', sports: '⚽ 스포츠', camera: '📷 사진',
      car: '🚗 자동차', hobby: '🎯 취미', domestic_travel: '🗺️ 국내여행',
      world_travel: '✈️ 세계여행', restaurant: '🍽️ 맛집',
      // 지식·동향
      it: '💻 IT·컴퓨터', politics: '📰 사회·정치', health: '🏥 건강·의학',
      economy: '💼 비즈니스·경제', language: '🌍 어학·외국어', education: '🎓 교육·학문',
      realestate: '🏢 부동산', selfdev: '📈 자기계발',
    };
    const categoryName = categoryNames[selectedCategory] || '🍽️ 맛집';

    discoverGoldenBtn.textContent = '🔍 발견 중...';
    (discoverGoldenBtn as HTMLButtonElement).disabled = true;

    // 진행률 UI 표시
    const resultDiv = document.getElementById('keyword-analysis-result');
    const contentDiv = document.getElementById('keyword-result-content');

    if (resultDiv && contentDiv) {
      resultDiv.style.display = 'block';
      contentDiv.innerHTML = `
        <div id="golden-progress-container" style="padding: 1.5rem;">
          <h5 style="margin: 0 0 1rem 0; color: var(--text-strong);">🏆 ${categoryName} 황금키워드 발견 중...</h5>
          
          <div style="margin-bottom: 1.5rem;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
              <span id="golden-progress-text" style="font-size: 0.85rem; color: var(--text-muted);">연관 키워드 수집 중...</span>
              <span id="golden-progress-percent" style="font-size: 0.85rem; font-weight: 600; color: #ec4899;">0%</span>
            </div>
            <div style="height: 8px; background: var(--bg-tertiary); border-radius: 4px; overflow: hidden;">
              <div id="golden-progress-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #ec4899, #db2777); border-radius: 4px; transition: width 0.3s ease;"></div>
            </div>
          </div>
          
          <div id="golden-log-container" style="background: var(--bg-tertiary); border-radius: 8px; padding: 1rem; max-height: 150px; overflow-y: auto; font-family: monospace; font-size: 0.8rem;">
            <div class="log-item" style="color: var(--text-muted);">⏳ ${categoryName} 연관 키워드 수집 시작...</div>
          </div>
        </div>
      `;
    }

    // 진행률 업데이트 함수
    const updateProgress = (percent: number, text: string, logMessage?: string) => {
      const progressBar = document.getElementById('golden-progress-bar');
      const progressText = document.getElementById('golden-progress-text');
      const progressPercent = document.getElementById('golden-progress-percent');
      const logContainer = document.getElementById('golden-log-container');

      if (progressBar) progressBar.style.width = `${percent}%`;
      if (progressText) progressText.textContent = text;
      if (progressPercent) progressPercent.textContent = `${percent}%`;
      if (logContainer && logMessage) {
        const logItem = document.createElement('div');
        logItem.className = 'log-item';
        logItem.style.color = 'var(--text-muted)';
        logItem.style.marginTop = '0.25rem';
        logItem.textContent = logMessage;
        logContainer.appendChild(logItem);
        logContainer.scrollTop = logContainer.scrollHeight;
      }
    };

    // 진행률 애니메이션
    let progress = 0;
    const logSteps = [
      '📊 시드 키워드 분석 중...',
      '🔍 연관 키워드 검색 중...',
      '📈 검색량 조회 중...',
      '📉 문서량 분석 중...',
      '⭐ 황금키워드 점수 계산 중...',
    ];
    let stepIndex = 0;

    const progressInterval = setInterval(() => {
      if (progress < 85) {
        progress += 4;
        if (progress % 16 === 0 && stepIndex < logSteps.length) {
          updateProgress(progress, logSteps[stepIndex], `✅ ${logSteps[stepIndex].replace('...', ' 완료')}`);
          stepIndex++;
        } else {
          updateProgress(progress, '키워드 분석 중...');
        }
      }
    }, 500);

    try {
      // ✅ 선택된 카테고리만 분석
      const result = await (window as any).electronAPI.discoverGoldenKeywordsBySingleCategory(selectedCategory, 10);

      clearInterval(progressInterval);
      updateProgress(100, '완료!', `🎉 ${categoryName} 황금키워드 발견 완료!`);

      // 1초 후 결과 표시
      setTimeout(() => {
        if (result.success && result.keywords && result.keywords.length > 0) {
          if (resultDiv && contentDiv) {
            resultDiv.style.display = 'block';

            contentDiv.innerHTML = `
              <h5 style="margin: 0 0 1rem 0; color: var(--text-strong);">🏆 ${result.category.icon} ${result.category.name} 황금키워드</h5>
              <p style="font-size: 0.8rem; color: var(--text-muted); margin-bottom: 1rem;">검색량이 높고 문서량이 낮은 블루오션 키워드입니다. 키워드 클릭 시 입력창에 자동 입력됩니다.</p>
              
              <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                <thead>
                  <tr style="background: var(--bg-tertiary);">
                    <th style="padding: 0.5rem; text-align: left; border-bottom: 1px solid var(--border-light);">키워드</th>
                    <th style="padding: 0.5rem; text-align: right; border-bottom: 1px solid var(--border-light);">검색량</th>
                    <th style="padding: 0.5rem; text-align: right; border-bottom: 1px solid var(--border-light);">문서량</th>
                    <th style="padding: 0.5rem; text-align: right; border-bottom: 1px solid var(--border-light);">점수</th>
                  </tr>
                </thead>
                <tbody>
                  ${result.keywords.map((kw: any) => `
                    <tr style="cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='var(--bg-tertiary)'" onmouseout="this.style.background=''" onclick="document.getElementById('keyword-analysis-input').value='${kw.keyword}'">
                      <td style="padding: 0.5rem; border-bottom: 1px solid var(--border-light);">
                        <span style="font-weight: 600; color: var(--text-strong);">${kw.keyword}</span>
                      </td>
                      <td style="padding: 0.5rem; text-align: right; border-bottom: 1px solid var(--border-light); color: #10b981; font-weight: 600;">
                        ${kw.searchVolume.toLocaleString()}회
                      </td>
                      <td style="padding: 0.5rem; text-align: right; border-bottom: 1px solid var(--border-light); color: ${kw.blogCount <= 1000 ? '#10b981' : kw.blogCount <= 10000 ? '#f59e0b' : '#ef4444'};">
                        ${kw.blogCount.toLocaleString()}개
                      </td>
                      <td style="padding: 0.5rem; text-align: right; border-bottom: 1px solid var(--border-light);">
                        <span style="background: ${kw.score >= 70 ? '#10b981' : kw.score >= 50 ? '#f59e0b' : '#ef4444'}; color: white; padding: 0.2rem 0.5rem; border-radius: 4px; font-weight: 600; font-size: 0.8rem;">${kw.score}점</span>
                      </td>
                    </tr>
                  `).join('')}
                </tbody>
              </table>
              
              <p style="font-size: 0.75rem; color: var(--text-muted); margin-top: 1rem;">💡 키워드를 클릭하면 입력창에 자동 입력됩니다. | 🔥 문서량 1,000개 이하 = 초황금</p>
            `;
          }
          toastManager.success(`${result.category.icon} ${result.category.name} 황금키워드 ${result.keywords.length}개 발견!`);
        } else {
          if (contentDiv) {
            contentDiv.innerHTML = `
              <div style="text-align: center; padding: 2rem;">
                <div style="font-size: 3rem; margin-bottom: 1rem;">😢</div>
                <h5 style="margin: 0 0 0.5rem 0; color: var(--text-strong);">황금키워드를 찾지 못했습니다</h5>
                <p style="color: var(--text-muted); font-size: 0.9rem;">다른 카테고리를 선택하거나 잠시 후 다시 시도해주세요.</p>
              </div>
            `;
          }
          toastManager.warning(result.message || '발견된 황금키워드가 없습니다.');
        }
      }, 500);
    } catch (error) {
      clearInterval(progressInterval);
      console.error('[DiscoverGolden] 오류:', error);
      toastManager.error('발견 중 오류 발생: ' + (error as Error).message);
    } finally {
      discoverGoldenBtn.textContent = '🔍 황금키워드 찾기';
      (discoverGoldenBtn as HTMLButtonElement).disabled = false;
    }
  });

  // ✅ 레거시: 카테고리별 황금키워드 발견 (전체) - 사용 안 함
  /*
  const discoverGoldenBtnLegacy = document.getElementById('discover-golden-btn-legacy');
  discoverGoldenBtnLegacy?.addEventListener('click', async () => {
    // 진행률 UI 표시
    const resultDiv = document.getElementById('keyword-analysis-result');
    const contentDiv = document.getElementById('keyword-result-content');
    
    if (resultDiv && contentDiv) {
      resultDiv.style.display = 'block';
      contentDiv.innerHTML = `레거시 기능`;
    }
    
    try {
      const result = await (window as any).electronAPI.discoverGoldenKeywordsByCategory(5);
      
      if (result.success && result.categories && result.categories.length > 0) {
        const resultDiv = document.getElementById('keyword-analysis-result');
        const contentDiv = document.getElementById('keyword-result-content');
        
        if (resultDiv && contentDiv) {
          resultDiv.style.display = 'block';
          
          let html = `레거시 결과`;
          
          for (const category of result.categories) {
            html += `카테고리: ${category.name}`;
          }
          
          contentDiv.innerHTML = html;
        }
      }
    } catch (error) {
      console.error('[DiscoverGolden] 오류:', error);
    }
  });
  */

  // ✅ 경쟁 분석 버튼
  const analyzeCompetitorBtn = document.getElementById('analyze-competitor-btn');
  analyzeCompetitorBtn?.addEventListener('click', async () => {
    const input = document.getElementById('competitor-keyword-input') as HTMLInputElement;
    const keyword = input?.value.trim();
    if (!keyword) {
      toastManager.warning('키워드를 입력해주세요.');
      return;
    }

    analyzeCompetitorBtn.textContent = '분석 중...';
    (analyzeCompetitorBtn as HTMLButtonElement).disabled = true;

    try {
      const result = await (window as any).electronAPI.analyzeCompetitors(keyword);
      if (result.success && result.result) {
        const analysis = result.result;
        const resultDiv = document.getElementById('competitor-analysis-result');
        const contentDiv = document.getElementById('competitor-result-content');

        if (resultDiv && contentDiv) {
          resultDiv.style.display = 'block';

          const difficultyColors: Record<string, string> = {
            'easy': '#10b981',
            'medium': '#f59e0b',
            'hard': '#ef4444',
            'very_hard': '#dc2626'
          };
          const difficultyLabels: Record<string, string> = {
            'easy': '쉬움',
            'medium': '보통',
            'hard': '어려움',
            'very_hard': '매우 어려움'
          };

          contentDiv.innerHTML = `
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
              <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px; text-align: center;">
                <div style="font-size: 0.85rem; color: var(--text-muted);">난이도</div>
                <div style="font-size: 1.1rem; font-weight: 700; color: ${difficultyColors[analysis.difficulty] || '#666'};">${difficultyLabels[analysis.difficulty] || analysis.difficulty}</div>
              </div>
              <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px; text-align: center;">
                <div style="font-size: 0.85rem; color: var(--text-muted);">평균 글자수</div>
                <div style="font-size: 1.1rem; font-weight: 700; color: var(--text-strong);">${analysis.contentAnalysis?.avgWordCount?.toLocaleString() || '-'}자</div>
              </div>
              <div style="background: var(--bg-tertiary); padding: 1rem; border-radius: 8px; text-align: center;">
                <div style="font-size: 0.85rem; color: var(--text-muted);">평균 이미지</div>
                <div style="font-size: 1.1rem; font-weight: 700; color: var(--text-strong);">${analysis.contentAnalysis?.avgImageCount || '-'}개</div>
              </div>
            </div>
            
            <div style="padding: 1rem; background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(124, 58, 237, 0.05)); border-radius: 8px; margin-bottom: 1rem;">
              <strong style="color: var(--primary);">🎯 승리 전략</strong>
              <p style="margin: 0.5rem 0 0 0; color: var(--text-strong);">${analysis.winningStrategy || '-'}</p>
            </div>
            
            <div style="padding: 1rem; background: var(--bg-tertiary); border-radius: 8px; margin-bottom: 1rem;">
              <strong>💡 인사이트</strong>
              <ul style="margin: 0.5rem 0 0 0; padding-left: 1.25rem; color: var(--text-muted);">
                ${(analysis.insights || []).map((i: string) => `<li>${i}</li>`).join('')}
              </ul>
            </div>
            
            <div style="padding: 1rem; background: var(--bg-tertiary); border-radius: 8px;">
              <strong>📝 추천 사항</strong>
              <ul style="margin: 0.5rem 0 0 0; padding-left: 1.25rem; color: var(--text-muted);">
                ${(analysis.recommendations || []).map((r: string) => `<li>${r}</li>`).join('')}
              </ul>
            </div>
          `;
        }
        toastManager.success('경쟁 분석 완료!');
      } else {
        toastManager.error(result.message || '분석 실패');
      }
    } catch (error) {
      console.error('[Competitor] 오류:', error);
      toastManager.error('분석 중 오류 발생: ' + (error as Error).message);
    } finally {
      analyzeCompetitorBtn.textContent = '🔍 경쟁 분석';
      (analyzeCompetitorBtn as HTMLButtonElement).disabled = false;
    }
  });

  // ✅ 제목 후보 생성 버튼
  const generateTitlesBtn = document.getElementById('generate-titles-btn');
  generateTitlesBtn?.addEventListener('click', async () => {
    const keywordInput = document.getElementById('title-keyword-input') as HTMLInputElement;
    const categorySelect = document.getElementById('title-category-select') as HTMLSelectElement;
    const keyword = keywordInput?.value.trim();
    const category = categorySelect?.value;

    if (!keyword) {
      toastManager.warning('키워드를 입력해주세요.');
      return;
    }

    generateTitlesBtn.textContent = '생성 중...';
    (generateTitlesBtn as HTMLButtonElement).disabled = true;

    try {
      const result = await (window as any).electronAPI.generateTitleCandidates(keyword, category || undefined, 5);
      if (result.success && result.result) {
        const abResult = result.result;
        const resultDiv = document.getElementById('title-ab-result');
        const contentDiv = document.getElementById('title-result-content');

        if (resultDiv && contentDiv) {
          resultDiv.style.display = 'block';
          contentDiv.innerHTML = `
            <div style="display: flex; flex-direction: column; gap: 0.75rem;">
              ${abResult.candidates.map((c: any, idx: number) => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem; background: ${idx === 0 ? 'linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(5, 150, 105, 0.1))' : 'var(--bg-tertiary)'}; border-radius: 8px; border: ${idx === 0 ? '2px solid rgba(16, 185, 129, 0.4)' : '1px solid var(--border-light)'};">
                  <div style="flex: 1;">
                    <div style="font-weight: 600; color: var(--text-strong); margin-bottom: 0.25rem;">${idx === 0 ? '🏆 ' : ''}${c.title}</div>
                    <div style="font-size: 0.8rem; color: var(--text-muted);">${c.style} · ${c.reasons?.[0] || ''}</div>
                  </div>
                  <div style="text-align: right; min-width: 60px;">
                    <div style="font-size: 1.25rem; font-weight: 700; color: ${c.score >= 80 ? '#10b981' : c.score >= 60 ? '#f59e0b' : '#ef4444'};">${c.score}</div>
                    <div style="font-size: 0.75rem; color: var(--text-muted);">CTR 점수</div>
                  </div>
                </div>
              `).join('')}
            </div>
          `;
        }
        toastManager.success('제목 후보 생성 완료!');
      } else {
        toastManager.error(result.message || '생성 실패');
      }
    } catch (error) {
      console.error('[TitleAB] 오류:', error);
      toastManager.error('생성 중 오류 발생: ' + (error as Error).message);
    } finally {
      generateTitlesBtn.textContent = '✨ 제목 후보 생성';
      (generateTitlesBtn as HTMLButtonElement).disabled = false;
    }
  });

  // ✅ 제목 평가 버튼
  const evaluateTitleBtn = document.getElementById('evaluate-title-btn');
  evaluateTitleBtn?.addEventListener('click', async () => {
    const input = document.getElementById('evaluate-title-input') as HTMLInputElement;
    const categorySelect = document.getElementById('title-category-select') as HTMLSelectElement;
    const title = input?.value.trim();

    if (!title) {
      toastManager.warning('평가할 제목을 입력해주세요.');
      return;
    }

    try {
      const result = await (window as any).electronAPI.evaluateTitle(title, categorySelect?.value || undefined);
      if (result.success && result.evaluation) {
        const ev = result.evaluation;
        toastManager.info(`📊 점수: ${ev.score}점 (${ev.style}) - ${ev.reasons?.[0] || ''}`);
      } else {
        toastManager.error(result.message || '평가 실패');
      }
    } catch (error) {
      toastManager.error('평가 중 오류 발생');
    }
  });

  // ✅ 성과 추적 추가 버튼
  const addTrackPostBtn = document.getElementById('add-track-post-btn');
  addTrackPostBtn?.addEventListener('click', async () => {
    const input = document.getElementById('track-post-url') as HTMLInputElement;
    const url = input?.value.trim();

    if (!url) {
      toastManager.warning('추적할 글 URL을 입력해주세요.');
      return;
    }

    try {
      const result = await (window as any).electronAPI.addPostToTrack(url);
      if (result.success) {
        toastManager.success('글이 추적 목록에 추가되었습니다.');
        input.value = '';
        // 목록 새로고침
        refreshTrackingList();
      } else {
        toastManager.error(result.message || '추가 실패');
      }
    } catch (error) {
      toastManager.error('추가 중 오류 발생');
    }
  });

  // 추적 목록 새로고침 함수
  async function refreshTrackingList() {
    try {
      const result = await (window as any).electronAPI.getAllTrackedPosts();
      const listDiv = document.getElementById('tracking-posts-list');
      if (listDiv && result.success && result.posts) {
        if (result.posts.length === 0) {
          listDiv.innerHTML = '<div style="color: var(--text-muted); font-style: italic;">추적 중인 글이 없습니다.</div>';
        } else {
          listDiv.innerHTML = result.posts.map((post: any) => `
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px; margin-bottom: 0.5rem;">
              <div style="flex: 1; overflow: hidden;">
                <div style="font-weight: 600; color: var(--text-strong); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${post.title || post.url}</div>
                <div style="font-size: 0.8rem; color: var(--text-muted);">조회: ${post.views || 0} · 댓글: ${post.comments || 0} · 공감: ${post.likes || 0}</div>
              </div>
            </div>
          `).join('');
        }
      }
    } catch (error) {
      console.error('추적 목록 로드 실패:', error);
    }
  }

  // 전체 새로고침 버튼
  document.getElementById('refresh-analytics-btn')?.addEventListener('click', refreshTrackingList);
});

// ✅ 다계정 관리 기능 초기화 함수
async function initMultiAccountManager() {
  console.log('[MultiAccount] 다계정 관리 기능 초기화 시작');

  const accountListContainer = document.getElementById('account-list');
  const noAccountsMessage = document.getElementById('no-accounts-message');
  const accountStatsSummary = document.getElementById('account-stats-summary');
  const addAccountBtn = document.getElementById('add-account-btn');

  if (!accountListContainer || !addAccountBtn) {
    console.log('[MultiAccount] 다계정 관리 UI 요소를 찾을 수 없습니다.');
    return;
  }

  // 계정 목록 렌더링 함수
  async function renderAccountList() {
    try {
      const result = await window.api.getAllBlogAccounts();
      if (!result.success || !result.accounts) {
        console.error('[MultiAccount] 계정 목록 로드 실패:', result.message);
        return;
      }

      const accounts = result.accounts;
      console.log('[MultiAccount] 계정 목록 로드:', accounts.length, '개');

      if (accounts.length === 0) {
        accountListContainer!.innerHTML = '';
        if (noAccountsMessage) noAccountsMessage.style.display = 'block';
        if (accountStatsSummary) accountStatsSummary.style.display = 'none';
        return;
      }

      if (noAccountsMessage) noAccountsMessage.style.display = 'none';
      if (accountStatsSummary) accountStatsSummary.style.display = 'block';

      // 통계 업데이트
      const statsResult = await window.api.getTotalBlogStats();
      if (statsResult.success && statsResult.stats) {
        const stats = statsResult.stats;
        const totalAccountsEl = document.getElementById('stats-total-accounts');
        const activeAccountsEl = document.getElementById('stats-active-accounts');
        const todayPostsEl = document.getElementById('stats-today-posts');
        const weekPostsEl = document.getElementById('stats-week-posts');

        if (totalAccountsEl) totalAccountsEl.textContent = String(stats.totalAccounts);
        if (activeAccountsEl) activeAccountsEl.textContent = String(stats.activeAccounts);
        if (todayPostsEl) todayPostsEl.textContent = String(stats.todayTotalPosts);
        if (weekPostsEl) weekPostsEl.textContent = String(stats.weekTotalPosts);
      }

      // 활성 계정 확인
      const activeResult = await window.api.getActiveBlogAccount();
      const activeAccountId = activeResult.success && activeResult.account ? activeResult.account.id : null;

      // 계정 목록 HTML 생성
      accountListContainer!.innerHTML = accounts.map((account: any) => {
        const isActive = account.id === activeAccountId;
        const hasCredentials = account.naverId ? true : false;

        return `
          <div class="account-item" data-account-id="${account.id}" style="
            display: flex; 
            align-items: center; 
            justify-content: space-between; 
            padding: 0.75rem 1rem; 
            background: ${isActive ? 'rgba(16, 185, 129, 0.15)' : 'rgba(255, 255, 255, 0.05)'}; 
            border: 2px solid ${isActive ? 'rgba(16, 185, 129, 0.5)' : 'rgba(255, 255, 255, 0.1)'}; 
            border-radius: 10px;
            transition: all 0.2s;
          ">
            <div style="display: flex; align-items: center; gap: 0.75rem; flex: 1;">
              <div style="
                width: 40px; 
                height: 40px; 
                border-radius: 50%; 
                background: ${isActive ? 'linear-gradient(135deg, #10b981, #059669)' : 'linear-gradient(135deg, #6366f1, #4f46e5)'}; 
                display: flex; 
                align-items: center; 
                justify-content: center; 
                font-size: 1.25rem;
              ">
                ${isActive ? '✓' : '👤'}
              </div>
              <div>
                <div style="font-weight: 600; color: var(--text-strong); display: flex; align-items: center; gap: 0.5rem;">
                  ${escapeHtml(account.name)}
                  ${isActive ? '<span style="font-size: 0.7rem; background: #10b981; color: white; padding: 0.15rem 0.5rem; border-radius: 4px;">활성</span>' : ''}
                  ${hasCredentials ? '<span style="font-size: 0.7rem; background: #3b82f6; color: white; padding: 0.15rem 0.5rem; border-radius: 4px;">로그인 정보 저장됨</span>' : ''}
                </div>
                <div style="font-size: 0.8rem; color: var(--text-muted);">
                  @${escapeHtml(account.blogId)} · 오늘 ${account.todayPosts || 0}/${account.settings?.dailyLimit || 5}건
                  ${account.settings?.autoRotate ? ' · 🔄 자동순환' : ''}
                </div>
              </div>
            </div>
            <div style="display: flex; gap: 0.5rem;">
              ${!isActive ? `
                <button type="button" class="set-active-btn" data-account-id="${account.id}" style="
                  padding: 0.4rem 0.75rem; 
                  background: linear-gradient(135deg, #10b981, #059669); 
                  color: white; 
                  border: none; 
                  border-radius: 6px; 
                  font-size: 0.75rem; 
                  cursor: pointer;
                  font-weight: 600;
                ">활성화</button>
              ` : ''}
              <button type="button" class="toggle-account-btn" data-account-id="${account.id}" style="
                padding: 0.4rem 0.75rem; 
                background: ${account.isActive ? 'rgba(245, 158, 11, 0.2)' : 'rgba(16, 185, 129, 0.2)'}; 
                color: ${account.isActive ? '#f59e0b' : '#10b981'}; 
                border: 1px solid ${account.isActive ? '#f59e0b' : '#10b981'}; 
                border-radius: 6px; 
                font-size: 0.75rem; 
                cursor: pointer;
                font-weight: 600;
              ">${account.isActive ? '비활성화' : '활성화'}</button>
              <button type="button" class="remove-account-btn" data-account-id="${account.id}" style="
                padding: 0.4rem 0.75rem; 
                background: rgba(239, 68, 68, 0.2); 
                color: #ef4444; 
                border: 1px solid #ef4444; 
                border-radius: 6px; 
                font-size: 0.75rem; 
                cursor: pointer;
                font-weight: 600;
              ">삭제</button>
            </div>
          </div>
        `;
      }).join('');

      // 이벤트 리스너 등록
      accountListContainer!.querySelectorAll('.set-active-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          const accountId = (e.target as HTMLElement).dataset.accountId;
          if (accountId) {
            const result = await window.api.setActiveBlogAccount(accountId);
            if (result.success) {
              toastManager.success('활성 계정이 변경되었습니다.');
              await renderAccountList();
            } else {
              toastManager.error(result.message || '활성화 실패');
            }
          }
        });
      });

      accountListContainer!.querySelectorAll('.toggle-account-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          const accountId = (e.target as HTMLElement).dataset.accountId;
          if (accountId) {
            const result = await window.api.toggleBlogAccount(accountId);
            if (result.success) {
              toastManager.success(result.isActive ? '계정이 활성화되었습니다.' : '계정이 비활성화되었습니다.');
              await renderAccountList();
            } else {
              toastManager.error(result.message || '토글 실패');
            }
          }
        });
      });

      accountListContainer!.querySelectorAll('.remove-account-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          const accountId = (e.target as HTMLElement).dataset.accountId;
          if (accountId && confirm('정말로 이 계정을 삭제하시겠습니까?')) {
            const result = await window.api.removeBlogAccount(accountId);
            if (result.success) {
              toastManager.success('계정이 삭제되었습니다.');
              await renderAccountList();
            } else {
              toastManager.error(result.message || '삭제 실패');
            }
          }
        });
      });

    } catch (error) {
      console.error('[MultiAccount] 계정 목록 렌더링 오류:', error);
    }
  }

  // 계정 추가 버튼 이벤트
  addAccountBtn.addEventListener('click', async () => {
    const nameInput = document.getElementById('new-account-name') as HTMLInputElement;
    const blogIdInput = document.getElementById('new-account-blog-id') as HTMLInputElement;
    const naverIdInput = document.getElementById('new-account-naver-id') as HTMLInputElement;
    const naverPwInput = document.getElementById('new-account-naver-pw') as HTMLInputElement;
    const dailyLimitInput = document.getElementById('new-account-daily-limit') as HTMLInputElement;
    const autoRotateInput = document.getElementById('new-account-auto-rotate') as HTMLInputElement;

    const name = nameInput?.value.trim();
    const blogId = blogIdInput?.value.trim();
    const naverId = naverIdInput?.value.trim();
    const naverPw = naverPwInput?.value;
    const dailyLimit = parseInt(dailyLimitInput?.value || '5');
    const autoRotate = autoRotateInput?.checked ?? true;

    if (!name || !blogId) {
      toastManager.warning('계정 별명과 블로그 ID는 필수입니다.');
      return;
    }

    try {
      const result = await window.api.addBlogAccount(name, blogId, naverId || undefined, naverPw || undefined, {
        dailyLimit,
        autoRotate
      });

      if (result.success) {
        toastManager.success(`계정 "${name}"이(가) 추가되었습니다.`);

        // 입력 필드 초기화
        if (nameInput) nameInput.value = '';
        if (blogIdInput) blogIdInput.value = '';
        if (naverIdInput) naverIdInput.value = '';
        if (naverPwInput) naverPwInput.value = '';
        if (dailyLimitInput) dailyLimitInput.value = '5';
        if (autoRotateInput) autoRotateInput.checked = true;

        await renderAccountList();
      } else {
        toastManager.error(result.message || '계정 추가 실패');
      }
    } catch (error) {
      console.error('[MultiAccount] 계정 추가 오류:', error);
      toastManager.error('계정 추가 중 오류가 발생했습니다.');
    }
  });

  // ✅ 계정 동기화 버튼 이벤트
  const syncAccountsBtn = document.getElementById('ar-sync-accounts-btn');
  syncAccountsBtn?.addEventListener('click', async () => {
    try {
      syncAccountsBtn.innerHTML = '<span>🔄</span> 동기화 중...';
      (syncAccountsBtn as HTMLButtonElement).disabled = true;

      const result = await (window.api as any).adminSyncAccounts();
      if (result.success) {
        toastManager.success('네이버 계정 정보가 패널로 동기화되었습니다.');
      } else {
        toastManager.error(result.message || '동기화 실패');
      }
    } catch (error) {
      console.error('[AccountSync] 동기화 오류:', error);
      toastManager.error('동기화 중 오류가 발생했습니다.');
    } finally {
      syncAccountsBtn.innerHTML = '<span>🔄</span> 패널로 계정 동기화';
      (syncAccountsBtn as HTMLButtonElement).disabled = false;
    }
  });

  // 초기 렌더링
  await renderAccountList();
  console.log('[MultiAccount] 다계정 관리 기능 초기화 완료');
}

// ✅ 다중계정 동시발행 모달 초기화 함수

// ✅ 비용 안전성을 고려한 이미지 생성 래퍼 함수 (자동화용)
// ✅ [2026-01-20 개선] 재시도 로직 + 부분 성공 처리 + 성공률 로깅
async function generateImagesForAutomation(
  provider: string,
  headings: any[],
  postTitle: string,
  options: {
    stopCheck?: () => boolean;
    onProgress?: (msg: string) => void;
    allowThumbnailText?: boolean;
    referenceImagePath?: string; // ✅ 참조 이미지 경로 추가
    collectedImages?: any[]; // ✅ [2026-01-21 FIX] 수집된 이미지 배열 추가
  } = {}
): Promise<any[]> {
  const { stopCheck, onProgress } = options;

  // ✅ [Debug] 썸네일 텍스트 옵션 로깅
  console.log(`[generateImagesForAutomation] 🖼️ allowThumbnailText = ${options.allowThumbnailText}, provider = ${provider}`);

  if (stopCheck && stopCheck()) return [];

  // ✅ [핵심 변경] 별도 썸네일 항목 없음!
  // 첫 번째 소제목 이미지 = 썸네일 (텍스트 포함 옵션이 켜져 있으면 텍스트 합성)
  // 쇼핑 커넥트 모드에서는 타이핑 순서만 다름 (이미지 → 소제목 → 본문)
  const items = headings.map((h: any, idx: number) => {
    const title = h.title || h.text || h.heading || (typeof h === 'string' ? h : '');
    return {
      heading: title,
      prompt: idx === 0 ? postTitle : (h.prompt || h.imagePrompt || title || 'Abstract Image'),
      // ✅ 첫 번째 이미지만 텍스트 포함 여부 적용 (썸네일화)
      isThumbnail: idx === 0,
      allowText: idx === 0 ? (options.allowThumbnailText || false) : false,
      referenceImagePath: h.referenceImagePath || options.referenceImagePath
    };
  }).filter(it => !!it.heading && it.heading.trim() !== '');

  // 소제목이 없는 경우 최소 1개 항목 생성
  if (items.length === 0 && postTitle) {
    items.push({
      heading: postTitle,
      prompt: postTitle,
      isThumbnail: true,
      allowText: options.allowThumbnailText || false,
      referenceImagePath: options.referenceImagePath
    });
  }

  onProgress?.(`🚀 이미지 생성 요청: ${items.length}개 (Provider: ${provider})`);

  // ✅ [2026-01-24 FIX] 재시도 로직 강화 - 연속 발행 안정성 개선
  const MAX_RETRIES = 3;  // 2 → 3회로 증가
  let lastError: Error | null = null;
  let bestResult: any = null;  // 부분 성공 시 최선의 결과 저장

  for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
    try {
      if (stopCheck && stopCheck()) return bestResult?.images || [];

      // 1. 메인 프로세스에 이미지 생성 요청
      const result = await generateImagesWithCostSafety({
        provider: provider,
        items: items,
        postTitle: postTitle,
        regenerate: false,
        referenceImagePath: options.referenceImagePath,
        collectedImages: options.collectedImages  // ✅ [2026-01-21 FIX] 수집된 이미지 전달
      });

      if (stopCheck && stopCheck()) return result?.images || bestResult?.images || [];

      if (result.success && result.images && result.images.length > 0) {
        const successCount = result.images.length;
        const totalRequested = items.length;
        const successRate = Math.round((successCount / totalRequested) * 100);

        // ✅ [2026-01-24 FIX] 부분 성공 저장 (나중에 더 나은 결과가 없으면 이것 사용)
        if (!bestResult || result.images.length > (bestResult.images?.length || 0)) {
          bestResult = result;
        }

        // ✅ 50% 이상 성공 시 즉시 반환 (부분 성공 허용)
        if (successRate >= 50) {
          onProgress?.(`✅ ${successCount}/${totalRequested}개 이미지 생성 완료 (성공률: ${successRate}%)`);
          console.log(`[Image Stats] 생성 성공률: ${successRate}% (${successCount}/${totalRequested}), 시도: ${attempt}/${MAX_RETRIES}`);
          return result.images;
        } else {
          // 50% 미만이면 더 시도
          console.log(`[Image Stats] 부분 성공 (${successRate}%), 더 나은 결과를 위해 재시도...`);
          if (attempt < MAX_RETRIES) {
            throw new Error(`이미지 생성 부분 성공 (${successCount}/${totalRequested}), 재시도 중...`);
          }
        }
      } else if (result.images && result.images.length === 0) {
        throw new Error('이미지 생성 결과가 비어있음');
      } else {
        throw new Error(result.message || '이미지 생성 결과 없음');
      }

    } catch (error) {
      lastError = error as Error;
      console.error(`[generateImagesForAutomation] 시도 ${attempt}/${MAX_RETRIES} 실패:`, error);

      if (attempt < MAX_RETRIES) {
        // ✅ [2026-01-24 FIX] 대기 시간 증가: 5초, 10초, 15초 (API 레이트 리밋 대응)
        const waitTime = 5000 * attempt; // 5초, 10초, 15초
        onProgress?.(`⚠️ 이미지 생성 실패 (${attempt}/${MAX_RETRIES}), ${waitTime / 1000}초 후 재시도...`);
        await new Promise(resolve => setTimeout(resolve, waitTime));
      }
    }
  }

  // ✅ [2026-01-24 FIX] 모든 재시도 실패해도 부분 성공 결과가 있으면 반환
  if (bestResult && bestResult.images && bestResult.images.length > 0) {
    const successCount = bestResult.images.length;
    const totalRequested = items.length;
    onProgress?.(`⚠️ 부분 성공: ${successCount}/${totalRequested}개 이미지 생성 (일부만 완료)`);
    console.log(`[Image Stats] 부분 성공 반환: ${successCount}/${totalRequested}개`);
    return bestResult.images;
  }

  // 모든 재시도 실패
  onProgress?.(`❌ 이미지 생성 최종 실패 (${MAX_RETRIES}회 시도): ${lastError?.message || '알 수 없는 오류'}`);
  throw lastError || new Error('이미지 생성 실패');
}

async function initMultiAccountPublishModal() {

  console.log('[MultiAccountPublish] 다중계정 동시발행 모달 초기화 시작');

  const multiAccountBtn = document.getElementById('multi-account-btn');
  const multiAccountModal = document.getElementById('multi-account-modal');
  const accountEditModal = document.getElementById('ma-account-edit-modal');

  if (!multiAccountBtn || !multiAccountModal) {
    console.log('[MultiAccountPublish] 모달 요소를 찾을 수 없습니다.');
    return;
  }

  // ✅ 모달이 body의 직접 자식이 아니면 body로 이동 (중첩 문제 해결)
  if (multiAccountModal.parentElement !== document.body) {
    console.log('[MultiAccountPublish] 모달을 body로 이동합니다.');
    document.body.appendChild(multiAccountModal);
  }

  // 선택된 계정 ID 목록
  let selectedAccountIds: string[] = [];
  let isPublishing = false;
  let stopRequested = false;

  // 모달 열기
  multiAccountBtn.addEventListener('click', async () => {
    console.log('[MultiAccountPublish] 모달 열기 버튼 클릭');

    // 먼저 모달을 표시
    multiAccountModal.style.display = 'flex';
    multiAccountModal.setAttribute('aria-hidden', 'false');

    // 그 다음 계정 목록 로드 (에러가 나도 모달은 열린 상태 유지)
    try {
      await renderMultiAccountList();
    } catch (error) {
      console.error('[MultiAccountPublish] 계정 목록 로드 중 오류:', error);
      // 오류가 발생해도 모달은 계속 표시
      const container = document.getElementById('ma-accounts-container');
      if (container) {
        container.innerHTML = `
          <div style="text-align: center; padding: 2rem; color: #ef4444;">
            <div style="font-size: 2rem; margin-bottom: 0.5rem;">⚠️</div>
            <p>계정 목록을 불러오지 못했습니다</p>
            <p style="font-size: 0.85rem; color: var(--text-muted);">${(error as Error).message}</p>
          </div>
        `;
      }
    }
  });

  // 모달 닫기
  document.querySelectorAll('[data-close-multi-account]').forEach(btn => {
    btn.addEventListener('click', () => {
      multiAccountModal.style.display = 'none';
      multiAccountModal.setAttribute('aria-hidden', 'true');
    });
  });

  // 계정 편집 모달 닫기
  document.querySelectorAll('[data-close-ma-edit]').forEach(btn => {
    btn.addEventListener('click', () => {
      if (accountEditModal) {
        accountEditModal.style.display = 'none';
        accountEditModal.setAttribute('aria-hidden', 'true');
      }
    });
  });

  // 연속 발행 모드 토글
  const continuousModeCheckbox = document.getElementById('ma-continuous-mode') as HTMLInputElement;
  const continuousSettings = document.getElementById('ma-continuous-settings');
  continuousModeCheckbox?.addEventListener('change', () => {
    if (continuousSettings) {
      continuousSettings.style.display = continuousModeCheckbox.checked ? 'flex' : 'none';
    }
  });

  // ✅ 콘텐츠 모드 선택 UI (다중계정)
  const maContentModeBtns = document.querySelectorAll('.ma-content-mode-btn');
  const maContentModeInput = document.getElementById('ma-content-mode') as HTMLInputElement;
  const maShoppingConnectSettings = document.getElementById('ma-shopping-connect-settings');

  maContentModeBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const mode = (btn as HTMLElement).dataset.mode;
      if (mode) {
        // 모든 버튼 선택 해제
        maContentModeBtns.forEach(b => b.classList.remove('selected'));
        // 현재 버튼 선택
        btn.classList.add('selected');

        // input 값 업데이트
        if (maContentModeInput) maContentModeInput.value = mode;

        // 쇼핑커넥트 모드 선택 시 설정 UI 표시
        if (maShoppingConnectSettings) {
          if (mode === 'affiliate') {
            maShoppingConnectSettings.style.display = 'block';
            // 애니메이션
            maShoppingConnectSettings.animate([
              { opacity: 0, transform: 'translateY(-10px)' },
              { opacity: 1, transform: 'translateY(0)' }
            ], { duration: 300, easing: 'ease-out' });
          } else {
            maShoppingConnectSettings.style.display = 'none';
          }
        }
      }
    });
  });

  // 계정 목록 렌더링
  async function renderMultiAccountList() {
    const container = document.getElementById('ma-accounts-container');
    const noAccountsMsg = document.getElementById('ma-no-accounts');

    if (!container) {
      console.warn('[MultiAccountPublish] ma-accounts-container 요소가 없습니다.');
      return;
    }

    try {
      console.log('[MultiAccountPublish] 계정 목록 로드 시작...');

      // window.api 존재 여부 확인
      if (!window.api) {
        console.error('[MultiAccountPublish] window.api가 정의되지 않았습니다!');
        container.innerHTML = `
          <div style="text-align: center; padding: 2rem; color: #ef4444;">
            <div style="font-size: 2rem; margin-bottom: 0.5rem;">⚠️</div>
            <p>API가 초기화되지 않았습니다</p>
            <p style="font-size: 0.85rem; color: var(--text-muted);">앱을 재시작해주세요</p>
          </div>
        `;
        if (noAccountsMsg) noAccountsMsg.style.display = 'none';
        return;
      }

      // getAllBlogAccounts 함수 존재 여부 확인
      if (typeof window.api.getAllBlogAccounts !== 'function') {
        console.error('[MultiAccountPublish] window.api.getAllBlogAccounts 함수가 없습니다!');
        container.innerHTML = `
          <div style="text-align: center; padding: 2rem; color: #ef4444;">
            <div style="font-size: 2rem; margin-bottom: 0.5rem;">⚠️</div>
            <p>계정 API가 없습니다</p>
            <p style="font-size: 0.85rem; color: var(--text-muted);">앱 버전을 확인해주세요</p>
          </div>
        `;
        if (noAccountsMsg) noAccountsMsg.style.display = 'none';
        return;
      }

      const result = await window.api.getAllBlogAccounts();
      console.log('[MultiAccountPublish] getAllBlogAccounts 결과:', result);

      if (!result.success || !result.accounts) {
        console.warn('[MultiAccountPublish] 계정 로드 실패:', result.message);
        if (noAccountsMsg) noAccountsMsg.style.display = 'block';
        return;
      }

      const accounts = result.accounts;

      if (accounts.length === 0) {
        if (noAccountsMsg) noAccountsMsg.style.display = 'block';
        return;
      }

      if (noAccountsMsg) noAccountsMsg.style.display = 'none';

      // 계정 카드 HTML 생성 (풀오토 세팅 버튼 추가)
      container.innerHTML = accounts.map((account: any) => {
        return `
          <div class="ma-account-card" data-account-id="${account.id}" style="
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 0.875rem;
            transition: all 0.2s;
          ">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div style="display: flex; align-items: center; gap: 0.75rem;">
                <div>
                  <div style="font-weight: 700; color: var(--text-strong); font-size: 1rem;">
                    👤 ${escapeHtml(account.name)}
                  </div>
                  <div style="font-size: 0.75rem; color: var(--text-muted);">ID: ${escapeHtml(account.blogId || account.name)}</div>
                </div>
              </div>
              <div style="display: flex; gap: 0.5rem;">
                <button type="button" class="ma-fullauto-btn" data-account-id="${account.id}" data-account-name="${escapeHtml(account.name)}" style="padding: 0.4rem 0.75rem; background: linear-gradient(135deg, #10b981, #059669); color: white; border: none; border-radius: 6px; font-size: 0.8rem; cursor: pointer; font-weight: 600;">⚡ 풀오토 세팅</button>
                <button type="button" class="ma-edit-btn" data-account-id="${account.id}" style="padding: 0.4rem 0.6rem; background: rgba(59, 130, 246, 0.2); color: #3b82f6; border: 1px solid #3b82f6; border-radius: 6px; font-size: 0.75rem; cursor: pointer;">⚙️ 편집</button>
                <button type="button" class="ma-delete-btn" data-account-id="${account.id}" style="padding: 0.4rem 0.6rem; background: rgba(239, 68, 68, 0.2); color: #ef4444; border: 1px solid #ef4444; border-radius: 6px; font-size: 0.75rem; cursor: pointer;">🗑️</button>
              </div>
            </div>
          </div>
        `;
      }).join('');

      // 풀오토 세팅 버튼 이벤트
      container.querySelectorAll('.ma-fullauto-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const button = e.target as HTMLElement;
          const accountId = button.dataset.accountId;
          const accountName = button.dataset.accountName;
          if (accountId && accountName) {
            openFullautoSettingModal(accountId, accountName);
          }
        });
      });

      // 편집 버튼 이벤트
      container.querySelectorAll('.ma-edit-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          e.stopPropagation();
          const accountId = (e.target as HTMLElement).closest('button')?.dataset.accountId;
          if (accountId) await openAccountEditModal(accountId);
        });
      });

      // 삭제 버튼 이벤트
      container.querySelectorAll('.ma-delete-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          e.stopPropagation();
          const accountId = (e.target as HTMLElement).closest('button')?.dataset.accountId;
          if (accountId && confirm('정말로 이 계정을 삭제하시겠습니까?')) {
            await window.api.removeBlogAccount(accountId);
            selectedAccountIds = selectedAccountIds.filter(id => id !== accountId);
            await renderMultiAccountList();
            updateSelectedCount();
          }
        });
      });

    } catch (error) {
      console.error('[MultiAccountPublish] 계정 목록 렌더링 오류:', error);
    }
  }

  // ✅ 발행 대기열 타입 정의
  interface QueueItem {
    id: string;
    accountId: string;
    accountName: string;
    sourceUrl: string;
    sourceKeyword: string;
    imageSource: string;
    toneStyle: string;
    category?: string;
    contentMode?: 'seo' | 'homefeed' | 'affiliate'; // ✅ [FIX] 쇼핑커넥트 모드 추가
    ctaType: 'none' | 'previous-post' | 'custom';
    ctaUrl: string;
    ctaText: string;
    includeThumbnailText?: boolean;
    useAiImage?: boolean; // ✅ AI 이미지 생성 사용 여부
    createProductThumbnail?: boolean; // ✅ 제품 이미지 기반 썸네일 합성 여부
    publishMode?: string;
    scheduleDate?: string;
    scheduleType?: 'app-schedule' | 'naver-server';
    affiliateLink?: string; // ✅ [2026-01-20] 쇼핑커넥트 제휴 링크
    videoOption?: boolean;  // ✅ [2026-01-20] VEO 영상 변환 옵션
    manualThumbnail?: string | null; // ✅ [2026-01-22] 수동 썸네일 경로
  }

  // ✅ 발행 대기열
  let publishQueue: QueueItem[] = [];

  // ✅ 대기열 UI 업데이트
  function renderQueue() {
    const container = document.getElementById('ma-queue-container');
    const noQueueMsg = document.getElementById('ma-no-queue');
    const queueCountEl = document.getElementById('ma-queue-count');

    if (!container) return;

    if (queueCountEl) {
      queueCountEl.textContent = String(publishQueue.length);
    }

    if (publishQueue.length === 0) {
      if (noQueueMsg) noQueueMsg.style.display = 'block';
      container.innerHTML = '';
      if (noQueueMsg) container.appendChild(noQueueMsg);
      return;
    }

    if (noQueueMsg) noQueueMsg.style.display = 'none';

    container.innerHTML = publishQueue.map((item, index) => {
      const sourceDisplay = item.sourceUrl ? `🔗 ${item.sourceUrl.substring(0, 30)}...` : `🔑 ${item.sourceKeyword}`;
      const toneEmoji = { friendly: '😊', professional: '💼', casual: '🎒', formal: '🎩', humorous: '😄', community_fan: '🔥', mom_cafe: '👩‍👧' }[item.toneStyle] || '😊';
      const ctaBadge = item.ctaType === 'previous-post' ? '<span style="background: #3b82f6; color: white; padding: 0.1rem 0.3rem; border-radius: 3px; font-size: 0.65rem; margin-left: 0.25rem;">🔗이전글</span>' :
        item.ctaType === 'custom' ? '<span style="background: #8b5cf6; color: white; padding: 0.1rem 0.3rem; border-radius: 3px; font-size: 0.65rem; margin-left: 0.25rem;">✏️CTA</span>' : '';

      return `
        <div class="ma-queue-item" data-queue-id="${item.id}" style="
          background: rgba(16, 185, 129, 0.1);
          border: 1px solid rgba(16, 185, 129, 0.3);
          border-radius: 8px;
          padding: 0.75rem;
          display: flex;
          justify-content: space-between;
          align-items: center;
        ">
          <div style="flex: 1; min-width: 0;">
            <div style="font-weight: 600; color: var(--text-strong); font-size: 0.9rem; display: flex; align-items: center; gap: 0.5rem;">
              <span style="background: #10b981; color: white; padding: 0.1rem 0.4rem; border-radius: 4px; font-size: 0.75rem;">${index + 1}</span>
              👤 ${escapeHtml(item.accountName)}${ctaBadge}
            </div>
            <div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.25rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
              ${sourceDisplay} | ${toneEmoji}
            </div>
          </div>
          <button type="button" class="ma-queue-remove-btn" data-queue-id="${item.id}" style="padding: 0.3rem 0.5rem; background: rgba(239, 68, 68, 0.2); color: #ef4444; border: 1px solid #ef4444; border-radius: 4px; font-size: 0.7rem; cursor: pointer;">✕</button>
        </div>
      `;
    }).join('');

    // 삭제 버튼 이벤트
    container.querySelectorAll('.ma-queue-remove-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const queueId = (e.target as HTMLElement).dataset.queueId;
        if (queueId) {
          publishQueue = publishQueue.filter(item => item.id !== queueId);
          renderQueue();
        }
      });
    });
  }

  // ✅ 풀오토 세팅 모달 열기
  function openFullautoSettingModal(accountId: string, accountName: string) {
    const modal = document.getElementById('ma-fullauto-setting-modal');
    if (!modal) return;

    // 계정 설정(잡블로그 여부 등) 캐시
    try {
      (modal as HTMLElement).dataset.isJabBlog = '0';
      (window.api as any).getAllBlogAccounts?.().then((res: any) => {
        const acc = res?.accounts?.find((a: any) => String(a?.id || '') === String(accountId || ''));
        const isJab = acc?.settings?.isJabBlog === true;
        try {
          (modal as HTMLElement).dataset.isJabBlog = isJab ? '1' : '0';
        } catch {
          // ignore
        }
      }).catch(() => {
        // ignore
      });
    } catch {
      // ignore
    }

    // 계정 정보 설정
    const accountIdInput = document.getElementById('ma-setting-account-id') as HTMLInputElement;
    const accountNameEl = document.getElementById('ma-setting-account-name');

    if (accountIdInput) accountIdInput.value = accountId;
    if (accountNameEl) accountNameEl.textContent = `📌 ${accountName}`;

    // 입력 필드 초기화
    const urlInput = document.getElementById('ma-setting-url') as HTMLInputElement;
    const keywordInput = document.getElementById('ma-setting-keyword') as HTMLInputElement;
    const imageSourceSelect = document.getElementById('ma-setting-image-source') as HTMLSelectElement;
    const toneSelect = document.getElementById('ma-setting-tone') as HTMLSelectElement;
    const ctaTypeSelectInit = document.getElementById('ma-setting-cta-type') as HTMLSelectElement | null;
    const ctaUrlInputInit = document.getElementById('ma-setting-cta-url') as HTMLInputElement | null;
    const ctaTextInputInit = document.getElementById('ma-setting-cta-text') as HTMLInputElement | null;

    if (urlInput) urlInput.value = '';
    if (keywordInput) keywordInput.value = '';
    if (imageSourceSelect) {
      const currentUiSource = UnifiedDOMCache.getImageSource();
      imageSourceSelect.value = currentUiSource || 'nano-banana-pro';
    }
    if (toneSelect) toneSelect.value = 'friendly';
    if (ctaTypeSelectInit) ctaTypeSelectInit.value = 'none';
    if (ctaUrlInputInit) ctaUrlInputInit.value = '';
    if (ctaTextInputInit) ctaTextInputInit.value = '';

    // ✅ 콘텐츠 카테고리 버튼 이벤트 (카테고리 모달 열기)
    const categoryBtn = document.getElementById('ma-setting-open-category-btn');
    if (categoryBtn) {
      const newCatBtn = categoryBtn.cloneNode(true) as HTMLButtonElement;
      categoryBtn.parentNode?.replaceChild(newCatBtn, categoryBtn);
      newCatBtn.addEventListener('click', () => {
        // 기존 카테고리 모달 열기 함수 호출
        (window as any).openCategoryModalInSettingMode?.();
      });
    }

    // ✅ 블로그 카테고리 분석 버튼 이벤트
    const analyzeBtn = document.getElementById('ma-setting-analyze-category-btn');
    if (analyzeBtn) {
      const newAnalyzeBtn = analyzeBtn.cloneNode(true) as HTMLButtonElement;
      analyzeBtn.parentNode?.replaceChild(newAnalyzeBtn, analyzeBtn);

      newAnalyzeBtn.addEventListener('click', async () => {
        try {
          newAnalyzeBtn.disabled = true;
          newAnalyzeBtn.innerHTML = '⏳ 분석중...';

          const accResult = await window.api.getAllBlogAccounts();
          const account = accResult.accounts?.find((a: any) => String(a.id) === String(accountId));

          if (!(account as any)?.naverId) {
            toastManager.warning('계정 정보를 찾을 수 없습니다.');
            return;
          }

          const response = await (window.api as any).fetchBlogCategories({
            naverId: (account as any).naverId,
            naverPassword: (account as any).naverPassword
          });

          if (response.success && response.categories && response.categories.length > 0) {
            const realCatContainer = document.getElementById('ma-setting-real-category-container');
            const realCatSelect = document.getElementById('ma-setting-real-category') as HTMLSelectElement;

            if (realCatContainer && realCatSelect) {
              realCatSelect.innerHTML = response.categories.map((cat: any) =>
                `<option value="${cat.categoryNo || cat.id}">${cat.categoryName || cat.name}</option>`
              ).join('');
              realCatContainer.style.display = 'block';
            }

            toastManager.success(`✅ ${response.categories.length}개의 블로그 카테고리 분석 완료`);
          } else {
            toastManager.error(response.message || '카테고리 분석 실패');
          }
        } catch (err) {
          console.error('카테고리 분석 오류:', err);
          toastManager.error('분석 중 오류 발생');
        } finally {
          newAnalyzeBtn.disabled = false;
          newAnalyzeBtn.innerHTML = '<span>🔍</span> 블로그 카테고리 분석하기';
        }
      });
    }

    // 콘텐츠 모드 및 썸네일 텍스트 옵션 초기화 (HTML에 이미 존재함)
    const contentModeSelect = document.getElementById('ma-setting-content-mode') as HTMLSelectElement | null;
    if (contentModeSelect) contentModeSelect.value = 'seo';

    const thumbnailCheckbox = document.getElementById('ma-setting-include-thumbnail-text') as HTMLInputElement | null;
    if (thumbnailCheckbox) thumbnailCheckbox.checked = false;

    // AI 이미지 생성 옵션 (신규)
    const useAiImageCheck = document.getElementById('ma-setting-use-ai-image') as HTMLInputElement | null;
    if (useAiImageCheck) useAiImageCheck.checked = true;

    const createThumbnailCheck = document.getElementById('ma-setting-create-product-thumbnail') as HTMLInputElement | null;
    if (createThumbnailCheck) createThumbnailCheck.checked = false;

    // ✅ 발행 모드 초기화 및 예약 컨테이너 토글 로직
    const publishModeRadios = document.querySelectorAll('input[name="ma-setting-publish-mode"]');
    const scheduleContainer = document.getElementById('ma-setting-schedule-container');
    const scheduleDateInput = document.getElementById('ma-setting-schedule-date') as HTMLInputElement | null;

    // 발행 모드 기본값 설정 (즉시)
    const publishModePublish = document.querySelector('input[name="ma-setting-publish-mode"][value="publish"]') as HTMLInputElement | null;
    if (publishModePublish) publishModePublish.checked = true;

    // 예약 컨테이너 초기 숨김
    if (scheduleContainer) scheduleContainer.style.display = 'none';

    // 예약 날짜 기본값 설정 (오늘)
    if (scheduleDateInput && !scheduleDateInput.value) {
      const today = new Date();
      const yyyy = today.getFullYear();
      const mm = String(today.getMonth() + 1).padStart(2, '0');
      const dd = String(today.getDate()).padStart(2, '0');
      scheduleDateInput.value = `${yyyy}-${mm}-${dd}`;
    }

    // 발행 모드 변경 시 예약 컨테이너 토글 (이벤트 위임 사용)
    const publishModeContainer = publishModeRadios[0]?.closest('div[style*="grid-template-columns"]');
    if (publishModeContainer) {
      publishModeContainer.addEventListener('change', (e) => {
        const target = e.target as HTMLInputElement;
        if (target.name === 'ma-setting-publish-mode' && scheduleContainer) {
          scheduleContainer.style.display = target.value === 'schedule' ? 'block' : 'none';
        }
      });
    }

    // ✅ CTA 유형이 이전글이면 바로 모달로 선택하게 함 (URL 자동 입력)
    const ctaTypeSelect = document.getElementById('ma-setting-cta-type') as HTMLSelectElement | null;
    const ctaUrlInput = document.getElementById('ma-setting-cta-url') as HTMLInputElement | null;
    const ctaTextInput = document.getElementById('ma-setting-cta-text') as HTMLInputElement | null;
    const categorySelectForCta = document.getElementById('ma-setting-category') as HTMLSelectElement | null;

    // 수동으로 모달 열어 변경할 버튼
    try {
      if (!document.getElementById('ma-setting-select-prevpost-btn') && ctaUrlInput?.parentElement) {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.id = 'ma-setting-select-prevpost-btn';
        btn.textContent = '🔍 이전글 선택';
        btn.style.cssText = `
          margin-top: 0.5rem;
          padding: 0.55rem 0.75rem;
          background: rgba(59, 130, 246, 0.15);
          color: #60a5fa;
          border: 1px solid rgba(59, 130, 246, 0.45);
          border-radius: 8px;
          cursor: pointer;
          font-weight: 800;
          font-size: 0.85rem;
          width: 100%;
        `;
        btn.addEventListener('click', () => {
          const postsAll = loadGeneratedPosts();
          const posts = (postsAll || []).filter((p: any) => String(p?.publishedUrl || '').trim().length > 0);
          if (posts.length === 0) {
            toastManager.warning('발행된 이전 글이 없습니다. 먼저 글을 발행한 뒤 다시 시도하세요.');
            return;
          }
          const catKey = String(categorySelectForCta?.value || '').trim();
          showPostSelectionModal(posts, (selectedPost) => {
            if (!selectedPost) return;
            const url = String(selectedPost.publishedUrl || '').trim();
            if (ctaUrlInput && url) ctaUrlInput.value = url;
            if (ctaTextInput && selectedPost.title) ctaTextInput.value = `📖 ${selectedPost.title}`;
          }, { defaultCategory: catKey || undefined });
        });
        ctaUrlInput.parentElement.appendChild(btn);
      }
    } catch {
      // ignore
    }

    if (ctaTypeSelect && !ctaTypeSelect.hasAttribute('data-listener-added')) {
      ctaTypeSelect.setAttribute('data-listener-added', 'true');
      ctaTypeSelect.addEventListener('change', () => {
        const v = String(ctaTypeSelect.value || '').trim();
        if (v !== 'previous-post') return;

        const isJabBlog = String((modal as any)?.dataset?.isJabBlog || '0') === '1';
        const catKey = String(categorySelectForCta?.value || '').trim();
        const postsAll = loadGeneratedPosts();
        const published = (postsAll || []).filter((p: any) => String(p?.publishedUrl || '').trim().length > 0);
        if (published.length === 0) {
          toastManager.warning('발행된 이전 글이 없습니다. 먼저 글을 발행한 뒤 다시 시도하세요.');
          return;
        }

        // ✅ 잡블로그가 아니면 같은 카테고리 최신 발행글을 자동으로 세팅
        if (!isJabBlog && catKey) {
          const candidates = published.filter((p: any) => String(p?.category || '').trim() === catKey);
          if (candidates.length > 0) {
            candidates.sort((a: any, b: any) => {
              const aT = new Date(a.publishedAt || a.updatedAt || a.createdAt || 0).getTime();
              const bT = new Date(b.publishedAt || b.updatedAt || b.createdAt || 0).getTime();
              return bT - aT;
            });
            const chosen = candidates[0];
            const url = String(chosen?.publishedUrl || '').trim();
            if (ctaUrlInput && url) ctaUrlInput.value = url;
            if (ctaTextInput && chosen?.title) ctaTextInput.value = `📖 ${chosen.title}`;
            toastManager.success('✅ 같은 카테고리의 최신 발행글이 자동으로 연결되었습니다.');
            return;
          }
        }

        // 폴백: 모달로 직접 선택 (카테고리 기본값 적용)
        showPostSelectionModal(published, (selectedPost) => {
          if (!selectedPost) return;
          const url = String(selectedPost.publishedUrl || '').trim();
          if (ctaUrlInput && url) ctaUrlInput.value = url;
          if (ctaTextInput && selectedPost.title) ctaTextInput.value = `📖 ${selectedPost.title}`;
        }, { defaultCategory: catKey || undefined });
      });
    }

    modal.style.display = 'flex';
    modal.setAttribute('aria-hidden', 'false');
  }

  // ✅ 풀오토 세팅 모달 닫기
  document.querySelector('[data-close-fullauto-setting]')?.addEventListener('click', () => {
    const modal = document.getElementById('ma-fullauto-setting-modal');
    if (modal) {
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
    }
  });

  // ✅ 대기열에 추가 버튼 (여러 URL/키워드 줄바꿈 지원)
  document.getElementById('ma-add-to-queue-btn')?.addEventListener('click', () => {
    const accountId = (document.getElementById('ma-setting-account-id') as HTMLInputElement)?.value;
    const accountNameEl = document.getElementById('ma-setting-account-name');
    const accountName = accountNameEl?.textContent?.replace('📌 ', '') || '';

    // ✅ textarea에서 여러 줄 읽기
    const urlText = (document.getElementById('ma-setting-url') as HTMLTextAreaElement)?.value || '';
    const keywordText = (document.getElementById('ma-setting-keyword') as HTMLTextAreaElement)?.value || '';

    // 줄바꿈으로 분리하고 빈 줄 제거
    const urls = urlText.split('\n').map(s => s.trim()).filter(s => s.length > 0);
    const keywords = keywordText.split('\n').map(s => s.trim()).filter(s => s.length > 0);

    const imageSource = (document.getElementById('ma-setting-image-source') as HTMLSelectElement)?.value || 'nano-banana-pro';
    const toneStyle = (document.getElementById('ma-setting-tone') as HTMLSelectElement)?.value || 'friendly';
    const category = String((document.getElementById('ma-setting-category') as HTMLSelectElement | null)?.value || '').trim() || 'general';
    const contentMode = ((document.getElementById('ma-setting-content-mode') as HTMLSelectElement | null)?.value || 'seo') as 'seo' | 'homefeed' | 'affiliate';
    const ctaType = (document.getElementById('ma-setting-cta-type') as HTMLSelectElement)?.value as 'none' | 'previous-post' | 'custom' || 'none';
    const ctaUrl = (document.getElementById('ma-setting-cta-url') as HTMLInputElement)?.value?.trim() || '';
    const ctaText = (document.getElementById('ma-setting-cta-text') as HTMLInputElement)?.value?.trim() || '';
    const includeThumbnailText = (document.getElementById('ma-setting-include-thumbnail-text') as HTMLInputElement | null)?.checked || false;
    const useAiImage = (document.getElementById('ma-setting-use-ai-image') as HTMLInputElement | null)?.checked ?? true;
    const createProductThumbnail = (document.getElementById('ma-setting-create-product-thumbnail') as HTMLInputElement | null)?.checked ?? false;

    // ✅ [2026-01-20] 쇼핑커넥트 전용 옵션 수집 (기본설정 탭 또는 쇼핑커넥트 서브탭에서)
    const affiliateLink = contentMode === 'affiliate'
      ? ((document.getElementById('ma-shopping-affiliate-link') as HTMLInputElement)?.value?.trim() ||
        (document.getElementById('ma-setting-affiliate-link') as HTMLInputElement)?.value?.trim() || '')
      : undefined;
    const videoOption = contentMode === 'affiliate'
      ? ((document.getElementById('ma-shopping-video-option') as HTMLInputElement)?.checked ||
        (document.getElementById('ma-setting-video-option') as HTMLInputElement)?.checked || false)
      : undefined;

    // ✅ 발행 모드 및 예약일시 읽기
    const publishMode = (document.querySelector('input[name="ma-setting-publish-mode"]:checked') as HTMLInputElement)?.value || 'publish';
    let scheduleDate: string | undefined;
    let scheduleType: 'app-schedule' | 'naver-server' | undefined;

    if (publishMode === 'schedule') {
      const dateVal = (document.getElementById('ma-setting-schedule-date') as HTMLInputElement)?.value;
      const timeVal = (document.getElementById('ma-setting-schedule-time') as HTMLInputElement)?.value;
      if (dateVal && timeVal) {
        scheduleDate = `${dateVal}T${timeVal}`;
        scheduleType = 'naver-server';
      }
    }

    // ✅ URL 우선, 없으면 키워드 사용
    const items: { url: string; keyword: string }[] = [];

    if (urls.length > 0) {
      urls.forEach(url => items.push({ url, keyword: '' }));
    } else if (keywords.length > 0) {
      keywords.forEach(keyword => items.push({ url: '', keyword }));
    }

    if (items.length === 0) {
      toastManager.warning('URL 또는 키워드를 입력해주세요.');
      return;
    }

    // ✅ 각 아이템에 대해 대기열 항목 생성
    let addedCount = 0;

    // ✅ [2026-01-22] 수동 썸네일 가져오기 (ma-full-auto 또는 ma-semi-auto 대상)
    const presetThumbnails = (window as any).presetThumbnails || {};
    const manualThumbnailForQueue = presetThumbnails['ma-full-auto'] || presetThumbnails['ma-semi-auto'] || null;

    items.forEach(({ url, keyword }) => {
      const queueItem: QueueItem = {
        id: `queue-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        accountId,
        accountName,
        sourceUrl: url,
        sourceKeyword: keyword,
        imageSource,
        toneStyle,
        category,
        contentMode,
        ctaType,
        ctaUrl,
        ctaText,
        includeThumbnailText,
        useAiImage,
        createProductThumbnail,
        publishMode,
        scheduleDate,
        scheduleType,
        affiliateLink,  // ✅ [2026-01-20] 쇼핑커넥트 제휴 링크
        videoOption,    // ✅ [2026-01-20] VEO 영상 변환 옵션
        manualThumbnail: manualThumbnailForQueue  // ✅ [2026-01-22] 수동 썸네일 저장
      };

      publishQueue.push(queueItem);
      addedCount++;
    });

    renderQueue();

    // 모달 닫기
    const modal = document.getElementById('ma-fullauto-setting-modal');
    if (modal) {
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
    }

    // ✅ 입력 필드 초기화
    (document.getElementById('ma-setting-url') as HTMLTextAreaElement).value = '';
    (document.getElementById('ma-setting-keyword') as HTMLTextAreaElement).value = '';

    if (addedCount === 1) {
      toastManager.success(`${accountName} 계정이 대기열에 추가되었습니다.`);
    } else {
      toastManager.success(`${accountName} 계정에서 ${addedCount}개 항목이 대기열에 추가되었습니다.`);
    }

    // ✅ [2026-01-22] 대기열 추가 후 수동 썸네일 자동 초기화
    // 다음 대기열 항목을 위해 깔끔하게 리셋
    if (typeof (window as any).clearManualThumbnail === 'function') {
      (window as any).clearManualThumbnail();
      console.log('[Queue] 수동 썸네일 초기화 완료');
    }

    // presetThumbnails도 초기화
    if ((window as any).presetThumbnails) {
      (window as any).presetThumbnails = {
        'image-tab': null,
        'full-auto': null,
        'continuous': null,
        'ma-semi-auto': null,
        'ma-full-auto': null
      };
      console.log('[Queue] presetThumbnails 초기화 완료');
    }
  });

  // ✅ [2026-01-20] 콘텐츠 모드 변경 시 쇼핑커넥트 설정 표시/숨김
  document.getElementById('ma-setting-content-mode')?.addEventListener('change', (e) => {
    const mode = (e.target as HTMLSelectElement).value;
    const shoppingSettings = document.getElementById('ma-shopping-connect-settings');
    if (shoppingSettings) {
      shoppingSettings.style.display = mode === 'affiliate' ? 'block' : 'none';
    }
  });

  // ✅ [2026-01-20] 썸네일 커스터마이징 버튼
  document.getElementById('ma-setting-goto-thumbnail-btn')?.addEventListener('click', () => {
    const modal = document.getElementById('ma-fullauto-setting-modal');
    if (modal) modal.style.display = 'none';

    const imageToolsTab = document.querySelector('[data-tab="image-tools"]') as HTMLElement;
    if (imageToolsTab) {
      imageToolsTab.click();
      setTimeout(() => {
        const thumbnailSubtab = document.querySelector('[data-subtab="thumbnail"]') as HTMLElement;
        if (thumbnailSubtab) {
          thumbnailSubtab.click();
          toastManager.info('🎨 썸네일 커스터마이징 화면입니다. 설정 후 풀오토 세팅으로 돌아가세요.');
        }
      }, 150);
    }
  });

  // ✅ [2026-01-20] 배너 커스터마이징 버튼  
  document.getElementById('ma-setting-goto-banner-btn')?.addEventListener('click', () => {
    const modal = document.getElementById('ma-fullauto-setting-modal');
    if (modal) modal.style.display = 'none';

    const imageToolsTab = document.querySelector('[data-tab="image-tools"]') as HTMLElement;
    if (imageToolsTab) {
      imageToolsTab.click();
      setTimeout(() => {
        const bannerSubtab = document.querySelector('[data-subtab="shopping-banner"]') as HTMLElement;
        if (bannerSubtab) {
          bannerSubtab.click();
          toastManager.info('🎨 배너 커스터마이징 화면입니다.');
        }
      }, 150);
    }
  });

  // ✅ 대기열 전체 삭제
  document.getElementById('ma-clear-queue-btn')?.addEventListener('click', () => {
    if (publishQueue.length === 0) {
      toastManager.info('대기열이 비어있습니다.');
      return;
    }
    if (confirm('대기열을 모두 삭제하시겠습니까?')) {
      publishQueue = [];
      renderQueue();
      toastManager.success('대기열이 삭제되었습니다.');
    }
  });

  // ✅ [2026-01-20] 풀오토 모달 서브탭 전환
  document.querySelectorAll('.ma-modal-subtab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const subtab = (btn as HTMLElement).dataset.subtab;
      if (!subtab) return;

      // 모든 탭 버튼 비활성화
      document.querySelectorAll('.ma-modal-subtab-btn').forEach(b => {
        (b as HTMLElement).style.borderBottom = '3px solid transparent';
        (b as HTMLElement).style.color = 'var(--text-muted)';
        b.classList.remove('active');
      });

      // 클릭된 탭 버튼 활성화
      (btn as HTMLElement).style.borderBottom = '3px solid #10b981';
      (btn as HTMLElement).style.color = '#10b981';
      btn.classList.add('active');

      // 모든 탭 콘텐츠 숨김
      document.querySelectorAll('.ma-modal-subtab-content').forEach(content => {
        (content as HTMLElement).style.display = 'none';
      });

      // 선택된 탭 콘텐츠 표시
      const contentId = `ma-modal-subtab-${subtab}-content`;
      const content = document.getElementById(contentId);
      if (content) content.style.display = 'block';
    });
  });

  // ✅ [2026-01-20] 예약 발행 활성화 체크박스
  document.getElementById('ma-setting-schedule-enabled')?.addEventListener('change', (e) => {
    const isEnabled = (e.target as HTMLInputElement).checked;
    const section = document.getElementById('ma-schedule-datetime-section');
    if (section) {
      section.style.opacity = isEnabled ? '1' : '0.5';
      section.style.pointerEvents = isEnabled ? 'auto' : 'none';
    }

    // 발행 모드도 자동 변경
    if (isEnabled) {
      const scheduleRadio = document.querySelector('input[name="ma-setting-publish-mode"][value="schedule"]') as HTMLInputElement;
      if (scheduleRadio) scheduleRadio.checked = true;
    }
  });

  // ✅ [2026-01-20] 쇼핑커넥트 탭의 썸네일/배너 버튼 (모달 닫기 포함)
  document.getElementById('ma-shopping-goto-thumbnail-btn')?.addEventListener('click', () => {
    const modal = document.getElementById('ma-fullauto-setting-modal');
    if (modal) modal.style.display = 'none';

    const imageToolsTab = document.querySelector('[data-tab="image-tools"]') as HTMLElement;
    if (imageToolsTab) {
      imageToolsTab.click();
      setTimeout(() => {
        const thumbnailSubtab = document.querySelector('[data-subtab="thumbnail"]') as HTMLElement;
        if (thumbnailSubtab) {
          thumbnailSubtab.click();
          toastManager.info('🎨 썸네일 커스터마이징 화면입니다. 설정 후 풀오토 세팅으로 돌아가세요.');
        }
      }, 150);
    }
  });

  document.getElementById('ma-shopping-goto-banner-btn')?.addEventListener('click', () => {
    const modal = document.getElementById('ma-fullauto-setting-modal');
    if (modal) modal.style.display = 'none';

    const imageToolsTab = document.querySelector('[data-tab="image-tools"]') as HTMLElement;
    if (imageToolsTab) {
      imageToolsTab.click();
      setTimeout(() => {
        const bannerSubtab = document.querySelector('[data-subtab="shopping-banner"]') as HTMLElement;
        if (bannerSubtab) {
          bannerSubtab.click();
          toastManager.info('🎨 배너 커스터마이징 화면입니다.');
        }
      }, 150);
    }
  });

  // ✅ [2026-01-20] 풀오토 이전글 선택 버튼
  document.getElementById('ma-setting-select-prevpost-btn')?.addEventListener('click', async () => {
    try {
      const modal = document.createElement('div');
      modal.className = 'unified-modal-overlay';
      modal.style.cssText = `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 20000; display: flex; align-items: center; justify-content: center;`;

      modal.innerHTML = `
        <div style="background: var(--bg-primary); border-radius: 12px; padding: 1.5rem; max-width: 600px; width: 95%; max-height: 80vh; overflow-y: auto;">
          <h3 style="margin: 0 0 1rem 0; color: var(--text-strong);">🔗 이전 글에서 CTA 데이터 가져오기</h3>
          <p style="font-size: 0.85rem; color: var(--text-muted); margin-bottom: 1rem;">저장된 글 목록에서 CTA 링크로 사용할 글을 선택하세요.</p>
          <div id="ma-prev-post-list-container" style="min-height: 200px; display: flex; align-items: center; justify-content: center;">
            <div class="loader-small"></div>
          </div>
          <div style="margin-top: 1.5rem; display: flex; justify-content: flex-end;">
            <button type="button" id="ma-prev-post-modal-cancel" style="padding: 0.6rem 1.2rem; background: var(--bg-tertiary); color: var(--text-muted); border: 1px solid var(--border-light); border-radius: 6px; cursor: pointer;">취소</button>
          </div>
        </div>
      `;

      document.body.appendChild(modal);

      const closeModal = () => {
        document.body.removeChild(modal);
      };

      modal.querySelector('#ma-prev-post-modal-cancel')?.addEventListener('click', closeModal);

      const listContainer = modal.querySelector('#ma-prev-post-list-container')!;
      listContainer.innerHTML = '<div style="color: var(--text-muted);">저장된 글 목록을 불러오는 중...</div>';

      const allPosts = loadGeneratedPosts();
      const publishedPosts = allPosts.filter((p: any) => p.publishedUrl && p.publishedUrl.trim());

      if (publishedPosts.length === 0 && allPosts.length === 0) {
        listContainer.innerHTML = '<div style="color: var(--text-muted);">저장된 글이 없습니다. 먼저 글을 생성해주세요.</div>';
        return;
      }

      const postsToShow = publishedPosts.length > 0 ? publishedPosts : allPosts;

      listContainer.innerHTML = `
        <div style="width: 100%;">
          <div style="padding: 0.5rem; background: var(--bg-tertiary); border-radius: 6px; margin-bottom: 0.75rem; font-size: 0.85rem; color: var(--text-muted);">
            📝 총 ${allPosts.length}개 글 (발행됨: ${publishedPosts.length}개)
          </div>
          ${postsToShow.slice(0, 20).map((p: any) => `
            <div style="padding: 0.75rem; border-bottom: 1px solid var(--border-light); cursor: pointer; transition: background 0.2s;" class="ma-prev-post-row" data-url="${p.publishedUrl || ''}" data-title="${(p.title || '').replace(/"/g, '&quot;')}">
              <div style="font-weight: 600; font-size: 0.9rem; color: var(--text-strong);">${p.title || '(제목 없음)'}</div>
              <div style="font-size: 0.75rem; color: var(--text-muted);">
                ${p.publishedUrl ? '✅ 발행됨' : '⏳ 미발행'} | ${new Date(p.createdAt || Date.now()).toLocaleDateString('ko-KR')}
              </div>
              ${p.publishedUrl ? `<div style="font-size: 0.7rem; color: var(--primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${p.publishedUrl}</div>` : ''}
            </div>
          `).join('')}
        </div>
      `;

      modal.querySelectorAll('.ma-prev-post-row').forEach(row => {
        row.addEventListener('click', () => {
          const url = (row as HTMLElement).dataset.url || '';
          const title = (row as HTMLElement).dataset.title || '';

          const ctaUrlInput = document.getElementById('ma-setting-cta-url') as HTMLInputElement;
          const ctaTextInput = document.getElementById('ma-setting-cta-text') as HTMLInputElement;
          const ctaTypeSelect = document.getElementById('ma-setting-cta-type') as HTMLSelectElement;

          if (ctaUrlInput) ctaUrlInput.value = url;
          if (ctaTextInput) ctaTextInput.value = `이전 글: ${title}`;
          if (ctaTypeSelect) ctaTypeSelect.value = 'previous-post';

          toastManager.success('이전 글 링크가 CTA 설정에 반영되었습니다.');
          closeModal();
        });
      });

    } catch (error) {
      console.error('ma-setting-select-prevpost-btn Error:', error);
      toastManager.error('포스팅 목록을 불러오는데 실패했습니다.');
    }
  });

  // 선택된 계정 수 업데이트 (더 이상 사용하지 않지만 호환성 유지)
  function updateSelectedCount() {
    const countEl = document.getElementById('ma-selected-count');
    if (countEl) {
      countEl.textContent = `${selectedAccountIds.length}개`;
    }
  }

  // 계정 편집 모달 열기
  async function openAccountEditModal(accountId?: string) {
    if (!accountEditModal) return;

    const titleEl = document.getElementById('ma-edit-title');
    const accountIdInput = document.getElementById('ma-edit-account-id') as HTMLInputElement;
    const nameInput = document.getElementById('ma-edit-name') as HTMLInputElement;
    const blogIdInput = document.getElementById('ma-edit-blog-id') as HTMLInputElement;
    const naverIdInput = document.getElementById('ma-edit-naver-id') as HTMLInputElement;
    const naverPwInput = document.getElementById('ma-edit-naver-pw') as HTMLInputElement;
    const isJabBlogCheckbox = document.getElementById('ma-edit-is-jabblog') as HTMLInputElement;
    const dailyLimitInput = document.getElementById('ma-edit-daily-limit') as HTMLInputElement;
    const imageSourceSelect = document.getElementById('ma-edit-image-source') as HTMLSelectElement;
    const toneSelect = document.getElementById('ma-edit-tone-style') as HTMLSelectElement;
    const publishModeSelect = document.getElementById('ma-edit-publish-mode') as HTMLSelectElement;
    const autoRotateCheckbox = document.getElementById('ma-edit-auto-rotate') as HTMLInputElement;

    // 키워드/URL은 세팅하기 패널에서 설정하므로 여기서는 사용하지 않음

    // ✅ 삭제 버튼 참조
    const deleteAccountBtn = document.getElementById('ma-delete-account-btn') as HTMLButtonElement;

    if (accountId) {
      // 편집 모드
      if (titleEl) titleEl.textContent = '계정 설정 편집';
      // ✅ 편집 모드에서 삭제 버튼 표시
      if (deleteAccountBtn) deleteAccountBtn.style.display = 'inline-block';

      const result = await window.api.getAllBlogAccounts();
      const account = result.accounts?.find((a: any) => a.id === accountId);

      if (account) {
        if (accountIdInput) accountIdInput.value = accountId;
        if (nameInput) nameInput.value = account.name || '';
        if (blogIdInput) blogIdInput.value = account.blogId || account.name || '';

        if (isJabBlogCheckbox) isJabBlogCheckbox.checked = account.settings?.isJabBlog === true;

        // 로그인 정보 가져오기
        const credResult = await window.api.getAccountCredentials(accountId);
        if (credResult.success && credResult.credentials) {
          if (naverIdInput) naverIdInput.value = credResult.credentials.naverId || '';
          if (naverPwInput) naverPwInput.value = credResult.credentials.naverPassword || '';
        }

        if (dailyLimitInput) dailyLimitInput.value = String(account.settings?.dailyLimit || 5);
        if (imageSourceSelect) imageSourceSelect.value = account.settings?.imageSource || 'gemini';
        if (toneSelect) toneSelect.value = account.settings?.toneStyle || 'friendly';
        if (publishModeSelect) publishModeSelect.value = account.settings?.publishMode || 'publish';
        if (autoRotateCheckbox) autoRotateCheckbox.checked = account.settings?.autoRotate !== false;

        // ✅ 카테고리/키워드 설정 로드
        const categorySelect = document.getElementById('ma-edit-category') as HTMLSelectElement;
        const keywordsTextarea = document.getElementById('ma-edit-keywords') as HTMLTextAreaElement;
        if (categorySelect) categorySelect.value = account.settings?.category || '';
        if (keywordsTextarea) {
          // keywords 배열을 쉼표로 구분된 문자열로 변환
          const keywordsArray = account.settings?.keywords || [];
          keywordsTextarea.value = keywordsArray.join(', ');
        }
      }

      // ✅ 편집 모드에서는 네이버 아이디 수정 불가 (readonly 적용)
      if (naverIdInput) {
        naverIdInput.readOnly = true;
        naverIdInput.style.background = 'var(--bg-tertiary)';
        naverIdInput.style.color = 'var(--text-muted)';
      }
    } else {
      // 추가 모드
      if (titleEl) titleEl.textContent = '새 계정 추가';
      // ✅ 추가 모드에서 삭제 버튼 숨김
      if (deleteAccountBtn) deleteAccountBtn.style.display = 'none';
      if (accountIdInput) accountIdInput.value = '';
      if (nameInput) nameInput.value = '';
      if (blogIdInput) blogIdInput.value = '';
      if (naverIdInput) {
        naverIdInput.value = '';
        // ✅ 추가 모드에서는 네이버 아이디 입력 가능 (readonly 해제)
        naverIdInput.readOnly = false;
        naverIdInput.style.background = 'var(--bg-secondary)';
        naverIdInput.style.color = 'var(--text-strong)';
      }
      if (naverPwInput) naverPwInput.value = '';
      if (isJabBlogCheckbox) isJabBlogCheckbox.checked = false;
      if (dailyLimitInput) dailyLimitInput.value = '5';
      if (imageSourceSelect) imageSourceSelect.value = 'gemini';
      if (toneSelect) toneSelect.value = 'friendly';
      if (publishModeSelect) publishModeSelect.value = 'publish';
      if (autoRotateCheckbox) autoRotateCheckbox.checked = true;

      // ✅ 카테고리/키워드 초기화
      const categorySelect = document.getElementById('ma-edit-category') as HTMLSelectElement;
      const keywordsTextarea = document.getElementById('ma-edit-keywords') as HTMLTextAreaElement;
      if (categorySelect) categorySelect.value = '';
      if (keywordsTextarea) keywordsTextarea.value = '';
    }

    accountEditModal.style.display = 'flex';
    accountEditModal.setAttribute('aria-hidden', 'false');
  }

  // ✅ 전역으로 openAccountEditModal 함수 노출 (발행 계정 선택에서도 사용)
  (window as any).openAccountEditModal = openAccountEditModal;

  // ✅ 전역으로 renderMultiAccountList 함수 노출 (계정 목록 새로고침용)
  (window as any).renderMultiAccountList = renderMultiAccountList;

  // ✅ 글로벌 계정 목록 새로고침 함수 (1개 계정 탭 + 다중계정 탭 모두 동기화)
  (window as any).refreshAllAccountLists = async () => {
    console.log('[Account] 모든 계정 목록 새로고침');
    try {
      await renderMultiAccountList();
    } catch (e) {
      console.error('[Account] renderMultiAccountList 오류:', e);
    }
    // 인라인 계정 목록 새로고침 시도
    if (typeof (window as any).renderInlineAccountList === 'function') {
      try {
        await (window as any).renderInlineAccountList();
      } catch (e) {
        console.error('[Account] renderInlineAccountList 오류:', e);
      }
    }
    // 1개 계정 탭 드롭다운 새로고침 시도
    if (typeof (window as any).loadMainAccountList === 'function') {
      try {
        await (window as any).loadMainAccountList();
      } catch (e) {
        console.error('[Account] loadMainAccountList 오류:', e);
      }
    }
  };

  // 계정 추가 버튼
  document.getElementById('ma-add-account-btn')?.addEventListener('click', () => {
    openAccountEditModal();
  });

  // 계정 저장 버튼
  document.getElementById('ma-save-account-btn')?.addEventListener('click', async () => {
    const accountIdInput = document.getElementById('ma-edit-account-id') as HTMLInputElement;
    const nameInput = document.getElementById('ma-edit-name') as HTMLInputElement;
    const blogIdInput = document.getElementById('ma-edit-blog-id') as HTMLInputElement;
    const naverIdInput = document.getElementById('ma-edit-naver-id') as HTMLInputElement;
    const naverPwInput = document.getElementById('ma-edit-naver-pw') as HTMLInputElement;
    const isJabBlogCheckbox = document.getElementById('ma-edit-is-jabblog') as HTMLInputElement;
    const dailyLimitInput = document.getElementById('ma-edit-daily-limit') as HTMLInputElement;
    const imageSourceSelect = document.getElementById('ma-edit-image-source') as HTMLSelectElement;
    const toneSelect = document.getElementById('ma-edit-tone-style') as HTMLSelectElement;
    const publishModeSelect = document.getElementById('ma-edit-publish-mode') as HTMLSelectElement;
    const autoRotateCheckbox = document.getElementById('ma-edit-auto-rotate') as HTMLInputElement;

    const accountId = accountIdInput?.value;
    const name = nameInput?.value.trim();
    const blogId = blogIdInput?.value.trim() || name; // blogId가 없으면 name 사용
    const naverId = naverIdInput?.value.trim();
    const naverPw = naverPwInput?.value;

    if (!name || !naverId || !naverPw) {
      toastManager.warning('필수 항목(별명, 네이버 ID, 비밀번호)을 모두 입력해주세요.');
      return;
    }

    const settings: any = {
      dailyLimit: parseInt(dailyLimitInput?.value || '5'),
      imageSource: imageSourceSelect?.value || 'gemini',
      toneStyle: toneSelect?.value || 'friendly',
      publishMode: publishModeSelect?.value || 'publish',
      autoRotate: autoRotateCheckbox?.checked !== false,
      isJabBlog: isJabBlogCheckbox?.checked === true,
    };

    try {
      if (accountId) {
        // 기존 계정 업데이트
        await window.api.updateBlogAccount(accountId, { name, blogId });
        await window.api.updateAccountCredentials(accountId, naverId, naverPw);
        await window.api.updateAccountSettings(accountId, settings);
        toastManager.success('계정 설정이 업데이트되었습니다.');
      } else {
        // 새 계정 추가
        const result = await window.api.addBlogAccount(name, blogId, naverId, naverPw, settings);
        if (result.success) {
          toastManager.success('계정이 추가되었습니다.');
        } else {
          toastManager.error(result.message || '계정 추가 실패');
          return;
        }
      }

      // 모달 닫기 및 목록 새로고침
      if (accountEditModal) {
        accountEditModal.style.display = 'none';
        accountEditModal.setAttribute('aria-hidden', 'true');
      }
      // ✅ 모든 계정 목록 동기화 (1개 계정 탭 + 다중계정 탭)
      if (typeof (window as any).refreshAllAccountLists === 'function') {
        await (window as any).refreshAllAccountLists();
      } else {
        await renderMultiAccountList();
      }
    } catch (error) {
      toastManager.error('저장 중 오류가 발생했습니다.');
    }
  });

  // ✅ 계정 삭제 버튼 핸들러
  document.getElementById('ma-delete-account-btn')?.addEventListener('click', async () => {
    const accountIdInput = document.getElementById('ma-edit-account-id') as HTMLInputElement;
    const accountId = accountIdInput?.value;

    if (!accountId) {
      toastManager.warning('삭제할 계정이 선택되지 않았습니다.');
      return;
    }

    // 확인 대화상자
    if (!confirm('정말로 이 계정을 삭제하시겠습니까?\n\n삭제된 계정은 복구할 수 없습니다.')) {
      return;
    }

    try {
      const result = await window.api.removeBlogAccount(accountId);
      if (result.success) {
        toastManager.success('계정이 삭제되었습니다.');

        // 모달 닫기
        if (accountEditModal) {
          accountEditModal.style.display = 'none';
          accountEditModal.setAttribute('aria-hidden', 'true');
        }

        // ✅ 모든 계정 목록 동기화 (1개 계정 탭 + 다중계정 탭)
        if (typeof (window as any).refreshAllAccountLists === 'function') {
          await (window as any).refreshAllAccountLists();
        } else {
          await renderMultiAccountList();
        }
      } else {
        toastManager.error(result.message || '계정 삭제 실패');
      }
    } catch (error) {
      console.error('[MultiAccount] 계정 삭제 오류:', error);
      toastManager.error('계정 삭제 중 오류가 발생했습니다.');
    }
  });

  // 대기 시간 포맷팅 함수
  const formatWaitTime = (seconds: number): string => {
    if (seconds < 60) return `${seconds}초`;
    if (seconds < 3600) {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return secs > 0 ? `${mins}분 ${secs}초` : `${mins}분`;
    }
    const hours = Math.floor(seconds / 3600);
    const mins = Math.floor((seconds % 3600) / 60);
    return mins > 0 ? `${hours}시간 ${mins}분` : `${hours}시간`;
  };

  // ✅ 풀오토 진행 모달 제어 함수들 (모달 제거됨 - 콘솔 로그만 사용)
  function showMAProgressModal() {
    const modal = document.getElementById('ma-publish-progress-modal');
    if (!modal) return;

    // ✅ 모달이 body의 직접 자식이 아니면 body로 이동 (중첩 문제 해결)
    if (modal.parentElement !== document.body) {
      console.log('[MultiAccountPublish] 진행 모달을 body로 이동합니다.');
      document.body.appendChild(modal);
    }

    modal.style.display = 'flex';
    modal.setAttribute('aria-hidden', 'false');

    const stopBtn = document.getElementById('ma-progress-stop-btn');
    if (stopBtn) stopBtn.style.display = 'flex';
    const closeBtn = document.getElementById('ma-progress-close-btn');
    if (closeBtn) closeBtn.style.display = 'none';
    const completeBtn = document.getElementById('ma-progress-complete-btn');
    if (completeBtn) completeBtn.style.display = 'none';

    const minimizeBtn = document.getElementById('ma-progress-minimize-btn') as HTMLButtonElement | null;
    if (minimizeBtn && !minimizeBtn.hasAttribute('data-listener-added')) {
      minimizeBtn.setAttribute('data-listener-added', 'true');
      minimizeBtn.addEventListener('click', () => {
        hideMAProgressModal();
      });
    }
  }

  function hideMAProgressModal() {
    const modal = document.getElementById('ma-publish-progress-modal');
    if (!modal) return;
    modal.style.display = 'none';
    modal.setAttribute('aria-hidden', 'true');
  }

  // 현재 진행률 상태 (콘솔 로그용)
  let currentProgressPercent = 0;
  let progressAnimationFrame: number | null = null;

  function updateMAProgress(current: number, total: number, accountName: string, step: string, subStep?: number, totalSubSteps?: number) {
    const totalSafe = Math.max(1, Number(total || 0));
    const currentSafe = Math.max(0, Number(current || 0));
    const sub = typeof subStep === 'number' ? subStep : 0;
    const subTotal = typeof totalSubSteps === 'number' && totalSubSteps > 0 ? totalSubSteps : 0;
    const subRatio = subTotal > 0 ? Math.max(0, Math.min(1, sub / subTotal)) : 0;
    const rawPercent = ((currentSafe + subRatio) / totalSafe) * 100;
    const percent = Math.max(0, Math.min(100, rawPercent));

    animateProgress(percent);

    const currentEl = document.getElementById('ma-progress-current');
    if (currentEl) currentEl.textContent = `${Math.min(currentSafe, totalSafe)} / ${totalSafe} 계정`;
    const taskAccount = document.getElementById('ma-task-account');
    if (taskAccount) taskAccount.textContent = accountName || '진행 중...';
    const taskStep = document.getElementById('ma-task-step');
    if (taskStep) taskStep.textContent = step || '';
  }

  function animateProgress(targetPercent: number) {
    const p = Math.max(0, Math.min(100, Number(targetPercent || 0)));
    currentProgressPercent = p;

    const bar = document.getElementById('ma-progress-bar') as HTMLDivElement | null;
    if (bar) bar.style.width = `${p.toFixed(0)}%`;
    const percentEl = document.getElementById('ma-progress-percent');
    if (percentEl) percentEl.textContent = `${p.toFixed(0)}%`;
  }

  function updateMAStep(stepId: string, status: 'active' | 'completed' | 'error' | 'pending') {
    const el = document.getElementById(stepId);
    if (!el) return;
    el.classList.remove('active', 'completed', 'error', 'pending');
    el.classList.add(status);
  }

  function resetMASteps() {
    ['ma-step-content', 'ma-step-image', 'ma-step-login', 'ma-step-publish'].forEach((id) => {
      updateMAStep(id, 'pending');
    });
  }

  function addMALog(message: string, type: 'info' | 'success' | 'error' | 'warning' = 'info') {
    const prefix = type === 'success' ? '✅' : type === 'error' ? '❌' : type === 'warning' ? '⚠️' : 'ℹ️';
    const line = `${prefix} ${message}`;
    try {
      appendLog(`[MA] ${line}`);
    } catch {
    }

    const liveLog = document.getElementById('ma-live-log');
    if (!liveLog) {
      console.log(`[FullAuto] ${line}`);
      return;
    }

    const item = document.createElement('div');
    item.textContent = line;
    if (type === 'success') item.style.color = '#10b981';
    else if (type === 'error') item.style.color = '#ef4444';
    else if (type === 'warning') item.style.color = '#f59e0b';
    else item.style.color = '#94a3b8';

    liveLog.appendChild(item);

    while (liveLog.childElementCount > 80) {
      liveLog.removeChild(liveLog.firstElementChild as Element);
    }
    liveLog.scrollTop = liveLog.scrollHeight;
  }

  function showMAResult(success: number, fail: number) {
    addMALog(`✅ 발행 완료 - 성공: ${success}건, 실패: ${fail}건`, 'success');

    const resultSummary = document.getElementById('ma-result-summary');
    if (resultSummary) resultSummary.style.display = 'block';

    const sEl = document.getElementById('ma-result-success');
    const fEl = document.getElementById('ma-result-fail');
    const tEl = document.getElementById('ma-result-total');
    if (sEl) sEl.textContent = String(success);
    if (fEl) fEl.textContent = String(fail);
    if (tEl) tEl.textContent = String(Math.max(0, Number(success || 0) + Number(fail || 0)));

    const stopBtn = document.getElementById('ma-progress-stop-btn');
    const closeBtn = document.getElementById('ma-progress-close-btn');
    const completeBtn = document.getElementById('ma-progress-complete-btn');
    if (stopBtn) stopBtn.style.display = 'none';
    if (closeBtn) closeBtn.style.display = 'none';
    if (completeBtn) completeBtn.style.display = 'flex';
    if (completeBtn && !completeBtn.hasAttribute('data-listener-added')) {
      completeBtn.setAttribute('data-listener-added', 'true');
      completeBtn.addEventListener('click', () => {
        hideMAProgressModal();
      });
    }

    const taskSpinner = document.getElementById('ma-task-spinner');
    if (taskSpinner) taskSpinner.style.animation = 'none';
    const progressIcon = document.getElementById('ma-progress-icon');
    if (progressIcon) {
      progressIcon.textContent = '✅';
      progressIcon.style.animation = 'none';
    }
    const badge = document.getElementById('ma-task-status-badge');
    if (badge) {
      badge.textContent = '완료';
      badge.style.background = 'rgba(16, 185, 129, 0.25)';
      (badge as HTMLElement).style.color = '#10b981';
    }
  }

  // ✅ 대기열 기반 풀오토 발행 시작
  document.getElementById('ma-start-publish-btn')?.addEventListener('click', async () => {
    // [UX Fix] 수정 중인 상태에서 확인 없이 시작하는 것 방지
    if ((window as any).currentEditingQueueId) {
      toastManager.warning('📢 현재 내용을 수정 중입니다. 먼저 "수정 완료(대기열에 추가)" 버튼을 눌러 저장해주세요!');
      return;
    }

    if (publishQueue.length === 0) {
      toastManager.warning('발행 대기열이 비어있습니다. 계정에서 "⚡ 풀오토 세팅"을 클릭하여 대기열에 추가하세요.');
      return;
    }

    if (isPublishing) {
      toastManager.warning('이미 발행이 진행 중입니다.');
      return;
    }

    // ✅ 발행 간격 계산 (초/분/시간 단위 지원, 최대 24시간)
    const intervalValue = parseInt((document.getElementById('ma-interval-value') as HTMLInputElement)?.value || '30');
    const intervalUnit = (document.getElementById('ma-interval-unit') as HTMLSelectElement)?.value || 'seconds';
    let intervalSeconds = intervalValue;
    if (intervalUnit === 'minutes') {
      intervalSeconds = intervalValue * 60;
    } else if (intervalUnit === 'hours') {
      intervalSeconds = intervalValue * 3600;
    }
    // 최대 24시간 (86400초) 제한
    intervalSeconds = Math.min(intervalSeconds, 86400);

    isPublishing = true;
    stopRequested = false;
    (window as any).stopFullAutoPublish = false; // 전역 중지 플래그 초기화

    const startBtn = document.getElementById('ma-start-publish-btn') as HTMLButtonElement | null;
    const startBtnOriginalHtml = startBtn?.innerHTML || '';
    if (startBtn) {
      startBtn.disabled = true;
      startBtn.innerHTML = '<span style="font-size: 1.25rem;">⏳</span> 발행 중...';
    }

    // 외부 진행 상황 섹션 숨기기 (모달로 대체)
    const progressSection = document.getElementById('ma-progress-section');
    const progressList = document.getElementById('ma-progress-list');
    if (progressSection) progressSection.style.display = 'none';
    if (progressList) progressList.innerHTML = '';

    // ✅ 새로운 애니메이션 모달 표시
    showMAProgressModal();
    resetMASteps();

    // 모달 초기화
    const liveLog = document.getElementById('ma-live-log');
    if (liveLog) liveLog.innerHTML = '';

    const resultSummary = document.getElementById('ma-result-summary');
    const stopBtn = document.getElementById('ma-progress-stop-btn');
    const closeBtn = document.getElementById('ma-progress-close-btn');
    const taskSpinner = document.getElementById('ma-task-spinner');
    const progressIcon = document.getElementById('ma-progress-icon');
    const progressTitle = document.getElementById('ma-progress-title');

    if (resultSummary) resultSummary.style.display = 'none';
    if (stopBtn) stopBtn.style.display = 'flex';
    if (closeBtn) closeBtn.style.display = 'none';
    if (taskSpinner) taskSpinner.style.animation = 'spin 1s linear infinite';
    if (progressIcon) {
      progressIcon.textContent = '🚀';
      progressIcon.style.animation = 'bounce 1s infinite';
    }
    if (progressTitle) progressTitle.textContent = '풀오토 다중계정 발행';

    let totalSuccess = 0;
    let totalFail = 0;
    const totalItems = publishQueue.length;

    const waitInterruptible = async (seconds: number) => {
      const ms = Math.max(0, Math.floor(seconds * 1000));
      const start = Date.now();
      while (Date.now() - start < ms) {
        if (stopRequested || (window as any).stopFullAutoPublish) return false;
        await new Promise((r) => setTimeout(r, 200));
      }
      return true;
    };

    // 예상 시간 계산
    const estimatedTime = totalItems * (intervalSeconds + 60); // 각 항목당 약 60초 + 간격
    const progressTime = document.getElementById('ma-progress-time');
    if (progressTime) progressTime.textContent = `예상 시간: ${formatWaitTime(estimatedTime)}`;

    addProgressItem(`🚀 대기열 ${totalItems}개 항목 발행 시작 (간격: ${formatWaitTime(intervalSeconds)})`, 'info');
    addMALog(`🚀 대기열 ${totalItems}개 항목 발행 시작`, 'info');
    updateMAProgress(0, totalItems, '준비 중...', '발행 시작');

    try {
      // ✅ 대기열 순차 처리
      for (let i = 0; i < publishQueue.length && !stopRequested && !(window as any).stopFullAutoPublish; i++) {
        const queueItem = publishQueue[i];
        let generatedPostId: string | null = null;

        // 모달 업데이트 (4단계: 콘텐츠→이미지→로그인→발행)
        const TOTAL_SUB_STEPS = 4;
        resetMASteps();
        currentProgressPercent = (i / totalItems) * 100; // 현재 계정 시작점으로 초기화
        updateMAProgress(i, totalItems, queueItem.accountName, '🚀 처리 시작...', 0, TOTAL_SUB_STEPS);
        addMALog(`📋 [${i + 1}/${totalItems}] ${queueItem.accountName} 처리 시작`, 'info');

        addProgressItem(`📋 [${i + 1}/${totalItems}] ${queueItem.accountName} 처리 시작...`, 'info');

        // ✅ UI 및 데이터 초기화: 이전 항목의 흔적 제거 (연속 발행/다중 계정 안정성)
        try {
          ImageManager.clearAll();
          // UI 즉시 동기화하여 이전 이미지 잔상 제거
          if (typeof syncGlobalImagesFromImageManager === 'function') {
            syncGlobalImagesFromImageManager();
          }
          (window as any).currentStructuredContent = null;
          (window as any).generatedImages = [];
        } catch (clearErr) {
          console.error('[FullAuto] 데이터 초기화 실패:', clearErr);
        }

        // 1. AI 콘텐츠 생성 (1/4 단계)
        updateMAStep('ma-step-content', 'active');
        updateMAProgress(i, totalItems, queueItem.accountName, '📝 AI 콘텐츠 생성 중...', 0.5, TOTAL_SUB_STEPS);
        addMALog('📝 AI 콘텐츠 생성 중...', 'info');
        addProgressItem(`   📝 AI 콘텐츠 생성 중...`, 'info');

        let structuredContent: any = null;
        let generatedImages: any[] = [];

        try {
          // 콘텐츠 생성 페이로드 구성
          const contentPayload: any = {
            assembly: {
              generator: 'gemini',
              toneStyle: queueItem.toneStyle,
              targetAge: 'all',
            }
          };

          // ✅ 카테고리(콘텐츠 카테고리) 전달
          try {
            const articleType = String(queueItem.category || '').trim() || 'general';
            contentPayload.assembly.articleType = articleType;
          } catch {
            // ignore
          }

          // ✅ 콘텐츠 모드 (SEO/홈판) 전달
          try {
            const cm = (queueItem.contentMode || 'seo') as 'seo' | 'homefeed' | 'affiliate';
            contentPayload.assembly.contentMode = cm;
          } catch {
            // ignore
          }

          const keywordList = queueItem.sourceKeyword
            ? queueItem.sourceKeyword.split(',').map(k => k.trim()).filter(Boolean)
            : [];
          if (keywordList.length > 0) {
            contentPayload.assembly.keywords = keywordList;
          }

          if (queueItem.sourceUrl) {
            contentPayload.assembly.rssUrl = [queueItem.sourceUrl];
          } else if (queueItem.sourceKeyword) {
            contentPayload.assembly.draftText = queueItem.sourceKeyword;
          }

          console.log('[FullAuto] 콘텐츠 생성 요청:', contentPayload);
          const apiClient = EnhancedApiClient.getInstance();
          const apiResponse = await apiClient.call(
            'generateStructuredContent',
            [contentPayload],
            {
              retryCount: 3,
              retryDelay: 2000,
              timeout: 600000
            }
          );
          const contentResult = apiResponse.data || { success: false, message: apiResponse.error };
          console.log('[FullAuto] 콘텐츠 생성 결과:', contentResult);

          if (isPaywallPayload(contentResult)) {
            activatePaywall(contentResult);
            throw new Error(contentResult.message || '콘텐츠 생성 실패');
          }

          if (!contentResult.success || !contentResult.content) {
            throw new Error(contentResult.message || '콘텐츠 생성 실패');
          }

          structuredContent = contentResult.content;
          console.log('[FullAuto] 구조화된 콘텐츠:', structuredContent);

          // ✅ [2026-01-24] 쇼핑커넥트 모드: SEO 제목 자동 생성
          // 네이버 자동완성 키워드를 활용하여 제품명에 세부 키워드 추가
          if (queueItem.contentMode === 'affiliate' && structuredContent.selectedTitle) {
            try {
              addMALog('🔍 SEO 최적화 제목 생성 중...', 'info');
              const seoResult = await (window as any).api.generateSeoTitle(structuredContent.selectedTitle);
              if (seoResult.success && seoResult.title && seoResult.title !== structuredContent.selectedTitle) {
                const originalTitle = structuredContent.selectedTitle;
                structuredContent.selectedTitle = seoResult.title;
                console.log(`[SEO] 제목 교체: "${originalTitle}" → "${seoResult.title}"`);
                addMALog(`✨ SEO 제목 적용: "${seoResult.title.substring(0, 30)}..."`, 'success');
              }
            } catch (seoErr) {
              console.warn('[SEO] 제목 생성 실패 (원본 사용):', seoErr);
            }
          }

          // ✅ UI 업데이트: 현재 처리 중인 콘텐츠를 화면에 표시
          try {
            (window as any).currentStructuredContent = structuredContent;
            await autoAnalyzeHeadings(structuredContent);
          } catch (uiErr) {
            console.error('[FullAuto] UI 업데이트 실패:', uiErr);
          }

          updateMAStep('ma-step-content', 'completed');
          addMALog(`✅ 콘텐츠 생성 완료: "${structuredContent.selectedTitle?.substring(0, 20)}..."`, 'success');
          addProgressItem(`   ✅ 콘텐츠 생성 완료: "${structuredContent.selectedTitle?.substring(0, 25)}..."`, 'success');

          // 2. 이미지 수집/생성 (2/4 단계) - 총 50장 수집 (소제목 + 예비 이미지)
          updateMAStep('ma-step-image', 'active');
          updateMAProgress(i, totalItems, queueItem.accountName, '🎨 이미지 수집 중...', 1, TOTAL_SUB_STEPS);
          addMALog('🎨 이미지 수집 중...', 'info');
          addProgressItem(`   🎨 이미지 수집 중...`, 'info');
          const headings = structuredContent.headings || [];

          // ✅ 2. 이미지 수집 (건너뜀)

          // ✅ 2. 이미지 수집/생성 실행
          try {
            // 이미지 소스 결정
            const imageSource = queueItem.imageSource || 'gemini'; // 기본값 gemini
            const skipImages = imageSource === 'skip';
            console.log('[FullAuto] 이미지 소스:', imageSource, ', 건너뛰기:', skipImages);

            if (skipImages) {
              // ✅ 이미지 없이 진행
              addMALog('⏭️ 이미지 생성 건너뛰기 (사용자 설정)', 'info');
              generatedImages = [];

            } else if (imageSource === 'naver') {
              // ✅ 네이버 이미지 검색
              addMALog(`🔍 네이버 이미지 검색 시작 (키워드: ${structuredContent.keywords?.[0] || structuredContent.selectedTitle})`, 'info');

              // 네이버 이미지 수집 로직 호출
              // generateImagesForAutomation 내부에서 naver 소스 처리
              generatedImages = await generateImagesForAutomation(
                imageSource,
                headings,
                structuredContent.selectedTitle,
                {
                  allowThumbnailText: queueItem.includeThumbnailText,
                  stopCheck: () => stopRequested || (window as any).stopFullAutoPublish,
                  onProgress: (msg) => {
                    addMALog(msg, 'info');
                    // updateMAProgress(i, totalItems, queueItem.accountName, msg, 1.5, TOTAL_SUB_STEPS);
                  }
                }
              );

            } else {
              // ✅ AI 이미지 생성
              addMALog(`🎨 AI 이미지 생성 시작 (소스로: ${imageSource})`, 'info');
              generatedImages = await generateImagesForAutomation(
                imageSource,
                headings,
                structuredContent.selectedTitle,
                {
                  allowThumbnailText: queueItem.includeThumbnailText,
                  stopCheck: () => stopRequested || (window as any).stopFullAutoPublish,
                  onProgress: (msg) => {
                    addMALog(msg, 'info');
                    // updateMAProgress(i, totalItems, queueItem.accountName, msg, 1.5, TOTAL_SUB_STEPS);
                  }
                }
              );
            }

            if (stopRequested || (window as any).stopFullAutoPublish) break;

          } catch (imgErr) {
            console.error('[FullAuto] 이미지 생성 중 오류:', imgErr);
            addMALog(`⚠️ 이미지 생성 중 오류 발생: ${(imgErr as Error).message}`, 'warning');
            // 이미지가 없어도 계속 진행 (텍스트 위주)
          }

          // ✅ UI 업데이트: 생성된 이미지들을 ImageManager에 등록하고 화면에 표시
          try {
            if (Array.isArray(generatedImages) && generatedImages.length > 0) {
              // 기존 이미지 유지 및 새 이미지 추가
              generatedImages.forEach((img: any) => {
                const titleKey = img.heading || '기타';
                const resolvedKey = ImageManager.resolveHeadingKey(titleKey);

                // 기존 이미지가 있으면 덮어쓰지 않고 추가하되, 첫 번째 이미지(대표)로 설정
                const existing = ImageManager.getImages(resolvedKey) || [];
                const isDuplicate = existing.some((e: any) => (e.url || e.filePath) === (img.url || img.filePath));

                if (!isDuplicate) {
                  ImageManager.imageMap.set(resolvedKey, [img, ...existing]);
                }
              });

              // UI 갱신: ImageManager의 내부 배열을 전역 window 객체와 동기화하고 화면에 표시
              if (typeof ImageManager.syncGeneratedImagesArray === 'function') {
                ImageManager.syncGeneratedImagesArray();
              }
              if (typeof syncGlobalImagesFromImageManager === 'function') {
                syncGlobalImagesFromImageManager();
              }

              // ✅ [수정] 이미지 그리드 UI 업데이트 추가 (작은 그리드 표시)
              const allImagesAfter = ImageManager.getAllImages();
              displayGeneratedImages(allImagesAfter);
            }
          } catch (uiImgErr) {
            console.error('[FullAuto] 이미지 UI 업데이트 실패:', uiImgErr);
          }

          // ✅ 생성된 글 목록에 항상 저장 (다중계정 풀오토도 글 목록에 노출)
          try {
            if (structuredContent) {
              generatedPostId = saveGeneratedPostFromData(structuredContent, generatedImages, {
                toneStyle: queueItem.toneStyle,
                ctaText: queueItem.ctaText || '',
                ctaLink: queueItem.ctaUrl || '',
                category: String(queueItem.category || '').trim() || undefined,
              });
              if (generatedPostId) {
                addMALog(`💾 생성된 글 목록 저장됨 (ID: ${generatedPostId})`, 'info');
              }
            }
          } catch {
            // ignore
          }

          updateMAStep('ma-step-image', 'completed');
          addMALog(`✅ ${generatedImages.length}개 이미지 준비 완료`, 'success');
          addProgressItem(`   ✅ ${generatedImages.length}개 이미지 준비 완료`, 'success');

        } catch (contentError) {
          updateMAStep('ma-step-content', 'error');
          addMALog(`❌ 콘텐츠 생성 실패: ${(contentError as Error).message}`, 'error');
          addProgressItem(`   ❌ 콘텐츠 생성 실패: ${(contentError as Error).message}`, 'error');
          totalFail++;
          continue; // 다음 대기열 항목으로
        }

        // 3. 발행 실행
        try {
          if (stopRequested || (window as any).stopFullAutoPublish) {
            break;
          }
          // 계정 자격증명 가져오기 (3/4 단계)
          updateMAStep('ma-step-login', 'active');
          updateMAProgress(i, totalItems, queueItem.accountName, '🔐 네이버 로그인 중...', 2, TOTAL_SUB_STEPS);
          addMALog('🔐 네이버 로그인 중...', 'info');

          console.log('[FullAuto] 계정 자격증명 요청:', queueItem.accountId);
          const credResult = await window.api.getAccountCredentials(queueItem.accountId);
          console.log('[FullAuto] 계정 자격증명 결과:', credResult.success);
          if (!credResult.success || !credResult.credentials) {
            throw new Error('계정 자격증명을 가져올 수 없습니다.');
          }

          updateMAStep('ma-step-login', 'completed');
          updateMAStep('ma-step-publish', 'active');
          updateMAProgress(i, totalItems, queueItem.accountName, '📤 블로그 발행 중...', 3, TOTAL_SUB_STEPS);
          // ✅ 3. 발행 전 CTA 최종 확인 (이전글 자동 연동)
          if (queueItem.ctaType === 'previous-post' && !queueItem.ctaUrl) {
            try {
              const catKey = String(queueItem.category || '').trim();
              const postsAll = loadGeneratedPosts();
              const published = (postsAll || []).filter((p: any) => String(p?.publishedUrl || '').trim().length > 0);

              console.log(`[FullAuto] CTA 매칭 시작 - 카테고리: ${catKey}, 발행된 글 수: ${published.length}`);

              if (catKey && published.length > 0) {
                // 카테고리 매칭 로직 강화 (공백 제거, 대소문자 무시 등)
                const normCat = catKey.replace(/\s+/g, '').toLowerCase();
                const candidates = published.filter((p: any) => {
                  const pCat = String(p?.category || '').trim();
                  if (!pCat) return false;
                  const normPCat = pCat.replace(/\s+/g, '').toLowerCase();
                  return normPCat === normCat || normPCat.includes(normCat) || normCat.includes(normPCat);
                });

                console.log(`[FullAuto] 매칭된 후보 수: ${candidates.length}`);

                if (candidates.length > 0) {
                  candidates.sort((a: any, b: any) => {
                    const aT = new Date(a.publishedAt || a.updatedAt || a.createdAt || 0).getTime();
                    const bT = new Date(b.publishedAt || b.updatedAt || b.createdAt || 0).getTime();
                    return bT - aT;
                  });
                  const chosen = candidates[0];
                  queueItem.ctaUrl = String(chosen?.publishedUrl || '').trim();
                  queueItem.ctaText = `📖 ${chosen.title}`;
                  addMALog(`🔗 CTA 자동 연동: "${chosen.title}"`, 'info');
                  console.log(`[FullAuto] CTA 연동 완료: ${queueItem.ctaUrl}`);
                } else {
                  console.log('[FullAuto] 일치하는 카테고리의 이전 글을 찾지 못했습니다.');
                }
              }
            } catch (ctaErr) {
              console.warn('[FullAuto] CTA 자동 연동 실패:', ctaErr);
            }
          }

          addMALog('📤 블로그 발행 중...', 'info');
          addProgressItem(`   🚀 ${queueItem.accountName} 발행 중...`, 'info');

          const publishOptions = {
            naverId: credResult.credentials.naverId,
            naverPassword: credResult.credentials.naverPassword,
            url: queueItem.sourceUrl || undefined,
            keywords: queueItem.sourceKeyword || undefined,
            generator: 'gemini',
            imageSource: queueItem.imageSource,
            toneStyle: queueItem.toneStyle,
            publishMode: queueItem.publishMode || 'publish',
            scheduleDate: queueItem.scheduleDate,
            scheduleType: queueItem.scheduleType || 'naver-server',
            categoryName: String(queueItem.category || '').trim() || undefined, // ✅ 블로그 폴더 카테고리 자동 선택용
            // ✅ [2026-01-24 FIX] CTA 설정 - skipCta가 명시적으로 true일 때만 건너뛰기 (ctaText 없음 != CTA 건너뛰기)
            skipCta: (queueItem as any)?.formData?.skipCta === true || (queueItem as any)?.skipCta === true,
            ctaPosition: ((queueItem as any)?.formData?.ctaPosition as 'top' | 'middle' | 'bottom') || 'bottom',
            ctas: (() => {
              const fromForm = Array.isArray((queueItem as any)?.formData?.ctas) ? (queueItem as any).formData.ctas : [];
              const list = fromForm
                .map((c: any) => ({ text: String(c?.text || '').trim(), link: String(c?.link || '').trim() || undefined }))
                .filter((c: any) => Boolean(c.text));
              if (list.length > 0) return list;
              const t = String(((queueItem as any)?.formData?.ctaText ?? queueItem.ctaText) || '').trim();
              const l = String(((queueItem as any)?.formData?.ctaLink ?? (queueItem as any)?.formData?.ctaUrl ?? queueItem.ctaUrl) || '').trim();
              return t ? [{ text: t, link: l || undefined }] : [];
            })(),
            ctaText: String(((queueItem as any)?.formData?.ctaText ?? queueItem.ctaText) || '').trim() || undefined,
            ctaLink: String(((queueItem as any)?.formData?.ctaLink ?? (queueItem as any)?.formData?.ctaUrl ?? queueItem.ctaUrl) || '').trim() || undefined,
            preGeneratedContent: structuredContent ? {
              title: String((queueItem as any)?.title || (queueItem as any)?.formData?.title || structuredContent.selectedTitle || '').trim() || structuredContent.selectedTitle,
              content: structuredContent.bodyPlain || structuredContent.content,
              hashtags: (structuredContent.hashtags || []).join(' '),
              structuredContent: structuredContent,
              generatedImages: generatedImages,
            } : null,
            keepBrowserOpen: true, // ✅ 항상 브라우저 세션 유지
            includeThumbnailText: queueItem.includeThumbnailText ?? false,
            contentMode: queueItem.contentMode,      // ✅ [2026-01-20] 쇼핑커넥트 모드 전달
            affiliateLink: queueItem.affiliateLink,  // ✅ [2026-01-20] 제휴 링크 전달
            videoOption: queueItem.videoOption,      // ✅ [2026-01-20] VEO 영상 변환 옵션
            useAiImage: queueItem.useAiImage ?? true, // ✅ [2026-01-20] AI 이미지 생성 사용 여부
            createProductThumbnail: queueItem.createProductThumbnail ?? false, // ✅ [2026-01-20] 제품 썸네일 합성
          };

          console.log('[FullAuto] 발행 옵션:', publishOptions);
          const result = await window.api.multiAccountPublish([queueItem.accountId], publishOptions);
          console.log('[FullAuto] 발행 결과:', result);

          if (stopRequested || (window as any).stopFullAutoPublish) {
            break;
          }

          if (result.success && result.results?.[0]?.success) {
            updateMAStep('ma-step-publish', 'completed');

            // ✅ 발행 URL을 생성된 글 목록에 저장 (유기적 연동)
            const publishedUrl = result.results?.[0]?.url;
            if (publishedUrl && structuredContent?.selectedTitle) {
              const today = new Date();
              savePublishedPost(today, structuredContent.selectedTitle, publishedUrl);

              // 제목으로 글 찾아서 URL 저장 (postId가 없을 때만 폴백)
              if (!generatedPostId) {
                const posts = loadGeneratedPosts();
                const matchingPost = posts.find(p => p.title === structuredContent.selectedTitle && !p.publishedUrl);
                if (matchingPost) {
                  updatePostAfterPublish(matchingPost.id, publishedUrl);
                  addMALog(`📎 발행 URL 저장됨: ${publishedUrl}`, 'info');
                }
              }
            }

            // ✅ 이번 다중계정 항목의 postId가 있으면 해당 글에 URL/이미지 확정 저장
            try {
              if (generatedPostId && publishedUrl) {
                updatePostAfterPublish(generatedPostId, publishedUrl);
                updatePostImages(generatedPostId, generatedImages);
              }
            } catch {
              // ignore
            }

            addMALog(`✅ ${queueItem.accountName}: 발행 성공!`, 'success');
            addProgressItem(`✅ [${i + 1}/${totalItems}] ${queueItem.accountName}: 발행 성공!`, 'success');
            totalSuccess++;
          } else {
            throw new Error(result.results?.[0]?.message || '발행 실패');
          }
        } catch (error) {
          updateMAStep('ma-step-publish', 'error');
          addMALog(`❌ ${queueItem.accountName}: ${(error as Error).message}`, 'error');
          addProgressItem(`❌ [${i + 1}/${totalItems}] ${queueItem.accountName}: ${(error as Error).message}`, 'error');
          totalFail++;
        }

        // 다음 항목 발행 전 대기 (마지막 항목 제외)
        if (i < publishQueue.length - 1 && !stopRequested && !(window as any).stopFullAutoPublish) {
          if (intervalSeconds > 0) {
            const waitMsg = formatWaitTime(intervalSeconds);
            updateMAProgress(i + 1, totalItems, '대기 중...', `⏳ 다음 발행까지 ${waitMsg} 대기`);
            addMALog(`⏳ 다음 발행까지 ${waitMsg} 대기...`, 'info');
            addProgressItem(`⏳ 다음 발행까지 ${waitMsg} 대기...`, 'info');
            const ok = await waitInterruptible(intervalSeconds);
            if (!ok) {
              break;
            }
          }
        }
      }
    } finally {
      isPublishing = false;
      const wasStopped = stopRequested || (window as any).stopFullAutoPublish;

      if (!wasStopped) {
        publishQueue = [];
        renderQueue();
      }

      updateMAProgress(totalItems, totalItems, '완료', wasStopped ? '⏹️ 발행이 중지되었습니다.' : '🎉 모든 발행 완료!');
      addMALog(wasStopped ? '⏹️ 발행이 중지되었습니다.' : `🎉 모든 발행 완료! (성공: ${totalSuccess}, 실패: ${totalFail})`, wasStopped ? 'warning' : 'success');

      // ✅ [2026-01-20 추가] 메모리 정리 - 풀오토 다중계정 발행 완료 후
      try {
        console.log('[FullAuto] 🧹 메모리 정리 시작...');

        // 전역 이미지 배열 초기화
        (window as any).generatedImages = [];
        (window as any).imageManagementGeneratedImages = [];
        (window as any).maPresetThumbnail = null;
        (window as any).maPresetThumbnailPath = null;

        // ImageManager 초기화
        if (typeof ImageManager !== 'undefined') {
          ImageManager.clear();
        }

        console.log('[FullAuto] ✅ 메모리 정리 완료');
      } catch (memErr) {
        console.warn('[FullAuto] 메모리 정리 중 오류:', memErr);
      }

      setTimeout(() => {
        hideMAProgressModal();
      }, 3000);

      addProgressItem(wasStopped ? '⏹️ 발행이 중지되었습니다.' : `🎉 모든 발행 완료! (성공: ${totalSuccess}, 실패: ${totalFail})`, wasStopped ? 'warning' : 'success');

      if (startBtn) {
        startBtn.disabled = false;
        startBtn.innerHTML = startBtnOriginalHtml || '<span style="font-size: 1.25rem;">🚀</span> 대기열 발행 시작';
      }

      if (wasStopped) {
        toastManager.warning(`대기열 발행 중지됨 (성공: ${totalSuccess}개, 실패: ${totalFail}개)`);
      } else {
        toastManager.success(`대기열 발행 완료! 성공: ${totalSuccess}개, 실패: ${totalFail}개`);
      }

      // ✅ [2026-01-23 FIX] 다중계정 발행 완료 후 글 목록 UI 갱신
      try {
        refreshGeneratedPostsList();
        console.log('[FullAuto] ✅ 생성된 글 목록 UI 갱신 완료');
      } catch (e) {
        console.warn('[FullAuto] 글 목록 갱신 실패:', e);
      }
    }
  });

  // 발행 중지 (강제 중지)
  document.getElementById('ma-stop-publish-btn')?.addEventListener('click', async () => {
    stopRequested = true;
    (window as any).stopFullAutoPublish = true;

    // ✅ 다중계정 발행 즉시 중지 (모든 브라우저 강제 종료)
    try {
      await window.api.multiAccountCancel();
    } catch (e) {
      // 무시
    }

    // ✅ UI 즉시 리셋 (발행 중 상태 해제)
    const startBtn = document.getElementById('ma-start-publish-btn') as HTMLButtonElement | null;
    if (startBtn) {
      startBtn.disabled = false;
      startBtn.innerHTML = '<span style="font-size: 1.25rem;">🚀</span> 대기열 발행 시작';
    }

    addMALog('⏹️ 발행이 강제 중지되었습니다.', 'warning');
    addProgressItem('⏹️ 발행이 강제 중지되었습니다.', 'warning');
    toastManager.warning('발행이 강제 중지되었습니다.');

    // 2초 후 모달 닫기
    setTimeout(() => {
      hideMAProgressModal();
    }, 2000);
  });

  document.getElementById('ma-progress-stop-btn')?.addEventListener('click', async () => {
    stopRequested = true;
    (window as any).stopFullAutoPublish = true;

    // ✅ 다중계정 발행 즉시 중지 (모든 브라우저 강제 종료)
    try {
      await window.api.multiAccountCancel();
    } catch (e) {
      // 무시
    }

    // ✅ UI 즉시 리셋 (발행 중 상태 해제)
    const startBtn = document.getElementById('ma-start-publish-btn') as HTMLButtonElement | null;
    if (startBtn) {
      startBtn.disabled = false;
      startBtn.innerHTML = '<span style="font-size: 1.25rem;">🚀</span> 대기열 발행 시작';
    }

    const stopBtn = document.getElementById('ma-progress-stop-btn');
    const closeBtn = document.getElementById('ma-progress-close-btn');
    const completeBtn = document.getElementById('ma-progress-complete-btn');
    if (stopBtn) stopBtn.style.display = 'none';
    if (closeBtn) {
      closeBtn.style.display = 'flex';
      if (!closeBtn.hasAttribute('data-listener-added')) {
        closeBtn.setAttribute('data-listener-added', 'true');
        closeBtn.addEventListener('click', () => {
          hideMAProgressModal();
        });
      }
    }
    if (completeBtn) completeBtn.style.display = 'none';

    addMALog('⏹️ 발행이 강제 중지되었습니다.', 'warning');
    addProgressItem('⏹️ 발행이 강제 중지되었습니다.', 'warning');
    toastManager.warning('발행이 강제 중지되었습니다.');
    setTimeout(() => {
      hideMAProgressModal();
    }, 2000);
  });

  // 진행 상황 항목 추가 (모달 로그로 통합)
  function addProgressItem(message: string, type: 'info' | 'success' | 'error' | 'warning') {
    // 모달 내부 로그로 통합 (외부 진행 목록은 더 이상 사용하지 않음)
    addMALog(message, type);
  }

  console.log('[MultiAccountPublish] 다중계정 동시발행 모달 초기화 완료');
}

// DOM 로드 시 다중계정 모달 초기화
document.addEventListener('DOMContentLoaded', () => {
  initMultiAccountPublishModal();
  initMainAccountSelector();
});

// ✅ 메인 대시보드 계정 선택 및 세션 관리
function initMainAccountSelector() {
  const accountSelector = document.getElementById('main-account-selector') as HTMLSelectElement;
  const addAccountBtn = document.getElementById('main-add-account-btn');
  const selectedAccountInfo = document.getElementById('selected-account-info');
  const selectedAccountName = document.getElementById('selected-account-name');
  const saveSessionBtn = document.getElementById('save-session-btn');
  const loadSessionBtn = document.getElementById('load-session-btn');
  const clearSessionBtn = document.getElementById('clear-session-btn');
  const naverIdInput = document.getElementById('naver-id') as HTMLInputElement;
  const naverPwInput = document.getElementById('naver-password') as HTMLInputElement;

  if (!accountSelector) return;

  // 현재 선택된 계정 ID
  let currentAccountId: string | null = null;

  // ✅ 계정 목록을 리렌더링할 때 change 핸들러가 의도치 않게 실행되어 세션이 날아가는 현상 방지
  let isRefreshingAccountList = false;

  let refreshAccountListTimer: any = null;
  let lastMultiAccountModalVisible = false;

  const scheduleAccountListRefresh = () => {
    try {
      if (refreshAccountListTimer) clearTimeout(refreshAccountListTimer);
    } catch {
      // ignore
    }
    refreshAccountListTimer = setTimeout(() => {
      loadAccountList();
    }, 250);
  };

  // 계정별 세션 데이터 저장소 (메모리)
  const accountSessions: Map<string, any> = new Map();

  // 계정 목록 로드
  async function loadAccountList() {
    try {
      const previousValue = accountSelector.value;
      isRefreshingAccountList = true;
      const result = await window.api.getAllBlogAccounts();
      if (result.success && result.accounts) {
        accountSelector.innerHTML = '<option value="">직접 입력</option>';
        result.accounts.forEach((account: any) => {
          const option = document.createElement('option');
          option.value = account.id;
          option.textContent = `👤 ${account.name}`;
          accountSelector.appendChild(option);
        });

        // ✅ 가능한 경우 기존 선택값 유지
        if (previousValue && Array.from(accountSelector.options).some(o => o.value === previousValue)) {
          accountSelector.value = previousValue;
        }
      }
    } catch (error) {
      console.error('[MainAccountSelector] 계정 목록 로드 실패:', error);
    } finally {
      isRefreshingAccountList = false;
    }
  }

  // ✅ 1개 계정 탭 드롭다운 새로고침 함수 글로벌 노출 (계정 동기화용)
  (window as any).loadMainAccountList = loadAccountList;

  // 현재 UI 상태 수집
  function collectCurrentSession(): any {
    return {
      // 제목/키워드/URL
      title: (document.getElementById('unified-title') as HTMLInputElement)?.value || '',
      keywords: (document.getElementById('unified-keywords') as HTMLInputElement)?.value || '',
      urls: Array.from(document.querySelectorAll('.unified-url-input') as NodeListOf<HTMLInputElement>).map(el => el.value).filter(v => v),

      // 생성된 콘텐츠
      generatedTitle: (document.getElementById('unified-generated-title') as HTMLInputElement)?.value || '',
      generatedContent: (document.getElementById('unified-generated-content') as HTMLTextAreaElement)?.value || '',
      generatedHashtags: (document.getElementById('unified-generated-hashtags') as HTMLInputElement)?.value || '',

      // 설정
      generator: (document.getElementById('unified-generator') as HTMLSelectElement)?.value || 'gemini',
      publishMode: (document.getElementById('unified-publish-mode') as HTMLSelectElement)?.value || 'publish',
      toneStyle: (document.getElementById('unified-tone-style') as HTMLSelectElement)?.value || 'friendly',
      imageSource: (document.getElementById('unified-image-source') as HTMLSelectElement)?.value || 'gemini',

      // CTA 설정
      ctaText: (document.getElementById('unified-cta-text') as HTMLInputElement)?.value || '',
      ctaLink: (document.getElementById('unified-cta-link') as HTMLInputElement)?.value || '',
      ctas: readUnifiedCtasFromUi(),
      skipCta: (document.getElementById('unified-skip-cta') as HTMLInputElement)?.checked || false,

      // 타임스탬프
      savedAt: new Date().toISOString(),
    };
  }

  // UI 상태 복원
  function restoreSession(session: any) {
    if (!session) return;

    // 제목/키워드
    const titleInput = document.getElementById('unified-title') as HTMLInputElement;
    const keywordsInput = document.getElementById('unified-keywords') as HTMLInputElement;
    if (titleInput) titleInput.value = session.title || '';
    if (keywordsInput) keywordsInput.value = session.keywords || '';

    // URL 필드
    const urlInputs = document.querySelectorAll('.unified-url-input') as NodeListOf<HTMLInputElement>;
    if (urlInputs[0] && session.urls?.[0]) urlInputs[0].value = session.urls[0];

    // 생성된 콘텐츠
    const genTitle = document.getElementById('unified-generated-title') as HTMLInputElement;
    const genContent = document.getElementById('unified-generated-content') as HTMLTextAreaElement;
    const genHashtags = document.getElementById('unified-generated-hashtags') as HTMLInputElement;
    if (genTitle) genTitle.value = session.generatedTitle || '';
    if (genContent) genContent.value = session.generatedContent || '';
    if (genHashtags) genHashtags.value = session.generatedHashtags || '';

    // 설정
    const generator = document.getElementById('unified-generator') as HTMLSelectElement;
    const publishMode = document.getElementById('unified-publish-mode') as HTMLSelectElement;
    const toneStyle = document.getElementById('unified-tone-style') as HTMLSelectElement;
    const imageSource = document.getElementById('unified-image-source') as HTMLSelectElement;
    if (generator) generator.value = session.generator || 'gemini';
    if (publishMode) publishMode.value = session.publishMode || 'publish';
    if (toneStyle) toneStyle.value = session.toneStyle || 'friendly';
    if (imageSource) imageSource.value = session.imageSource || 'gemini';

    // CTA 설정
    const ctaText = document.getElementById('unified-cta-text') as HTMLInputElement;
    const ctaLink = document.getElementById('unified-cta-link') as HTMLInputElement;
    const skipCta = document.getElementById('unified-skip-cta') as HTMLInputElement;
    if (ctaText) ctaText.value = session.ctaText || '';
    if (ctaLink) ctaLink.value = session.ctaLink || '';
    if (skipCta) skipCta.checked = session.skipCta || false;

    // ✅ 다중 CTA 복원 (컨테이너가 있는 경우)
    try {
      const container = document.getElementById('unified-cta-items-container');
      if (container && Array.isArray(session.ctas)) {
        container.innerHTML = '';
        for (const c of session.ctas) {
          const text = String((c as any)?.text || '').trim();
          const link = String((c as any)?.link || '').trim();
          if (!text) continue;
          const row = document.createElement('div');
          row.className = 'unified-cta-item';
          row.style.cssText = 'display:flex; gap:0.5rem; align-items:center; margin-bottom:0.5rem;';
          row.innerHTML = `
            <input type="text" class="unified-cta-text" placeholder="CTA 텍스트" style="flex:1; padding: 0.75rem; border: 1px solid var(--border-light); border-radius: var(--radius-sm); font-size: 0.9rem; background: var(--bg-primary);" value="${escapeHtml(text)}">
            <input type="url" class="unified-cta-link" placeholder="링크 URL" style="flex:1; padding: 0.75rem; border: 1px solid var(--border-light); border-radius: var(--radius-sm); font-size: 0.9rem; background: var(--bg-primary);" value="${escapeHtml(link)}">
            <button type="button" class="unified-cta-remove" style="padding:0.5rem 0.75rem; background: rgba(239,68,68,0.15); color:#ef4444; border: 1px solid rgba(239,68,68,0.35); border-radius: 8px; cursor:pointer;">✕</button>
          `;
          container.appendChild(row);
        }
      }
    } catch {
      // ignore
    }
  }

  // UI 초기화
  function clearSession() {
    // 제목/키워드
    const titleInput = document.getElementById('unified-title') as HTMLInputElement;
    const keywordsInput = document.getElementById('unified-keywords') as HTMLInputElement;
    if (titleInput) titleInput.value = '';
    if (keywordsInput) keywordsInput.value = '';

    // URL 필드
    const urlInputs = document.querySelectorAll('.unified-url-input') as NodeListOf<HTMLInputElement>;
    urlInputs.forEach(input => input.value = '');

    // 생성된 콘텐츠
    const genTitle = document.getElementById('unified-generated-title') as HTMLInputElement;
    const genContent = document.getElementById('unified-generated-content') as HTMLTextAreaElement;
    const genHashtags = document.getElementById('unified-generated-hashtags') as HTMLInputElement;
    if (genTitle) genTitle.value = '';
    if (genContent) genContent.value = '';
    if (genHashtags) genHashtags.value = '';

    // CTA 설정
    const ctaText = document.getElementById('unified-cta-text') as HTMLInputElement;
    const ctaLink = document.getElementById('unified-cta-link') as HTMLInputElement;
    const skipCta = document.getElementById('unified-skip-cta') as HTMLInputElement;
    if (ctaText) ctaText.value = '';
    if (ctaLink) ctaLink.value = '';
    if (skipCta) skipCta.checked = false;
  }

  // 계정 선택 변경
  accountSelector.addEventListener('change', async () => {
    if (isRefreshingAccountList) return;
    const selectedId = accountSelector.value;

    // 이전 계정 세션 저장
    if (currentAccountId) {
      accountSessions.set(currentAccountId, collectCurrentSession());
    }

    if (selectedId) {
      // 계정 선택됨
      currentAccountId = selectedId;

      // 계정 정보 가져오기
      const result = await window.api.getAllBlogAccounts();
      const account = result.accounts?.find((a: any) => a.id === selectedId);

      if (account) {
        (window as any).currentMainAccountSettings = account.settings || {};
        // 선택된 계정 정보 표시
        if (selectedAccountInfo) selectedAccountInfo.style.display = 'block';
        if (selectedAccountName) selectedAccountName.textContent = account.name;

        // 로그인 정보 채우기
        const credResult = await window.api.getAccountCredentials(selectedId);
        if (credResult.success && credResult.credentials) {
          if (naverIdInput) naverIdInput.value = credResult.credentials.naverId || '';
          if (naverPwInput) naverPwInput.value = credResult.credentials.naverPassword || '';
        }

        // 저장된 세션이 있으면 복원, 없으면 초기화
        if (accountSessions.has(selectedId)) {
          restoreSession(accountSessions.get(selectedId));
          toastManager.info(`📂 ${account.name} 계정의 이전 세션을 불러왔습니다.`);
        } else {
          clearSession();
          toastManager.info(`👤 ${account.name} 계정으로 전환되었습니다. 새로운 세션입니다.`);
        }
      }
    } else {
      // 직접 입력 모드
      currentAccountId = null;
      (window as any).currentMainAccountSettings = null;
      if (selectedAccountInfo) selectedAccountInfo.style.display = 'none';
      clearSession();
      if (naverIdInput) naverIdInput.value = '';
      if (naverPwInput) naverPwInput.value = '';
      toastManager.info('📝 직접 입력 모드로 전환되었습니다.');
    }
  });

  // 계정 추가 버튼 - 다중계정 모달 열기
  addAccountBtn?.addEventListener('click', () => {
    if (typeof (window as any).openAccountEditModal === 'function') {
      (window as any).openAccountEditModal();
      return;
    }

    const multiAccountModal = document.getElementById('multi-account-modal');
    if (multiAccountModal) {
      multiAccountModal.style.display = 'flex';
      multiAccountModal.setAttribute('aria-hidden', 'false');
      return;
    }

    const multiAccountBtn = document.getElementById('multi-account-btn');
    multiAccountBtn?.click();
  });

  // 세션 저장 버튼
  saveSessionBtn?.addEventListener('click', () => {
    if (!currentAccountId) {
      toastManager.warning('계정을 먼저 선택해주세요.');
      return;
    }
    accountSessions.set(currentAccountId, collectCurrentSession());
    toastManager.success('💾 현재 세션이 저장되었습니다.');
  });

  // 세션 불러오기 버튼
  loadSessionBtn?.addEventListener('click', () => {
    if (!currentAccountId) {
      toastManager.warning('계정을 먼저 선택해주세요.');
      return;
    }
    if (accountSessions.has(currentAccountId)) {
      restoreSession(accountSessions.get(currentAccountId));
      toastManager.success('📂 저장된 세션을 불러왔습니다.');
    } else {
      toastManager.warning('저장된 세션이 없습니다.');
    }
  });

  // 세션 초기화 버튼
  clearSessionBtn?.addEventListener('click', () => {
    if (confirm('현재 세션을 초기화하시겠습니까?\n입력된 모든 내용이 삭제됩니다.')) {
      clearSession();
      if (currentAccountId) {
        accountSessions.delete(currentAccountId);
      }
      toastManager.success('🗑️ 세션이 초기화되었습니다.');
    }
  });

  // 초기 로드
  loadAccountList();

  // 다중계정 모달에서 계정 추가/삭제 시 목록 새로고침
  const observer = new MutationObserver(() => {
    if (!multiAccountModal) return;
    const el = multiAccountModal as HTMLElement;
    const isVisible = el.style.display !== 'none' && getComputedStyle(el).display !== 'none';

    // ✅ 모달이 닫힐 때 1회만 새로고침 (열림/애니메이션 중 잦은 트리거 방지)
    if (lastMultiAccountModalVisible && !isVisible) {
      scheduleAccountListRefresh();
    }
    lastMultiAccountModalVisible = isVisible;
  });

  const multiAccountModal = document.getElementById('multi-account-modal');
  if (multiAccountModal) {
    try {
      const el = multiAccountModal as HTMLElement;
      lastMultiAccountModalVisible = el.style.display !== 'none' && getComputedStyle(el).display !== 'none';
    } catch {
      lastMultiAccountModalVisible = false;
    }
    observer.observe(multiAccountModal, { attributes: true, attributeFilter: ['style'] });
  }

  console.log('[MainAccountSelector] 메인 계정 선택기 초기화 완료');
}

// ==========================================
// ✅ AI 어시스턴트 채팅 UI
// ==========================================
function initAIAssistant() {
  const assistantBtn = document.getElementById('ai-assistant-btn');
  const assistantPanel = document.getElementById('ai-assistant-panel');
  const closeBtn = document.getElementById('ai-assistant-close');
  const chatInput = document.getElementById('ai-chat-input') as HTMLInputElement;
  const sendBtn = document.getElementById('ai-chat-send');
  const messagesContainer = document.getElementById('ai-chat-messages');
  const quickBtns = document.querySelectorAll('.ai-quick-btn');

  if (!assistantBtn || !assistantPanel) {
    console.log('[AIAssistant] 요소를 찾을 수 없음');
    return;
  }

  // 패널 열기/닫기
  assistantBtn.addEventListener('click', () => {
    const isVisible = assistantPanel.style.display === 'flex';
    assistantPanel.style.display = isVisible ? 'none' : 'flex';
    if (!isVisible && chatInput) {
      chatInput.focus();
    }
  });

  closeBtn?.addEventListener('click', () => {
    assistantPanel.style.display = 'none';
  });

  // 메시지 전송
  async function sendMessage(message: string) {
    if (!message.trim() || !messagesContainer) return;

    // 사용자 메시지 추가
    const userMsgDiv = document.createElement('div');
    userMsgDiv.className = 'ai-message user';
    userMsgDiv.innerHTML = `<div style="color: var(--text-strong); line-height: 1.6;">${escapeHtml(message)}</div>`;
    messagesContainer.appendChild(userMsgDiv);

    // 입력창 초기화
    if (chatInput) chatInput.value = '';

    // 타이핑 인디케이터 추가
    const typingDiv = document.createElement('div');
    typingDiv.className = 'ai-message assistant';
    typingDiv.innerHTML = `
      <div class="ai-typing">
        <span></span><span></span><span></span>
      </div>
    `;
    typingDiv.style.background = 'linear-gradient(135deg, rgba(148, 163, 184, 0.15), rgba(100, 116, 139, 0.1))';
    typingDiv.style.padding = '1rem';
    typingDiv.style.borderRadius = '12px';
    typingDiv.style.border = '1px solid rgba(148, 163, 184, 0.3)';
    messagesContainer.appendChild(typingDiv);
    typingDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });

    try {
      // AI 응답 요청
      console.log('[AIAssistant] IPC 호출 시작:', message);
      console.log('[AIAssistant] window.api.aiAssistantChat 존재:', typeof window.api.aiAssistantChat);
      if (!window.api.aiAssistantChat) {
        throw new Error('aiAssistantChat API가 정의되지 않았습니다');
      }
      const result = await window.api.aiAssistantChat(message);
      console.log('[AIAssistant] IPC 응답:', result);

      // 타이핑 인디케이터 제거
      typingDiv.remove();

      // AI 응답 추가
      const aiMsgDiv = document.createElement('div');
      aiMsgDiv.className = 'ai-message assistant';
      aiMsgDiv.style.background = 'linear-gradient(135deg, rgba(148, 163, 184, 0.15), rgba(100, 116, 139, 0.1))';
      aiMsgDiv.style.padding = '1rem';
      aiMsgDiv.style.borderRadius = '12px';
      aiMsgDiv.style.border = '1px solid rgba(148, 163, 184, 0.3)';

      const responseText = result?.response || '죄송해요, 응답을 생성하지 못했어요.';
      aiMsgDiv.innerHTML = `<div style="color: var(--text-strong); line-height: 1.6; white-space: pre-wrap;">${formatAIResponse(responseText)}</div>`;
      messagesContainer.appendChild(aiMsgDiv);

      // 액션 버튼 추가
      if (result?.actions && result.actions.length > 0) {
        const actionsDiv = document.createElement('div');
        actionsDiv.style.cssText = 'display: flex; gap: 0.5rem; flex-wrap: wrap; margin-top: 0.75rem;';
        result.actions.forEach((action: any) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.textContent = action.label;
          btn.style.cssText = 'padding: 0.5rem 0.75rem; background: rgba(236, 72, 153, 0.2); border: 1px solid rgba(236, 72, 153, 0.4); border-radius: 8px; color: var(--text-strong); font-size: 0.8rem; cursor: pointer;';
          btn.addEventListener('click', () => handleAIAction(action.action));
          actionsDiv.appendChild(btn);
        });
        aiMsgDiv.appendChild(actionsDiv);
      }

      // 후속 질문 제안
      const followUps = result?.suggestFollowUp ?? [];
      if (false && followUps.length > 0) {
        const suggestDiv = document.createElement('div');
        suggestDiv.style.cssText = 'margin-top: 0.75rem; display: flex; gap: 0.5rem; flex-wrap: wrap;';
        followUps.slice(0, 3).forEach((suggestion: string) => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.textContent = suggestion;
          btn.style.cssText = 'padding: 0.4rem 0.6rem; background: rgba(139, 92, 246, 0.15); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 12px; color: var(--text-muted); font-size: 0.75rem; cursor: pointer;';
          btn.addEventListener('click', () => sendMessage(suggestion));
          suggestDiv.appendChild(btn);
        });
        aiMsgDiv.appendChild(suggestDiv);
      }

      aiMsgDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });

    } catch (error) {
      typingDiv.remove();
      const errorDiv = document.createElement('div');
      errorDiv.className = 'ai-message assistant';
      errorDiv.innerHTML = `<div style="color: var(--text-strong);">❌ 오류가 발생했어요. 다시 시도해주세요.</div>`;
      errorDiv.style.background = 'rgba(239, 68, 68, 0.15)';
      errorDiv.style.padding = '1rem';
      errorDiv.style.borderRadius = '12px';
      errorDiv.style.border = '1px solid rgba(239, 68, 68, 0.3)';
      messagesContainer.appendChild(errorDiv);

      errorDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  }

  // AI 응답 포맷팅
  function formatAIResponse(text: string): string {
    return text
      .replace(/\n/g, '<br>')
      .replace(/•/g, '•')
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
  }

  // AI 액션 처리
  function handleAIAction(action: string) {
    // AI 패널 닫기
    const panel = document.getElementById('ai-assistant-panel');
    if (panel) panel.style.display = 'none';

    switch (action) {
      case 'openUnifiedTab':
        // 스마트 자동 발행 탭으로 이동 (포커스는 강제하지 않음)
        const unifiedTabBtn = document.querySelector('[data-tab="unified"]') as HTMLElement;
        unifiedTabBtn?.click();
        setTimeout(() => {
          document.getElementById('unified-semi-auto-section')?.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 350);
        break;
      case 'openImagesTab':
        // 이미지 관리 탭으로 이동
        const imagesTabBtn = document.querySelector('[data-tab="images"]') as HTMLElement;
        imagesTabBtn?.click();
        break;
      case 'switchToUrlMode':
      case 'switchToKeywordMode':
      case 'startGeneration':
        // 스마트 자동 발행 탭으로 이동
        const unifiedTab = document.querySelector('[data-tab="unified"]') as HTMLElement;
        unifiedTab?.click();
        // 키워드 입력란에 포커스
        setTimeout(() => {
          const keywordInput = document.getElementById('ua-keyword') as HTMLInputElement;
          keywordInput?.focus();
        }, 300);
        break;
      case 'startFullAuto':
      case 'openMultiAccountModal':
        // 풀오토 다중계정 버튼 클릭
        const multiAccountBtn = document.getElementById('multi-account-btn');
        multiAccountBtn?.click();
        break;
      case 'generateImage':
        // 썸네일 생성기 탭으로 이동
        const imageToolsTab = document.querySelector('[data-tab="image-tools"]') as HTMLElement;
        imageToolsTab?.click();
        break;
      case 'openSettings':
        const settingsBtn = document.getElementById('settings-button-fixed');
        settingsBtn?.click();
        break;
      case 'openToolsHub':
        // 가이드/분석 모음 모달 열기
        const toolsHubBtn = document.getElementById('tools-hub-btn');
        toolsHubBtn?.click();
        break;
      case 'openExternalTools':
        // 가이드/분석 모음 모달 열고 외부유입 탭으로 이동
        const toolsBtn1 = document.getElementById('tools-hub-btn');
        toolsBtn1?.click();
        setTimeout(() => {
          const externalTab = document.querySelector('[data-tools-tab="external"]') as HTMLElement;
          externalTab?.click();
        }, 300);
        break;
      case 'openAnalyticsTools':
        // 가이드/분석 모음 모달 열고 분석도구 탭으로 이동
        const toolsBtn2 = document.getElementById('tools-hub-btn');
        toolsBtn2?.click();
        setTimeout(() => {
          const analyticsTab = document.querySelector('[data-tools-tab="analytics"]') as HTMLElement;
          analyticsTab?.click();
        }, 300);
        break;
      case 'openLeword':
        // LEWORD 키워드 분석 받으러 오픈채팅으로 이동
        window.api?.openExternalUrl?.('https://open.kakao.com/o/sPcaslwh');
        break;
      case 'openDatalab':
        // 네이버 데이터랩 열기
        window.api?.openExternalUrl?.('https://datalab.naver.com/');
        break;
      case 'openScheduleTab':
        // 예약 발행 탭으로 이동
        const scheduleTab = document.querySelector('[data-tab="schedule"]') as HTMLElement;
        scheduleTab?.click();
        break;
      case 'openContinuousTab':
        // 연속 발행 탭으로 이동
        const continuousTab = document.querySelector('[data-tab="continuous"]') as HTMLElement;
        continuousTab?.click();
        break;
      case 'playTutorialVideo':
        // 가이드/분석 모음 모달 열고 사용법 탭으로 이동
        const toolsBtn3 = document.getElementById('tools-hub-btn');
        toolsBtn3?.click();
        setTimeout(() => {
          const tutorialsTab = document.querySelector('[data-tools-tab="tutorials"]') as HTMLElement;
          tutorialsTab?.click();
        }, 300);
        break;
      case 'runAutoFix':
        // 🔧 자동 수정 실행
        runSystemAutoFix();
        break;
    }
  }

  // ✅ 시스템 자동 수정 실행
  async function runSystemAutoFix() {
    const messagesContainer = document.getElementById('ai-chat-messages');
    if (!messagesContainer) return;

    const pin = prompt('관리자 PIN을 입력하세요');
    if (pin === null) {
      return;
    }

    try {
      const verify = await window.api.verifyAdminPin?.(pin);
      if (!verify?.success) {
        const failDiv = document.createElement('div');
        failDiv.className = 'ai-message assistant';
        failDiv.style.cssText = 'background: rgba(239, 68, 68, 0.15); padding: 1rem; border-radius: 12px; border: 1px solid rgba(239, 68, 68, 0.3);';
        failDiv.innerHTML = `<div style="color: var(--text-strong); line-height: 1.6;">❌ ${escapeHtml(verify?.message || 'PIN 확인 실패')}</div>`;
        messagesContainer.appendChild(failDiv);
        failDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
        return;
      }
    } catch (e) {
      const failDiv = document.createElement('div');
      failDiv.className = 'ai-message assistant';
      failDiv.style.cssText = 'background: rgba(239, 68, 68, 0.15); padding: 1rem; border-radius: 12px; border: 1px solid rgba(239, 68, 68, 0.3);';
      failDiv.innerHTML = `<div style="color: var(--text-strong); line-height: 1.6;">❌ PIN 확인 중 오류가 발생했습니다.</div>`;
      messagesContainer.appendChild(failDiv);
      failDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
      return;
    }

    // 진행 중 메시지 표시
    const progressDiv = document.createElement('div');
    progressDiv.className = 'ai-message assistant';
    progressDiv.style.cssText = 'background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(37, 99, 235, 0.1)); padding: 1rem; border-radius: 12px; border: 1px solid rgba(59, 130, 246, 0.3);';
    progressDiv.innerHTML = `<div style="color: var(--text-strong); line-height: 1.6;">🔧 자동 수정 실행 중...</div>`;
    messagesContainer.appendChild(progressDiv);
    progressDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });

    try {
      const result = await window.api.aiAssistantRunAutoFix();
      progressDiv.remove();

      const resultDiv = document.createElement('div');
      resultDiv.className = 'ai-message assistant';

      if (result.success && result.fixResults && result.fixResults.length > 0) {
        resultDiv.style.cssText = 'background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(5, 150, 105, 0.1)); padding: 1rem; border-radius: 12px; border: 1px solid rgba(16, 185, 129, 0.3);';
        let html = `<div style="color: var(--text-strong); line-height: 1.6;">`;
        html += `<strong>✅ 자동 수정 완료!</strong><br><br>`;
        result.fixResults.forEach((fix: any) => {
          html += `• <strong>${fix.action}</strong>: ${fix.message}<br>`;
        });
        html += `<br>설정이 저장되었습니다. 앱을 재시작하면 변경사항이 적용됩니다.</div>`;
        resultDiv.innerHTML = html;
      } else {
        resultDiv.style.cssText = 'background: linear-gradient(135deg, rgba(212, 175, 55, 0.15), rgba(184, 134, 11, 0.1)); padding: 1rem; border-radius: 12px; border: 1px solid rgba(212, 175, 55, 0.3);';
        resultDiv.innerHTML = `<div style="color: var(--text-strong); line-height: 1.6;">ℹ️ ${result.message}</div>`;
      }

      messagesContainer.appendChild(resultDiv);
      resultDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });

      toastManager.success(result.message);

    } catch (error) {
      progressDiv.remove();

      const errorDiv = document.createElement('div');
      errorDiv.className = 'ai-message assistant';
      errorDiv.style.cssText = 'background: rgba(239, 68, 68, 0.15); padding: 1rem; border-radius: 12px; border: 1px solid rgba(239, 68, 68, 0.3);';
      errorDiv.innerHTML = `<div style="color: var(--text-strong);">❌ 자동 수정 중 오류가 발생했습니다.</div>`;
      messagesContainer.appendChild(errorDiv);

      errorDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });

      toastManager.error('자동 수정 실패');
    }
  }

  // 전송 버튼 클릭
  sendBtn?.addEventListener('click', () => {
    if (chatInput) sendMessage(chatInput.value);
  });

  // Enter 키로 전송
  chatInput?.addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage(chatInput.value);
    }
  });

  // 빠른 질문 버튼
  quickBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      const question = btn.getAttribute('data-question');
      if (question) sendMessage(question);
    });
  });

  // ✅ 오늘의 팁 기능
  const dailyTips = [
    '키워드는 검색량 500~3000 사이가 상위노출 확률이 높아요!',
    '글 발행 후 30분 내에 첫 유입이 발생하면 좋은 신호예요 📈',
    '이미지는 최소 3개 이상 넣으면 체류시간이 늘어나요 🖼️',
    '본문에 키워드를 자연스럽게 5~7회 반복하면 좋아요',
    '풀오토 발행 시 계정마다 30분 이상 간격을 두세요 ⏰',
    '소제목(H2, H3)을 활용하면 가독성이 좋아져요',
    '저품질 방지를 위해 하루 발행량은 2~3개가 적당해요',
    '네이버 데이터랩에서 실시간 트렌드를 확인하세요 📊',
    '글 길이는 1500~2500자가 가장 이상적이에요',
    'LEWORD에서 경쟁도 낮은 키워드를 찾아보세요 🔍',
    '썸네일은 밝고 눈에 띄는 색상이 클릭률이 높아요',
    '발행 시간은 오전 8시, 점심, 저녁 9시가 좋아요 🕐',
    '관련 키워드를 태그에 5~10개 추가하세요 🏷️',
    'URL 참고 발행 시 원본과 다른 관점으로 작성하세요',
    '정기적으로 과거 글을 업데이트하면 노출이 유지돼요'
  ];

  const tipContent = document.getElementById('ai-tip-content');
  const tipRefreshBtn = document.getElementById('ai-tip-refresh');

  function showRandomTip() {
    if (tipContent) {
      const randomTip = dailyTips[Math.floor(Math.random() * dailyTips.length)];
      tipContent.textContent = randomTip;
    }
  }

  tipRefreshBtn?.addEventListener('click', showRandomTip);

  // ✅ 대화 초기화 버튼
  const clearChatBtn = document.getElementById('ai-clear-chat');
  clearChatBtn?.addEventListener('click', () => {
    if (messagesContainer) {
      messagesContainer.innerHTML = `
        <div class="ai-message assistant" style="background: linear-gradient(135deg, rgba(212, 175, 55, 0.15), rgba(184, 134, 11, 0.1)); padding: 1rem; border-radius: 12px; border: 1px solid rgba(212, 175, 55, 0.3);">
          <div style="color: var(--text-strong); line-height: 1.6;">
            대화가 초기화되었어요! ✨<br><br>
            무엇이든 물어보세요! 🙌
          </div>
        </div>
      `;
    }

    try {
      window.api?.aiAssistantClearChat?.();
    } catch {
      // ignore
    }
  });

  // ✅ 바로가기 링크 클릭 처리
  document.addEventListener('click', (e) => {
    const target = e.target as HTMLElement;
    if (target.classList.contains('ai-action-link')) {
      e.preventDefault();
      const action = target.getAttribute('data-action');
      if (action) {
        handleAIAction(action);
      }
    }
  });

  console.log('[AIAssistant] AI 어시스턴트 초기화 완료');
}

// AI 어시스턴트 초기화 호출
initAIAssistant();

// ✅ 도구 모음 + 다계정 자동순환 모달 초기화 (이벤트 위임 방식)
function initToolsHubModal() {
  console.log('[ToolsHub] 초기화 시작...');

  // 이벤트 위임: document에서 클릭 이벤트 감지
  document.addEventListener('click', (e) => {
    const target = e.target as HTMLElement;

    // 가이드/분석 모음 버튼 클릭
    if (target.id === 'tools-hub-btn' || target.closest('#tools-hub-btn')) {
      e.preventDefault();
      e.stopPropagation();
      console.log('[ToolsHub] 버튼 클릭됨 (위임)');
      const modal = document.getElementById('tools-hub-modal');
      console.log('[ToolsHub] 모달 요소:', modal);
      if (modal) {
        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden', 'false');
        console.log('[ToolsHub] 모달 열림, display:', modal.style.display);

        // 사용법 영상 목록 로드
        loadTutorialVideos();
      } else {
        console.error('[ToolsHub] 모달을 찾을 수 없음');
      }
    }

    // 다계정 자동순환 버튼 클릭
    if (target.id === 'auto-rotation-btn' || target.closest('#auto-rotation-btn')) {
      e.preventDefault();
      e.stopPropagation();
      console.log('[AutoRotation] 버튼 클릭됨');
      const modal = document.getElementById('auto-rotation-modal');
      if (modal) {
        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden', 'false');
        console.log('[AutoRotation] 모달 열림');
      }
    }

    // 닫기 버튼 클릭
    if (target.id === 'tools-hub-close' || target.closest('#tools-hub-close')) {
      const modal = document.getElementById('tools-hub-modal');
      if (modal) modal.style.display = 'none';
    }

    // 다계정 자동순환 모달 닫기
    if (target.id === 'auto-rotation-close' || target.closest('#auto-rotation-close')) {
      const modal = document.getElementById('auto-rotation-modal');
      if (modal) modal.style.display = 'none';
    }

    // 모달 외부 클릭
    if (target.id === 'tools-hub-modal') {
      target.style.display = 'none';
    }
    if (target.id === 'auto-rotation-modal') {
      target.style.display = 'none';
    }
  });

  const toolsTabs = document.querySelectorAll('.tools-hub-tab');
  const toolsPanels = document.querySelectorAll('.tools-tab-panel');

  // 탭 전환
  toolsTabs.forEach(tab => {
    tab.addEventListener('click', () => {
      const targetTab = tab.getAttribute('data-tools-tab');

      // 모든 탭 비활성화
      toolsTabs.forEach(t => {
        t.classList.remove('active');
        (t as HTMLElement).style.color = 'var(--text-muted)';
      });

      // 클릭한 탭 활성화
      tab.classList.add('active');
      (tab as HTMLElement).style.color = 'var(--text-strong)';

      // 모든 패널 숨기기
      toolsPanels.forEach(panel => {
        (panel as HTMLElement).style.display = 'none';
      });

      // 해당 패널 표시
      const targetPanel = document.getElementById(`tools-tab-${targetTab}`);
      if (targetPanel) targetPanel.style.display = 'block';

      // ✅ 사용법 탭 클릭 시 영상 목록 로드
      if (targetTab === 'tutorials') {
        console.log('[ToolsHub] 사용법 탭 클릭 - 영상 로드');
        loadTutorialVideos();
      }
    });
  });

  console.log('[ToolsHub] 도구 모음 모달 초기화 완료');
}

// 도구 모음 모달 초기화 호출
initToolsHubModal();
initGeminiSelectionUI();

// ✅ Gemini 모델 선택 UI 스타일 로직
function initGeminiSelectionUI(): void {
  const cards = document.querySelectorAll('.gemini-model-card');
  if (cards.length === 0) return;

  function updateStyles() {
    cards.forEach(card => {
      const input = card.querySelector('input[type="radio"]') as HTMLInputElement;
      if (!input) return;

      const cardEl = card as HTMLElement;
      const iconBg = card.querySelector('div:first-child') as HTMLElement;

      if (input.checked) {
        // 선택됨
        cardEl.style.borderColor = '#d4af37';
        cardEl.style.boxShadow = '0 4px 12px rgba(212, 175, 55, 0.15)';
        if (iconBg) iconBg.style.backgroundColor = '#fffbeb';
        input.style.accentColor = '#d4af37';
      } else {
        // 해제됨
        cardEl.style.borderColor = '#e5e7eb';
        cardEl.style.boxShadow = '0 2px 4px rgba(0,0,0,0.03)';
        if (iconBg) iconBg.style.backgroundColor = '#f3f4f6';
        input.style.accentColor = '#6b7280';
      }
    });
  }

  // 초기 실행
  updateStyles();

  // 이벤트 리스너
  const inputs = document.querySelectorAll('input[name="primaryGeminiTextModel"]');
  inputs.forEach(input => {
    input.addEventListener('change', updateStyles);
  });

  console.log('[UI] Gemini 모델 선택 스타일 초기화 완료');
}

// ✅ 콘텐츠 모드 도움말 시스템 및 스마트 발행 버튼 초기화
(function initContentModeHelpAndSmartPublish() {
  console.log('[ContentModeHelp] Initializing content mode help modal and smart publish buttons...');

  // 제휴마케팅 모드 지원 카테고리 [2026-01-22 확장]
  const AFFILIATE_ENABLED_CATEGORIES = [
    // 기존 카테고리
    'it_computer', 'shopping_review', 'fashion', 'food_recipe', 'tasty_restaurant',
    'parenting', 'interior', 'pet', 'car', 'game', 'hobby', 'travel_domestic', 'travel_world',
    // 추가 카테고리 (2026-01-22)
    'health', 'sports', 'gardening', 'photo', 'business_economy', 'education_scholarship',
    'language', 'realestate', 'self_dev', 'general', 'literature', 'movie', 'art_design',
    'music', 'good_writing', 'cartoon', 'it', 'tips'  // it, tips도 유지
  ];

  // ✅ 도움말 모달 표시 함수
  function showContentModeHelpModal(mode: string): void {
    const modal = document.getElementById('content-mode-help-modal');
    if (!modal) return;

    // 모든 섹션 숨기기
    document.querySelectorAll('.help-content-section').forEach(section => {
      (section as HTMLElement).style.display = 'none';
    });

    // 선택된 모드 섹션 표시
    const targetSection = document.getElementById(`help-content-${mode}`);
    if (targetSection) {
      targetSection.style.display = 'block';
    }

    // 타이틀 업데이트
    const icons: Record<string, string> = { seo: '🔍', homefeed: '🏠', affiliate: '🛒', custom: '✏️' };
    const names: Record<string, string> = { seo: 'SEO 모드 가이드', homefeed: '홈판 모드 가이드', affiliate: '쇼핑커넥트 모드 가이드', custom: '사용자정의 모드 가이드' };

    const iconEl = document.getElementById('content-mode-help-icon');
    const nameEl = document.getElementById('content-mode-help-mode-name');
    if (iconEl) iconEl.textContent = icons[mode] || '🎯';
    if (nameEl) nameEl.textContent = names[mode] || '콘텐츠 모드 가이드';

    modal.style.display = 'flex';
  }

  // ✅ 도움말 버튼 이벤트
  document.querySelectorAll('.content-mode-help-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation(); // 버튼 클릭이 모드 버튼으로 전파되지 않도록
      const mode = (btn as HTMLElement).dataset.helpMode;
      if (mode) showContentModeHelpModal(mode);
    });
  });

  // ✅ 도움말 모달 닫기 이벤트
  document.getElementById('close-content-mode-help-modal')?.addEventListener('click', () => {
    const modal = document.getElementById('content-mode-help-modal');
    if (modal) modal.style.display = 'none';
  });

  document.getElementById('close-content-mode-help-btn')?.addEventListener('click', () => {
    const modal = document.getElementById('content-mode-help-modal');
    if (modal) modal.style.display = 'none';
  });

  // 모달 배경 클릭 시 닫기
  document.getElementById('content-mode-help-modal')?.addEventListener('click', (e) => {
    if (e.target === e.currentTarget) {
      (e.currentTarget as HTMLElement).style.display = 'none';
    }
  });

  // ✅ 제휴마케팅 모드 조건부 활성화 함수
  function updateAffiliateModeState(): void {
    const affiliateBtn = document.getElementById('affiliate-mode-btn') as HTMLButtonElement;
    if (!affiliateBtn) return;

    // 현재 선택된 카테고리 가져오기
    const categorySelect = document.getElementById('unified-article-type') as HTMLSelectElement;
    const currentCategory = categorySelect?.value || '';

    const isEnabled = AFFILIATE_ENABLED_CATEGORIES.includes(currentCategory);

    if (isEnabled) {
      affiliateBtn.style.opacity = '1';
      affiliateBtn.disabled = false;
      affiliateBtn.title = '';
    } else {
      affiliateBtn.style.opacity = '0.5';
      affiliateBtn.disabled = true;
      affiliateBtn.title = '리뷰형 카테고리(상품리뷰, 자동차, IT 등)를 선택해야 사용할 수 있습니다';

      // 현재 제휴마케팅 모드가 선택된 상태라면 SEO로 전환
      const contentModeInput = document.getElementById('unified-content-mode') as HTMLInputElement;
      if (contentModeInput?.value === 'affiliate') {
        // SEO 모드로 자동 전환
        const seoBtn = document.querySelector('.content-mode-btn[data-mode="seo"]') as HTMLButtonElement;
        if (seoBtn) seoBtn.click();
      }
    }
  }

  // 카테고리 변경 시 쇼핑 커넥트 상태 업데이트
  document.getElementById('unified-article-type')?.addEventListener('change', () => {
    setTimeout(updateAffiliateModeState, 100);
  });

  // 카테고리 모달에서 선택 시에도 업데이트 (MutationObserver)
  const categoryDisplay = document.getElementById('selected-categories-display');
  if (categoryDisplay) {
    const observer = new MutationObserver(() => {
      setTimeout(updateAffiliateModeState, 100);
    });
    observer.observe(categoryDisplay, { childList: true, subtree: true, characterData: true });
  }

  // ✅ 쇼핑 커넥트 모드 시 카테고리 드롭다운 필터링
  let originalCategoryOptions: HTMLOptionElement[] = [];
  function filterCategoryForAffiliateMode(isAffiliateMode: boolean): void {
    const categorySelect = document.getElementById('unified-article-type') as HTMLSelectElement;
    if (!categorySelect) return;

    // 원본 옵션 백업 (최초 1회 또는 옵션 개수가 변동된 경우 - 35개 기준)
    if (originalCategoryOptions.length < 35 && categorySelect.options.length >= 35) {
      console.log('[AffiliateFilter] Capturing original category options (count:', categorySelect.options.length, ')');
      originalCategoryOptions = Array.from(categorySelect.options).map(opt => opt.cloneNode(true) as HTMLOptionElement);
    }

    const currentValue = categorySelect.value;
    console.log('[AffiliateFilter] mode:', isAffiliateMode ? 'AFFILIATE' : 'SEO/HOMEFEED', 'currentValue:', currentValue);

    const aiLabel = document.getElementById('unified-use-ai-image-label');
    const aiHint = document.getElementById('unified-use-ai-image-hint');
    const thumbLabel = document.getElementById('unified-create-product-thumbnail-label');
    const thumbHint = document.getElementById('unified-create-product-thumbnail-hint');

    if (isAffiliateMode) {
      // 제휴마케팅 모드: 리뷰 가능 카테고리만 표시
      categorySelect.innerHTML = '';
      originalCategoryOptions.forEach(opt => {
        if (AFFILIATE_ENABLED_CATEGORIES.includes(opt.value) || opt.value === '') {
          categorySelect.appendChild(opt.cloneNode(true));
        }
      });

      // 이전 선택 값이 여전히 유효하다면 복원, 아니면 첫 번째 유효 옵션
      if (currentValue && Array.from(categorySelect.options).some(o => o.value === currentValue)) {
        categorySelect.value = currentValue;
      } else {
        const firstValidOption = Array.from(categorySelect.options).find(o => AFFILIATE_ENABLED_CATEGORIES.includes(o.value));
        if (firstValidOption) categorySelect.value = firstValidOption.value;
      }
      appendLog('🛒 쇼핑 커넥트 모드: 리뷰 가능 카테고리만 표시됩니다.');

      // ✅ 라벨 변경: 쇼핑커넥트 특화
      if (aiLabel) aiLabel.textContent = '🤖 AI 라이프스타일 이미지 생성';
      if (aiHint) aiHint.textContent = '수집된 제품 사진을 배경으로 연출 이미지를 생성합니다. (해제 시 수집 사진 그대로 사용)';
    } else {
      // 일반 모드: 모든 카테고리 복원
      const currentValue = categorySelect.value;
      categorySelect.innerHTML = '';
      originalCategoryOptions.forEach(opt => {
        categorySelect.appendChild(opt.cloneNode(true));
      });
      // 이전 선택 값 복원
      // ✅ 라벨 원복: 일반 모드
      if (aiLabel) aiLabel.textContent = '🤖 AI 이미지 생성 사용';
      if (aiHint) aiHint.textContent = '나노바나나 등 AI 엔진을 활용해 이미지를 생성합니다.';

      // 통일된 라벨 (다시 확인)
      if (thumbLabel) thumbLabel.textContent = '🎨 1번 이미지 텍스트 포함 (썸네일화)';
      if (thumbHint) thumbHint.textContent = '첫 번째 이미지에 제목 및 디자인 합성';
    }
  }

  // ✅ 콘텐츠 모드 버튼 클릭 시 카테고리 필터링 및 쇼핑 커넥트 설정 표시/숨김
  document.querySelectorAll('.content-mode-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const mode = (btn as HTMLElement).dataset.mode;

      setTimeout(() => filterCategoryForAffiliateMode(mode === 'affiliate'), 100);

      // ✅ 쇼핑 커넥트 설정 영역 표시/숨김
      const shoppingConnectSettings = document.getElementById('shopping-connect-settings');
      const shoppingConnectImageOptions = document.getElementById('shopping-connect-image-options');
      const thumbnailTextOptionContainer = document.getElementById('thumbnail-text-option-container');
      // ✅ [2026-01-19] 고급 화질 및 모델 설정 (쇼핑커넥트에서 불필요)
      const imageQualityToggle = document.getElementById('toggle-image-quality-settings')?.parentElement;
      const imageQualityPanel = document.getElementById('image-quality-settings-panel');

      if (mode === 'affiliate') {
        if (shoppingConnectSettings) shoppingConnectSettings.style.display = 'block';
        if (shoppingConnectImageOptions) shoppingConnectImageOptions.style.display = 'block';
        // ✅ 쇼핑커넥트에서는 1번 이미지 텍스트 포함 옵션 숨김 (자동 적용)
        if (thumbnailTextOptionContainer) thumbnailTextOptionContainer.style.display = 'none';
        // ✅ [2026-01-19] 고급 화질 및 모델 설정 숨김
        if (imageQualityToggle) imageQualityToggle.style.display = 'none';
        if (imageQualityPanel) imageQualityPanel.style.display = 'none';
        appendLog('🛒 쇼핑 커넥트 모드가 활성화되었습니다. 제휴 링크를 입력해주세요.');
      } else {
        if (shoppingConnectSettings) shoppingConnectSettings.style.display = 'none';
        if (shoppingConnectImageOptions) shoppingConnectImageOptions.style.display = 'none';
        // ✅ 일반 모드에서는 1번 이미지 텍스트 포함 옵션 표시
        if (thumbnailTextOptionContainer) thumbnailTextOptionContainer.style.display = 'block';
        // ✅ [2026-01-19] 일반 모드에서는 고급 화질 설정 표시
        if (imageQualityToggle) imageQualityToggle.style.display = 'block';
      }
    });
  });

  // 초기 상태 설정
  setTimeout(updateAffiliateModeState, 500);

  // ✅ 스마트 발행 버튼 가시성 관리
  let hasGeneratedContent = false;

  function updatePublishButtonVisibility(): void {
    const publishModeSelect = document.getElementById('publish-mode-select') as HTMLSelectElement;
    const imageEngineSection = document.getElementById('unified-only-image-engine');
    const previewSection = document.getElementById('unified-preview-section');
    const semiAutoSection = document.getElementById('unified-semi-auto-section');
    const postsListContent = document.getElementById('posts-list-content');
    const postsListToggleIcon = document.getElementById('posts-list-toggle-icon');
    const postsListToggleHint = document.getElementById('posts-list-toggle-hint');

    if (hasGeneratedContent) {
      // 콘텐츠가 생성된 후:
      // - 발행모드 드롭다운 반자동으로 고정 (풀오토 비활성화)
      if (publishModeSelect) {
        publishModeSelect.value = 'semi-auto';
        // 풀오토 옵션 비활성화
        const fullAutoOption = publishModeSelect.querySelector('option[value="full-auto"]') as HTMLOptionElement;
        if (fullAutoOption) {
          fullAutoOption.disabled = true;
          fullAutoOption.textContent = '⚡ 풀오토 (글 생성 후 사용 불가)';
        }
      }
      updatePublishButtonStyle();

      // - 이미지 엔진 숨김
      if (imageEngineSection) imageEngineSection.style.display = 'none';

      // - 미리보기 표시
      if (previewSection) previewSection.style.display = 'block';

      // - 반자동 섹션 표시
      if (semiAutoSection) {
        semiAutoSection.style.display = 'block';
      }

      // - 글 목록은 접힌 상태 (사용자 요청: 접혀 있어야 함)
      const postsListContainer = document.getElementById('unified-only-posts-list');
      if (postsListContainer) postsListContainer.style.display = 'block'; // 컨테이너는 항상 보임
      if (postsListContent) postsListContent.style.display = 'none';
      if (postsListToggleIcon) postsListToggleIcon.style.transform = 'rotate(0deg)';
      if (postsListToggleHint) postsListToggleHint.textContent = '클릭하여 펼치기';

    } else {
      // 초기 상태:
      // - 발행모드 드롭다운 풀오토 (옵션 활성화)
      if (publishModeSelect) {
        publishModeSelect.value = 'full-auto';
        // 풀오토 옵션 다시 활성화
        const fullAutoOption = publishModeSelect.querySelector('option[value="full-auto"]') as HTMLOptionElement;
        if (fullAutoOption) {
          fullAutoOption.disabled = false;
          fullAutoOption.textContent = '⚡ 풀오토';
        }
      }
      updatePublishButtonStyle();

      // - 이미지 엔진 표시
      if (imageEngineSection) imageEngineSection.style.display = 'block';

      // - 미리보기 숨김
      if (previewSection) previewSection.style.display = 'none';

      // - 반자동 섹션 표시 (사용자 요청으로 기본 표시)
      if (semiAutoSection) semiAutoSection.style.display = 'block';

      // - 글 목록은 접힌 상태로 표시 (사용자 요청: 초기에도 열람 가능해야 함)
      const postsListContainer = document.getElementById('unified-only-posts-list');
      if (postsListContainer) postsListContainer.style.display = 'block'; // 컨테이너 보임
      if (postsListContent) postsListContent.style.display = 'none'; // 내용은 숨김
      if (postsListToggleIcon) postsListToggleIcon.style.transform = 'rotate(0deg)';
      if (postsListToggleHint) postsListToggleHint.textContent = '클릭하여 펼치기';
    }
  }


  // 발행 모드 드롭다운 변경 시 버튼 스타일 업데이트
  function updatePublishButtonStyle(): void {
    const publishModeSelect = document.getElementById('publish-mode-select') as HTMLSelectElement;
    const publishBtn = document.getElementById('unified-publish-btn');
    const publishModeDesc = document.getElementById('publish-mode-desc');

    if (!publishModeSelect || !publishBtn) return;

    const mode = publishModeSelect.value;

    if (mode === 'full-auto') {
      publishBtn.style.background = 'linear-gradient(135deg, #3b82f6, #2563eb)';
      publishBtn.style.boxShadow = '0 4px 12px rgba(59, 130, 246, 0.4)';
      if (publishModeDesc) publishModeDesc.innerHTML = '💡 URL/키워드 입력 → AI 글 생성 → 이미지 생성 → 발행 (한 번에)';
    } else {
      publishBtn.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
      publishBtn.style.boxShadow = '0 4px 12px rgba(245, 158, 11, 0.4)';
      if (publishModeDesc) publishModeDesc.innerHTML = '💡 AI 글 생성 → 미리보기 확인/수정 → 수동 발행';
    }
  }


  // 드롭다운 이벤트 리스너
  document.getElementById('publish-mode-select')?.addEventListener('change', updatePublishButtonStyle);

  // 통합 발행 버튼 클릭 핸들러
  document.getElementById('unified-publish-btn')?.addEventListener('click', () => {
    const publishModeSelect = document.getElementById('publish-mode-select') as HTMLSelectElement;
    const mode = publishModeSelect?.value || 'full-auto';

    if (mode === 'full-auto') {
      // 풀오토 발행 실행
      document.getElementById('full-auto-publish-btn')?.click();
    } else {
      // 반자동 발행 실행
      document.getElementById('semi-auto-publish-btn')?.click();
    }
  });


  // 콘텐츠 생성 완료 감지
  function markContentGenerated(): void {
    hasGeneratedContent = true;
    updatePublishButtonVisibility();
    console.log('[SmartPublish] Content generated - showing semi-auto publish only');
  }

  function markContentCleared(): void {
    hasGeneratedContent = false;
    updatePublishButtonVisibility();
    console.log('[SmartPublish] Content cleared - showing full-auto publish only');
  }

  // 글 생성 버튼 클릭 시 콘텐츠 생성됨으로 마킹
  document.getElementById('generate-from-url-btn')?.addEventListener('click', () => {
    markContentGenerated();
  });

  document.getElementById('generate-manual-btn')?.addEventListener('click', () => {
    markContentGenerated();
  });

  // 백업 불러오기 시 콘텐츠 생성됨으로 마킹
  document.getElementById('load-backup-btn')?.addEventListener('click', () => {
    setTimeout(markContentGenerated, 1000);
  });

  // 글 목록에서 불러오기 시 콘텐츠 생성됨으로 마킹 (이벤트 위임 사용)
  const postsListContainer = document.getElementById('generated-posts-list');
  if (postsListContainer) {
    postsListContainer.addEventListener('click', (e) => {
      const target = e.target as HTMLElement;
      // "불러오기" 버튼 클릭 감지 (클래스 또는 텍스트로)
      if (target.classList.contains('load-post-btn') ||
        target.closest('.load-post-btn') ||
        target.textContent?.includes('불러오기')) {
        setTimeout(markContentGenerated, 500);
      }
    });
  }

  // 전체 초기화 버튼 클릭 시 콘텐츠 클리어
  document.getElementById('global-refresh-btn')?.addEventListener('click', () => {
    setTimeout(markContentCleared, 500);
  });

  // 초기 상태 설정 (풀오토만 표시)
  setTimeout(updatePublishButtonVisibility, 1000);

  // 전역 함수로 노출 (다른 곳에서도 사용 가능)
  (window as any).markContentGenerated = markContentGenerated;
  (window as any).markContentCleared = markContentCleared;
  (window as any).updateAffiliateModeState = updateAffiliateModeState;

  console.log('[ContentModeHelp] Content mode help modal and smart publish buttons initialized');
})();

// ✅ 반자동 모드 섹션 접기/펼치기 토글

// ✅ 개선된 스마트 발행 버튼 가시성 로직
// ✅ 개선된 스마트 발행 버튼 가시성 로직 (통합됨 - updatePublishButtonVisibility 사용)
// (function initImprovedSmartPublish() {
//   console.log('[ImprovedSmartPublish] Improved smart publish logic integrated into updatePublishButtonVisibility');
//   // Conflict resolution: Logic moved to updatePublishButtonVisibility to prevent UI state flapping
// })();

// ✅ URL/키워드 탭 전환 함수
(window as any).switchGenerationTab = function (tab: 'url' | 'keyword'): void {
  const urlTab = document.getElementById('tab-url-btn');
  const keywordTab = document.getElementById('tab-keyword-btn');
  const urlContent = document.getElementById('tab-content-url');
  const keywordContent = document.getElementById('tab-content-keyword');

  if (!urlTab || !keywordTab || !urlContent || !keywordContent) return;

  if (tab === 'url') {
    // URL 탭 활성화
    urlTab.style.background = 'linear-gradient(135deg, #3b82f6, #2563eb)';
    urlTab.style.color = 'white';
    keywordTab.style.background = 'transparent';
    keywordTab.style.color = 'var(--text-muted)';
    urlContent.style.display = 'block';
    keywordContent.style.display = 'none';
  } else {
    // 키워드 탭 활성화
    keywordTab.style.background = 'linear-gradient(135deg, #10b981, #059669)';
    keywordTab.style.color = 'white';
    urlTab.style.background = 'transparent';
    urlTab.style.color = 'var(--text-muted)';
    keywordContent.style.display = 'block';
    urlContent.style.display = 'none';
  }

  console.log('[TabSwitch] Switched to:', tab);
};

// ✅ 생성된 글 목록 접기/펼치기 토글
(window as any).togglePostsListSection = function (): void {
  const content = document.getElementById('posts-list-content');
  const icon = document.getElementById('posts-list-toggle-icon');
  const hint = document.getElementById('posts-list-toggle-hint');

  if (!content || !icon || !hint) return;

  const isCollapsed = content.style.display === 'none';

  if (isCollapsed) {
    content.style.display = 'block';
    icon.style.transform = 'rotate(180deg)';
    hint.textContent = '클릭하여 접기';
  } else {
    content.style.display = 'none';
    icon.style.transform = 'rotate(0deg)';
    hint.textContent = '클릭하여 펼치기';
  }
};

// ✅ 로그 섹션 접기/펼치기 토글
(window as any).toggleLogSection = function (): void {
  const content = document.getElementById('log-section-content');
  const icon = document.getElementById('log-section-toggle-icon');
  const hint = document.getElementById('log-section-toggle-hint');

  if (!content || !icon || !hint) return;

  const isCollapsed = content.style.display === 'none';

  if (isCollapsed) {
    content.style.display = 'block';
    icon.style.transform = 'rotate(180deg)';
    hint.textContent = '클릭하여 접기';
  } else {
    content.style.display = 'none';
    icon.style.transform = 'rotate(0deg)';
    hint.textContent = '클릭하여 펼치기';
  }
};

// ============================================
// ✅ 이미지 화질/모델 설정 UI 관리
// ============================================

async function initImageQualitySettings(): Promise<void> {
  const toggleBtn = document.getElementById('toggle-image-quality-settings');
  const panel = document.getElementById('image-quality-settings-panel');
  const arrow = document.getElementById('image-quality-arrow');

  if (!toggleBtn || !panel || !arrow) return;

  console.log('[ImageQuality] UI 초기화 시작');

  // 1. 토글 기능
  toggleBtn.addEventListener('click', () => {
    const isHidden = panel.style.display === 'none';
    panel.style.display = isHidden ? 'block' : 'none';
    arrow.style.transform = isHidden ? 'rotate(180deg)' : 'rotate(0deg)';
  });

  // 2. 초기 설정 로드
  try {
    // configManager에서 설정 가져오기 (비동기)
    const config = await window.api.getConfig();
    console.log('[ImageQuality] 로드된 설정:', config);

    const defaults = {
      imageQualityMode: 'balanced',
      thumbnailImageModel: 'gemini-3-pro',  // ✅ [2026-01-21] 기본값 1K로 변경 (안정성 향상)
      otherImagesModel: 'gemini-3-pro',  // ✅ [2026-01-21] 본문 이미지도 1K 기본
      lockThumbnailTo4K: false  // ✅ 4K 고정 해제
    };

    const settings = { ...defaults, ...config };

    // 화질 모드 라디오 버튼 설정
    const modeRadio = document.querySelector(`input[name="imageQualityMode"][value="${settings.imageQualityMode}"]`) as HTMLInputElement;
    if (modeRadio) modeRadio.checked = true;

    // 상세 설정 드롭다운 값 설정
    const thumbSelect = document.getElementById('thumbnail-model-select') as HTMLSelectElement;
    const bodySelect = document.getElementById('body-image-model-select') as HTMLSelectElement;
    if (thumbSelect) thumbSelect.value = settings.thumbnailImageModel || 'gemini-3-pro';  // ✅ 기본값 1K
    if (bodySelect) bodySelect.value = settings.otherImagesModel || 'gemini-2.5-flash';

    // 썸네일 고정 체크박스
    const lockCheckbox = document.getElementById('lock-thumbnail-4k') as HTMLInputElement;
    if (lockCheckbox) lockCheckbox.checked = settings.lockThumbnailTo4K !== false; // 기본값 true

    // 초기 UI 상태 업데이트 (커스텀 상세 설정 표시 여부 등)
    updateQualityUISubState(settings.imageQualityMode);

  } catch (e) {
    console.warn('[ImageQuality] 설정 로드 실패:', e);
  }

  // 3. UI 변경 이벤트 리스너 (설정 저장)

  // 화질 모드 변경
  document.querySelectorAll('input[name="imageQualityMode"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
      const mode = (e.target as HTMLInputElement).value;
      updateQualityUISubState(mode);
      saveImageQualitySettings();
    });
  });

  // 상세 모델 변경
  document.getElementById('thumbnail-model-select')?.addEventListener('change', saveImageQualitySettings);
  document.getElementById('body-image-model-select')?.addEventListener('change', saveImageQualitySettings);
  document.getElementById('lock-thumbnail-4k')?.addEventListener('change', saveImageQualitySettings);
}

// UI 상태 업데이트 헬퍼
function updateQualityUISubState(mode: string): void {
  const customSettings = document.getElementById('custom-quality-settings');
  if (customSettings) {
    customSettings.style.display = mode === 'custom' ? 'block' : 'none';
  }

  // 패널이 닫혀있다면 모드가 변경되었을 때 자동으로 열기 (사용자 피드백)
  const panel = document.getElementById('image-quality-settings-panel');
  const arrow = document.getElementById('image-quality-arrow');
  if (panel && panel.style.display === 'none' && mode === 'custom') {
    panel.style.display = 'block';
    if (arrow) arrow.style.transform = 'rotate(180deg)';
  }
}

// 설정 저장 헬퍼
async function saveImageQualitySettings(): Promise<void> {
  const mode = (document.querySelector('input[name="imageQualityMode"]:checked') as HTMLInputElement)?.value || 'balanced';
  const thumbModel = (document.getElementById('thumbnail-model-select') as HTMLSelectElement)?.value;
  const bodyModel = (document.getElementById('body-image-model-select') as HTMLSelectElement)?.value;
  const lockThumb = (document.getElementById('lock-thumbnail-4k') as HTMLInputElement)?.checked;

  const newSettings = {
    imageQualityMode: mode,
    thumbnailImageModel: thumbModel,
    otherImagesModel: bodyModel,
    lockThumbnailTo4K: lockThumb
  };

  console.log('[ImageQuality] 설정 저장 중...', newSettings);

  try {
    await window.api.saveConfig(newSettings);
    // 토스트 메시지는 너무 빈번할 수 있으므로 생략하거나 console 로그만 남김
    console.log('[ImageQuality] 설정 저장 완료');
  } catch (e) {
    console.error('[ImageQuality] 설정 저장 실패:', e);
  }
}

// 초기화 실행
document.addEventListener('DOMContentLoaded', initImageQualitySettings);

// ✅ [2026-01-22] 예약 설정 도움말 모달
function showScheduleHelpModal(): void {
  // 기존 모달이 있으면 제거
  const existingModal = document.getElementById('schedule-help-modal-overlay');
  if (existingModal) {
    existingModal.remove();
  }

  const overlay = document.createElement('div');
  overlay.id = 'schedule-help-modal-overlay';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.8);
    z-index: 99999;
    display: flex;
    align-items: center;
    justify-content: center;
    animation: fadeIn 0.2s ease;
  `;

  const modal = document.createElement('div');
  modal.style.cssText = `
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    border-radius: 16px;
    padding: 28px;
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.1);
    color: #fff;
  `;

  modal.innerHTML = `
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
      <h2 style="margin: 0; font-size: 22px; color: #4ade80;">📅 순차 예약 발행 가이드</h2>
      <button id="close-schedule-help" style="background: none; border: none; color: #fff; font-size: 24px; cursor: pointer; padding: 5px;">&times;</button>
    </div>

    <div style="background: rgba(74, 222, 128, 0.1); border-left: 4px solid #4ade80; padding: 12px; margin-bottom: 20px; border-radius: 0 8px 8px 0;">
      <strong>💡 TIP:</strong> 먼저 발행할 글을 대기열에 추가한 후 예약 설정을 진행하세요!
    </div>

    <div style="margin-bottom: 24px;">
      <h3 style="color: #60a5fa; margin-bottom: 12px; font-size: 16px;">📋 설정 순서</h3>
      <ol style="margin: 0; padding-left: 20px; line-height: 1.8;">
        <li><strong>발행 큐 세팅</strong> - 발행할 글들을 대기열에 추가</li>
        <li><strong>예약 설정 탭</strong>으로 이동</li>
        <li>아래 옵션들 설정 후 <strong>"대기열 전체에 순차 예약 적용"</strong> 클릭</li>
      </ol>
    </div>

    <div style="margin-bottom: 24px;">
      <h3 style="color: #60a5fa; margin-bottom: 12px; font-size: 16px;">⚙️ 옵션 설명</h3>
      
      <div style="background: rgba(255, 255, 255, 0.05); border-radius: 8px; padding: 14px; margin-bottom: 12px;">
        <strong style="color: #fbbf24;">📅 예약 시작 일시</strong>
        <p style="margin: 8px 0 0; color: #d1d5db; font-size: 14px;">
          첫 번째 글의 발행 시간.<br>
          <span style="color: #4ade80;">비워두면 → 현재 시간부터 자동 시작!</span>
        </p>
      </div>

      <div style="background: rgba(255, 255, 255, 0.05); border-radius: 8px; padding: 14px; margin-bottom: 12px;">
        <strong style="color: #fbbf24;">⏱️ 항목별 발행 간격</strong>
        <p style="margin: 8px 0 0; color: #d1d5db; font-size: 14px;">
          각 글 사이의 시간 간격 설정.<br>
          예: <code style="background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 4px;">2시간</code> 선택 시 → 10:00, 12:00, 14:00 ...
        </p>
      </div>

      <div style="background: rgba(255, 255, 255, 0.05); border-radius: 8px; padding: 14px;">
        <strong style="color: #fbbf24;">🎲 랜덤 시간 편차 적용</strong>
        <p style="margin: 8px 0 0; color: #d1d5db; font-size: 14px;">
          체크 시 각 발행에 <strong>±15분</strong> 랜덤 편차 추가.<br>
          <span style="color: #4ade80;">✓ 봇 감지 방지 효과!</span><br>
          예: 2시간 간격 → 실제로 1:45 ~ 2:15 사이로 분산됨
        </p>
      </div>
    </div>

    <div style="background: rgba(96, 165, 250, 0.1); border-left: 4px solid #60a5fa; padding: 12px; border-radius: 0 8px 8px 0;">
      <strong>📊 예시 (5개 글, 2시간 간격, 랜덤 ON)</strong>
      <div style="font-family: monospace; font-size: 13px; margin-top: 8px; color: #d1d5db;">
        1번 글: 10:08 (+8분 랜덤)<br>
        2번 글: 11:55 (-5분 랜덤)<br>
        3번 글: 14:12 (+12분 랜덤)<br>
        4번 글: 15:57 (-3분 랜덤)<br>
        5번 글: 18:07 (+7분 랜덤)
      </div>
    </div>
  `;

  overlay.appendChild(modal);
  document.body.appendChild(overlay);

  // 닫기 이벤트
  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) {
      overlay.remove();
    }
  });

  modal.querySelector('#close-schedule-help')?.addEventListener('click', () => {
    overlay.remove();
  });

  // ESC 키로 닫기
  const handleEsc = (e: KeyboardEvent) => {
    if (e.key === 'Escape') {
      overlay.remove();
      document.removeEventListener('keydown', handleEsc);
    }
  };
  document.addEventListener('keydown', handleEsc);
}

// ✅ 전역으로 노출 (버튼 onclick에서 호출 가능)
(window as any).showScheduleHelpModal = showScheduleHelpModal;

// ✅ [2026-01-22] 예약 설정 모달 감지 및 도움말 버튼 자동 주입
function injectScheduleHelpButton(container: Element): void {
  // 이미 버튼이 있으면 추가하지 않음
  if (container.querySelector('.schedule-help-btn-injected')) return;

  // "순차 예약 설정" 텍스트가 포함된 요소 찾기
  const headings = container.querySelectorAll('h2, h3, h4, .modal-title, div');
  let targetHeading: Element | null = null;

  for (const el of headings) {
    if (el.textContent?.includes('순차 예약') || el.textContent?.includes('예약 설정')) {
      targetHeading = el;
      break;
    }
  }

  if (targetHeading) {
    const helpBtn = document.createElement('button');
    helpBtn.className = 'schedule-help-btn-injected';
    helpBtn.innerHTML = '❓';
    helpBtn.title = '예약 발행 도움말';
    helpBtn.style.cssText = `
      margin-left: 10px;
      padding: 4px 10px;
      border: none;
      border-radius: 50%;
      background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
      color: white;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(74, 222, 128, 0.3);
    `;
    helpBtn.onmouseover = () => {
      helpBtn.style.transform = 'scale(1.1)';
      helpBtn.style.boxShadow = '0 4px 12px rgba(74, 222, 128, 0.5)';
    };
    helpBtn.onmouseout = () => {
      helpBtn.style.transform = 'scale(1)';
      helpBtn.style.boxShadow = '0 2px 8px rgba(74, 222, 128, 0.3)';
    };
    helpBtn.onclick = (e) => {
      e.stopPropagation();
      showScheduleHelpModal();
    };

    // 제목 옆에 버튼 추가 (또는 부모에 추가)
    if (targetHeading.parentElement) {
      targetHeading.parentElement.style.display = 'flex';
      targetHeading.parentElement.style.alignItems = 'center';
    }
    targetHeading.appendChild(helpBtn);
    console.log('[ScheduleHelp] ✅ 도움말 버튼 주입 완료');
  }
}

// ✅ MutationObserver로 모달 감지
const scheduleModalObserver = new MutationObserver((mutations) => {
  for (const mutation of mutations) {
    for (const node of mutation.addedNodes) {
      if (node instanceof HTMLElement) {
        // 모달이나 다이얼로그 감지
        if (
          node.classList.contains('modal') ||
          node.classList.contains('dialog') ||
          node.getAttribute('role') === 'dialog' ||
          node.querySelector('.modal-content') ||
          node.textContent?.includes('순차 예약') ||
          node.textContent?.includes('예약 설정') ||
          node.textContent?.includes('항목별 발행') ||
          node.textContent?.includes('대기열 전체')
        ) {
          setTimeout(() => injectScheduleHelpButton(node), 100);
        }
      }
    }
  }
});

// Observer 시작
scheduleModalObserver.observe(document.body, {
  childList: true,
  subtree: true
});

// ✅ [2026-01-22] 연속 발행 예약 시간 자동 계산 및 적용 (window에 노출)
function calculateAndApplyScheduleTimes(options: {
  baseTime?: Date;
  intervalMinutes?: number;
  useRandomOffset?: boolean;
}): void {
  const {
    baseTime = new Date(),
    intervalMinutes = 120, // 기본 2시간
    useRandomOffset = true
  } = options;

  console.log('[ScheduleCalc] 예약 시간 계산 시작:', {
    baseTime: baseTime.toLocaleString(),
    intervalMinutes,
    useRandomOffset
  });

  // 대기열 아이템 (내부 변수 또는 DOM에서 찾기)
  const queueItems = document.querySelectorAll('[data-queue-item], .queue-item, .publishing-queue-item');

  if (queueItems.length === 0) {
    console.warn('[ScheduleCalc] 대기열 아이템을 찾지 못했습니다.');
    return;
  }

  queueItems.forEach((item, index) => {
    const offsetMinutes = index * intervalMinutes;
    // 랜덤 편차: ±15분
    const randomOffset = useRandomOffset ? Math.floor(Math.random() * 31) - 15 : 0;
    const scheduledTime = new Date(baseTime.getTime() + (offsetMinutes + randomOffset) * 60000);

    // ISO-like 문자열 생성
    const yyyy = scheduledTime.getFullYear();
    const mm = String(scheduledTime.getMonth() + 1).padStart(2, '0');
    const dd = String(scheduledTime.getDate()).padStart(2, '0');
    const hh = String(scheduledTime.getHours()).padStart(2, '0');
    const mi = String(scheduledTime.getMinutes()).padStart(2, '0');
    const scheduleStr = `${yyyy}-${mm}-${dd}T${hh}:${mi}`;

    // 아이템에 데이터 속성 설정
    item.setAttribute('data-schedule-date', scheduleStr);
    item.setAttribute('data-publish-mode', 'schedule');

    console.log(`[ScheduleCalc] ${index + 1}번 글: ${scheduledTime.toLocaleString()} (${randomOffset >= 0 ? '+' : ''}${randomOffset}분 편차)`);
  });

  console.log('[ScheduleCalc] ✅ 모든 아이템에 예약 시간 적용 완료');
}

(window as any).calculateAndApplyScheduleTimes = calculateAndApplyScheduleTimes;

// ✅ [2026-01-22] collectFormData 강화 - 대기열 아이템의 예약 시간 읽기
(window as any).getScheduleDataFromQueueItem = function (index: number): { publishMode: string; scheduleDate: string } | null {
  const queueItems = document.querySelectorAll('[data-queue-item], .queue-item, .publishing-queue-item');
  const item = queueItems[index];

  if (item) {
    return {
      publishMode: item.getAttribute('data-publish-mode') || 'publish',
      scheduleDate: item.getAttribute('data-schedule-date') || ''
    };
  }
  return null;
};

console.log('[Renderer] ✅ 예약 설정 도움말 및 자동 주입 시스템 초기화 완료');

// ✅ [2026-01-22] 수동 썸네일 설정 함수 - 썸네일 생성기에서 호출
(window as any).setManualThumbnailForFullAuto = function (thumbnailData: {
  url: string;
  filePath?: string;
  heading?: string;
  provider?: string;
}): void {
  const manualThumbnail = {
    ...thumbnailData,
    heading: thumbnailData.heading || '썸네일',
    headingIndex: 0,
    isManualThumbnail: true, // ✅ 수동 썸네일 플래그
    source: 'thumbnail-generator', // ✅ 썸네일 생성기에서 설정됨
    isThumbnail: true,
  };

  // 기존 이미지 배열 가져오기
  const existingImages = (window as any).imageManagementGeneratedImages || [];

  // 첫 번째 이미지가 이미 수동 썸네일이면 교체, 아니면 앞에 추가
  if (existingImages.length > 0 && (existingImages[0]?.isManualThumbnail || existingImages[0]?.source === 'thumbnail-generator')) {
    existingImages[0] = manualThumbnail;
    console.log('[ManualThumbnail] ✅ 기존 수동 썸네일 교체');
  } else {
    existingImages.unshift(manualThumbnail);
    console.log('[ManualThumbnail] ✅ 수동 썸네일 추가 (기존 이미지 앞에 삽입)');
  }

  (window as any).imageManagementGeneratedImages = existingImages;
  console.log('[ManualThumbnail] 현재 이미지 개수:', existingImages.length);
};

// ✅ 수동 썸네일 제거 함수
(window as any).clearManualThumbnail = function (): void {
  const existingImages = (window as any).imageManagementGeneratedImages || [];

  if (existingImages.length > 0 && (existingImages[0]?.isManualThumbnail || existingImages[0]?.source === 'thumbnail-generator')) {
    existingImages.shift();
    (window as any).imageManagementGeneratedImages = existingImages;
    console.log('[ManualThumbnail] ✅ 수동 썸네일 제거됨');
  }
};

console.log('[Renderer] ✅ 수동 썸네일 설정 함수 등록 완료');

// ✅ [2026-01-25] 환경설정 저장 전역 함수 (HTML onclick에서 호출)
(window as any).saveSettingsHandler = async function (): Promise<void> {
  try {
    console.log('[Settings] 💾 저장 버튼 클릭됨');

    // 설정 수집
    const geminiApiKey = (document.getElementById('gemini-api-key') as HTMLInputElement)?.value?.trim() || undefined;
    const perplexityApiKey = (document.getElementById('perplexity-api-key') as HTMLInputElement)?.value?.trim() || undefined;
    const unsplashApiKey = (document.getElementById('unsplash-api-key') as HTMLInputElement)?.value?.trim() || undefined;
    const pixabayApiKey = (document.getElementById('pixabay-api-key') as HTMLInputElement)?.value?.trim() || undefined;
    const prodiaToken = (document.getElementById('prodia-token') as HTMLInputElement)?.value?.trim() || undefined;
    const naverClientId = (document.getElementById('naver-client-id') as HTMLInputElement)?.value?.trim() || undefined;
    const naverClientSecret = (document.getElementById('naver-client-secret') as HTMLInputElement)?.value?.trim() || undefined;
    const naverAdApiKey = (document.getElementById('naver-ad-api-key') as HTMLInputElement)?.value?.trim() || undefined;
    const naverAdSecretKey = (document.getElementById('naver-ad-secret-key') as HTMLInputElement)?.value?.trim() || undefined;
    const naverAdCustomerId = (document.getElementById('naver-ad-customer-id') as HTMLInputElement)?.value?.trim() || undefined;
    const stabilityApiKey = (document.getElementById('stability-api-key') as HTMLInputElement)?.value?.trim() || undefined;
    const falaiApiKey = (document.getElementById('falai-api-key') as HTMLInputElement)?.value?.trim() || undefined;
    const customImageSavePath = (document.getElementById('custom-image-save-path') as HTMLInputElement)?.value?.trim() || undefined;

    const dailyPostLimit = parseInt((document.getElementById('daily-post-limit') as HTMLInputElement)?.value || '3');
    const freeQuotaPublish = parseInt((document.getElementById('free-quota-publish') as HTMLInputElement)?.value || '2');
    const freeQuotaContent = parseInt((document.getElementById('free-quota-content') as HTMLInputElement)?.value || '5');
    const freeQuotaMedia = parseInt((document.getElementById('free-quota-media') as HTMLInputElement)?.value || '30');

    const primaryGeminiTextModel = (document.querySelector('input[name="primaryGeminiTextModel"]:checked') as HTMLInputElement)?.value || 'gemini-3-pro-preview';
    const geminiPlanType = (document.querySelector('input[name="geminiPlanType"]:checked') as HTMLInputElement)?.value as 'free' | 'paid' || 'paid';

    const config: any = {
      geminiApiKey,
      perplexityApiKey,
      unsplashApiKey,
      pixabayApiKey,
      prodiaToken,
      naverClientId,
      naverClientSecret,
      naverDatalabClientId: naverClientId,
      naverDatalabClientSecret: naverClientSecret,
      naverAdApiKey,
      naverAdSecretKey,
      naverAdCustomerId,
      stabilityApiKey,
      falaiApiKey,
      customImageSavePath,
      dailyPostLimit,
      freeQuotaPublish,
      freeQuotaContent,
      freeQuotaMedia,
      primaryGeminiTextModel,
      geminiPlanType,
    };

    console.log('[Settings] 저장할 config:', Object.keys(config).length, '개 항목');

    // 저장 실행 - saveConfig는 AppConfig를 직접 반환함 (success 객체 아님)
    const result = await window.api.saveConfig(config);

    if (result) {
      console.log('[Settings] ✅ 저장 성공');

      // 토스트 알림
      if (typeof toastManager !== 'undefined' && toastManager.success) {
        toastManager.success('✅ 설정이 저장되었습니다!');
      } else {
        alert('✅ 설정이 저장되었습니다!');
      }

      // 모달 닫기
      const settingsModal = document.getElementById('settings-modal') as HTMLDivElement;
      if (settingsModal) {
        settingsModal.setAttribute('aria-hidden', 'true');
        settingsModal.style.display = 'none';
      }
    } else {
      console.error('[Settings] ❌ 저장 실패: 결과 없음');
      alert('❌ 설정 저장 실패');
    }
  } catch (error) {
    console.error('[Settings] ❌ 저장 오류:', error);
    alert(`❌ 설정 저장 실패: ${(error as Error).message}`);
  }
};

// ✅ [2026-01-25] 환경설정 모달 닫기 전역 함수
(window as any).closeSettingsModal = function (): void {
  const settingsModal = document.getElementById('settings-modal') as HTMLDivElement;
  if (settingsModal) {
    settingsModal.setAttribute('aria-hidden', 'true');
    settingsModal.style.display = 'none';
  }
  console.log('[Settings] 환경설정 모달 닫힘');
};

console.log('[Renderer] ✅ 환경설정 저장/닫기 함수 등록 완료');
