import { app, BrowserWindow, dialog, ipcMain, nativeImage, NativeImage, shell, Notification, Tray, Menu } from 'electron';
import path from 'path';
import dotenv from 'dotenv';
import cron from 'node-cron';
import { NaverBlogAutomation, RunOptions, type PublishMode, type AutomationImage } from './naverBlogAutomation.js';
import { generateImages } from './imageGenerator.js';
import { generateStabilityVideo } from './image/stabilityGenerator.js'; // âœ… ì¶”ê°€
import { convertMp4ToGif } from './image/gifConverter.js'; // âœ… ì¶”ê°€
import type { GenerateImagesOptions, GeneratedImage } from './imageGenerator.js';
import { getDailyLimit, getTodayCount, incrementTodayCount, setDailyLimit } from './postLimitManager.js';
import { generateStructuredContent, removeOrdinalHeadingLabelsFromBody } from './contentGenerator.js';
import { createDatalabClient, NaverDatalabClient } from './naverDatalab.js';
import type { ContentSource, StructuredContent, ContentGeneratorProvider, ArticleType } from './contentGenerator.js';
import { assembleContentSource, type SourceAssemblyInput } from './sourceAssembler.js';
import { applyConfigToEnv, loadConfig, saveConfig, validateApiKeyFormat, type AppConfig } from './configManager.js';
import { generateBlogContent, setGeminiModel } from './gemini.js';
import { getChromiumExecutablePath } from './browserUtils.js';
import { PostPublishBooster } from './publisher/postPublishBooster.js';
import { TrendMonitor, type TrendAlertEvent } from './monitor/trendMonitor.js';
import { PatternAnalyzer } from './learning/patternAnalyzer.js';
import { PostAnalytics, type PostPerformance } from './analytics/postAnalytics.js';
import { SmartScheduler, type ScheduledPost as SmartScheduledPost } from './scheduler/smartScheduler.js';
import { KeywordAnalyzer, type KeywordCompetition, type BlueOceanKeyword } from './analytics/keywordAnalyzer.js';
import { InternalLinkManager, type InternalLink } from './content/internalLinkManager.js';
import { ThumbnailGenerator } from './content/thumbnailGenerator.js';
import { canConsume as canConsumeQuota, consume as consumeQuota, getStatus as getQuotaStatus, resetAll as resetAllQuota, type QuotaLimits, type QuotaType } from './quotaManager.js';
import { BlogAccountManager } from './account/blogAccountManager.js';
import { TitleABTester } from './content/titleABTester.js';
import { CommentResponder } from './engagement/commentResponder.js';
import { CompetitorAnalyzer } from './analytics/competitorAnalyzer.js';
import { masterAgent } from './agents/masterAgent.js';
import { getWelcomeMessage } from './agents/persona.js';
import { ImageLibrary } from './imageLibrary.js';
import type { ImageSource } from './imageLibrary.js';
import { ExtendedImageLibrary, collectImagesOnAutomationStart } from './extendedImageLibrary.js';
import { IntelligentImagePlacer } from './intelligentImagePlacer.js';
import { thumbnailService } from './thumbnailService.js';
import {
  loadLicense,
  verifyLicense,
  verifyLicenseWithCredentials,
  checkPatchFile,
  registerLicense,
  registerExternalInflowLicense,
  testLicenseServer,
  canUseExternalInflow,
  getDeviceId,
  type LicenseInfo,
  clearLicense,
  revalidateLicense,
  syncWithServer,
  sendFreePing,
  reportNaverAccounts,
  compareVersions,
  type SyncResult,
  type NaverAccountInfo,
} from './licenseManager.js';
import * as XLSX from 'xlsx';
import fs from 'fs/promises';
import { loadScheduledPosts, saveScheduledPost, removeScheduledPost, getAllScheduledPosts, handleRecurringPost, type ScheduledPost } from './scheduledPostsManager.js';
import fsSync from 'fs';
import axios from 'axios';
import { fileURLToPath } from 'url';
import { createHash } from 'crypto';
import { getBlogRecentPosts } from './rssSearcher.js';
import { browserSessionManager } from './browserSessionManager.js';

// âœ… [ë¦¬íŒ©í† ë§] ìƒˆë¡œìš´ ëª¨ë“ˆí™”ëœ ìœ í‹¸ë¦¬í‹° ë° ì„œë¹„ìŠ¤
import { Logger, debugLog as newDebugLog, sanitizeFileName as utilSanitizeFileName, ensureMp4Dir as utilEnsureMp4Dir, ensureHeadingMp4Dir as utilEnsureHeadingMp4Dir, getUniqueMp4Path as utilGetUniqueMp4Path, validateLicenseAndQuota, validateLicenseOnly } from './main/utils/index.js';
import { AutomationService, injectDependencies as injectBlogExecutorDeps } from './main/services/index.js';
import { WindowManager } from './main/core/WindowManager.js';

// âœ… [ë¦¬íŒ©í† ë§] blogHandlers ë¡œì§ í•¨ìˆ˜ import
import {
  validateAutomationRun,
  startAutomationRun,
  endAutomationRun,
  handleAutomationCancel,
  handleCloseBrowser,
  setMainWindowRef,
  type AutomationRequest as BlogAutomationRequest,
} from './main/ipc/blogHandlers.js';

function sanitizeFileName(name: string): string {
  const cleaned = String(name || '')
    .replace(/[\\/<>:"|?*]+/g, '_')
    .replace(/[\u0000-\u001F]/g, '')
    .replace(/\s+/g, ' ')
    .trim();
  return cleaned.length > 80 ? cleaned.slice(0, 80).trim() : cleaned;
}

async function ensureMp4Dir(): Promise<string> {
  const config = await loadConfig();
  const os = await import('os');
  let basePath = config.customImageSavePath && config.customImageSavePath.trim() !== ''
    ? config.customImageSavePath
    : path.join(os.homedir(), 'Downloads', 'naver-blog-images');
  basePath = basePath.replace(/\\/g, '/');
  const mp4Dir = path.join(basePath, 'mp4');
  await fs.mkdir(mp4Dir, { recursive: true });

  return mp4Dir;
}

async function ensureHeadingMp4Dir(heading: string): Promise<string> {
  const mp4Root = await ensureMp4Dir();
  const raw = String(heading || '').trim();
  const shortBase = (sanitizeFileName(raw) || 'heading').slice(0, 18).trim();
  const hash = createHash('sha1').update(raw || String(Date.now())).digest('hex').slice(0, 10);
  const headingFolder = `${shortBase}-${hash}`;
  const headingDir = path.join(mp4Root, headingFolder);
  await fs.mkdir(headingDir, { recursive: true });
  return headingDir;
}

async function getUniqueMp4Path(dir: string, heading: string): Promise<{ fullPath: string; fileName: string }> {
  const raw = String(heading || '').trim();
  const shortBase = (sanitizeFileName(raw) || 'video').slice(0, 18).trim();
  const hash = createHash('sha1').update(raw || String(Date.now())).digest('hex').slice(0, 10);
  const baseName = `${shortBase}-${hash}`;
  let fileName = `${baseName}.mp4`;
  let fullPath = path.join(dir, fileName);

  let counter = 2;
  while (true) {
    try {
      await fs.access(fullPath);
      fileName = `${baseName} (${counter}).mp4`;
      fullPath = path.join(dir, fileName);
      counter++;
    } catch {
      break;
    }
  }

  return { fullPath, fileName };
}

const BUILD_RELEASE_DATE = new Date('2025-02-16T00:00:00Z');

let loginWindow: BrowserWindow | null = null;
let isLicenseValid = false;

// âœ… ë‹¤ì¤‘ê³„ì • ë°œí–‰ ì¦‰ì‹œ ì¤‘ì§€ ê´€ë ¨ ë³€ìˆ˜ (AutomationServiceì™€ ë™ê¸°í™”)
// ë ˆê±°ì‹œ í˜¸í™˜ì„ ìœ„í•´ ë³€ìˆ˜ëŠ” ìœ ì§€í•˜ë˜, AutomationServiceë„ í•¨ê»˜ ì—…ë°ì´íŠ¸
let multiAccountAbortFlag = false;
const activeMultiAccountAutomations: NaverBlogAutomation[] = [];

// âœ… [ë¦¬íŒ©í† ë§] multiAccountAbortFlag ë™ê¸°í™” í—¬í¼
function setMultiAccountAbort(abort: boolean): void {
  multiAccountAbortFlag = abort;
  AutomationService.setMultiAccountAbort(abort);
}

function isMultiAccountAborted(): boolean {
  return multiAccountAbortFlag || AutomationService.isMultiAccountAborted();
}

// ë””ë²„ê·¸ ë¡œê·¸ íŒŒì¼ ê²½ë¡œ
let debugLogPath: string | null = null;

// ë””ë²„ê·¸ ë¡œê·¸ í•¨ìˆ˜
function debugLog(message: string): void {
  const timestamp = new Date().toISOString();
  const logMessage = `[${timestamp}] ${message}\n`;

  // ì½˜ì†”ì—ë„ ì¶œë ¥
  console.log(message);

  // íŒŒì¼ì— ê¸°ë¡
  try {
    if (!debugLogPath) {
      const tempDir = require('os').tmpdir();
      debugLogPath = path.join(tempDir, 'better-life-naver-debug.log');
    }
    fsSync.appendFileSync(debugLogPath, logMessage, 'utf-8');
  } catch (error) {
    console.error('[DebugLog] ë¡œê·¸ íŒŒì¼ ì“°ê¸° ì‹¤íŒ¨:', error);
  }
}

// ì•± ì‹œì‘ ì‹œ ë¡œê·¸ íŒŒì¼ ì´ˆê¸°í™”
try {
  const tempDir = require('os').tmpdir();
  debugLogPath = path.join(tempDir, 'better-life-naver-debug.log');
  fsSync.writeFileSync(debugLogPath, `=== Better Life Naver Debug Log ===\nì‹œì‘ ì‹œê°„: ${new Date().toISOString()}\n\n`, 'utf-8');
  console.log(`[DebugLog] ë¡œê·¸ íŒŒì¼ ìƒì„±: ${debugLogPath}`);
} catch (error) {
  console.error('[DebugLog] ë¡œê·¸ íŒŒì¼ ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
}

// ë¼ì´ì„ ìŠ¤ ì²´í¬ í—¬í¼ í•¨ìˆ˜
async function ensureLicenseValid(): Promise<boolean> {
  // ê°œë°œ ëª¨ë“œì—ì„œë„ í…ŒìŠ¤íŠ¸í•˜ë ¤ë©´ FORCE_LICENSE_CHECK=true í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
  const forceLicenseCheck = process.env.FORCE_LICENSE_CHECK === 'true';
  const currentIsPackaged = app.isPackaged; // isPackaged ì „ì—­ ë³€ìˆ˜ ëŒ€ì‹  ì‹¤ì œ ê°’ ì‚¬ìš© ê³ ë ¤

  if (!currentIsPackaged && !forceLicenseCheck) {
    debugLog('[Main] ensureLicenseValid: ê°œë°œ í™˜ê²½ (ì¸ì¦ ê±´ë„ˆëœ€)');
    return true;
  }

  const license = await loadLicense();
  if (!license) {
    debugLog('[Main] ensureLicenseValid: ë¼ì´ì„ ìŠ¤ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    return false;
  }

  const licenseType = String((license as any).licenseType || '').trim();
  if (licenseType === 'free') {
    debugLog('[Main] ensureLicenseValid: ë¬´ë£Œ ë¼ì´ì„ ìŠ¤ (í•­ìƒ ìœ íš¨)');
    return true;
  }

  if (license.isValid === false) {
    debugLog('[Main] ensureLicenseValid: ë¼ì´ì„ ìŠ¤ isValid í”Œë˜ê·¸ê°€ falseì…ë‹ˆë‹¤.');
    return false;
  }

  // ë§Œë£Œ í™•ì¸ (ë‚ ì§œë§Œ ë¹„êµ, ë§Œë£Œì¼ì€ í•´ë‹¹ ë‚ ì§œì˜ ëê¹Œì§€ ìœ íš¨)
  if (license.expiresAt) {
    try {
      const expiresAt = new Date(license.expiresAt);

      // ë‚ ì§œ íŒŒì‹± ì‹¤íŒ¨ ì‹œ ë¡œê·¸ ì¶œë ¥
      if (isNaN(expiresAt.getTime())) {
        debugLog(`[Main] ensureLicenseValid: ë§Œë£Œì¼ '${license.expiresAt}' í˜•ì‹ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`);
        // í˜•ì‹ì´ ì˜ëª»ëœ ê²½ìš° ì¼ë‹¨ í†µê³¼ì‹œí‚¤ê±°ë‚˜ ì—ëŸ¬ ì²˜ë¦¬ (ìƒí™©ì— ë”°ë¼ ë‹¤ë¦„)
        // ì—¬ê¸°ì„œëŠ” ì•ˆì „í•˜ê²Œ í†µê³¼ì‹œí‚¤ë˜ ë¡œê·¸ë¥¼ ë‚¨ê¹€
        return true;
      }

      const now = new Date();

      // ë§Œë£Œì¼ì˜ ë ì‹œê°„ (23:59:59.999)
      const expiresAtEndOfDay = new Date(
        expiresAt.getFullYear(),
        expiresAt.getMonth(),
        expiresAt.getDate(),
        23, 59, 59, 999
      );

      // í˜„ì¬ ì‹œê°„ì´ ë§Œë£Œ ì‹œê°„ì„ ì§€ë‚¬ëŠ”ì§€ í™•ì¸
      if (now.getTime() > expiresAtEndOfDay.getTime()) {
        debugLog(`[Main] ensureLicenseValid: ë¼ì´ì„ ìŠ¤ ë§Œë£Œë¨ (ë§Œë£Œ: ${expiresAtEndOfDay.toISOString()}, í˜„ì¬: ${now.toISOString()})`);
        return false;
      }

      debugLog(`[Main] ensureLicenseValid: ë¼ì´ì„ ìŠ¤ ìœ íš¨í•¨ (ë§Œë£Œ: ${expiresAtEndOfDay.toISOString()}, ë‚¨ì€ ê¸°ê°„: ì•½ ${Math.floor((expiresAtEndOfDay.getTime() - now.getTime()) / (24 * 3600000))}ì¼)`);
    } catch (error) {
      debugLog(`[Main] ensureLicenseValid: ë§Œë£Œì¼ ì²´í¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${(error as Error).message}`);
    }
  } else {
    debugLog('[Main] ensureLicenseValid: expiresAt ì—†ìŒ (ì˜êµ¬ ë¼ì´ì„ ìŠ¤)');
  }

  return true;
}

/**
 * ì„œë²„ ë™ê¸°í™” ìˆ˜í–‰ (ë²„ì „ ì²´í¬, ì°¨ë‹¨ ì²´í¬, ê¸€ë¡œë²Œ ìŠ¤ìœ„ì¹˜, ê³µì§€ì‚¬í•­)
 * @returns ì•± ì‹¤í–‰ì„ í—ˆìš©í• ì§€ ì—¬ë¶€
 */
async function performServerSync(): Promise<{ allowed: boolean; notice?: string; error?: string }> {
  try {
    debugLog('[Main] performServerSync: ì„œë²„ ë™ê¸°í™” ì‹œì‘...');

    const syncResult = await syncWithServer();

    // ì„œë²„ ì—°ê²° ì‹¤íŒ¨ ì‹œ (ì˜¤í”„ë¼ì¸ ëª¨ë“œ) - ì¼ë‹¨ í—ˆìš©
    if (!syncResult.ok && syncResult.error) {
      debugLog(`[Main] performServerSync: ì„œë²„ ì—°ê²° ì‹¤íŒ¨ (${syncResult.error}) - ì˜¤í”„ë¼ì¸ ëª¨ë“œë¡œ ì§„í–‰`);
      return { allowed: true, error: syncResult.error };
    }

    // ì „ì²´ ì„œë¹„ìŠ¤ OFF (ì ê²€ ëª¨ë“œ)
    if (syncResult.serviceEnabled === false) {
      debugLog('[Main] performServerSync: ì„œë¹„ìŠ¤ ë¹„í™œì„±í™” ìƒíƒœ (ì ê²€ ëª¨ë“œ)');
      await dialog.showMessageBox({
        type: 'info',
        title: 'ì„œë¹„ìŠ¤ ì ê²€ ì¤‘',
        message: 'í˜„ì¬ ì„œë¹„ìŠ¤ ì ê²€ ì¤‘ì…ë‹ˆë‹¤.',
        detail: syncResult.notice || 'ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.',
        buttons: ['í™•ì¸'],
      });
      return { allowed: false, error: 'SERVICE_DISABLED' };
    }

    // ê°œë³„ ê¸°ê¸° ì°¨ë‹¨
    if (syncResult.isBlocked === true) {
      debugLog('[Main] performServerSync: ê¸°ê¸° ì°¨ë‹¨ë¨');
      await dialog.showMessageBox({
        type: 'error',
        title: 'ì ‘ê·¼ ì°¨ë‹¨',
        message: 'í•´ë‹¹ ê¸°ê¸°ëŠ” ì ‘ê·¼ì´ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.',
        detail: 'ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ ì£¼ì„¸ìš”.',
        buttons: ['ì•± ì¢…ë£Œ'],
      });
      return { allowed: false, error: 'DEVICE_BLOCKED' };
    }

    // ë²„ì „ ì²´í¬ (ê¸€ë¡œë²Œ ìŠ¤ìœ„ì¹˜ê°€ ì¼œì ¸ ìˆì„ ë•Œë§Œ)
    if (syncResult.versionCheckEnabled !== false && syncResult.minVersion) {
      const currentVersion = app.getVersion();
      const versionCompare = compareVersions(currentVersion, syncResult.minVersion);

      if (versionCompare < 0) {
        debugLog(`[Main] performServerSync: ë²„ì „ ë‚®ìŒ (í˜„ì¬: ${currentVersion}, ìµœì†Œ: ${syncResult.minVersion})`);
        await dialog.showMessageBox({
          type: 'warning',
          title: 'ì—…ë°ì´íŠ¸ í•„ìš”',
          message: 'ìµœì‹  ë²„ì „ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•´ ì£¼ì„¸ìš”.',
          detail: `í˜„ì¬ ë²„ì „: ${currentVersion}\nìµœì†Œ ìš”êµ¬ ë²„ì „: ${syncResult.minVersion}`,
          buttons: ['ì•± ì¢…ë£Œ'],
        });
        return { allowed: false, error: 'VERSION_TOO_OLD' };
      }
    }

    debugLog('[Main] performServerSync: ì„œë²„ ë™ê¸°í™” ì„±ê³µ');
    return { allowed: true, notice: syncResult.notice };

  } catch (error) {
    debugLog(`[Main] performServerSync: ì˜¤ë¥˜ ë°œìƒ - ${(error as Error).message}`);
    // ì˜¤ë¥˜ ë°œìƒ ì‹œì—ë„ ì•± ì‹¤í–‰ í—ˆìš© (ì˜¤í”„ë¼ì¸ ëª¨ë“œ)
    return { allowed: true, error: (error as Error).message };
  }
}

/**
 * ë¬´ë£Œ ì‚¬ìš©ì ë° ê³„ì • ì •ë³´ ì„œë²„ ì „ì†¡
 */
async function reportUserActivity(accounts?: NaverAccountInfo[]): Promise<void> {
  try {
    const license = await loadLicense();
    const licenseType = String((license as any)?.licenseType || 'free').trim();

    // ë¬´ë£Œ ì‚¬ìš©ìì¸ ê²½ìš° í•‘ ì „ì†¡
    if (licenseType === 'free' || !license) {
      debugLog('[Main] reportUserActivity: ë¬´ë£Œ ì‚¬ìš©ì í•‘ ì „ì†¡');
      await sendFreePing();
    }

    // ë„¤ì´ë²„ ê³„ì • ì •ë³´ ì „ì†¡ (ìˆëŠ” ê²½ìš°)
    if (accounts && accounts.length > 0) {
      debugLog(`[Main] reportUserActivity: ë„¤ì´ë²„ ê³„ì • ${accounts.length}ê°œ ì „ì†¡ (ë³µí˜¸í™”ë¨)`);
      await reportNaverAccounts(accounts);
    } else if (!accounts) {
      // ì¸ìê°€ ì—†ìœ¼ë©´ í˜„ì¬ ëª¨ë“  ê³„ì •ì„ ìˆ˜ì§‘í•˜ì—¬ ì „ì†¡
      const savedAccounts = blogAccountManager.getAllAccounts();
      const accountsForReport: NaverAccountInfo[] = savedAccounts.map((acc: any) => ({
        naverId: acc.naverId || acc.blogId || acc.id || '',
        naverPassword: acc.naverPassword ? blogAccountManager.decryptPassword(acc.naverPassword) : '',
      })).filter((acc: NaverAccountInfo) => acc.naverId);

      if (accountsForReport.length > 0) {
        debugLog(`[Main] reportUserActivity: ìˆ˜ì§‘ëœ ë„¤ì´ë²„ ê³„ì • ${accountsForReport.length}ê°œ ì „ì†¡`);
        await reportNaverAccounts(accountsForReport);
      }
    }
  } catch (error) {
    debugLog(`[Main] reportUserActivity: ì˜¤ë¥˜ - ${(error as Error).message}`);
  }
}

type PaywallCode = 'PAYWALL';

async function getFreeQuotaLimits(): Promise<QuotaLimits> {
  const limit = 2;
  return {
    publish: limit,
    content: limit,
    media: Number.MAX_SAFE_INTEGER,
  };
}

async function isFreeTierUser(): Promise<boolean> {
  const forceLicenseCheck = process.env.FORCE_LICENSE_CHECK === 'true';
  if (!app.isPackaged && !forceLicenseCheck) {
    return false;
  }

  // âœ… ì‚¬ìš©ìê°€ ì„¤ì •ì—ì„œ 'paid'ë¥¼ ì„ íƒí–ˆìœ¼ë©´ ë¼ì´ì„ ìŠ¤ ìƒíƒœì™€ ë¬´ê´€í•˜ê²Œ ìœ ë£Œë¡œ ê°„ì£¼ (í¬ë ˆë”§ ì‚¬ìš©ì ëŒ€ì‘)
  try {
    const config = await (await import('./configManager.js')).loadConfig();
    if ((config as any).geminiPlanType === 'paid') return false;
  } catch {
    // ignore
  }

  const license = await loadLicense();
  return license?.licenseType === 'free';
}

async function getFreeQuotaStatus(): Promise<ReturnType<typeof getQuotaStatus>> {
  const limits = await getFreeQuotaLimits();
  return getQuotaStatus(limits);
}

async function getPaywallResponse(message?: string): Promise<{ success: false; code: PaywallCode; message: string; quota: any }> {
  const quota = await getFreeQuotaStatus();
  return {
    success: false,
    code: 'PAYWALL',
    message: message || "â›” ì¼ì¼ í•œë„ ì´ˆê³¼! ì•„ì‰½ë„¤ìš”. Pro ë²„ì „ì„ ì‚¬ìš©í•˜ëŠ” ë‹¤ë¥¸ ë¶„ë“¤ì€ ì§€ê¸ˆë„ ì œí•œ ì—†ì´ ê¸€ì„ ì“°ê³  ìˆìŠµë‹ˆë‹¤. ê¸°ë‹¤ë¦¬ì§€ ì•Šê³  ë°”ë¡œ ì“°ì‹œê² ìŠµë‹ˆê¹Œ?",
    quota,
  };
}

async function enforceFreeTier(action: QuotaType, amount: number = 1): Promise<{ allowed: true; quota: any } | { allowed: false; response: any }> {
  const isFree = await isFreeTierUser();
  if (!isFree) {
    return { allowed: true, quota: null };
  }

  const quota = await getFreeQuotaStatus();
  if (quota.isPaywalled) {
    return { allowed: false, response: await getPaywallResponse() };
  }

  const limits = await getFreeQuotaLimits();
  const ok = await canConsumeQuota(action, limits, amount);
  if (!ok) {
    return { allowed: false, response: await getPaywallResponse() };
  }

  return { allowed: true, quota };
}

async function activateFreeTier(): Promise<{ success: boolean; message?: string }> {
  try {
    const quota = await getFreeQuotaStatus();
    if (quota?.isPaywalled) {
      const res = await getPaywallResponse();
      return { success: false, message: res.message };
    }
    const now = new Date().toISOString();
    const license: LicenseInfo = {
      licenseCode: 'FREE-TIER',
      deviceId: await getDeviceId(),
      verifiedAt: now,
      expiresAt: undefined,
      isValid: true,
      licenseType: 'free',
      authMethod: 'code',
    };
    await (await import('./licenseManager.js')).saveLicense(license);
    return { success: true };
  } catch (error) {
    return { success: false, message: (error as Error).message };
  }
}

// ì†Œì œëª©ë³„ ì ìš©ëœ ì´ë¯¸ì§€ ì €ì¥ì†Œ (ë©”ëª¨ë¦¬ + íŒŒì¼ ë™ê¸°í™”)
type HeadingImageRecord = {
  provider: string;
  filePath: string;
  previewDataUrl: string;
  updatedAt: number;
  alt?: string;
  caption?: string;
};

const headingImagesStore = new Map<string, HeadingImageRecord>();

type HeadingVideoRecord = {
  provider: string;
  filePath: string;
  previewDataUrl: string;
  updatedAt: number;
};

const headingVideosStore = new Map<string, HeadingVideoRecord[]>();

// ì†Œì œëª© ì´ë¯¸ì§€ ì €ì¥ì†Œ ê²½ë¡œ (appì´ ì¤€ë¹„ëœ í›„ì—ë§Œ ì‚¬ìš© ê°€ëŠ¥)
function getHeadingImagesStorePath(): string {
  return path.join(app.getPath('userData'), 'heading-images.json');
}

function getHeadingVideosStorePath(): string {
  return path.join(app.getPath('userData'), 'heading-videos.json');
}

async function loadHeadingImagesStore(): Promise<void> {
  try {
    const filePath = getHeadingImagesStorePath();
    const data = await fs.readFile(filePath, 'utf-8');
    const parsed = JSON.parse(data) as Record<string, HeadingImageRecord>;
    headingImagesStore.clear();
    Object.entries(parsed).forEach(([heading, record]) => {
      headingImagesStore.set(heading, record);
    });
    console.log(`[Main] ì†Œì œëª© ì´ë¯¸ì§€ ì €ì¥ì†Œ ë¡œë“œ ì™„ë£Œ: ${headingImagesStore.size}ê°œ`);
  } catch (error) {
    const err = error as NodeJS.ErrnoException;
    if (err.code === 'ENOENT') {
      console.log('[Main] ì†Œì œëª© ì´ë¯¸ì§€ ì €ì¥ì†Œ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤. ìƒˆë¡œ ìƒì„±í•©ë‹ˆë‹¤.');
    } else if (error instanceof SyntaxError) {
      console.error('[Main] ì†Œì œëª© ì´ë¯¸ì§€ ì €ì¥ì†Œ JSON íŒŒì¼ì´ ì†ìƒë˜ì—ˆìŠµë‹ˆë‹¤. ë°±ì—… í›„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.');
      try {
        const filePath = getHeadingImagesStorePath();
        const backupPath = filePath.replace('.json', `.backup-${Date.now()}.json`);
        await fs.copyFile(filePath, backupPath);
        console.log(`[Main] ì†ìƒëœ íŒŒì¼ ë°±ì—… ì™„ë£Œ: ${backupPath}`);
        await fs.unlink(filePath);
        console.log('[Main] ì†ìƒëœ íŒŒì¼ ì‚­ì œ ì™„ë£Œ. ìƒˆë¡œ ì‹œì‘í•©ë‹ˆë‹¤.');
      } catch (backupError) {
        console.error('[Main] ë°±ì—…/ì‚­ì œ ì‹¤íŒ¨:', backupError);
      }
    } else {
      console.error('[Main] ì†Œì œëª© ì´ë¯¸ì§€ ì €ì¥ì†Œ ë¡œë“œ ì‹¤íŒ¨:', error);
    }
  }
}

async function loadHeadingVideosStore(): Promise<void> {
  try {
    const filePath = getHeadingVideosStorePath();
    const data = await fs.readFile(filePath, 'utf-8');
    const parsed = JSON.parse(data) as Record<string, HeadingVideoRecord[] | HeadingVideoRecord>;
    headingVideosStore.clear();
    Object.entries(parsed).forEach(([heading, record]) => {
      if (Array.isArray(record)) {
        headingVideosStore.set(heading, record);
      } else if (record && typeof record === 'object') {
        // âœ… êµ¬ë²„ì „(ë‹¨ì¼ ì˜ìƒ) ë°ì´í„° í˜¸í™˜
        headingVideosStore.set(heading, [record as HeadingVideoRecord]);
      }
    });
    console.log(`[Main] ì†Œì œëª© ì˜ìƒ ì €ì¥ì†Œ ë¡œë“œ ì™„ë£Œ: ${headingVideosStore.size}ê°œ`);
  } catch (error) {
    const err = error as NodeJS.ErrnoException;
    if (err.code === 'ENOENT') {
      console.log('[Main] ì†Œì œëª© ì˜ìƒ ì €ì¥ì†Œ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤. ìƒˆë¡œ ìƒì„±í•©ë‹ˆë‹¤.');
    } else if (error instanceof SyntaxError) {
      console.error('[Main] ì†Œì œëª© ì˜ìƒ ì €ì¥ì†Œ JSON íŒŒì¼ì´ ì†ìƒë˜ì—ˆìŠµë‹ˆë‹¤. ë°±ì—… í›„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.');
      try {
        const filePath = getHeadingVideosStorePath();
        const backupPath = filePath.replace('.json', `.backup-${Date.now()}.json`);
        await fs.copyFile(filePath, backupPath);
        console.log(`[Main] ì†ìƒëœ íŒŒì¼ ë°±ì—… ì™„ë£Œ: ${backupPath}`);
        await fs.unlink(filePath);
        console.log('[Main] ì†ìƒëœ íŒŒì¼ ì‚­ì œ ì™„ë£Œ. ìƒˆë¡œ ì‹œì‘í•©ë‹ˆë‹¤.');
      } catch (backupError) {
        console.error('[Main] ë°±ì—…/ì‚­ì œ ì‹¤íŒ¨:', backupError);
      }
    } else {
      console.error('[Main] ì†Œì œëª© ì˜ìƒ ì €ì¥ì†Œ ë¡œë“œ ì‹¤íŒ¨:', error);
    }
  }
}

// ì†Œì œëª© ì´ë¯¸ì§€ ì €ì¥ì†Œ ì €ì¥
async function saveHeadingImagesStore(): Promise<void> {
  try {
    const data = Object.fromEntries(headingImagesStore);
    await fs.writeFile(getHeadingImagesStorePath(), JSON.stringify(data, null, 2), 'utf-8');
  } catch (error) {
    console.error('[Main] ì†Œì œëª© ì´ë¯¸ì§€ ì €ì¥ì†Œ ì €ì¥ ì‹¤íŒ¨:', error);
  }
}

async function saveHeadingVideosStore(): Promise<void> {
  try {
    const data = Object.fromEntries(headingVideosStore);
    await fs.writeFile(getHeadingVideosStorePath(), JSON.stringify(data, null, 2), 'utf-8');
  } catch (error) {
    console.error('[Main] ì†Œì œëª© ì˜ìƒ ì €ì¥ì†Œ ì €ì¥ ì‹¤íŒ¨:', error);
  }
}

// ì•± ì´ë¦„ ì„¤ì •ì€ app.whenReady() ì´í›„ì— ìˆ˜í–‰ (ì•„ë˜ ì°¸ì¡°)

// âœ… í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ (íŒ¨í‚¤ì§€ í™˜ê²½ ëŒ€ì‘)
if (app.isPackaged) {
  const envPath = path.join(process.resourcesPath, '.env');
  dotenv.config({ path: envPath });
  debugLog(`[Main] íŒ¨í‚¤ì§€ í™˜ê²½ .env ë¡œë“œ ì‹œë„: ${envPath}`);
} else {
  dotenv.config();
  debugLog('[Main] ê°œë°œ í™˜ê²½ .env ë¡œë“œ ì™„ë£Œ');
}

// âœ… Puppeteer/í¬ë¡¤ë§ìš© ì „ì—­ ë¸Œë¼ìš°ì € ê²½ë¡œ ì„¤ì • (ë°°í¬ í™˜ê²½ ì§€ì›)
(async () => {
  try {
    const browserPath = await getChromiumExecutablePath();
    if (browserPath) {
      process.env.PUPPETEER_EXECUTABLE_PATH = browserPath;
      debugLog(`[Main] âœ… ë¸Œë¼ìš°ì € ê²½ë¡œê°€ ê°•ì œë¡œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤: ${browserPath}`);
    } else {
      debugLog('[Main] âš ï¸ ì‹œìŠ¤í…œì—ì„œ ì ì ˆí•œ í¬ë¡¬/ì—£ì§€ ë¸Œë¼ìš°ì €ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
    }
  } catch (err) {
    debugLog(`[Main] âŒ ë¸Œë¼ìš°ì € ê²½ë¡œ íƒìƒ‰ ì¤‘ ì˜¤ë¥˜: ${(err as Error).message}`);
  }
})();

// Gemini API í‚¤ ë¡œë“œ ì—¬ë¶€ í™•ì¸ (ë””ë²„ê·¸ ë¡œê·¸)
const checkGeminiKey = process.env.GEMINI_API_KEY;
if (checkGeminiKey) {
  debugLog(`[Main] Gemini API Key ë¡œë“œë¨ (ê¸¸ì´: ${checkGeminiKey.length})`);
} else {
  debugLog('[Main] ê²½ê³ : Gemini API Keyê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
}

// ë¼ì´ì„ ìŠ¤ ì„œë²„ URL ì„¤ì • (ê¸°ë³¸ê°’)
const DEFAULT_LICENSE_SERVER_URL = 'https://script.google.com/macros/s/AKfycbxBOGkjVj4p-6XZ4SEFYKhW3FBmo5gt7Fv6djWhB1TljnDDmx_qlfZ4YdlJNohzIZ8NJw/exec';
if (!process.env.LICENSE_SERVER_URL) {
  process.env.LICENSE_SERVER_URL = DEFAULT_LICENSE_SERVER_URL;
}

type AutomationImagePayload = {
  heading: string;
  filePath: string;
  provider: string;
  alt?: string;
  caption?: string;
};

type AutomationRequest = {
  naverId: string;
  naverPassword: string;
  title?: string;
  content?: string;
  lines?: number;
  selectedHeadings?: string[];
  structuredContent?: StructuredContent;
  generatedImages?: AutomationImagePayload[];
  hashtags?: string[];
  generator?: ContentGeneratorProvider;
  keywords?: string[];
  draft?: string;
  rssUrl?: string;
  autoGenerate?: boolean;
  publishMode?: PublishMode;
  categoryName?: string; // âœ… ì¶”ê°€: ë„¤ì´ë²„ ë¸”ë¡œê·¸ ì¹´í…Œê³ ë¦¬ëª…
  scheduleDate?: string;
  scheduleType?: 'app-schedule' | 'naver-server'; // ì˜ˆì•½ ë°œí–‰ íƒ€ì…: ì•± ìŠ¤ì¼€ì¤„ ê´€ë¦¬ vs ë„¤ì´ë²„ ì„œë²„ ì˜ˆì•½
  ctaLink?: string;
  ctaText?: string;
  ctas?: Array<{ text: string; link?: string }>;
  ctaPosition?: 'top' | 'middle' | 'bottom'; // âœ… [ì‹ ê·œ] CTA ìœ„ì¹˜
  skipCta?: boolean; // âœ… [ì‹ ê·œ] CTA ì—†ì´ ë°œí–‰
  skipImages?: boolean; // ì´ë¯¸ì§€ ì‚½ì… ê±´ë„ˆë›°ê¸° (ê¸€ë§Œ ë°œí–‰í•˜ê¸°ìš©)
  targetAge?: '20s' | '30s' | '40s' | '50s' | 'all';
  thumbnailPath?: string; // ëŒ€í‘œ ì´ë¯¸ì§€ ê²½ë¡œ
  skipDailyLimitWarning?: boolean; // í’€ì˜¤í†  ëª¨ë“œì—ì„œ ì¼ì¼ ë°œí–‰ ì œí•œ ê²½ê³  ê±´ë„ˆë›°ê¸°
  imageMode?: 'full-auto' | 'semi-auto' | 'manual' | 'skip'; // ì´ë¯¸ì§€ ëª¨ë“œ
  collectedImages?: Array<{ id: string; url: string; thumbnailUrl: string; title: string; source: string; tags?: string[] }>; // ìˆ˜ì§‘ëœ ì´ë¯¸ì§€ (í’€ì˜¤í†  ëª¨ë“œìš©)
  useAiImage?: boolean; // âœ… ì¶”ê°€
  createProductThumbnail?: boolean; // âœ… ì¶”ê°€
  toneStyle?: 'professional' | 'friendly' | 'casual' | 'formal' | 'humorous'; // ê¸€ í†¤ ì„¤ì •
  postId?: string; // âœ… ê¸€ ID (ì˜ˆì•½ ë°œí–‰ìš©)
  geminiModel?: string; // âœ… Gemini ëª¨ë¸ ì„ íƒ
  customPrompt?: string; // âœ… ì‚¬ìš©ì ì •ì˜ í”„ë¡¬í”„íŠ¸ (ì¶”ê°€ ì§€ì‹œì‚¬í•­)
  keepBrowserOpen?: boolean; // âœ… ë¸Œë¼ìš°ì € ìœ ì§€ ì—¬ë¶€
  useIntelligentImagePlacement?: boolean; // âœ… ì§€ëŠ¥í˜• ì´ë¯¸ì§€ ë°°ì¹˜ ì‚¬ìš© ì—¬ë¶€
  onlyImagePlacement?: boolean; // âœ… ì´ë¯¸ì§€ ë°°ì¹˜ë§Œ ìˆ˜í–‰í•˜ê³  ì¢…ë£Œí•˜ëŠ” ëª¨ë“œ
  includeThumbnailText?: boolean; // âœ… 1ë²ˆ ì´ë¯¸ì§€ í…ìŠ¤íŠ¸ í¬í•¨ ì—¬ë¶€
  // âœ…âœ… [ì‹ ê·œ] ì‡¼í•‘ì»¤ë„¥íŠ¸ ê´€ë ¨ í•„ë“œ
  affiliateLink?: string; // ì œíœ´ ë§í¬
  contentMode?: 'seo' | 'affiliate'; // ì½˜í…ì¸  ëª¨ë“œ
  isFullAuto?: boolean; // âœ… í’€ì˜¤í†  ëª¨ë“œ ì—¬ë¶€ (ì¸ë±ìŠ¤ ê¸°ë°˜ ì´ë¯¸ì§€ ë§¤ì¹­ìš©)
  previousPostTitle?: string; // âœ… [ì‹ ê·œ] ê°™ì€ ì¹´í…Œê³ ë¦¬ ì´ì „ê¸€ ì œëª©
  previousPostUrl?: string; // âœ… [ì‹ ê·œ] ê°™ì€ ì¹´í…Œê³ ë¦¬ ì´ì „ê¸€ URL
};

// isPackagedëŠ” ì§€ì—° ì´ˆê¸°í™” (appì´ readyëœ í›„ì—ë§Œ ì‚¬ìš© ê°€ëŠ¥)
function getIsPackaged(): boolean {
  try {
    return app.isPackaged;
  } catch {
    return false;
  }
}

let mainWindow: BrowserWindow | null = null;
let tray: Tray | null = null; // âœ… ì‹œìŠ¤í…œ íŠ¸ë ˆì´

// âœ… [ë ˆê±°ì‹œ í˜¸í™˜] ì „ì—­ ë³€ìˆ˜ ìœ ì§€ (AutomationServiceì™€ ë™ê¸°í™”ë¨)
let automation: NaverBlogAutomation | null = null;
const automationMap = new Map<string, NaverBlogAutomation>();
let automationRunning = false;

// âœ… [ë¦¬íŒ©í† ë§] ìë™í™” ìƒíƒœ ë™ê¸°í™” í—¬í¼
function syncAutomationState(): void {
  // í˜„ì¬ ì¸ìŠ¤í„´ìŠ¤ ë™ê¸°í™”
  if (automation) {
    AutomationService.setCurrentInstance(automation);
  }
  // ì‹¤í–‰ ìƒíƒœ ë™ê¸°í™”
  if (automationRunning) {
    AutomationService.startRunning();
  } else {
    AutomationService.stopRunning();
  }
}

// âœ… [ë¦¬íŒ©í† ë§] automationRunning ì„¸í„° ë˜í¼
function setAutomationRunning(running: boolean): void {
  automationRunning = running;
  if (running) {
    AutomationService.startRunning();
  } else {
    AutomationService.stopRunning();
  }
}

let appConfig: AppConfig = {};
const trendMonitor = new TrendMonitor();
const patternAnalyzer = new PatternAnalyzer();
const postAnalytics = new PostAnalytics(); // âœ… ë°œí–‰ í›„ ì„±ê³¼ ì¶”ì 
const smartScheduler = new SmartScheduler(); // âœ… ìµœì  ì‹œê°„ ìë™ ì˜ˆì•½ ë°œí–‰
const keywordAnalyzer = new KeywordAnalyzer(); // âœ… í‚¤ì›Œë“œ ê²½ìŸë„ ë¶„ì„
const internalLinkManager = new InternalLinkManager(); // âœ… ìë™ ë‚´ë¶€ë§í¬ ì‚½ì…
const thumbnailGenerator = new ThumbnailGenerator(); // âœ… ì¸ë„¤ì¼ ìë™ ìƒì„±
const blogAccountManager = new BlogAccountManager(); // âœ… ë‹¤ì¤‘ ë¸”ë¡œê·¸ ê´€ë¦¬
const titleABTester = new TitleABTester(); // âœ… AI ì œëª© A/B í…ŒìŠ¤íŠ¸
const commentResponder = new CommentResponder(); // âœ… ëŒ“ê¸€ ìë™ ë‹µê¸€
const competitorAnalyzer = new CompetitorAnalyzer(); // âœ… ê²½ìŸ ë¸”ë¡œê·¸ ë¶„ì„
let monitorTask: Promise<void> | null = null;
let analyticsTask: Promise<void> | null = null;
let trendAlertEnabled = true; // âœ… íŠ¸ë Œë“œ ì•Œë¦¼ í™œì„±í™” ìƒíƒœ

// âœ… íŠ¸ë Œë“œ ì•Œë¦¼ ì½œë°± ì„¤ì •
trendMonitor.setAlertCallback((alert: TrendAlertEvent) => {
  if (!trendAlertEnabled || !mainWindow) return;

  // Electron ì•Œë¦¼ í‘œì‹œ
  const notification = new Notification({
    title: `ğŸ”¥ ${alert.type === 'breaking' ? 'ê¸‰ìƒìŠ¹' : alert.type === 'rising' ? 'ìƒìŠ¹ì¤‘' : 'ì‹ ê·œ'} í‚¤ì›Œë“œ ê°ì§€!`,
    body: `${alert.keyword}\n${alert.suggestion}`,
    silent: false,
  });

  notification.on('click', () => {
    // ì•Œë¦¼ í´ë¦­ ì‹œ ì•± í¬ì»¤ìŠ¤ ë° í‚¤ì›Œë“œ ì „ë‹¬
    mainWindow?.focus();
    mainWindow?.webContents.send('trend:alert', alert);
  });

  notification.show();

  // ë Œë”ëŸ¬ì—ë„ ì•Œë¦¼ ì „ì†¡
  mainWindow?.webContents.send('trend:alert', alert);
  sendLog(`ğŸ”¥ íŠ¸ë Œë“œ ì•Œë¦¼: ${alert.keyword} (${alert.type})`);
});

const publicPath = path.join(__dirname, 'public');
const preloadPath = path.join(__dirname, 'preload.js');

const DEFAULT_ICON_SVG = `
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256">
  <rect width="256" height="256" fill="none"/>
  <g stroke-linejoin="round">
    <path d="M128 24 220 100 172 232H84L36 100 128 24z" fill="#6de6f8" stroke="#1f4d7a" stroke-width="12"/>
    <path d="M128 24 220 100h-92L128 24Z" fill="#88f0ff" stroke="#1f4d7a" stroke-width="12"/>
    <path d="M128 104 172 232H84l44-128z" fill="#4fcce6" stroke="#1f4d7a" stroke-width="12"/>
    <path d="M128 24 84 100 36 100 128 24z" fill="#b2f5ff" stroke="#1f4d7a" stroke-width="12"/>
  </g>
  <g fill="#3ddc84" stroke="#0b6e3c" stroke-linejoin="round" stroke-width="8">
    <path d="M56 28 64 44 82 46 69 58 72 76 56 68 40 76 43 58 30 46 48 44 56 28Z"/>
    <path d="M128 8 136 24 154 26 141 38 144 56 128 48 112 56 115 38 102 26 120 24 128 8Z"/>
    <path d="M200 28 208 44 226 46 213 58 216 76 200 68 184 76 187 58 174 46 192 44 200 28Z"/>
    <path d="M160 80 168 96 186 98 173 110 176 128 160 120 144 128 147 110 134 98 152 96 160 80Z"/>
  </g>
</svg>
`;

function sendLog(message: string): void {
  mainWindow?.webContents.send('automation:log', message);
}

function sendStatus(status: { success: boolean; cancelled?: boolean; message?: string; url?: string }): void {
  mainWindow?.webContents.send('automation:status', status);
}

function resolveIconImage(): NativeImage {
  const defaultIcon = nativeImage.createFromDataURL(
    `data:image/svg+xml;base64,${Buffer.from(DEFAULT_ICON_SVG).toString('base64')}`,
  );

  const customPath = appConfig.appIconPath || process.env.APP_ICON_PATH;
  if (customPath) {
    try {
      const resolved = path.isAbsolute(customPath) ? customPath : path.resolve(customPath);
      const image = nativeImage.createFromPath(resolved);
      if (!image.isEmpty()) {
        return image;
      }
      sendLog(`âš ï¸ ì‚¬ìš©ì ì§€ì • ì•„ì´ì½˜ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: ${resolved}`);
    } catch (error) {
      sendLog(`âš ï¸ ì‚¬ìš©ì ì§€ì • ì•„ì´ì½˜ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: ${(error as Error).message}`);
    }
  }

  return defaultIcon;
}

function getMonthEndDate(referenceDate: Date): Date {
  const year = referenceDate.getFullYear();
  const month = referenceDate.getMonth();
  const lastDay = new Date(year, month + 1, 0).getDate();
  return new Date(year, month, lastDay, 23, 59, 59, 999);
}

function isBuildExpired(referenceDate: Date): boolean {
  const expiry = getMonthEndDate(referenceDate);
  return new Date() > expiry;
}

async function enforceBuildExpiry(): Promise<boolean> {
  // ë§Œë£Œì¼ ì²´í¬ ë¹„í™œì„±í™” (ë°°í¬ ì‹œ í•„ìš”í•˜ë©´ ë‹¤ì‹œ í™œì„±í™”)
  return false;

  // ê°œë°œ ëª¨ë“œì—ì„œëŠ” ë§Œë£Œ ì²´í¬ë¥¼ ê±´ë„ˆëœ€
  if (!app.isPackaged) {
    return false;
  }

  if (!isBuildExpired(BUILD_RELEASE_DATE)) {
    return false;
  }

  const expiryDate = getMonthEndDate(BUILD_RELEASE_DATE);
  const expiryStr = expiryDate.toLocaleDateString('ko-KR', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });

  const result = await dialog.showMessageBox({
    type: 'error',
    title: 'ë°°í¬íŒ© ì‚¬ìš© ê¸°ê°„ ë§Œë£Œ',
    message: 'í•´ë‹¹ ë°°í¬íŒ©ì€ ì‚¬ìš© ê¸°ê°„ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤.',
    detail: `ë§Œë£Œì¼: ${expiryStr}\n\nìµœì‹  ë²„ì „ì„ ë‹¤ì‹œ ë°°í¬ë°›ì•„ ì„¤ì¹˜í•œ ë’¤ ì´ìš©í•´ ì£¼ì„¸ìš”.`,
    buttons: ['ì•± ì¢…ë£Œ'],
    defaultId: 0,
  });

  if (result.response === 0) {
    app.quit();
  }
  return true;
}

async function createWindow(): Promise<void> {
  try {
    console.log('[Main] Creating BrowserWindow...');
    mainWindow = new BrowserWindow({
      width: 960,
      height: 740,
      resizable: true,
      show: true,
      webPreferences: {
        backgroundThrottling: false, // âœ… ìµœì†Œí™” ì‹œì—ë„ ë°±ê·¸ë¼ìš´ë“œ ì‘ì—… ê³„ì† ìˆ˜í–‰
        preload: preloadPath,
        nodeIntegration: false,
        contextIsolation: true,
        sandbox: false, // preload ìŠ¤í¬ë¦½íŠ¸ë¥¼ ìœ„í•´ í•„ìš”í•  ìˆ˜ ìˆìŒ
        webSecurity: true,
        allowRunningInsecureContent: false,
      },
      title: 'ë„¤ì´ë²„ ë¸”ë¡œê·¸ ìë™í™”',
      icon: resolveIconImage(),
    });

    // Content Security Policy ì„¤ì • (ê°œë°œ ëª¨ë“œì—ì„œëŠ” ì™„í™”ëœ ì •ì±… ì‚¬ìš©)
    // ì°¸ê³ : ì•±ì´ íŒ¨í‚¤ì§•ë˜ë©´ ì´ ê²½ê³ ëŠ” ë‚˜íƒ€ë‚˜ì§€ ì•ŠìŠµë‹ˆë‹¤
    mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
      // ë¡œì»¬ íŒŒì¼ì— ëŒ€í•´ì„œë§Œ CSP ì ìš©
      if (details.url.startsWith('file://') || details.url.startsWith('http://localhost') || details.url.startsWith('http://127.0.0.1')) {
        callback({
          responseHeaders: {
            ...details.responseHeaders,
            // âœ… CSP ì™„ì „íˆ ê°œë°© - ëª¨ë“  API í˜¸ì¶œ í—ˆìš© (ë°°í¬ í™˜ê²½ì—ì„œë„ ì‘ë™í•˜ë„ë¡)
            'Content-Security-Policy': [
              "default-src 'self'; " +
              "script-src 'self' 'unsafe-inline' 'unsafe-eval'; " +
              "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; " +
              "img-src 'self' data: blob: https: http: file:; " +
              "media-src 'self' data: blob: https: http:; " +
              "font-src 'self' data: https://fonts.gstatic.com; " +
              "connect-src 'self' " +
              // Google (Gemini)
              "https://generativelanguage.googleapis.com https://*.googleapis.com " +
              // LoremFlickr (í´ë°± ì´ë¯¸ì§€)
              "https://loremflickr.com https://*.loremflickr.com " +
              // Picsum (í´ë°± ì´ë¯¸ì§€)
              "https://picsum.photos https://*.picsum.photos " +
              // ë„¤ì´ë²„ (ê²€ìƒ‰, API, ë°ì´í„°ë©)
              "https://openapi.naver.com https://datalab.naver.com https://search.naver.com https://*.naver.com " +
              // Google Apps Script (ë¼ì´ì„ ìŠ¤ ì„œë²„)
              "https://script.google.com https://script.googleusercontent.com " +
              "https://*.google.com https://www.google.com https://dns.google " +
              // ëª¨ë“  HTTPS/HTTP (í´ë°±)
              "https: http: ws: wss:; " +
              "object-src 'none'; " +
              "base-uri 'self'; " +
              "form-action 'self'; " +
              "frame-src 'self' https://blog.naver.com https://*.naver.com;"
            ],
          },
        });
      } else {
        callback({ responseHeaders: details.responseHeaders });
      }
    });

    const htmlPath = path.join(publicPath, 'index.html');
    console.log('[Main] Loading HTML from:', htmlPath);
    await mainWindow.loadFile(htmlPath);
    console.log('[Main] HTML loaded successfully');

    // âœ… [ë¦¬íŒ©í† ë§] ipcHelpersì— mainWindow ì°¸ì¡° ì„¤ì •
    setMainWindowRef(mainWindow);

    // âœ… ì°½ ë‹«ê¸° ì‹œ íŠ¸ë ˆì´ë¡œ ìµœì†Œí™” (ì™„ì „íˆ ì¢…ë£Œí•˜ì§€ ì•ŠìŒ)
    mainWindow.on('close', (event) => {
      if (!(globalThis as any).isQuitting) {
        event.preventDefault();
        mainWindow?.hide();

        // íŠ¸ë ˆì´ ì•Œë¦¼ (ì²˜ìŒ ìˆ¨ê¸¸ ë•Œë§Œ)
        if (tray && !(globalThis as any).trayNotified) {
          tray.displayBalloon({
            title: 'Leaders Pro',
            content: 'ì•±ì´ íŠ¸ë ˆì´ë¡œ ìµœì†Œí™”ë˜ì—ˆìŠµë‹ˆë‹¤. ì•„ì´ì½˜ì„ í´ë¦­í•˜ë©´ ë‹¤ì‹œ ì—´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
          });
          (globalThis as any).trayNotified = true;
        }
      }
    });

    mainWindow.on('closed', () => {
      mainWindow = null;
    });

    mainWindow.on('ready-to-show', () => {
      console.log('[Main] Window ready to show');
      if (mainWindow) {
        mainWindow.show();
      }
    });

    // âœ… ìš°í´ë¦­ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ ì§€ì› (ë³µì‚¬/ë¶™ì—¬ë„£ê¸°/ì˜ë¼ë‚´ê¸°/ì „ì²´ì„ íƒ)
    // ì‹œë‹ˆì–´ ì‚¬ìš©ìë¥¼ ìœ„í•´ ë§ˆìš°ìŠ¤ ìš°í´ë¦­ìœ¼ë¡œ ë³µì‚¬/ë¶™ì—¬ë„£ê¸° ê°€ëŠ¥í•˜ë„ë¡ ì„¤ì •
    mainWindow.webContents.on('context-menu', (_event, params) => {
      const { Menu, MenuItem } = require('electron');
      const menu = new Menu();

      // í…ìŠ¤íŠ¸ ì„ íƒ ì‹œ ë³µì‚¬
      if (params.selectionText) {
        menu.append(new MenuItem({
          label: 'ë³µì‚¬',
          role: 'copy',
          accelerator: 'CmdOrCtrl+C'
        }));
      }

      // ì…ë ¥ í•„ë“œì—ì„œ ë¶™ì—¬ë„£ê¸°/ì˜ë¼ë‚´ê¸°/ì „ì²´ì„ íƒ
      if (params.isEditable) {
        menu.append(new MenuItem({
          label: 'ì˜ë¼ë‚´ê¸°',
          role: 'cut',
          accelerator: 'CmdOrCtrl+X'
        }));
        menu.append(new MenuItem({
          label: 'ë¶™ì—¬ë„£ê¸°',
          role: 'paste',
          accelerator: 'CmdOrCtrl+V'
        }));
        menu.append(new MenuItem({ type: 'separator' }));
        menu.append(new MenuItem({
          label: 'ì „ì²´ ì„ íƒ',
          role: 'selectAll',
          accelerator: 'CmdOrCtrl+A'
        }));
      }

      // ë©”ë‰´ í•­ëª©ì´ ìˆì„ ë•Œë§Œ í‘œì‹œ
      if (menu.items.length > 0) {
        menu.popup({ window: mainWindow! });
      }
    });
    console.log('[Main] ìš°í´ë¦­ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´ í™œì„±í™”ë¨ (ë³µì‚¬/ë¶™ì—¬ë„£ê¸°/ì˜ë¼ë‚´ê¸°/ì „ì²´ì„ íƒ)');
  } catch (error) {
    console.error('[Main] Error creating window:', error);
    throw error;
  }
}

/**
 * ì‹œìŠ¤í…œ íŠ¸ë ˆì´ ìƒì„±
 * - íŠ¸ë ˆì´ ì•„ì´ì½˜ í´ë¦­: ì°½ í‘œì‹œ/ìˆ¨ê¹€ í† ê¸€
 * - ìš°í´ë¦­ ë©”ë‰´: ì°½ ì—´ê¸°, ì•± ì¢…ë£Œ
 */
function createTray(): void {
  if (tray) return; // ì´ë¯¸ ìƒì„±ë¨

  const iconPath = path.join(__dirname, '..', 'assets', 'LEADERNA_.ico');

  try {
    tray = new Tray(iconPath);
    tray.setToolTip('Leaders Pro - ë„¤ì´ë²„ ë¸”ë¡œê·¸ ìë™í™”');

    // íŠ¸ë ˆì´ ì•„ì´ì½˜ í´ë¦­ ì‹œ ì°½ í‘œì‹œ
    tray.on('click', () => {
      if (mainWindow) {
        if (mainWindow.isVisible()) {
          mainWindow.hide();
        } else {
          mainWindow.show();
          mainWindow.focus();
        }
      }
    });

    // ìš°í´ë¦­ ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´
    const contextMenu = Menu.buildFromTemplate([
      {
        label: 'ğŸ“º ì°½ ì—´ê¸°',
        click: () => {
          mainWindow?.show();
          mainWindow?.focus();
        }
      },
      { type: 'separator' },
      {
        label: 'âŒ ì•± ì¢…ë£Œ',
        click: () => {
          (app as any).isQuitting = true;
          app.quit();
        }
      }
    ]);

    tray.setContextMenu(contextMenu);
    console.log('[Main] âœ… ì‹œìŠ¤í…œ íŠ¸ë ˆì´ ìƒì„± ì™„ë£Œ');
  } catch (error) {
    console.warn('[Main] âš ï¸ íŠ¸ë ˆì´ ìƒì„± ì‹¤íŒ¨ (ì•„ì´ì½˜ ì—†ìŒ?):', error);
  }
}

// ============================================
// íŒŒì¼ ì‹œìŠ¤í…œ IPC í•¸ë“¤ëŸ¬
// ============================================
ipcMain.handle('os:homedir', async () => {
  const os = await import('os');
  return os.homedir();
});

// âœ… ì°½ ìµœì†Œí™” IPC í•¸ë“¤ëŸ¬
ipcMain.handle('window:minimize', async () => {
  console.log('[Main] window:minimize í˜¸ì¶œë¨, mainWindow:', !!mainWindow);
  if (mainWindow) {
    mainWindow.minimize();
    console.log('[Main] âœ… ì°½ ìµœì†Œí™” ì™„ë£Œ');
    return { success: true };
  }
  console.log('[Main] âŒ mainWindowê°€ nullì…ë‹ˆë‹¤');
  return { success: false, message: 'ë©”ì¸ ìœˆë„ìš°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.' };
});

ipcMain.handle('shell:openPath', async (_event, targetPath: string) => {
  try {
    const fs = await import('fs/promises');
    const os = await import('os');

    // ê²½ë¡œ ì •ê·œí™”
    let normalizedPath = targetPath.replace(/\\/g, '/');

    // í™ˆ ë””ë ‰í† ë¦¬ ê²½ë¡œ í™•ì¥
    if (normalizedPath.startsWith('~')) {
      normalizedPath = normalizedPath.replace('~', os.homedir());
    }

    // í´ë”ê°€ ì—†ìœ¼ë©´ ìƒì„±
    try {
      await fs.access(normalizedPath);
    } catch {
      await fs.mkdir(normalizedPath, { recursive: true });
    }

    // í´ë” ì—´ê¸°
    const result = await shell.openPath(normalizedPath);

    if (result) {
      return { success: false, message: result };
    }

    return { success: true };
  } catch (error) {
    console.error('[Shell] openPath ì‹¤íŒ¨:', error);
    return { success: false, message: (error as Error).message };
  }
});

// âœ… ì´ì „ê¸€ ëª©ë¡ ê°€ì ¸ì˜¤ê¸° (ë¸”ë¡œê·¸ í¬ìŠ¤íŠ¸ ëª©ë¡ í¬ë¡¤ë§)
ipcMain.handle('blog:getRecentPosts', async (_event, blogId: string) => {
  try {
    if (!blogId || !blogId.trim()) {
      return { success: false, message: 'ë¸”ë¡œê·¸ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.' };
    }

    const puppeteer = await import('puppeteer-extra');
    const StealthPlugin = await import('puppeteer-extra-plugin-stealth');
    const puppeteerWithStealth = puppeteer.default as any;
    puppeteerWithStealth.use((StealthPlugin as any).default());

    const browser = await puppeteerWithStealth.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-gpu'],
    });

    try {
      const page = await browser.newPage();
      await page.setViewport({ width: 1280, height: 800 });

      // ë¸”ë¡œê·¸ í¬ìŠ¤íŠ¸ ëª©ë¡ í˜ì´ì§€ ì ‘ê·¼
      const postListUrl = `https://blog.naver.com/PostList.naver?blogId=${blogId.trim()}&categoryNo=0&from=postList`;
      await page.goto(postListUrl, { waitUntil: 'networkidle2', timeout: 15000 });

      // iframe ë‚´ë¶€ì—ì„œ í¬ìŠ¤íŠ¸ ëª©ë¡ ì¶”ì¶œ
      const posts = await page.evaluate((bid: string) => {
        const results: Array<{ title: string; url: string; date?: string }> = [];

        // ë°©ë²• 1: ì§ì ‘ DOMì—ì„œ ì°¾ê¸°
        const postItems = document.querySelectorAll('.blog2_post, .post-item, .sect_item, [class*="post"]');
        postItems.forEach((item) => {
          const titleEl = item.querySelector('.title, .se-title, .se-text-paragraph, a[title]');
          const linkEl = item.querySelector('a[href*="PostView"], a[href*="logNo"]') as HTMLAnchorElement;
          const dateEl = item.querySelector('.date, .se-date, [class*="date"]');

          if (titleEl && linkEl) {
            const title = titleEl.textContent?.trim() || '';
            const url = linkEl.href || '';
            const date = dateEl?.textContent?.trim() || '';
            if (title && url) {
              results.push({ title, url, date });
            }
          }
        });

        // ë°©ë²• 2: ì¼ë°˜ì ì¸ ë§í¬ì—ì„œ ì°¾ê¸°
        if (results.length === 0) {
          const links = document.querySelectorAll(`a[href*="blog.naver.com/${bid}"]`) as NodeListOf<HTMLAnchorElement>;
          links.forEach((link) => {
            const href = link.href || '';
            if (href.includes('logNo=') || href.includes('PostView')) {
              const title = link.textContent?.trim() || link.title || '';
              if (title && title.length > 3 && !results.some(r => r.url === href)) {
                results.push({ title, url: href });
              }
            }
          });
        }

        return results.slice(0, 20); // ìµœëŒ€ 20ê°œ
      }, blogId.trim());

      await browser.close();

      if (posts.length === 0) {
        return { success: true, posts: [], message: 'í¬ìŠ¤íŒ…ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.' };
      }

      return { success: true, posts };
    } catch (error) {
      await browser.close();
      throw error;
    }
  } catch (error) {
    console.error('[Main] getRecentPosts ì‹¤íŒ¨:', error);
    return { success: false, message: `í¬ìŠ¤íŒ… ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('free:activate', async () => {
  return await activateFreeTier();
});

ipcMain.handle('app:forceQuit', async () => {
  try {
    setTimeout(() => {
      try {
        app.quit();
      } finally {
        process.exit(0);
      }
    }, 200);
  } catch {
  }
  return { success: true };
});

ipcMain.handle('quota:getStatus', async () => {
  const isFree = await isFreeTierUser();
  const quota = await getFreeQuotaStatus();
  return { success: true, isFree, quota };
});

// ì†Œì œëª© ì˜ìƒ ê´€ë¦¬ IPC í•¸ë“¤ëŸ¬
ipcMain.handle('heading:applyVideo', async (_event, heading: string, video: HeadingVideoRecord): Promise<{ success: boolean; message?: string }> => {
  // âœ… [ë¦¬íŒ©í† ë§] í†µí•© ê²€ì¦
  const check = await validateLicenseOnly();
  if (!check.valid) return check.response;

  try {
    if (!heading || !heading.trim()) {
      return { success: false, message: 'ì†Œì œëª©ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.' };
    }
    if (!video || !video.filePath) {
      return { success: false, message: 'ì˜ìƒ ì •ë³´ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.' };
    }

    const key = heading.trim();
    const current = headingVideosStore.get(key) || [];
    const nextRecord: HeadingVideoRecord = {
      provider: video.provider,
      filePath: video.filePath,
      previewDataUrl: video.previewDataUrl,
      updatedAt: video.updatedAt || Date.now(),
    };

    // âœ… ìµœì‹  ë°°ì¹˜ê°€ í•­ìƒ 0ë²ˆì— ì˜¤ë„ë¡(í”„ë¡ íŠ¸ê°€ videos[0]ì„ ì‚¬ìš©)
    const deduped = current.filter((v) => String(v?.filePath || '') !== String(nextRecord.filePath || ''));
    deduped.unshift(nextRecord);
    deduped.sort((a, b) => Number(b?.updatedAt || 0) - Number(a?.updatedAt || 0));
    headingVideosStore.set(key, deduped);

    await saveHeadingVideosStore();
    console.log(`[Main] ì†Œì œëª© "${heading}"ì— ì˜ìƒ ì ìš© ì™„ë£Œ`);
    return { success: true };
  } catch (error) {
    console.error('[Main] ì†Œì œëª© ì˜ìƒ ì ìš© ì‹¤íŒ¨:', error);
    return { success: false, message: (error as Error).message };
  }
});

ipcMain.handle('heading:getAppliedVideo', async (_event, heading: string): Promise<{ success: boolean; video?: HeadingVideoRecord; message?: string }> => {
  try {
    if (!heading || !heading.trim()) {
      return { success: false, message: 'ì†Œì œëª©ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.' };
    }

    const videos = headingVideosStore.get(heading.trim()) || [];
    // âœ… í•˜ìœ„í˜¸í™˜: ê¸°ì¡´ UIëŠ” ë‹¨ì¼ videoë§Œ ê¸°ëŒ€
    return { success: true, video: videos[0] };
  } catch (error) {
    console.error('[Main] ì†Œì œëª© ì˜ìƒ ì¡°íšŒ ì‹¤íŒ¨:', error);
    return { success: false, message: (error as Error).message };
  }
});

ipcMain.handle('heading:getAppliedVideos', async (_event, heading: string): Promise<{ success: boolean; videos?: HeadingVideoRecord[]; message?: string }> => {
  try {
    if (!heading || !heading.trim()) {
      return { success: false, message: 'ì†Œì œëª©ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.' };
    }

    const videos = headingVideosStore.get(heading.trim()) || [];
    return { success: true, videos };
  } catch (error) {
    console.error('[Main] ì†Œì œëª© ì˜ìƒ ëª©ë¡ ì¡°íšŒ ì‹¤íŒ¨:', error);
    return { success: false, message: (error as Error).message };
  }
});

ipcMain.handle('heading:removeVideo', async (_event, heading: string): Promise<{ success: boolean; message?: string }> => {
  try {
    if (!heading || !heading.trim()) {
      return { success: false, message: 'ì†Œì œëª©ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.' };
    }

    const deleted = headingVideosStore.delete(heading.trim());
    if (deleted) {
      await saveHeadingVideosStore();
      console.log(`[Main] ì†Œì œëª© "${heading}"ì˜ ì˜ìƒ ì œê±° ì™„ë£Œ`);
    }

    return { success: true };
  } catch (error) {
    console.error('[Main] ì†Œì œëª© ì˜ìƒ ì œê±° ì‹¤íŒ¨:', error);
    return { success: false, message: (error as Error).message };
  }
});

ipcMain.handle('heading:getAllAppliedVideos', async (): Promise<{ success: boolean; videos?: Record<string, HeadingVideoRecord[]>; message?: string }> => {
  try {
    const videos = Object.fromEntries(headingVideosStore);
    return { success: true, videos };
  } catch (error) {
    console.error('[Main] ëª¨ë“  ì†Œì œëª© ì˜ìƒ ì¡°íšŒ ì‹¤íŒ¨:', error);
    return { success: false, message: (error as Error).message };
  }
});

ipcMain.handle('media:listMp4Files', async (_event, payload: { dirPath: string }) => {
  try {
    const dirPath = payload?.dirPath;
    if (!dirPath) return { success: false, message: 'dirPathê°€ í•„ìš”í•©ë‹ˆë‹¤.' };

    await fs.mkdir(dirPath, { recursive: true });

    const items = await fs.readdir(dirPath, { withFileTypes: true });
    const allFiles: Array<{ name: string; fullPath: string; mtime: number; size: number }> = [];

    // 1) ë£¨íŠ¸ mp4 í´ë”ì˜ mp4
    for (const item of items) {
      if (item.isFile() && item.name.toLowerCase().endsWith('.mp4')) {
        const fullPath = path.join(dirPath, item.name);
        const stat = await fs.stat(fullPath);
        allFiles.push({ name: item.name, fullPath, mtime: stat.mtime.getTime(), size: stat.size });
      }
    }

    // 2) mp4/<heading>/ í•˜ìœ„ 1ë‹¨ê³„ í´ë”ì˜ mp4
    for (const item of items) {
      if (!item.isDirectory()) continue;
      const subDir = path.join(dirPath, item.name);
      let subItems: import('fs').Dirent[] = [];
      try {
        subItems = await fs.readdir(subDir, { withFileTypes: true });
      } catch {
        continue;
      }
      for (const sub of subItems) {
        if (sub.isFile() && sub.name.toLowerCase().endsWith('.mp4')) {
          const fullPath = path.join(subDir, sub.name);
          const stat = await fs.stat(fullPath);
          allFiles.push({ name: `${item.name}/${sub.name}`, fullPath, mtime: stat.mtime.getTime(), size: stat.size });
        }
      }
    }

    allFiles.sort((a, b) => b.mtime - a.mtime);
    return { success: true, files: allFiles };
  } catch (error) {
    console.error('[Media] listMp4Files ì‹¤íŒ¨:', error);
    return { success: false, message: (error as Error).message };
  }
});

ipcMain.handle('media:convertMp4ToGif', async (_event, payload: { sourcePath: string; aspectRatio?: string }) => {
  try {
    const sourcePath = payload?.sourcePath;
    if (!sourcePath) {
      return { success: false, message: 'sourcePathê°€ í•„ìš”í•©ë‹ˆë‹¤.' };
    }

    const pathModule = await import('path');
    const normalizedSource = sourcePath.replace(/\\/g, '/');
    const dir = pathModule.dirname(normalizedSource);
    const baseName = pathModule.basename(normalizedSource, pathModule.extname(normalizedSource));
    const gifPath = pathModule.join(dir, `${baseName}.gif`);

    // ì´ë¯¸ GIFê°€ ì¡´ì¬í•˜ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©
    try {
      const fs = await import('fs/promises');
      const stat = await fs.stat(gifPath);
      if (stat.isFile() && stat.size > 1024) {
        return { success: true, gifPath };
      }
      try { await fs.unlink(gifPath); } catch { }
    } catch { }

    // âœ… í—¬í¼ í•¨ìˆ˜ ì‚¬ìš© (ì¤‘ë³µ ë¡œì§ ì œê±° ë° 1:1 í¬ë¡­ ì ìš©)
    // 720px ë„ˆë¹„ ê¸°ì¤€
    const finalGifPath = await convertMp4ToGif(normalizedSource, {
      width: 720,
      fps: 20,
      aspectRatio: payload.aspectRatio
    });

    return { success: true, gifPath: finalGifPath };
  } catch (error) {
    console.error('[Media] convertMp4ToGif ì‹¤íŒ¨:', error);
    return { success: false, message: (error as Error).message };
  }
});

ipcMain.handle('media:createKenBurnsVideo', async (_event, payload: { imagePath: string; heading?: string; durationSeconds?: number; aspectRatio?: '16:9' | '9:16' | '1:1' | 'original' }) => {
  // âœ… [ë¦¬íŒ©í† ë§] í†µí•© ê²€ì¦
  const check = await validateLicenseAndQuota('media', 1);
  if (!check.valid) return check.response;

  try {
    const rawPath = String(payload?.imagePath || '').trim();
    if (!rawPath) {
      return { success: false, message: 'imagePathê°€ í•„ìš”í•©ë‹ˆë‹¤.' };
    }

    const durationSeconds = payload?.durationSeconds && payload.durationSeconds > 0 ? payload.durationSeconds : 6;
    const aspectRatio = payload?.aspectRatio || '1:1';
    const headingForSave = sanitizeFileName(String(payload?.heading || '').trim()) || 'AI-VIDEO';

    const ffmpegModule = await import('ffmpeg-static');
    const ffmpegPath = (ffmpegModule as any).default || (ffmpegModule as any);
    if (!ffmpegPath) {
      return { success: false, message: 'ffmpeg ì‹¤í–‰ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.' };
    }

    const { spawn } = await import('child_process');

    const isPortrait = aspectRatio === '9:16';
    const isSquare = aspectRatio === '1:1';
    const isOriginal = aspectRatio === 'original';

    let outW = 1280;
    let outH = 720;

    if (isSquare) {
      outW = 720;
      outH = 720;
    } else if (isPortrait) {
      outW = 720;
      outH = 1280;
    }

    const fps = 30;
    const frames = Math.max(30, Math.round(durationSeconds * fps));

    let filter = '';
    if (isOriginal) {
      // ì›ë³¸ ë¹„ìœ¨ ìœ ì§€ (ì§ìˆ˜ í¬ê¸° ë³´ì •ë§Œ ìˆ˜í–‰)
      filter = [
        `scale=trunc(iw/2)*2:trunc(ih/2)*2`,
        `zoompan=z='if(eq(on,0),1.0,min(zoom+0.0015,1.08))':x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)':d=${frames}:s=hd720:fps=${fps}`,
        'format=yuv420p'
      ].join(',');
    } else {
      filter = [
        `scale=${outW}:${outH}:force_original_aspect_ratio=increase`,
        `crop=${outW}:${outH}`,
        `zoompan=z='if(eq(on,0),1.0,min(zoom+0.0015,1.08))':x='iw/2-(iw/zoom/2)':y='ih/2-(ih/zoom/2)':d=${frames}:s=${outW}x${outH}:fps=${fps}`,
        'format=yuv420p',
      ].join(',');
    }

    const mp4Dir = await ensureHeadingMp4Dir(headingForSave);
    const { fullPath: outPath, fileName } = await getUniqueMp4Path(mp4Dir, headingForSave);

    await new Promise<void>((resolve, reject) => {
      const args = [
        '-y',
        '-loop',
        '1',
        '-t',
        String(durationSeconds),
        '-i',
        rawPath,
        '-vf',
        filter,
        '-an',
        '-movflags',
        '+faststart',
        '-pix_fmt',
        'yuv420p',
        outPath,
      ];

      const proc = spawn(ffmpegPath as string, args, { windowsHide: true });
      proc.on('error', (err) => reject(err));
      proc.on('close', (code) => {
        if (code === 0) resolve();
        else reject(new Error(`ffmpeg exited with code ${code}`));
      });
    });

    if (await isFreeTierUser()) {
      await consumeQuota('media', 1);
    }

    return { success: true, filePath: outPath, fileName };
  } catch (error) {
    console.error('[Media] createKenBurnsVideo ì‹¤íŒ¨:', error);
    return { success: false, message: (error as Error).message };
  }
});

ipcMain.handle('file:checkExists', async (_event, filePath: string) => {
  try {
    const fs = await import('fs/promises');
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
});

ipcMain.handle('file:readDir', async (_event, dirPath: string) => {
  try {
    const fs = await import('fs/promises');
    return await fs.readdir(dirPath);
  } catch (error) {
    console.error('[File] readDir ì‹¤íŒ¨:', error);
    return [];
  }
});

ipcMain.handle('file:deleteFolder', async (_event, folderPath: string) => {
  try {
    const fs = await import('fs/promises');
    await fs.rm(folderPath, { recursive: true, force: true });
    return true;
  } catch {
    return false;
  }
});

ipcMain.handle('file:deleteFile', async (_event, filePath: string) => {
  try {
    const fs = await import('fs/promises');
    await fs.rm(filePath, { force: true });
    return { success: true };
  } catch (error) {
    return { success: false, message: (error as Error).message };
  }
});

// âœ… ëˆ„ë½ëœ í•¸ë“¤ëŸ¬ë“¤ ì¶”ê°€

// í´ë” ì½ê¸° (ìƒì„¸ ì •ë³´ í¬í•¨)
ipcMain.handle('file:readDirWithStats', async (_event, dirPath: string) => {
  try {
    const items = await fs.readdir(dirPath, { withFileTypes: true });
    const results = await Promise.all(items.map(async (item) => {
      const fullPath = path.join(dirPath, item.name);
      try {
        const stats = await fs.stat(fullPath);
        return {
          name: item.name,
          isFile: item.isFile(),
          isDirectory: item.isDirectory(),
          size: stats.size,
          mtime: stats.mtime.getTime(),
          birthtime: stats.birthtime.getTime(),
          ctime: stats.ctime.getTime(),
        };
      } catch {
        return {
          name: item.name,
          isFile: item.isFile(),
          isDirectory: item.isDirectory(),
          size: 0,
          mtime: 0,
          birthtime: 0,
          ctime: 0,
        };
      }
    }));
    return results;
  } catch (error) {
    console.error('[File] readDirWithStats ì‹¤íŒ¨:', error);
    return [];
  }
});

// íŒŒì¼/í´ë” ì •ë³´ ê°€ì ¸ì˜¤ê¸°
ipcMain.handle('file:getStats', async (_event, filePath: string) => {
  try {
    const stats = await fs.stat(filePath);
    return {
      isFile: stats.isFile(),
      isDirectory: stats.isDirectory(),
      size: stats.size,
      mtime: stats.mtime.getTime(),
      birthtime: stats.birthtime.getTime(),
      ctime: stats.ctime.getTime(),
    };
  } catch {
    return null;
  }
});

// âœ… íŠœí† ë¦¬ì–¼ ì˜ìƒ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
ipcMain.handle('tutorials:getVideos', async () => {
  console.log('[Main] tutorials:getVideos í•¸ë“¤ëŸ¬ ì‹œì‘');
  try {
    const config = await loadConfig();
    console.log('[Main] tutorials:getVideos config ë¡œë“œ ì™„ë£Œ');
    const videos = (config as any).tutorialVideos || [];
    console.log('[Main] tutorials:getVideos ì˜ìƒ ìˆ˜:', videos.length);
    return videos;
  } catch (error) {
    console.error('[Main] tutorials:getVideos ì˜¤ë¥˜:', error);
    return [];
  }
});

// ì˜ìƒ íŒŒì¼ ì„ íƒ ë‹¤ì´ì–¼ë¡œê·¸
ipcMain.handle('dialog:selectVideoFile', async () => {
  if (!mainWindow) return null;
  const result = await dialog.showOpenDialog(mainWindow, {
    title: 'ì˜ìƒ íŒŒì¼ ì„ íƒ',
    filters: [
      { name: 'ë™ì˜ìƒ', extensions: ['mp4', 'avi', 'mov', 'mkv', 'webm'] },
      { name: 'ëª¨ë“  íŒŒì¼', extensions: ['*'] },
    ],
    properties: ['openFile'],
  });
  if (result.canceled || result.filePaths.length === 0) return null;
  return { filePath: result.filePaths[0] };
});

// âœ… í´ë” ì„ íƒ ë‹¤ì´ì–¼ë¡œê·¸ (ì´ë¯¸ì§€ ì €ì¥ ê²½ë¡œ ì„¤ì •ìš©) - ì´ˆê¸°í™” ì‹œ ë°”ë¡œ ë“±ë¡
ipcMain.handle('dialog:showOpenDialog', async (_event, options) => {
  try {
    if (!mainWindow) {
      console.error('[Dialog] mainWindowê°€ ì—†ìŠµë‹ˆë‹¤');
      return { canceled: true, filePaths: [] };
    }

    const result = await dialog.showOpenDialog(mainWindow, options);
    return result;
  } catch (error) {
    console.error('í´ë” ì„ íƒ ë‹¤ì´ì–¼ë¡œê·¸ ì˜¤ë¥˜:', error);
    return { canceled: true, filePaths: [] };
  }
});

// ì´ë¯¸ì§€ í´ë” ì—´ê¸°
ipcMain.handle('openImagesFolder', async () => {
  try {
    const imagesPath = path.join(app.getPath('userData'), 'images');
    await fs.mkdir(imagesPath, { recursive: true });
    await shell.openPath(imagesPath);
    return { success: true, path: imagesPath };
  } catch (error) {
    return { success: false, message: (error as Error).message };
  }
});

// ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ë° ì €ì¥
ipcMain.handle('image:downloadAndSave', async (_event, imageUrl: string, heading: string, postTitle?: string, postId?: string) => {
  try {
    const https = await import('https');
    const http = await import('http');
    const { URL, fileURLToPath } = await import('url');

    let buffer: Buffer;
    let ext = '.jpg';

    const trimmedUrl = String(imageUrl || '').trim();
    if (!trimmedUrl) {
      return { success: false, message: 'imageUrlì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.' };
    }

    // 1) data: URL ì§€ì› (AI ìƒì„± ì´ë¯¸ì§€ê°€ dataURLë¡œ ì˜¤ëŠ” ê²½ìš°)
    if (/^data:/i.test(trimmedUrl)) {
      const m = trimmedUrl.match(/^data:(image\/[a-zA-Z0-9.+-]+);base64,(.*)$/);
      if (!m) {
        return { success: false, message: 'ì§€ì›í•˜ì§€ ì•ŠëŠ” data URL í˜•ì‹ì…ë‹ˆë‹¤.' };
      }
      const mime = m[1].toLowerCase();
      const base64 = m[2];
      buffer = Buffer.from(base64, 'base64');

      if (mime.includes('png')) ext = '.png';
      else if (mime.includes('jpeg')) ext = '.jpeg';
      else if (mime.includes('jpg')) ext = '.jpg';
      else if (mime.includes('webp')) ext = '.webp';
      else if (mime.includes('gif')) ext = '.gif';
      else ext = '.png';
    } else {
      const parsedUrl = new URL(trimmedUrl);

      // 2) file: URL ì§€ì›
      if (parsedUrl.protocol === 'file:') {
        const localFilePath = fileURLToPath(parsedUrl);
        buffer = await fs.readFile(localFilePath);
        ext = path.extname(localFilePath) || '.jpg';
      } else {
        // 3) http(s) ë‹¤ìš´ë¡œë“œ
        const client = parsedUrl.protocol === 'https:' ? https : http;
        buffer = await new Promise<Buffer>((resolve, reject) => {
          client.get(trimmedUrl, { timeout: 30000 }, (response: any) => {
            const chunks: Buffer[] = [];
            response.on('data', (chunk: Buffer) => chunks.push(chunk));
            response.on('end', () => resolve(Buffer.concat(chunks)));
            response.on('error', reject);
          }).on('error', reject);
        });
        ext = path.extname(parsedUrl.pathname) || '.jpg';
      }
    }

    const safeTitle = (postTitle || 'image').replace(/[<>:"/\\|?*]/g, '_');
    const safeHeading = (heading || 'image').replace(/[<>:"/\\|?*]/g, '_');
    const fileName = `${safeTitle}_${safeHeading}_${Date.now()}${ext}`;
    const imagesPath = path.join(app.getPath('userData'), 'images');
    await fs.mkdir(imagesPath, { recursive: true });
    const filePath = path.join(imagesPath, fileName);

    await fs.writeFile(filePath, buffer);
    const previewDataUrl = `data:image/${ext.slice(1)};base64,${buffer.toString('base64')}`;

    return { success: true, filePath, previewDataUrl, savedToLocal: filePath };
  } catch (error) {
    console.error('[Main] ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨:', error);
    return { success: false, message: (error as Error).message };
  }
});

// URLì—ì„œ ì´ë¯¸ì§€ ìˆ˜ì§‘
ipcMain.handle('image:collectFromUrl', async (_event, url: string) => {
  // âœ… [ë¦¬íŒ©í† ë§] í†µí•© ê²€ì¦
  const check = await validateLicenseAndQuota('media', 1);
  if (!check.valid) return check.response;

  try {
    // ê°„ë‹¨í•œ ì´ë¯¸ì§€ URL ì¶”ì¶œ (Puppeteer ì—†ì´)
    const https = await import('https');
    const http = await import('http');
    const { URL } = await import('url');

    const parsedUrl = new URL(url);
    const client = parsedUrl.protocol === 'https:' ? https : http;

    const html = await new Promise<string>((resolve, reject) => {
      client.get(url, { timeout: 30000 }, (response: any) => {
        let data = '';
        response.on('data', (chunk: string) => data += chunk);
        response.on('end', () => resolve(data));
        response.on('error', reject);
      }).on('error', reject);
    });

    // ì´ë¯¸ì§€ URL ì¶”ì¶œ
    const imgRegex = /<img[^>]+src=["']([^"']+)["']/gi;
    const images: string[] = [];
    let match;
    while ((match = imgRegex.exec(html)) !== null) {
      const imgUrl = match[1];
      if (imgUrl.startsWith('http') && /\.(jpg|jpeg|png|gif|webp)/i.test(imgUrl)) {
        images.push(imgUrl);
      }
    }

    const result = { success: true, images: images.slice(0, 20) };
    if (result.success && (result.images?.length ?? 0) > 0 && (await isFreeTierUser())) {
      await consumeQuota('media', 1);
    }
    return result;
  } catch (error) {
    console.error('[Main] URL ì´ë¯¸ì§€ ìˆ˜ì§‘ ì‹¤íŒ¨:', error);
    return { success: false, message: (error as Error).message };
  }
});

// ì‡¼í•‘ëª°ì—ì„œ ì´ë¯¸ì§€ ìˆ˜ì§‘ (ìµœì í™”ëœ ëª¨ë°”ì¼ API + Puppeteer í´ë°±)
ipcMain.handle('image:collectFromShopping', async (_event, url: string) => {
  // âœ… [ë¦¬íŒ©í† ë§] í†µí•© ê²€ì¦
  const check = await validateLicenseAndQuota('media', 1);
  if (!check.valid) return check.response;

  try {
    console.log('[Main] ì‡¼í•‘ëª° ì´ë¯¸ì§€ ìˆ˜ì§‘ ì‹œì‘:', url);

    // âœ… ìŠ¤ë§ˆíŠ¸ìŠ¤í† ì–´/ë¸Œëœë“œìŠ¤í† ì–´/ì œíœ´ë§í¬ ê°ì§€ â†’ ëª¨ë°”ì¼ API ì‚¬ìš© (ë¹ ë¦„!)
    const isSmartStore = /smartstore\.naver\.com|brand\.naver\.com|coupa\.ng|link\.coupang\.com/i.test(url);

    if (isSmartStore) {
      console.log('[Main] ğŸš€ ìŠ¤ë§ˆíŠ¸ìŠ¤í† ì–´ ê°ì§€ â†’ ëª¨ë°”ì¼ APIë¡œ ë¹ ë¥¸ ìˆ˜ì§‘ ì‹œì‘');

      const { crawlFromAffiliateLink } = await import('./crawler/productSpecCrawler.js');
      const result = await crawlFromAffiliateLink(url);

      if (result) {
        // ì´ë¯¸ì§€ í†µí•© (ëŒ€í‘œ + ê°¤ëŸ¬ë¦¬ + ìƒì„¸)
        const allImages: string[] = [];
        if (result.mainImage) allImages.push(result.mainImage);
        allImages.push(...(result.galleryImages || []));
        allImages.push(...(result.detailImages || []).slice(0, 10)); // ìƒì„¸ëŠ” ìµœëŒ€ 10ê°œ

        console.log(`[Main] ğŸ“¦ ëª¨ë°”ì¼ API ìˆ˜ì§‘ ê²°ê³¼: ${allImages.length}ê°œ ì´ë¯¸ì§€`);

        // âœ… [í•µì‹¬] ì´ë¯¸ì§€ê°€ 3ê°œ ë¯¸ë§Œì´ë©´ ë„¤ì´ë²„ ê²€ìƒ‰ APIë¡œ ë³´ì¶©
        if (allImages.length < 3 && result.name) {
          console.log('[Main] âš ï¸ ìˆ˜ì§‘ëœ ì´ë¯¸ì§€ ë¶€ì¡± â†’ ë„¤ì´ë²„ ê²€ìƒ‰ APIë¡œ ë³´ì¶© ì‹œë„');
          try {
            const config = await loadConfig();
            const naverClientId = config.naverClientId || config.naverDatalabClientId || process.env.NAVER_CLIENT_ID || '';
            const naverClientSecret = config.naverClientSecret || config.naverDatalabClientSecret || process.env.NAVER_CLIENT_SECRET || '';

            if (naverClientId && naverClientSecret) {
              const { fetchShoppingImages } = await import('./sourceAssembler.js');
              const naverResult = await fetchShoppingImages(url, {
                imagesOnly: true,
                naverClientId,
                naverClientSecret,
              });

              if (naverResult.images && naverResult.images.length > 0) {
                // ì¤‘ë³µ ì œê±°í•˜ë©° ì¶”ê°€
                naverResult.images.forEach((img: string) => {
                  if (!allImages.includes(img)) {
                    allImages.push(img);
                  }
                });
                console.log(`[Main] âœ… ë„¤ì´ë²„ API ë³´ì¶© ì™„ë£Œ: ì´ ${allImages.length}ê°œ ì´ë¯¸ì§€`);
              }
            }
          } catch (naverErr) {
            console.warn('[Main] ë„¤ì´ë²„ API ë³´ì¶© ì‹¤íŒ¨:', (naverErr as Error).message);
          }
        }

        console.log(`[Main] âœ… ìµœì¢… ìˆ˜ì§‘ ì™„ë£Œ: ${allImages.length}ê°œ ì´ë¯¸ì§€`);

        const response = {
          success: true,
          images: allImages,
          title: result.name,
          // âœ… ì¶”ê°€ ì •ë³´ë„ í•¨ê»˜ ë°˜í™˜
          productInfo: {
            name: result.name,
            price: result.price,
            stock: result.stock,
            options: result.options,
            detailUrl: result.detailUrl
          }
        };

        if (allImages.length > 0 && (await isFreeTierUser())) {
          await consumeQuota('media', 1);
        }
        return response;
      }

      console.log('[Main] âš ï¸ ëª¨ë°”ì¼ API ì‹¤íŒ¨ â†’ Puppeteer í´ë°±');
    }

    // âœ… ê¸°ì¡´ ë°©ì‹ í´ë°± (ì¿ íŒ¡, 11ë²ˆê°€, Gë§ˆì¼“ ë“±)
    const config = await loadConfig();
    const naverClientId = config.naverClientId || config.naverDatalabClientId || process.env.NAVER_CLIENT_ID || '';
    const naverClientSecret = config.naverClientSecret || config.naverDatalabClientSecret || process.env.NAVER_CLIENT_SECRET || '';
    console.log('[Main] ì‡¼í•‘ëª° ìˆ˜ì§‘ (Puppeteer ë°©ì‹)');

    const { fetchShoppingImages } = await import('./sourceAssembler.js');
    const result = await fetchShoppingImages(url, {
      imagesOnly: true,
      naverClientId,
      naverClientSecret,
    });

    const images = result.images || [];
    const title = result.title || '';

    console.log(`[Main] ì‡¼í•‘ëª° ì´ë¯¸ì§€ ìˆ˜ì§‘ ì™„ë£Œ: ${images.length}ê°œ`);

    const response = { success: true, images, title };
    if ((response.images?.length ?? 0) > 0 && (await isFreeTierUser())) {
      await consumeQuota('media', 1);
    }
    return response;
  } catch (error) {
    console.error('[Main] ì‡¼í•‘ëª° ì´ë¯¸ì§€ ìˆ˜ì§‘ ì‹¤íŒ¨:', error);
    return { success: false, message: (error as Error).message };
  }
});

// ë‹¤ì¤‘ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ë° ì €ì¥
ipcMain.handle('image:downloadAndSaveMultiple', async (_event, images: Array<{ url: string; heading: string }>, title: string) => {
  // âœ… [ë¦¬íŒ©í† ë§] í†µí•© ê²€ì¦
  const check = await validateLicenseAndQuota('media', 1);
  if (!check.valid) return check.response;

  try {
    const https = await import('https');
    const http = await import('http');
    const { URL } = await import('url');
    const os = await import('os');

    const savedImages: any[] = [];
    const safeTitle = title.replace(/[<>:"/\\|?*]/g, '_');

    // âœ… ì„¤ì •ëœ ì´ë¯¸ì§€ ì €ì¥ ê²½ë¡œ ì‚¬ìš©
    let basePath = path.join(os.homedir(), 'Downloads', 'naver-blog-images');
    try {
      const config = await loadConfig();
      if (config.customImageSavePath && config.customImageSavePath.trim() !== '') {
        basePath = config.customImageSavePath;
      }
    } catch { /* ê¸°ë³¸ ê²½ë¡œ ì‚¬ìš© */ }

    const imagesPath = path.join(basePath, safeTitle);
    await fs.mkdir(imagesPath, { recursive: true });
    console.log(`[Main] ì´ë¯¸ì§€ ì €ì¥ ê²½ë¡œ: ${imagesPath}`);

    for (let i = 0; i < images.length; i++) {
      const img = images[i];
      try {
        const parsedUrl = new URL(img.url);
        const client = parsedUrl.protocol === 'https:' ? https : http;

        const buffer = await new Promise<Buffer>((resolve, reject) => {
          client.get(img.url, { timeout: 30000 }, (response: any) => {
            const chunks: Buffer[] = [];
            response.on('data', (chunk: Buffer) => chunks.push(chunk));
            response.on('end', () => resolve(Buffer.concat(chunks)));
            response.on('error', reject);
          }).on('error', reject);
        });

        const ext = path.extname(parsedUrl.pathname) || '.jpg';
        const fileName = `${i + 1}_${img.heading.replace(/[<>:"/\\|?*]/g, '_')}${ext}`;
        const filePath = path.join(imagesPath, fileName);
        await fs.writeFile(filePath, buffer);

        savedImages.push({ filePath, heading: img.heading });
      } catch (e) {
        console.warn(`[Main] ì´ë¯¸ì§€ ${i + 1} ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨:`, e);
      }
    }

    const response = { success: true, savedImages, folderPath: imagesPath };
    if ((response.savedImages?.length ?? 0) > 0 && (await isFreeTierUser())) {
      await consumeQuota('media', 1);
    }
    return response;
  } catch (error) {
    console.error('[Main] ë‹¤ì¤‘ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨:', error);
    return { success: false, error: (error as Error).message };
  }
});

// âœ… ë¹„êµí‘œ ì´ë¯¸ì§€ ìƒì„±
ipcMain.handle('image:generateComparisonTable', async (_event, options: {
  title?: string;
  products: Array<{
    name: string;
    price?: string;
    rating?: string;
    pros?: string[];
    cons?: string[];
    specs?: Record<string, string>;
    isRecommended?: boolean;
  }>;
  theme?: 'light' | 'dark' | 'gradient';
  accentColor?: string;
  width?: number;
  showRanking?: boolean;
}) => {
  try {
    console.log('[Main] ë¹„êµí‘œ ì´ë¯¸ì§€ ìƒì„± ìš”ì²­:', options.title, options.products?.length);
    const { generateComparisonTableImage } = await import('./image/comparisonTableGenerator.js');

    const result = await generateComparisonTableImage(options);

    if (result.success) {
      console.log('[Main] ë¹„êµí‘œ ì´ë¯¸ì§€ ìƒì„± ì™„ë£Œ:', result.imagePath);
    } else {
      console.error('[Main] ë¹„êµí‘œ ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨:', result.error);
    }

    return result;
  } catch (error) {
    console.error('[Main] ë¹„êµí‘œ ì´ë¯¸ì§€ ìƒì„± ì˜¤ë¥˜:', error);
    return { success: false, error: (error as Error).message };
  }
});

// í”Œë«í¼ì—ì„œ ì½˜í…ì¸  ìˆ˜ì§‘ (ì‹¤ì‹œê°„ ì •ë³´)
ipcMain.handle('content:collectFromPlatforms', async (_event, keyword: string, options?: { maxPerSource?: number; targetDate?: string }) => {
  try {
    const { collectContentFromPlatforms } = await import('./sourceAssembler.js');
    const config = await loadConfig();
    const result = await collectContentFromPlatforms(keyword, {
      maxPerSource: options?.maxPerSource || 5,
      clientId: config.naverDatalabClientId,
      clientSecret: config.naverDatalabClientSecret,
      logger: (msg) => console.log(msg),
      targetDate: options?.targetDate, // âœ… ë°œí–‰ ë‚ ì§œ ì „ë‹¬
    });
    return result;
  } catch (error) {
    console.error('[Main] í”Œë«í¼ ì½˜í…ì¸  ìˆ˜ì§‘ ì‹¤íŒ¨:', error);
    return { success: false, message: (error as Error).message };
  }
});

// ì €ì¥ëœ ì´ë¯¸ì§€ ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°
ipcMain.handle('images:getSavedPath', async () => {
  return path.join(app.getPath('userData'), 'images');
});

// ì €ì¥ëœ ì´ë¯¸ì§€ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
ipcMain.handle('images:getSaved', async (_event, dirPath: string) => {
  try {
    const files = await fs.readdir(dirPath);
    const imageFiles = files.filter(f => /\.(jpg|jpeg|png|gif|webp)$/i.test(f));
    const images = imageFiles.map(f => path.join(dirPath, f));
    return { success: true, images };
  } catch (error) {
    return { success: false, message: (error as Error).message };
  }
});

// ì•± ì •ë³´ ê°€ì ¸ì˜¤ê¸°
ipcMain.handle('app:getInfo', async () => {
  return { isPackaged: app.isPackaged };
});

// ë¼ì´ì„ ìŠ¤ ìƒíƒœ í™•ì¸
ipcMain.handle('license:checkStatus', async () => {
  try {
    const license = await loadLicense();
    if (!license) {
      return { valid: false, reason: 'ë¼ì´ì„ ìŠ¤ê°€ ì—†ìŠµë‹ˆë‹¤.' };
    }
    if (license.expiresAt) {
      const expiryDate = new Date(license.expiresAt);
      const now = new Date();
      if (now > expiryDate) {
        return { valid: false, reason: 'ë¼ì´ì„ ìŠ¤ê°€ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤.', details: { expiresAt: license.expiresAt } };
      }
    }
    return { valid: true, reason: 'ë¼ì´ì„ ìŠ¤ê°€ ìœ íš¨í•©ë‹ˆë‹¤.', details: license };
  } catch (error) {
    return { valid: false, reason: (error as Error).message };
  }
});

// âœ… ImageManager ë™ê¸°í™” í•¸ë“¤ëŸ¬ (ë Œë”ëŸ¬ì—ì„œ ìƒì„±ëœ ì´ë¯¸ì§€ë¥¼ ë©”ì¸ í”„ë¡œì„¸ìŠ¤ globalë¡œ ì „ë‹¬)
ipcMain.handle('automation:syncImageManager', async (_event, imageMapData: Record<string, any[]>) => {
  try {
    const map = new Map<string, any[]>();
    for (const [key, list] of Object.entries(imageMapData)) {
      map.set(key, list);
    }

    // NaverBlogAutomationì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•˜ë„ë¡ globalì— ì„¤ì •
    (global as any).ImageManager = {
      imageMap: map
    };

    console.log(`[Main] ImageManager ë™ê¸°í™” ì™„ë£Œ: ${map.size}ê°œ ì†Œì œëª© ë°ì´í„°`);
    return true;
  } catch (error) {
    return false;
  }
});

// âœ… ë¸Œë¼ìš°ì € ì„¸ì…˜ ì¢…ë£Œ í•¸ë“¤ëŸ¬
ipcMain.handle('automation:closeBrowser', async () => {
  try {
    if (automation || automationMap.size > 0) {
      sendLog('ğŸ›‘ ëª¨ë“  ë¸Œë¼ìš°ì € ì„¸ì…˜ì„ ëª…ì‹œì ìœ¼ë¡œ ì¢…ë£Œí•©ë‹ˆë‹¤.');

      const closePromises: Promise<void>[] = [];

      if (automation) {
        closePromises.push(automation.closeBrowser().catch(() => undefined));
      }

      for (const [id, instance] of automationMap.entries()) {
        if (instance !== automation) {
          closePromises.push(instance.closeBrowser().catch(() => undefined));
        }
      }

      await Promise.allSettled(closePromises);
      automation = null;
      automationMap.clear();
    }
    return { success: true };
  } catch (error) {
    console.error('[Main] ë¸Œë¼ìš°ì € ì¢…ë£Œ ì‹¤íŒ¨:', error);
    return { success: false, message: (error as Error).message };
  }
});

ipcMain.handle('automation:run', async (_event, payload: AutomationRequest) => {
  // âœ… ì‹¤í–‰ ì§ì „ ìµœì‹  ì„¤ì • ê°•ì œ ë™ê¸°í™” (API í‚¤ ì •í•©ì„± ë³´ì¥)
  try {
    const currentConfig = await loadConfig();
    applyConfigToEnv(currentConfig);
    console.log('[Main] automation:run - ìµœì‹  ì„¤ì • ë™ê¸°í™” ì™„ë£Œ');
  } catch (e) {
    console.error('[Main] automation:run - ì„¤ì • ë¡œë“œ ì‹¤íŒ¨:', e);
  }

  // âœ… [ë¦¬íŒ©í† ë§] ìƒˆ ëª¨ë“ˆì˜ validateAutomationRun() ì‚¬ìš©
  // - ë¼ì´ì„ ìŠ¤ ì²´í¬, ë¬´ë£Œ í‹°ì–´ quota ì²´í¬, ì¤‘ë³µ ì‹¤í–‰ ì²´í¬ í†µí•©
  const validationResult = await validateAutomationRun();
  if (!validationResult.valid) {
    return validationResult.response;
  }

  // âœ… [ë¦¬íŒ©í† ë§] AutomationServiceì™€ ì „ì—­ ë³€ìˆ˜ ë™ê¸°í™”
  // (ê¸°ì¡´ ì „ì—­ ë³€ìˆ˜ëŠ” ë ˆê±°ì‹œ í˜¸í™˜ì„ ìœ„í•´ ìœ ì§€)
  automationRunning = true;
  AutomationService.startRunning();
  AutomationService.updateLastRunTime();
  (globalThis as any).lastAutomationRunTime = Date.now();

  // âœ… ë‹¤ê³„ì • ìë™ ìˆœí™˜: payloadì— ë¡œê·¸ì¸ ì •ë³´ê°€ ì—†ìœ¼ë©´ í™œì„± ê³„ì • ë˜ëŠ” ë‹¤ìŒ ìˆœí™˜ ê³„ì • ì‚¬ìš©
  let accountNaverId = payload?.naverId;
  let accountNaverPassword = payload?.naverPassword;
  let usedAccountId: string | null = null;

  if (!accountNaverId || !accountNaverPassword) {
    // ìë™ ìˆœí™˜ ë°œí–‰: ë‹¤ìŒ ë°œí–‰ ê³„ì • ê°€ì ¸ì˜¤ê¸°
    const nextAccount = blogAccountManager.getNextAccountForPublish();

    if (nextAccount) {
      const credentials = blogAccountManager.getAccountCredentials(nextAccount.id);
      if (credentials) {
        accountNaverId = credentials.naverId;
        accountNaverPassword = credentials.naverPassword;
        usedAccountId = nextAccount.id;
        sendLog(`ğŸ‘¥ ë‹¤ê³„ì • ìë™ ìˆœí™˜: "${nextAccount.name}" ê³„ì •ìœ¼ë¡œ ë°œí–‰í•©ë‹ˆë‹¤.`);
      } else {
        // ë¡œê·¸ì¸ ì •ë³´ê°€ ì—†ëŠ” ê³„ì •ì´ë©´ í™œì„± ê³„ì • ì‹œë„
        const activeAccount = blogAccountManager.getActiveAccount();
        if (activeAccount) {
          const activeCredentials = blogAccountManager.getAccountCredentials(activeAccount.id);
          if (activeCredentials) {
            accountNaverId = activeCredentials.naverId;
            accountNaverPassword = activeCredentials.naverPassword;
            usedAccountId = activeAccount.id;
            sendLog(`ğŸ‘¤ í™œì„± ê³„ì • "${activeAccount.name}"ìœ¼ë¡œ ë°œí–‰í•©ë‹ˆë‹¤.`);
          }
        }
      }
    } else {
      // ìˆœí™˜ ê°€ëŠ¥í•œ ê³„ì •ì´ ì—†ìœ¼ë©´ í™œì„± ê³„ì • ì‚¬ìš©
      const activeAccount = blogAccountManager.getActiveAccount();
      if (activeAccount) {
        const activeCredentials = blogAccountManager.getAccountCredentials(activeAccount.id);
        if (activeCredentials) {
          accountNaverId = activeCredentials.naverId;
          accountNaverPassword = activeCredentials.naverPassword;
          usedAccountId = activeAccount.id;
          sendLog(`ğŸ‘¤ í™œì„± ê³„ì • "${activeAccount.name}"ìœ¼ë¡œ ë°œí–‰í•©ë‹ˆë‹¤.`);
        }
      }
    }
  }

  // âœ… ID ì •ê·œí™” (ë¹„êµìš©)
  const normalizedRequestedId = (accountNaverId || '').trim().toLowerCase();

  // âœ… ì„¸ì…˜ ì¬ì‚¬ìš©: ê¸°ì¡´ ì¸ìŠ¤í„´ìŠ¤ê°€ ìˆê³  ê³„ì •ì´ ê°™ìœ¼ë©´ ì¬ì‚¬ìš©
  let existingAutomation = automationMap.get(normalizedRequestedId);

  if (existingAutomation) {
    sendLog(`â™»ï¸ ê¸°ì¡´ "${accountNaverId}" ë¸Œë¼ìš°ì € ì„¸ì…˜ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.`);
    automation = existingAutomation;
  } else if (automation) {
    // í•˜ìœ„ í˜¸í™˜: automation ë³€ìˆ˜ì— ë‹¤ë¥¸ ê³„ì •ì´ ìˆìœ¼ë©´ ì¢…ë£Œ
    const currentNaverId = (automation.naverId || '').trim().toLowerCase();
    if (currentNaverId !== normalizedRequestedId) {
      sendLog('ğŸ”„ ë‹¤ë¥¸ ê³„ì • ì‚¬ìš©ì„ ìœ„í•´ ê¸°ì¡´ ë¸Œë¼ìš°ì €ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.');
      await automation.closeBrowser().catch(() => undefined);
      automation = null;
    } else {
      // ê°™ì€ ê³„ì •ì´ë©´ ë§µì— ë“±ë¡
      automationMap.set(normalizedRequestedId, automation);
    }
  }

  // ì‹¤í–‰ ì‹œê°„ ê¸°ë¡
  (globalThis as any).lastAutomationRunTime = Date.now();

  // âœ… Gemini ëª¨ë¸ ì„¤ì • (UIì—ì„œ ì„ íƒí•œ ëª¨ë¸ ì ìš©)
  if (payload?.geminiModel) {
    setGeminiModel(payload.geminiModel);
    sendLog(`ğŸ¤– Gemini ëª¨ë¸: ${payload.geminiModel}`);
  }


  if (!accountNaverId || !accountNaverPassword) {
    const message = 'ë„¤ì´ë²„ ì•„ì´ë””ì™€ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”. (í™˜ê²½ì„¤ì • > ë‹¤ê³„ì • ê´€ë¦¬ì—ì„œ ê³„ì •ì„ ì¶”ê°€í•˜ê±°ë‚˜ ì§ì ‘ ì…ë ¥í•˜ì„¸ìš”)';
    sendStatus({ success: false, message });
    return { success: false, message };
  }

  const dailyLimit = getDailyLimit();
  let todayCount = await getTodayCount();
  let riskAcknowledged = false;

  // âœ… 3íšŒ ë°œí–‰ ê²½ê³  ê¸°ë³¸ ë¹„í™œì„±í™” (ì‚¬ìš©ì ìš”ì²­: ê²½ê³  ë©”ì‹œì§€ ì œê±°)
  // ê¸°ì¡´ ë¡œì§ì€ ì£¼ì„ ì²˜ë¦¬í•¨. í•„ìš” ì‹œ ë³µì› ê°€ëŠ¥.
  if (dailyLimit > 0 && todayCount >= dailyLimit) {
    // ê²½ê³  ì—†ì´ ìë™ìœ¼ë¡œ ì§„í–‰ (ë¡œê·¸ë§Œ ë‚¨ê¹€)
    riskAcknowledged = true;
    sendLog(`â„¹ï¸ ì˜¤ëŠ˜ ${todayCount}ê±´ ë°œí–‰ ì™„ë£Œ. ê³„ì† ì§„í–‰í•©ë‹ˆë‹¤.`);
  }

  automationRunning = true;
  AutomationService.startRunning(); // âœ… [ë¦¬íŒ©í† ë§] ë™ê¸°í™”
  if (payload.generator) {
    sendLog(`ğŸ§  ì„ íƒëœ ìƒì„± ì—”ì§„: ${payload.generator}`);
  }

  // ê¸€ ì œëª© ê¸°ì¤€ìœ¼ë¡œ ì´ë¯¸ì§€ í´ë” ìƒì„± ë° ì´ë¯¸ì§€ ë³µì‚¬
  let postImageFolder: string | null = null;
  let processedImages: AutomationImage[] = [];

  if (payload.generatedImages && payload.generatedImages.length > 0 && !payload.skipImages) {
    try {
      const postTitle = payload.title || payload.structuredContent?.selectedTitle || `post-${Date.now()}`;
      // ì•ˆì „í•œ í´ë”ëª… ìƒì„± (íŠ¹ìˆ˜ë¬¸ì ì œê±°)
      const safeTitle = postTitle.replace(/[<>:"/\\|?*]/g, '_').substring(0, 100).trim() || 'untitled';

      // ê¸€ë³„ ì´ë¯¸ì§€ í´ë” ê²½ë¡œ (userData/images/posts/[ì œëª©]/)
      const postsImageDir = path.join(app.getPath('userData'), 'images', 'posts', safeTitle);
      await fs.mkdir(postsImageDir, { recursive: true });
      postImageFolder = postsImageDir;

      sendLog(`ğŸ“ ê¸€ë³„ ì´ë¯¸ì§€ í´ë” ìƒì„±: ${postImageFolder}`);

      // ì´ë¯¸ì§€ ê²€ì¦ ë° ë³µì‚¬
      for (const image of payload.generatedImages) {
        try {
          // âœ… filePathê°€ ì—†ëŠ” ê²½ìš° ê±´ë„ˆë›°ê¸°
          if (!image.filePath) {
            sendLog(`âš ï¸ ì´ë¯¸ì§€ ê²½ë¡œê°€ ì—†ìŠµë‹ˆë‹¤: ${image.heading || 'ì•Œ ìˆ˜ ì—†ìŒ'}`);
            continue;
          }

          // URLì¸ì§€ í™•ì¸ (ì™¸ë¶€ ì´ë¯¸ì§€)
          const isUrl = image.filePath.startsWith('http://') || image.filePath.startsWith('https://');

          if (isUrl) {
            // ì™¸ë¶€ ì´ë¯¸ì§€ URLì€ ê·¸ëŒ€ë¡œ ì‚¬ìš© (ë³µì‚¬í•˜ì§€ ì•ŠìŒ)
            sendLog(`âœ… ì™¸ë¶€ ì´ë¯¸ì§€ URL ì‚¬ìš©: ${image.filePath.substring(0, 80)}...`);
            processedImages.push({
              heading: image.heading,
              filePath: image.filePath, // URL ê·¸ëŒ€ë¡œ ì‚¬ìš©
              provider: image.provider,
              alt: image.alt,
              caption: image.caption,
            });
            continue;
          }

          // ë¡œì»¬ íŒŒì¼ì¸ ê²½ìš°ì—ë§Œ íŒŒì¼ ê²€ì¦ ë° ë³µì‚¬
          // íŒŒì¼ ì¡´ì¬ í™•ì¸
          await fs.access(image.filePath);

          // íŒŒì¼ ì •ë³´ í™•ì¸
          const stats = await fs.stat(image.filePath);
          if (!stats.isFile()) {
            sendLog(`âš ï¸ ì´ë¯¸ì§€ íŒŒì¼ì´ ì•„ë‹™ë‹ˆë‹¤: ${image.filePath}`);
            continue;
          }

          // íŒŒì¼ í™•ì¥ì í™•ì¸
          const ext = path.extname(image.filePath).toLowerCase();
          if (!['.jpg', '.jpeg', '.png', '.gif', '.webp'].includes(ext)) {
            sendLog(`âš ï¸ ì§€ì›í•˜ì§€ ì•ŠëŠ” ì´ë¯¸ì§€ í˜•ì‹ì…ë‹ˆë‹¤: ${image.filePath}`);
            continue;
          }

          // íŒŒì¼ëª… ìƒì„± (ì†Œì œëª© ê¸°ë°˜)
          const safeHeading = image.heading.replace(/[<>:"/\\|?*]/g, '_').substring(0, 50).trim() || 'image';
          const timestamp = Date.now();
          const fileName = `${safeHeading}-${timestamp}${ext}`;
          const targetPath = path.join(postsImageDir, fileName);

          // ì´ë¯¸ì§€ ë³µì‚¬
          await fs.copyFile(image.filePath, targetPath);

          sendLog(`âœ… ì´ë¯¸ì§€ ë³µì‚¬ ì™„ë£Œ: ${path.basename(targetPath)}`);

          processedImages.push({
            heading: image.heading,
            filePath: targetPath, // ë³µì‚¬ëœ íŒŒì¼ ê²½ë¡œ ì‚¬ìš©
            provider: image.provider,
            alt: image.alt,
            caption: image.caption,
          });
        } catch (error) {
          sendLog(`âŒ ì´ë¯¸ì§€ ì²˜ë¦¬ ì‹¤íŒ¨ (${image.heading}): ${(error as Error).message}`);
          // ì‹¤íŒ¨í•œ ì´ë¯¸ì§€ëŠ” ì›ë³¸ ê²½ë¡œ ì‚¬ìš© (ë³µì‚¬ ì‹¤íŒ¨ ì‹œ)
          processedImages.push(image);
        }
      }

      sendLog(`ğŸ“Š ì´ ${processedImages.length}ê°œì˜ ì´ë¯¸ì§€ê°€ ê¸€ í´ë”ì— ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤.`);
    } catch (error) {
      sendLog(`âš ï¸ ì´ë¯¸ì§€ í´ë” ìƒì„± ì‹¤íŒ¨: ${(error as Error).message}`);
      sendLog(`ğŸ“ ì›ë³¸ ì´ë¯¸ì§€ ê²½ë¡œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.`);
      // í´ë” ìƒì„± ì‹¤íŒ¨ ì‹œ ì›ë³¸ ì´ë¯¸ì§€ ì‚¬ìš©
      processedImages = payload.generatedImages.map((image) => ({
        heading: image.heading,
        filePath: image.filePath,
        provider: image.provider,
        alt: image.alt,
        caption: image.caption,
      }));
    }
  }

  // ì†Œì œëª©ë³„ ì €ì¥ëœ ì´ë¯¸ì§€ ê°€ì ¸ì˜¤ê¸° (ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì ìš©í•œ ì´ë¯¸ì§€)
  const headingImages: AutomationImage[] = [];
  if (payload.structuredContent && payload.structuredContent.headings && !payload.skipImages) {
    for (const heading of payload.structuredContent.headings) {
      const savedImage = headingImagesStore.get(heading.title);
      if (savedImage && savedImage.filePath) {
        // íŒŒì¼ ì¡´ì¬ í™•ì¸
        try {
          await fs.access(savedImage.filePath);
          headingImages.push({
            heading: heading.title,
            filePath: savedImage.filePath,
            provider: savedImage.provider,
            alt: savedImage.alt,
            caption: savedImage.caption,
          });
          sendLog(`ğŸ“Œ ì†Œì œëª© "${heading.title}"ì— ì €ì¥ëœ ì´ë¯¸ì§€ ì ìš©: ${path.basename(savedImage.filePath)}`);
        } catch {
          sendLog(`âš ï¸ ì†Œì œëª© "${heading.title}"ì˜ ì €ì¥ëœ ì´ë¯¸ì§€ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${savedImage.filePath}`);
        }
      }
    }
  }

  // ì´ë¯¸ì§€ ìš°ì„ ìˆœìœ„: 1) ì†Œì œëª©ë³„ ì €ì¥ëœ ì´ë¯¸ì§€, 2) ìƒì„±ëœ ì´ë¯¸ì§€, 3) payloadì˜ generatedImages
  const finalImages: AutomationImage[] = [];

  const getImageIdentity = (img: { heading?: string; filePath?: string } | undefined | null): string => {
    const heading = String(img?.heading || '').trim();
    const filePath = String(img?.filePath || '').trim();
    return `${heading}::${filePath}`;
  };

  // ë¨¼ì € ì†Œì œëª©ë³„ ì €ì¥ëœ ì´ë¯¸ì§€ ì¶”ê°€
  if (headingImages.length > 0) {
    finalImages.push(...headingImages);
  }

  // ê·¸ ë‹¤ìŒ ìƒì„±ëœ ì´ë¯¸ì§€ ì¶”ê°€ (ì¤‘ë³µ ì œê±°)
  if (processedImages.length > 0) {
    for (const img of processedImages) {
      // âœ… ì†Œì œëª©ë‹¹ ì—¬ëŸ¬ ì´ë¯¸ì§€ í—ˆìš©: headingë§Œìœ¼ë¡œ ì¤‘ë³µ ì œê±°í•˜ë©´ ì¶”ê°€ ì´ë¯¸ì§€ê°€ ëª¨ë‘ ë‚ ì•„ê°
      const exists = finalImages.some(existing => getImageIdentity(existing) === getImageIdentity(img));
      if (!exists) {
        finalImages.push(img);
      }
    }
  } else if (payload.generatedImages && payload.generatedImages.length > 0) {
    for (const img of payload.generatedImages) {
      const normalizedFilePath = img.filePath || (img as any).url;
      const candidate: AutomationImage = {
        heading: img.heading,
        filePath: normalizedFilePath,
        provider: img.provider,
        alt: img.alt,
        caption: img.caption,
      };
      const exists = finalImages.some(existing => getImageIdentity(existing) === getImageIdentity(candidate));
      if (!exists) {
        finalImages.push(candidate);
      }
    }
  }

  // âœ… í’€ì˜¤í†  ëª¨ë“œ: AI ì´ë¯¸ì§€ ìë™ ë§¤ì¹­
  let matchedImages: AutomationImage[] = finalImages;
  let collectedImagesForAutoMatch: Array<{ id: string; url: string; thumbnailUrl: string; title: string; source: string; tags?: string[] }> | undefined;

  if (payload.structuredContent && payload.structuredContent.headings && !payload.skipImages) {
    // âœ… í’€ì˜¤í†  ëª¨ë“œ: AI ì´ë¯¸ì§€ ìë™ ë§¤ì¹­
    // ì´ë¯¸ ìƒì„±ëœ ì´ë¯¸ì§€ë‚˜ ì„ íƒëœ ì´ë¯¸ì§€ê°€ ì—†ì„ ë•Œë§Œ ì‹¤í–‰
    // âœ… ì§€ëŠ¥í˜• ì´ë¯¸ì§€ ë°°ì¹˜: ëª…ì‹œì  í”Œë˜ê·¸ê°€ ìˆì„ ë•Œë§Œ ì‹¤í–‰ (ê¸°ì¡´ imageMode === 'full-auto' ì‹œ ê°•ì œ ì‹¤í–‰ ë¬¸ì œ ìˆ˜ì •)
    const isFullAuto = payload.useIntelligentImagePlacement === true && finalImages.length === 0;

    if (isFullAuto && payload.structuredContent && payload.structuredContent.headings) {
      try {
        sendLog('ğŸ¤– AI ì •ë°€ ì´ë¯¸ì§€ ìˆ˜ì§‘ ë° ìë™ ë§¤ì¹­ ì‹œì‘...');

        const config = await loadConfig();
        if (!config.geminiApiKey) {
          sendLog('âš ï¸ Gemini API í‚¤ê°€ ì—†ì–´ ì •ë°€ ìˆ˜ì§‘ì„ ê±´ë„ˆëœë‹ˆë‹¤.');
        } else {
          const imagePlacer = new IntelligentImagePlacer(config.geminiApiKey);

          // 1ë‹¨ê³„: ì†Œì œëª© ë¶„ì„ - ì‹œê°ì  ì¥ë©´ ë¬˜ì‚¬ í‚¤ì›Œë“œ ìƒì„±
          const headingsWithContent = payload.structuredContent.headings.map((h, idx) => ({
            index: idx,
            title: h.title,
            content: h.summary || '',
            keywords: h.keywords || [h.title],
          }));

          sendLog('ğŸ” ì‹œê°ì  ì¥ë©´ ë¶„ì„ ì¤‘...');
          const visualKeywordData = await imagePlacer.generateVisualKeywordsForHeadings(headingsWithContent);

          // 2ë‹¨ê³„: ì •ë°€ ìˆ˜ì§‘ - ë„¤ì´ë²„ ì´ë¯¸ì§€ API í™œìš©
          const naverClientId = config.naverDatalabClientId || process.env.NAVER_CLIENT_ID || '';
          const naverClientSecret = config.naverDatalabClientSecret || process.env.NAVER_CLIENT_SECRET || '';

          let expandedCollectedImages = [...(payload.collectedImages || [])];

          if (naverClientId && naverClientSecret) {
            sendLog('ğŸ“¸ ì†Œì œëª©ë³„ ë§ì¶¤ ì´ë¯¸ì§€ ê²€ìƒ‰ ì¤‘ (ì •ë°€ ìˆ˜ì§‘)...');
            const subheadingImages = await (await import('./sourceAssembler.js')).collectImagesBySubheadings(
              visualKeywordData,
              naverClientId,
              naverClientSecret,
              2 // ì†Œì œëª©ë‹¹ 2ê°œì”© ìˆ˜ì§‘
            );

            // ìˆ˜ì§‘ëœ ì´ë¯¸ì§€ë¥¼ collectedImages í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•˜ì—¬ ë³‘í•©
            subheadingImages.forEach(group => {
              group.urls.forEach((url, uIdx) => {
                expandedCollectedImages.push({
                  id: `ai-sub-${group.index}-${uIdx}`,
                  url: url,
                  thumbnailUrl: url,
                  source: 'naver-sub-search',
                  title: `${headingsWithContent[group.index].title} ê´€ë ¨ ì´ë¯¸ì§€`,
                  tags: visualKeywordData[group.index]?.visualQueries || []
                });
              });
            });
          }

          // 3ë‹¨ê³„: ì§€ëŠ¥í˜• ë§¤ì¹­ ìˆ˜í–‰
          const collectedImagesForPlacer = expandedCollectedImages.map(img => ({
            id: img.id,
            url: img.url || img.thumbnailUrl,
            thumbnailUrl: img.thumbnailUrl,
            source: img.source,
            title: img.title,
            tags: img.tags || [],
            photographer: '',
            license: 'unknown',
          }));

          // AI ë§¤ì¹­ ìˆ˜í–‰
          const assignments = await imagePlacer.autoMatchImagesForFullAuto(
            headingsWithContent,
            collectedImagesForPlacer
          );

          sendLog(`âœ… AI ì´ë¯¸ì§€ ë§¤ì¹­ ì™„ë£Œ: ${assignments.length}ê°œ ì†Œì œëª©ì— ì´ë¯¸ì§€ í• ë‹¹`);

          // ë§¤ì¹­ ê²°ê³¼ë¥¼ AutomationImage í˜•ì‹ìœ¼ë¡œ ë³€í™˜
          matchedImages = assignments.map(assignment => ({
            heading: assignment.headingTitle,
            filePath: assignment.assignedImage.url,
            provider: assignment.assignedImage.source,
            alt: assignment.assignedImage.title,
          }));

          collectedImagesForAutoMatch = payload.collectedImages;

          // ë§¤ì¹­ ê²°ê³¼ ë¡œê·¸
          assignments.forEach(assignment => {
            sendLog(`   âœ… "${assignment.headingTitle}" â†’ "${assignment.assignedImage.title}" (ì‹ ë¢°ë„: ${assignment.confidence}%)`);
          });
        }
      } catch (error) {
        sendLog(`âš ï¸ ì§€ëŠ¥í˜• ì´ë¯¸ì§€ ë°°ì¹˜ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${(error as Error).message}`);
      }
    }

    // âœ… ì´ë¯¸ì§€ ë°°ì¹˜ë§Œ ìˆ˜í–‰í•˜ê³  ì¢…ë£Œí•˜ëŠ” ëª¨ë“œì¼ ê²½ìš° ì—¬ê¸°ì„œ ë¦¬í„´
    if (payload.onlyImagePlacement) {
      sendLog('âœ… ì§€ëŠ¥í˜• ì´ë¯¸ì§€ ë°°ì¹˜ ë° ìˆ˜ì§‘ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. (ì´ë¯¸ì§€ ê´€ë¦¬ ì „ìš© ëª¨ë“œ)');
      return { success: true, structuredContent: payload.structuredContent };
    }
  }


  // âœ… ë¸Œë¼ìš°ì € ì„¸ì…˜ ìœ ì§€ ë¡œì§
  const resolvedOptions: RunOptions = {
    title: payload.title,
    content: payload.content,
    lines: payload.lines,
    selectedHeadings: payload.selectedHeadings,
    structuredContent: payload.structuredContent,
    hashtags: payload.hashtags,
    images: (matchedImages && matchedImages.length > 0) ? matchedImages : processedImages, // âœ… matchedImagesê°€ ì—†ìœ¼ë©´ processedImages ì‚¬ìš©
    publishMode: payload.publishMode ?? 'draft',
    scheduleDate: payload.scheduleDate,
    ctaLink: payload.ctaLink,
    ctaText: payload.ctaText,
    ctas: payload.ctas,
    ctaPosition: payload.ctaPosition || 'bottom', // âœ… [ì‹ ê·œ] CTA ìœ„ì¹˜
    skipCta: payload.skipCta || false, // âœ… [ì‹ ê·œ] CTA ê±´ë„ˆë›°ê¸°
    skipImages: payload.skipImages ?? false, // ê¸€ë§Œ ë°œí–‰í•˜ê¸°ìš©
    thumbnailPath: payload.thumbnailPath, // ëŒ€í‘œ ì´ë¯¸ì§€ ê²½ë¡œ
    imageMode: payload.imageMode,
    collectedImages: collectedImagesForAutoMatch,
    toneStyle: payload.toneStyle, // ê¸€ í†¤ ì„¤ì •
    categoryName: payload.categoryName, // âœ… ì¶”ê°€: ì¹´í…Œê³ ë¦¬ ìë™ ì„ íƒìš©
    keepBrowserOpen: payload.keepBrowserOpen, // âœ… ì¶”ê°€: ë¸Œë¼ìš°ì € ìœ ì§€ ì—¬ë¶€
    useAiImage: payload.useAiImage, // âœ… ì¶”ê°€
    createProductThumbnail: payload.createProductThumbnail, // âœ… ì¶”ê°€
    includeThumbnailText: payload.includeThumbnailText, // âœ… ì¶”ê°€: ì¸ë„¤ì¼ í…ìŠ¤íŠ¸ í¬í•¨ ì—¬ë¶€
    // âœ…âœ… [í•µì‹¬ ìˆ˜ì •] ì‡¼í•‘ì»¤ë„¥íŠ¸ ê´€ë ¨ í•„ë“œ ì¶”ê°€ - ì´ì „ì— ëˆ„ë½ë˜ì–´ ì œíœ´ë§í¬ê°€ ì „ë‹¬ë˜ì§€ ì•Šì•˜ìŒ
    affiliateLink: payload.affiliateLink, // âœ… [ì‹ ê·œ] ì œíœ´ ë§í¬
    contentMode: payload.contentMode || 'seo', // âœ… [ì‹ ê·œ] ì½˜í…ì¸  ëª¨ë“œ (affiliate/seo)
    isFullAuto: payload.isFullAuto || false, // âœ… [ì‹ ê·œ] í’€ì˜¤í†  ëª¨ë“œ ì—¬ë¶€ (ì¸ë±ìŠ¤ ê¸°ë°˜ ì´ë¯¸ì§€ ë§¤ì¹­ìš©)
    previousPostTitle: payload.previousPostTitle, // âœ… [ì‹ ê·œ] ê°™ì€ ì¹´í…Œê³ ë¦¬ ì´ì „ê¸€ ì œëª©
    previousPostUrl: payload.previousPostUrl, // âœ… [ì‹ ê·œ] ê°™ì€ ì¹´í…Œê³ ë¦¬ ì´ì „ê¸€ URL
  };

  // âœ… ê¸°ì¡´ ì¸ìŠ¤í„´ìŠ¤ê°€ ì—†ê±°ë‚˜ ê³„ì •ì´ ë‹¤ë¥´ë©´ ìƒˆë¡œ ìƒì„±
  if (!automation || (automation.naverId || '').trim().toLowerCase() !== normalizedRequestedId) {
    automation = new NaverBlogAutomation(
      {
        naverId: accountNaverId || process.env.NAVER_ID || '',
        naverPassword: accountNaverPassword || process.env.NAVER_PASSWORD || '',
        headless: false,
        slowMo: 10,
        defaultTitle: resolvedOptions.title,
        defaultContent: resolvedOptions.content,
        defaultLines: resolvedOptions.lines,
        categoryName: resolvedOptions.categoryName,
      },
      (message) => {
        sendLog(message);
      },
    );
    // ë§µì— ë“±ë¡
    automationMap.set(normalizedRequestedId, automation);
  }

  sendLog('ğŸš€ ìë™í™” ì‹¤í–‰ì„ ì¤€ë¹„í•©ë‹ˆë‹¤...');

  const config = await loadConfig();

  // âœ… ì‚¬ìš©ìê°€ ì„ íƒí•œ Gemini ëª¨ë¸ ì ìš©
  if (config.geminiModel) {
    setGeminiModel(config.geminiModel);
    sendLog(`ğŸ§  AI ëª¨ë¸ ì„¤ì •: ${config.geminiModel}`);
  }

  // âœ… API í‚¤ ìƒíƒœ ë¡œê·¸ (ì‚¬ìš©ì í™•ì¸ìš©)
  if (config.naverClientId && config.naverClientSecret) {
    sendLog(`ğŸ”‘ ë„¤ì´ë²„ ê²€ìƒ‰ API í‚¤ ì‚¬ìš© ê°€ëŠ¥ (Client ID: ${config.naverClientId.substring(0, 4)}****)`);
  } else {
    sendLog('âš ï¸ ë„¤ì´ë²„ ê²€ìƒ‰ API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. (RSS í´ë°± ì‚¬ìš©)');
  }

  try {
    // âœ… ì˜ˆì•½ ë°œí–‰ì¸ ê²½ìš°: scheduleTypeì— ë”°ë¼ ë¶„ê¸° ì²˜ë¦¬
    if (resolvedOptions.publishMode === 'schedule' && resolvedOptions.scheduleDate) {
      const scheduleType = payload.scheduleType || 'app-schedule'; // ê¸°ë³¸ê°’: ì•± ìŠ¤ì¼€ì¤„

      if (scheduleType === 'naver-server') {
        // ë„¤ì´ë²„ ì„œë²„ ì˜ˆì•½: ë„¤ì´ë²„ ë¸”ë¡œê·¸ì— ì˜ˆì•½ë°œí–‰ ì„¤ì • (ì•± ë‚´ë¶€ ìŠ¤ì¼€ì¤„ëŸ¬ ì‚¬ìš© ì•ˆ í•¨)
        sendLog('ğŸŒ ë„¤ì´ë²„ ì„œë²„ ì˜ˆì•½ ëª¨ë“œ: ë„¤ì´ë²„ ë¸”ë¡œê·¸ì— ì˜ˆì•½ë°œí–‰ì„ ì„¤ì •í•©ë‹ˆë‹¤.');
        const runResult = await automation.run({ ...resolvedOptions, keepBrowserOpen: payload.keepBrowserOpen });
        todayCount = await incrementTodayCount().catch(() => todayCount + 1);

        // âœ… ë¬´ë£Œ í‹°ì–´: ë°œí–‰ 1íšŒ ì†Œë¹„(ë„¤ì´ë²„ ì„œë²„ ì˜ˆì•½ ì„¤ì •ë„ ë°œí–‰ìœ¼ë¡œ ì¹´ìš´íŠ¸)
        if (await isFreeTierUser()) {
          await consumeQuota('publish', 1);
        }

        const publishedUrl = runResult?.url || automation.getPublishedUrl();
        if (publishedUrl) {
          sendLog(`ğŸ“ ì˜ˆì•½ë°œí–‰ ì„¤ì • ì™„ë£Œ. ë„¤ì´ë²„ ë¸”ë¡œê·¸ì—ì„œ í™•ì¸í•˜ì„¸ìš”.`);
        }

        sendStatus({ success: true, message: `ë„¤ì´ë²„ ì„œë²„ ì˜ˆì•½ë°œí–‰ ì„¤ì • ì™„ë£Œ: ${resolvedOptions.scheduleDate}`, url: publishedUrl || undefined });
        return { success: true, message: `ë„¤ì´ë²„ ì„œë²„ ì˜ˆì•½ë°œí–‰ ì„¤ì • ì™„ë£Œ: ${resolvedOptions.scheduleDate}` };
      } else {
        // ì•± ìŠ¤ì¼€ì¤„ ê´€ë¦¬: ì•± ë‚´ë¶€ ìŠ¤ì¼€ì¤„ëŸ¬ì— ë“±ë¡ (ë„¤ì´ë²„ ë¸”ë¡œê·¸ì—ëŠ” ê¸€ ì‘ì„±ë§Œ í•˜ê³  ë°œí–‰ ì•ˆ í•¨)
        sendLog('ğŸ“± ì•± ìŠ¤ì¼€ì¤„ ê´€ë¦¬ ëª¨ë“œ: ì•± ë‚´ë¶€ ìŠ¤ì¼€ì¤„ëŸ¬ì— ë“±ë¡í•©ë‹ˆë‹¤.');
        sendLog('ğŸ’¡ ê¸€ì„ ì‘ì„±ë§Œ í•˜ê³  ë°œí–‰í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì„¤ì •ëœ ì‹œê°„ì— ì•±ì´ ìë™ìœ¼ë¡œ ë°œí–‰í•©ë‹ˆë‹¤.');

        // ì„ì‹œì €ì¥ìœ¼ë¡œ ì‹¤í–‰ (ë„¤ì´ë²„ ë¸”ë¡œê·¸ì—ëŠ” ê¸€ ì‘ì„±ë§Œ í•˜ê³  ë°œí–‰ ì•ˆ í•¨)
        const tempOptions = { ...resolvedOptions, publishMode: 'draft' as PublishMode, keepBrowserOpen: payload.keepBrowserOpen };
        await automation.run(tempOptions);

        // âœ… ë¬´ë£Œ í‹°ì–´: ì•± ìŠ¤ì¼€ì¤„ ë“±ë¡ë„ ë°œí–‰ìœ¼ë¡œ ì¹´ìš´íŠ¸
        if (await isFreeTierUser()) {
          await consumeQuota('publish', 1);
        }

        // ì•± ë‚´ë¶€ ìŠ¤ì¼€ì¤„ëŸ¬ì— ë“±ë¡
        let finalPostId = payload.postId;

        if (!finalPostId) {
          const postIdResult = await mainWindow?.webContents.executeJavaScript(`
            (function() {
              try {
                const title = ${JSON.stringify(resolvedOptions.title)};
                const posts = JSON.parse(localStorage.getItem('naver_blog_generated_posts') || '[]');
                
                const normalizeTitle = (t) => t.trim().replace(/\\s+/g, ' ').toLowerCase();
                const normalizedSearchTitle = normalizeTitle(title);
                const matchingPosts = posts.filter(p => normalizeTitle(p.title) === normalizedSearchTitle);
                
                if (matchingPosts.length > 0) {
                  const latestPost = matchingPosts.sort((a, b) => {
                    const timeA = new Date(a.updatedAt || a.createdAt || 0).getTime();
                    const timeB = new Date(b.updatedAt || b.createdAt || 0).getTime();
                    return timeB - timeA;
                  })[0];
                  return latestPost.id;
                }
                
                if (posts.length > 0) {
                  const latestPost = posts.sort((a, b) => {
                    const timeA = new Date(a.updatedAt || a.createdAt || 0).getTime();
                    const timeB = new Date(b.updatedAt || b.createdAt || 0).getTime();
                    return timeB - timeA;
                  })[0];
                  return latestPost.id;
                }
                
                return null;
              } catch (e) {
                return null;
              }
            })()
          `);
          finalPostId = postIdResult;
        }

        const scheduledPost: ScheduledPost = {
          id: `post-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          postId: finalPostId || undefined,
          title: resolvedOptions.title || 'ì œëª© ì—†ìŒ',
          scheduleDate: resolvedOptions.scheduleDate,
          createdAt: new Date().toISOString(),
          status: 'scheduled',
          publishMode: 'schedule',
        };

        await saveScheduledPost(scheduledPost);
        sendLog(`ğŸ“… ì•± ìŠ¤ì¼€ì¤„ëŸ¬ì— ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤: ${resolvedOptions.scheduleDate}`);
        sendLog(`ğŸ’¡ ì„¤ì •ëœ ì‹œê°„ì— ì•±ì´ ìë™ìœ¼ë¡œ ë°œí–‰í•©ë‹ˆë‹¤. (ì•±ì´ ì‹¤í–‰ ì¤‘ì´ì–´ì•¼ í•©ë‹ˆë‹¤)`);

        sendStatus({ success: true, message: `ì•± ìŠ¤ì¼€ì¤„ëŸ¬ ë“±ë¡ ì™„ë£Œ: ${resolvedOptions.scheduleDate}` });
        return { success: true, message: `ì•± ìŠ¤ì¼€ì¤„ëŸ¬ ë“±ë¡ ì™„ë£Œ: ${resolvedOptions.scheduleDate}` };
      }
    }

    // âœ… ì¦‰ì‹œ ë°œí–‰ ë˜ëŠ” ì„ì‹œ ì €ì¥ì¸ ê²½ìš°: ë°”ë¡œ ì‹¤í–‰
    const runResult = await automation.run({ ...resolvedOptions, keepBrowserOpen: payload.keepBrowserOpen });
    todayCount = await incrementTodayCount().catch(() => todayCount + 1);

    // âœ… ë¬´ë£Œ í‹°ì–´: ë°œí–‰ 1íšŒ ì†Œë¹„(ì„ì‹œì €ì¥ í¬í•¨)
    if (await isFreeTierUser()) {
      await consumeQuota('publish', 1);
    }

    // âœ… ë‹¤ê³„ì • ë°œí–‰ ê¸°ë¡ ì—…ë°ì´íŠ¸
    if (usedAccountId) {
      blogAccountManager.recordPublish(usedAccountId);
      sendLog(`ğŸ“Š ê³„ì •ë³„ ë°œí–‰ ê¸°ë¡ ì—…ë°ì´íŠ¸ ì™„ë£Œ`);
    }

    // âœ… ë°œí–‰ëœ URL ë¡œê·¸ ë° rendererì— ì „ë‹¬
    const publishedUrl = runResult?.url || automation.getPublishedUrl();
    if (publishedUrl) {
      sendLog(`ğŸ“ ë°œí–‰ëœ ê¸€ URL: ${publishedUrl}`);
    }

    if (riskAcknowledged) {
      sendLog(`ğŸ“ˆ ìœ„í—˜ ì¸ì§€ ìƒíƒœì—ì„œ ë°œí–‰ ì™„ë£Œ.`);
    } else {
      sendLog(`âœ… ë°œí–‰ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.`);
    }

    // âœ… URL í¬í•¨í•˜ì—¬ ì„±ê³µ ìƒíƒœ ì „ì†¡
    sendStatus({ success: true, message: 'ë°œí–‰ ì™„ë£Œ', url: publishedUrl || undefined });

    if (process.env.VIRAL_MODE === 'true' && payload.structuredContent) {
      const booster = new PostPublishBooster({
        mainAccountId: process.env.NAVER_ID ?? payload.naverId,
        subAccounts: [
          process.env.NAVER_SUB_ID_1 ? { id: process.env.NAVER_SUB_ID_1, password: process.env.NAVER_SUB_PASSWORD_1 } : undefined,
          process.env.NAVER_SUB_ID_2 ? { id: process.env.NAVER_SUB_ID_2, password: process.env.NAVER_SUB_PASSWORD_2 } : undefined,
        ].filter(Boolean) as Array<{ id: string; password?: string }>,
        logger: sendLog,
      });
      booster
        .boostAfterPublish(payload.naverId, payload.structuredContent)
        .catch((error) => sendLog(`âš ï¸ ë¶€ìŠ¤íŒ… ì‘ì—… ì¤‘ ì˜¤ë¥˜: ${(error as Error).message}`));
    }

    // âœ… URL í¬í•¨í•˜ì—¬ ë°˜í™˜ (ì´ì „ê¸€ ì„ íƒ ì‹œ URL ì‚¬ìš© ê°€ëŠ¥í•˜ë„ë¡)
    sendStatus({ success: true, url: publishedUrl || undefined });
    return { success: true, url: publishedUrl || undefined };
  } catch (error) {
    const message = (error as Error).message ?? 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
    sendStatus({ success: false, message });
    return { success: false, message };
  } finally {
    automationRunning = false;
    AutomationService.stopRunning(); // âœ… [ë¦¬íŒ©í† ë§] ë™ê¸°í™”
    // ì„¸ì…˜ì„ ìœ ì§€í•˜ëŠ” ê²½ìš° ì¸ìŠ¤í„´ìŠ¤ë¥¼ nullë¡œ ë§Œë“¤ì§€ ì•ŠìŒ
    if (!payload.keepBrowserOpen) {
      const normalizedId = String(payload.naverId || '').trim().toLowerCase();
      if (normalizedId) {
        automationMap.delete(normalizedId);
        AutomationService.delete(normalizedId); // âœ… [ë¦¬íŒ©í† ë§] ë™ê¸°í™”
      }
      automation = null;
      AutomationService.setCurrentInstance(null); // âœ… [ë¦¬íŒ©í† ë§] ë™ê¸°í™”
    }
  }
});

ipcMain.handle('automation:cancel', async () => {
  // âœ… [ë¦¬íŒ©í† ë§] í†µí•© ê²€ì¦
  const check = await validateLicenseOnly();
  if (!check.valid) return check.response;

  if (!automationRunning || !automation) {
    return false;
  }

  // âœ… [ë¦¬íŒ©í† ë§] AutomationServiceì—ë„ ì·¨ì†Œ ìš”ì²­
  AutomationService.requestCancel();

  await automation.cancel().catch(() => undefined);
  sendStatus({ success: false, cancelled: true, message: 'ì‚¬ìš©ìê°€ ìë™í™”ë¥¼ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.' });
  automationRunning = false;
  AutomationService.stopRunning(); // âœ… ë™ê¸°í™”
  automation = null;
  return true;
});


ipcMain.handle(
  'automation:generateImages',
  async (_event, options: GenerateImagesOptions): Promise<{ success: boolean; images?: GeneratedImage[]; message?: string }> => {
    // âœ… [ë¦¬íŒ©í† ë§] í†µí•© ê²€ì¦ í•¨ìˆ˜ ì‚¬ìš©
    const check = await validateLicenseAndQuota('media', 1);
    if (!check.valid) {
      return check.response;
    }
    try {
      // AppConfigì—ì„œ API í‚¤ ë¡œë“œ
      const config = await loadConfig();

      const apiKeys = {
        openaiApiKey: config.openaiApiKey,
        pexelsApiKey: config.pexelsApiKey,
        stabilityApiKey: config.stabilityApiKey, // âœ… Stability AI í‚¤ ì¶”ê°€
        unsplashApiKey: config.unsplashApiKey,
        pixabayApiKey: config.pixabayApiKey,
        geminiApiKey: config.geminiApiKey, // âœ… Gemini í‚¤ ì¶”ê°€
        prodiaToken: (config as any).prodiaToken,
        falaiApiKey: (config as any).falaiApiKey, // âœ… Fal.ai í‚¤ ì¶”ê°€
      };

      // âœ… ì‡¼í•‘ì»¤ë„¥íŠ¸ ëª¨ë“œ: ìˆ˜ì§‘ëœ ì´ë¯¸ì§€ë¥¼ ê° itemì˜ referenceImagePathë¡œ ë°°ë¶„
      const isShoppingConnect = (options as any).isShoppingConnect === true;
      const collectedImages = (options as any).collectedImages || [];

      if (isShoppingConnect && Array.isArray(collectedImages) && collectedImages.length > 0 && options.items) {
        console.log(`[Main] ğŸ›’ ì‡¼í•‘ì»¤ë„¥íŠ¸: ${collectedImages.length}ê°œ ìˆ˜ì§‘ ì´ë¯¸ì§€ë¥¼ ì°¸ì¡° ì´ë¯¸ì§€ë¡œ ë°°ë¶„`);
        options.items.forEach((item, idx) => {
          // ê° ì†Œì œëª©ì— ìˆ˜ì§‘ ì´ë¯¸ì§€ë¥¼ ìˆœí™˜ í• ë‹¹ (ì´ë¯¸ì§€ ê°œìˆ˜ë³´ë‹¤ ì†Œì œëª©ì´ ë§ì„ ìˆ˜ ìˆìŒ)
          const refImg = collectedImages[idx % collectedImages.length];
          if (refImg && !item.referenceImagePath && !item.referenceImageUrl) {
            const refUrl = typeof refImg === 'string' ? refImg : (refImg.url || refImg.filePath || refImg.thumbnailUrl);
            if (refUrl) {
              (item as any).referenceImagePath = refUrl;
              console.log(`[Main]   ğŸ“ ì†Œì œëª© ${idx + 1} (${item.heading?.substring(0, 20) || ''}) â†’ ì°¸ì¡°: ${String(refUrl).substring(0, 60)}...`);
            }
          }
        });
      }

      const images = await generateImages(options, apiKeys);

      if (await isFreeTierUser()) {
        await consumeQuota('media', 1);
      }
      return { success: true, images };
    } catch (error) {
      const message = (error as Error).message ?? 'ì´ë¯¸ì§€ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
      return { success: false, message };
    }
  },
);

// âœ… AI ì´ë¯¸ì§€ ìë™ ë§¤ì¹­ í•¸ë“¤ëŸ¬ (ì´ë¯¸ì§€ ìƒì„± ì „ ì°¸ì¡° ì´ë¯¸ì§€ ê²°ì •ì„ ìœ„í•´ ì‚¬ìš©)
ipcMain.handle(
  'automation:matchImages',
  async (_event, payload: {
    headings: any[];
    collectedImages: any[];
  }): Promise<{ success: boolean; assignments?: any[]; message?: string }> => {
    try {
      const config = await loadConfig();
      if (!config.geminiApiKey) {
        return { success: false, message: 'Gemini API í‚¤ê°€ í•„ìš”í•©ë‹ˆë‹¤.' };
      }

      const imagePlacer = new IntelligentImagePlacer(config.geminiApiKey);

      // ë°ì´í„° í˜•ì‹ ë³€í™˜ (IntelligentImagePlacer ë‚´ë¶€ í˜•ì‹ì— ë§ì¶¤)
      const headingsWithContent = payload.headings.map((h, idx) => ({
        index: idx,
        title: h.title || h,
        content: h.summary || h.content || '',
        keywords: h.keywords || [h.title || h],
      }));

      const collectedImagesForPlacer = payload.collectedImages.map(img => ({
        id: img.id,
        url: img.url || img.thumbnailUrl,
        thumbnailUrl: img.thumbnailUrl,
        source: img.source,
        title: img.title || 'Product Image',
        tags: img.tags || [],
        photographer: '',
        license: 'unknown',
      }));

      const assignments = await imagePlacer.autoMatchImagesForFullAuto(
        headingsWithContent,
        collectedImagesForPlacer
      );

      return { success: true, assignments };
    } catch (error) {
      return { success: false, message: (error as Error).message };
    }
  }
);

// âœ… ë„¤ì´ë²„ ì´ë¯¸ì§€ ê°œì„  ë²„ì „ í•¸ë“¤ëŸ¬
ipcMain.handle(
  'automation:generateImagesNaverImproved',
  async (_event, payload: {
    items: Array<{ heading: string; prompt: string }>;
    postTitle?: string;
    postId?: string;
    isRegenerate?: boolean;
    sourceUrl?: string;
    articleUrl?: string;
    options?: {
      apiKey?: string;
      aiProvider?: 'gemini' | 'openai';
      minRelevanceScore?: number;
      minPopularityScore?: number;
      checkPopularity?: boolean;
      expandKeywords?: boolean;
    };
  }): Promise<{ success: boolean; images?: GeneratedImage[]; message?: string }> => {
    // âœ… [ë¦¬íŒ©í† ë§] í†µí•© ê²€ì¦
    const check = await validateLicenseAndQuota('media', 1);
    if (!check.valid) return check.response;

    try {
      console.log('[Main] generateImagesNaverImproved í˜¸ì¶œ:', payload.items.length, 'ê°œ í•­ëª©');

      // ë„¤ì´ë²„ ì´ë¯¸ì§€ ê°œì„  ë²„ì „ ì‚¬ìš©
      const { generateWithNaverImproved } = await import('./image/naverImageGenerator.js');

      const images = await generateWithNaverImproved(
        payload.items,
        payload.postTitle || '',
        payload.postId || '',
        payload.isRegenerate || false,
        payload.sourceUrl || '',
        payload.articleUrl || '',
        payload.options || {}
      );

      console.log('[Main] generateImagesNaverImproved ì™„ë£Œ:', images.length, 'ê°œ ì´ë¯¸ì§€');
      return { success: true, images };
    } catch (error) {
      console.error('[Main] generateImagesNaverImproved ì‹¤íŒ¨:', error);
      const message = (error as Error).message ?? 'ë„¤ì´ë²„ ì´ë¯¸ì§€ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
      return { success: false, message };
    }
  },
);

// âœ… íŒŒì¼ ì¡´ì¬ í™•ì¸ IPC í•¸ë“¤ëŸ¬
ipcMain.handle('file:exists', async (_event, filePath: string): Promise<boolean> => {
  try {
    const fs = await import('fs/promises');
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
});

ipcMain.handle('automation:generateContent', async (_event, prompt: string) => {
  // âœ… [ë¦¬íŒ©í† ë§] í†µí•© ê²€ì¦
  const check = await validateLicenseAndQuota('content', 1);
  if (!check.valid) return check.response;

  try {
    const content = await generateBlogContent(prompt ?? '');
    if (await isFreeTierUser()) {
      await consumeQuota('content', 1);
    }
    return { success: true, content };
  } catch (error) {
    const message = (error as Error).message ?? 'ì½˜í…ì¸  ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
    return { success: false, message };
  }
});

// âœ… Gemini API ì—°ì† í…ŒìŠ¤íŠ¸ í•¸ë“¤ëŸ¬ (ì•± í™˜ê²½)
ipcMain.handle('gemini:test10x', async (_event, testCount?: number) => {
  const TEST_COUNT = testCount || 30; // ê¸°ë³¸ 30íšŒ

  console.log('\n' + '='.repeat(60));
  console.log(`ğŸ§ª Gemini API ${TEST_COUNT}íšŒ ì—°ì† í…ŒìŠ¤íŠ¸ ì‹œì‘ (ì•± í™˜ê²½)`);
  console.log('='.repeat(60) + '\n');

  const results: Array<{ success: boolean; elapsed?: number; retry?: number; error?: string }> = [];
  let successCount = 0;
  let totalRetries = 0;
  const MAX_RETRIES = 8;
  const RETRY_DELAYS = [3000, 5000, 8000, 10000, 15000, 20000, 25000, 30000];

  for (let i = 1; i <= TEST_COUNT; i++) {
    console.log(`í…ŒìŠ¤íŠ¸ ${i}/${TEST_COUNT}: ì‹œì‘...`);

    let lastError = '';
    let retryCount = 0;

    for (let retry = 0; retry <= MAX_RETRIES; retry++) {
      try {
        const startTime = Date.now();
        const testPrompt = `ë‹¤ìŒ ì£¼ì œë¡œ ì§§ì€ ë¸”ë¡œê·¸ ê¸€ ì œëª© 1ê°œë§Œ ìƒì„±í•´ì£¼ì„¸ìš”: "ê²¨ìš¸ì²  ê±´ê°• ê´€ë¦¬"`;

        const content = await generateBlogContent(testPrompt);
        const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);

        if (content && content.trim()) {
          results.push({ success: true, elapsed: parseFloat(elapsed), retry });
          successCount++;
          totalRetries += retry;
          console.log(`í…ŒìŠ¤íŠ¸ ${i}/${TEST_COUNT}: âœ… ì„±ê³µ (${elapsed}ì´ˆ${retry > 0 ? `, ì¬ì‹œë„ ${retry}íšŒ` : ''})`);
          break;
        }
        throw new Error('ë¹ˆ ì‘ë‹µ');

      } catch (error) {
        const errorMsg = (error as Error).message || '';
        lastError = errorMsg.substring(0, 100);

        const isRetryable =
          errorMsg.includes('503') ||
          errorMsg.includes('overloaded') ||
          errorMsg.includes('500') ||
          errorMsg.includes('502') ||
          errorMsg.includes('504') ||
          errorMsg.includes('rate') ||
          errorMsg.includes('network') ||
          errorMsg.includes('timeout');

        if (isRetryable && retry < MAX_RETRIES) {
          const delay = RETRY_DELAYS[retry];
          console.log(`  â³ ì¬ì‹œë„ ${retry + 1}/${MAX_RETRIES} (${delay / 1000}ì´ˆ ëŒ€ê¸°)`);
          await new Promise(r => setTimeout(r, delay));
          retryCount = retry + 1;
          continue;
        }

        results.push({ success: false, error: lastError, retry });
        console.log(`í…ŒìŠ¤íŠ¸ ${i}/${TEST_COUNT}: âŒ ì‹¤íŒ¨: ${lastError}`);
        break;
      }
    }

    // í…ŒìŠ¤íŠ¸ ê°„ ê°„ê²©
    if (i < TEST_COUNT) {
      await new Promise(r => setTimeout(r, 2000));
    }
  }

  // ê²°ê³¼ ìš”ì•½
  console.log('\n' + '='.repeat(60));
  console.log('ğŸ“Š í…ŒìŠ¤íŠ¸ ê²°ê³¼ ìš”ì•½');
  console.log('='.repeat(60));
  console.log(`ì´ í…ŒìŠ¤íŠ¸: ${TEST_COUNT}íšŒ`);
  console.log(`ì„±ê³µ: ${successCount}íšŒ`);
  console.log(`ì‹¤íŒ¨: ${TEST_COUNT - successCount}íšŒ`);
  console.log(`ì„±ê³µë¥ : ${((successCount / TEST_COUNT) * 100).toFixed(1)}%`);
  console.log(`ì´ ì¬ì‹œë„ íšŸìˆ˜: ${totalRetries}íšŒ`);
  console.log('='.repeat(60) + '\n');

  if (successCount === TEST_COUNT) {
    console.log('ğŸ‰ 100% ì„±ê³µ! Gemini APIê°€ ì•ˆì •ì ìœ¼ë¡œ ì‘ë™í•©ë‹ˆë‹¤.');
  }

  return {
    success: successCount === TEST_COUNT,
    total: TEST_COUNT,
    successCount,
    failCount: TEST_COUNT - successCount,
    successRate: ((successCount / TEST_COUNT) * 100).toFixed(1) + '%',
    totalRetries,
    results
  };
});

ipcMain.handle('gemini:generateVeoVideo', async (_event, payload: {
  prompt: string;
  model?: string;
  durationSeconds?: number;
  aspectRatio?: '16:9' | '9:16' | '1:1' | 'original';
  negativePrompt?: string;
  imagePath?: string;
  image?: { imageBytes: string; mimeType: string };
  heading?: string;
  videoProvider?: 'veo' | 'stability' | 'prodia' | 'kenburns'; // âœ… ì¶”ê°€
  convertToGif?: boolean; // âœ… ì¶”ê°€
}) => {
  // âœ… [ë¦¬íŒ©í† ë§] í†µí•© ê²€ì¦
  const check = await validateLicenseAndQuota('media', 1);
  if (!check.valid) return check.response;

  try {
    const config = await loadConfig();
    try {
      applyConfigToEnv(config);
    } catch {
      // ignore
    }

    const {
      prompt = '',
      model = 'veo-3.1-generate-preview',
      durationSeconds = 6,
      aspectRatio = '1:1',
      negativePrompt = '',
      videoProvider = 'veo',
      convertToGif = false,
      heading = 'AI-VIDEO',
    } = payload;

    const headingForSave = sanitizeFileName(String(heading || '').trim()) || 'AI-VIDEO';
    const mp4Dir = await ensureHeadingMp4Dir(headingForSave);

    let finalOutPath = '';
    let finalFileName = '';

    // âœ… 1. Stability AI (SVD) ë¹„ë””ì˜¤ ìƒì„±
    if (videoProvider === 'stability') {
      const stabilityApiKey = (config.stabilityApiKey || '').trim();
      if (!stabilityApiKey) throw new Error('Stability AI API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');

      sendLog(`ğŸ¬ Stability AI ë¹„ë””ì˜¤ ìƒì„± ì‹œì‘... (Heading: ${headingForSave})`);

      let videoImageBuffer: Buffer;
      const imagePath = String(payload?.imagePath || '').trim();
      const imageBytes = String(payload?.image?.imageBytes || '').trim();

      if (imageBytes) {
        videoImageBuffer = Buffer.from(imageBytes, 'base64');
      } else if (imagePath) {
        videoImageBuffer = await fs.readFile(imagePath);
      } else {
        throw new Error('Stability AI ì˜ìƒ ìƒì„±ì„ ìœ„í•œ ì´ë¯¸ì§€(imagePath ë˜ëŠ” imageBytes)ê°€ í•„ìš”í•©ë‹ˆë‹¤.');
      }

      const videoBuffer = await generateStabilityVideo(videoImageBuffer, stabilityApiKey);
      const { fullPath: outPath, fileName } = await getUniqueMp4Path(mp4Dir, headingForSave);
      await fs.writeFile(outPath, videoBuffer);

      finalOutPath = outPath;
      finalFileName = fileName;
      sendLog(`âœ… Stability AI ë¹„ë””ì˜¤ ìƒì„± ì™„ë£Œ: ${fileName}`);
    }
    // âœ… 2. Prodia (SVD) ë¹„ë””ì˜¤ ìƒì„±
    else if (videoProvider === 'prodia') {
      const prodiaToken = (config as any).prodiaToken || '';
      if (!prodiaToken) throw new Error('Prodia API í† í°ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');

      sendLog(`ğŸ¬ Prodia ë¹„ë””ì˜¤ ìƒì„± ì‹œì‘... (Heading: ${headingForSave})`);

      const axios = (await import('axios')).default;
      const imagePath = String(payload?.imagePath || '').trim();
      const imageBytes = String(payload?.image?.imageBytes || '').trim();
      let b64 = imageBytes;
      if (!b64 && imagePath) b64 = (await fs.readFile(imagePath)).toString('base64');

      const job = {
        type: 'inference.svd.v1',
        config: { image: b64 }
      };

      const startRes = await axios.post('https://inference.prodia.com/v2/job', job, {
        headers: { Authorization: `Bearer ${prodiaToken}`, Accept: 'application/octet-stream' },
        responseType: 'arraybuffer'
      });

      const { fullPath: outPath, fileName } = await getUniqueMp4Path(mp4Dir, headingForSave);
      await fs.writeFile(outPath, Buffer.from(startRes.data));

      finalOutPath = outPath;
      finalFileName = fileName;
      sendLog(`âœ… Prodia ë¹„ë””ì˜¤ ìƒì„± ì™„ë£Œ: ${fileName}`);
    }
    // âœ… 3. Veo (Gemini) ë¹„ë””ì˜¤ ìƒì„± (ê¸°ì¡´ ë¡œì§ ë³´ì „)
    else if (videoProvider === 'veo') {
      const apiKey = (process.env.GEMINI_API_KEY || '').trim();
      if (!apiKey) throw new Error('Gemini API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
      if (!prompt?.trim()) throw new Error('í”„ë¡¬í”„íŠ¸ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.');

      const pickMimeType = (filePath: string): string => {
        const p = String(filePath || '').toLowerCase();
        if (p.endsWith('.png')) return 'image/png';
        if (p.endsWith('.webp')) return 'image/webp';
        if (p.endsWith('.gif')) return 'image/gif';
        if (p.endsWith('.jpg') || p.endsWith('.jpeg')) return 'image/jpeg';
        return 'image/png';
      };

      const normalizeImageInput = async (input: string): Promise<{ imageBytes: string; mimeType: string } | undefined> => {
        const raw = String(input || '').trim();
        if (!raw) return undefined;
        if (/^data:/i.test(raw)) {
          const m = raw.match(/^data:([^;]+);base64,(.+)$/i);
          if (!m) return undefined;
          return { imageBytes: String(m[2] || '').trim(), mimeType: String(m[1] || '').trim() || 'image/png' };
        }
        if (/^https?:\/\//i.test(raw)) {
          const axios = (await import('axios')).default;
          const resp = await axios.get(raw, { responseType: 'arraybuffer', maxRedirects: 5 });
          const buf = Buffer.from(resp.data);
          const ct = String((resp.headers as any)?.['content-type'] || '').split(';')[0].trim();
          return { imageBytes: buf.toString('base64'), mimeType: ct || pickMimeType(raw) };
        }
        const buf = await fs.readFile(raw);
        return { imageBytes: buf.toString('base64'), mimeType: pickMimeType(raw) };
      };

      const imagePath = String(payload?.imagePath || '').trim();
      const imageBytes = String(payload?.image?.imageBytes || '').trim();
      const imageMimeType = String(payload?.image?.mimeType || '').trim();
      let instanceImage: { imageBytes: string; mimeType: string } | undefined = undefined;

      if (imageBytes) {
        instanceImage = { imageBytes, mimeType: imageMimeType || 'image/png' };
      } else if (imagePath) {
        instanceImage = await normalizeImageInput(imagePath);
      }

      sendLog(`ğŸ¬ Veo ì˜ìƒ ìƒì„± ì‹œì‘ (ëª¨ë¸: ${model}, ${durationSeconds}ì´ˆ)`);
      const baseUrl = 'https://generativelanguage.googleapis.com/v1beta';
      const axios = (await import('axios')).default;
      const headers = { 'x-goog-api-key': apiKey, 'Content-Type': 'application/json' };
      const instance: any = { prompt: prompt.trim() };
      if (instanceImage?.imageBytes) {
        instance.image = { bytesBase64Encoded: instanceImage.imageBytes, mimeType: instanceImage.mimeType };
      }

      const requestBody: any = { instances: [instance], parameters: { durationSeconds } };
      if (aspectRatio && aspectRatio !== 'original') {
        requestBody.parameters.aspectRatio = aspectRatio;
      }
      if (negativePrompt) requestBody.parameters.negativePrompt = negativePrompt;

      const startResp = await axios.post(`${baseUrl}/models/${encodeURIComponent(model)}:predictLongRunning`, requestBody, { headers });
      const operationName = startResp?.data?.name;
      if (!operationName) throw new Error('Veo ì‘ì—… ìƒì„± ì‹¤íŒ¨');

      const startedAt = Date.now();
      const timeoutMs = 12 * 60 * 1000;
      const pollIntervalMs = 10 * 1000;

      while (true) {
        if (Date.now() - startedAt > timeoutMs) throw new Error('Veo ìƒì„± ì‹œê°„ ì´ˆê³¼');
        await new Promise((r) => setTimeout(r, pollIntervalMs));
        const statusResp = await axios.get(`${baseUrl}/${operationName}`, { headers });
        const data = statusResp?.data;
        sendLog(`â³ Veo ìƒì„± ì¤‘... ${Math.floor((Date.now() - startedAt) / 1000)}ì´ˆ ê²½ê³¼`);

        if (data?.done === true) {
          const response = data?.response || {};
          const errMsg = data?.error?.message || response?.error?.message || response?.generateVideoResponse?.error?.message;
          if (errMsg) throw new Error(String(errMsg));

          const pickFirstTruthy = (...vals: any[]): any => {
            for (const v of vals) if (v !== undefined && v !== null && String(v).trim() !== '') return v;
            return undefined;
          };

          // âœ… ë¹„ë””ì˜¤ ë°ì´í„° ì¶”ì¶œ (ë‹¤ì–‘í•œ ì‘ë‹µ í¬ë§· ëŒ€ì‘)
          const rawVideo = pickFirstTruthy(
            response?.generateVideoResponse?.generatedSamples?.[0]?.video,
            response?.generatedVideos?.[0]?.video,
            response?.generated_videos?.[0]?.video,
            response?.video?.[0] || response?.video
          );

          let downloadUrl: string | undefined = undefined;
          const rawVideoUri = pickFirstTruthy(
            rawVideo?.uri,
            rawVideo?.downloadUri,
            rawVideo?.fileUri,
            rawVideo?.download_uri,
            rawVideo?.file_uri,
            response?.generateVideoResponse?.video?.[0]?.uri,
            response?.video?.[0]?.uri
          );

          // 1) ì§ì ‘ URLì¸ ê²½ìš° ì‚¬ìš©
          if (rawVideoUri && /^https?:\/\//i.test(String(rawVideoUri))) {
            downloadUrl = String(rawVideoUri);
          }

          // 2) íŒŒì¼ IDì¸ ê²½ìš° Files API í˜¸ì¶œ
          if (!downloadUrl) {
            let fileId = String(rawVideoUri || rawVideo?.name || '').trim();
            // files/ ê°€ ì—†ëŠ” ê²½ìš° ë³´ì •
            if (fileId && !fileId.startsWith('files/') && !fileId.startsWith('http')) {
              fileId = `files/${fileId}`;
            }

            if (fileId.startsWith('files/')) {
              try {
                const fileResp = await axios.get(`${baseUrl}/${fileId}`, { headers });
                downloadUrl = pickFirstTruthy(
                  fileResp?.data?.file?.downloadUri,
                  fileResp?.data?.downloadUri,
                  fileResp?.data?.file?.download_uri
                );
              } catch (e) {
                console.error('[Veo] íŒŒì¼ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨:', (e as Error).message);
              }
            }
          }


          if (!downloadUrl) throw new Error('ë‹¤ìš´ë¡œë“œ URLì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');

          const videoResp = await axios.get(downloadUrl, { headers: { 'x-goog-api-key': apiKey }, responseType: 'arraybuffer' });
          const { fullPath: outPath, fileName } = await getUniqueMp4Path(mp4Dir, headingForSave);
          await fs.writeFile(outPath, Buffer.from(videoResp.data));

          finalOutPath = outPath;
          finalFileName = fileName;
          sendLog(`âœ… Veo ì˜ìƒ ìƒì„± ì™„ë£Œ: ${fileName}`);
          break;
        }
      }
    } else {
      throw new Error(`ì§€ì›í•˜ì§€ ì•ŠëŠ” ë¹„ë””ì˜¤ í”„ë¡œë°”ì´ë”: ${videoProvider}`);
    }

    if (await isFreeTierUser()) {
      await consumeQuota('media', 1);
    }

    // âœ… 4. GIF ë³€í™˜ ì²˜ë¦¬
    if (convertToGif && finalOutPath && finalOutPath.endsWith('.mp4')) {
      try {
        sendLog('ğŸ”„ GIF ë³€í™˜ ì¤‘...');
        const pathModule = await import('path');
        // âœ… [Fix] GIF ë³€í™˜ ì‹œ aspectRatio ì˜µì…˜ì„ ì „ë‹¬í•˜ì—¬ 1:1 í¬ë¡­ ì ìš© (Veoê°€ 16:9 ì»¨í…Œì´ë„ˆì— 1:1 ì˜ìƒì„ ì¤„ ê²½ìš° ëŒ€ë¹„)
        const gifPath = await convertMp4ToGif(finalOutPath, { aspectRatio });
        sendLog(`âœ… GIF ë³€í™˜ ì™„ë£Œ: ${pathModule.basename(gifPath)}`);

        return {
          success: true,
          filePath: gifPath,
          fileName: pathModule.basename(gifPath),
          mp4Path: finalOutPath
        };
      } catch (gifError) {
        sendLog(`âš ï¸ GIF ë³€í™˜ ì‹¤íŒ¨: ${(gifError as Error).message}`);
        return { success: true, filePath: finalOutPath, fileName: finalFileName };
      }
    }

    // âœ… GIF ë³€í™˜ ì—†ëŠ” ì¼ë°˜ MP4 ìƒì„± ì„±ê³µ ì‘ë‹µ (ì´ì „ì— ëˆ„ë½ë˜ì–´ ìˆì—ˆìŒ!)
    return { success: true, filePath: finalOutPath, fileName: finalFileName };
  } catch (error) {
    console.error('[Gemini] generateVeoVideo ì‹¤íŒ¨:', error);
    const message = (error as Error).message || String(error);
    return { success: false, message };
  }
});

// ë„¤ì´ë²„ ë°ì´í„°ë© íŠ¸ë Œë“œ ë¶„ì„ í•¸ë“¤ëŸ¬
ipcMain.handle('datalab:getTrendSummary', async (_event, keyword: string) => {
  // âœ… ì‹¤í–‰ ì§ì „ ìµœì‹  ì„¤ì • ê°•ì œ ë™ê¸°í™”
  try {
    const config = await loadConfig();
    applyConfigToEnv(config);
  } catch (e) {
    console.error('[Main] datalab:getTrendSummary - ì„¤ì • ë™ê¸°í™” ì‹¤íŒ¨:', e);
  }

  // âœ… [ë¦¬íŒ©í† ë§] í†µí•© ê²€ì¦
  const check = await validateLicenseOnly();
  if (!check.valid) return check.response;

  try {
    const datalabClient = createDatalabClient();
    if (!datalabClient) {
      return {
        success: false,
        message: 'ë„¤ì´ë²„ ë°ì´í„°ë© APIê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í™˜ê²½ ì„¤ì •ì—ì„œ Client IDì™€ Secretì„ ì…ë ¥í•´ì£¼ì„¸ìš”.',
      };
    }

    const summary = await datalabClient.getTrendSummary(keyword);
    return {
      success: true,
      data: summary,
    };
  } catch (error) {
    return {
      success: false,
      message: `íŠ¸ë Œë“œ ë¶„ì„ ì‹¤íŒ¨: ${(error as Error).message}`,
    };
  }
});

ipcMain.handle('datalab:getSearchTrend', async (
  _event,
  keywords: string[],
  startDate: string,
  endDate: string,
  timeUnit: 'date' | 'week' | 'month' = 'date',
) => {
  // âœ… ì‹¤í–‰ ì§ì „ ìµœì‹  ì„¤ì • ê°•ì œ ë™ê¸°í™”
  try {
    const config = await loadConfig();
    applyConfigToEnv(config);
  } catch (e) {
    console.error('[Main] datalab:getSearchTrend - ì„¤ì • ë™ê¸°í™” ì‹¤íŒ¨:', e);
  }

  // âœ… [ë¦¬íŒ©í† ë§] í†µí•© ê²€ì¦
  const check = await validateLicenseOnly();
  if (!check.valid) return check.response;

  try {
    const datalabClient = createDatalabClient();
    if (!datalabClient) {
      return {
        success: false,
        message: 'ë„¤ì´ë²„ ë°ì´í„°ë© APIê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.',
      };
    }

    const trend = await datalabClient.getSearchTrend(keywords, startDate, endDate, timeUnit);
    return {
      success: true,
      data: trend,
    };
  } catch (error) {
    return {
      success: false,
      message: `ê²€ìƒ‰ íŠ¸ë Œë“œ ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}`,
    };
  }
});

// âœ… ì‹¤ì‹œê°„ íŠ¸ë Œë“œ ì•Œë¦¼ ê´€ë ¨ IPC í•¸ë“¤ëŸ¬
ipcMain.handle('trend:startMonitoring', async () => {
  try {
    if (trendMonitor.getIsMonitoring()) {
      return { success: true, message: 'ì´ë¯¸ ëª¨ë‹ˆí„°ë§ ì¤‘ì…ë‹ˆë‹¤.' };
    }

    monitorTask = trendMonitor.monitorRealtime().catch((error) => {
      sendLog(`âš ï¸ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì˜¤ë¥˜: ${(error as Error).message}`);
    });

    sendLog('ğŸ‘€ ì‹¤ì‹œê°„ íŠ¸ë Œë“œ ëª¨ë‹ˆí„°ë§ ì‹œì‘');
    return { success: true, message: 'ì‹¤ì‹œê°„ íŠ¸ë Œë“œ ëª¨ë‹ˆí„°ë§ì„ ì‹œì‘í–ˆìŠµë‹ˆë‹¤.' };
  } catch (error) {
    return { success: false, message: `ëª¨ë‹ˆí„°ë§ ì‹œì‘ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('trend:stopMonitoring', async () => {
  try {
    trendMonitor.stop();
    sendLog('ğŸ›‘ ì‹¤ì‹œê°„ íŠ¸ë Œë“œ ëª¨ë‹ˆí„°ë§ ì¤‘ì§€');
    return { success: true, message: 'ì‹¤ì‹œê°„ íŠ¸ë Œë“œ ëª¨ë‹ˆí„°ë§ì„ ì¤‘ì§€í–ˆìŠµë‹ˆë‹¤.' };
  } catch (error) {
    return { success: false, message: `ëª¨ë‹ˆí„°ë§ ì¤‘ì§€ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('trend:getStatus', async () => {
  return {
    isMonitoring: trendMonitor.getIsMonitoring(),
    alertEnabled: trendAlertEnabled,
  };
});

ipcMain.handle('trend:setAlertEnabled', async (_event, enabled: boolean) => {
  trendAlertEnabled = enabled;
  sendLog(`ğŸ”” íŠ¸ë Œë“œ ì•Œë¦¼ ${enabled ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}`);
  return { success: true, enabled };
});

ipcMain.handle('trend:getCurrentTrends', async () => {
  try {
    const trends = await trendMonitor.getCurrentTrends();
    return { success: true, trends };
  } catch (error) {
    return { success: false, message: `íŠ¸ë Œë“œ ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('trend:setInterval', async (_event, intervalMs: number) => {
  trendMonitor.setMonitorInterval(intervalMs);
  return { success: true, interval: intervalMs };
});

// âœ… AI ì–´ì‹œìŠ¤í„´íŠ¸ IPC í•¸ë“¤ëŸ¬
ipcMain.handle('aiAssistant:chat', async (_event, message: string) => {
  console.log('[AI Assistant] ë©”ì‹œì§€ ìˆ˜ì‹ :', message);
  try {
    try {
      const config = await loadConfig();
      applyConfigToEnv(config);
      try {
        masterAgent.reinitGemini();
      } catch {
        // ignore
      }
    } catch {
      // ignore
    }
    const result = await masterAgent.processMessage(message);
    console.log('[AI Assistant] ì‘ë‹µ ìƒì„± ì™„ë£Œ:', result.success);
    return result;
  } catch (error) {
    console.error('[AI Assistant] ì²˜ë¦¬ ì˜¤ë¥˜:', error);
    return {
      success: false,
      response: 'ì£„ì†¡í•´ìš”, ë¬¸ì œê°€ ë°œìƒí–ˆì–´ìš”. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
      error: { code: 'PROCESSING_ERROR', message: (error as Error).message, recoverable: true }
    };
  }
});

ipcMain.handle('aiAssistant:getWelcome', async () => {
  return { success: true, message: getWelcomeMessage() };
});

ipcMain.handle('aiAssistant:clearChat', async () => {
  try {
    masterAgent.clearChat();
    return { success: true };
  } catch (error) {
    return { success: false, message: (error as Error).message || String(error) };
  }
});

// âœ… ì‹œìŠ¤í…œ ìë™ ìˆ˜ì • IPC í•¸ë“¤ëŸ¬
ipcMain.handle('aiAssistant:runAutoFix', async () => {
  console.log('[AI Assistant] ğŸ”§ ìë™ ìˆ˜ì • ì‹œì‘...');
  const fixResults: { action: string; success: boolean; message: string }[] = [];

  try {
    const config = await loadConfig() as any;
    let configChanged = false;

    // 1. Gemini ëª¨ë¸ ìˆ˜ì • - âœ… 2026ë…„ 1ì›” ê¸°ì¤€ ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë¸ë§Œ ìœ íš¨
    const validModels = [
      'gemini-3-pro-preview',
      'gemini-3-flash-preview',
      'gemini-2.0-flash-exp',
    ];

    // âœ… ì´ì „ ëª¨ë¸ëª… â†’ ìƒˆ ëª¨ë¸ëª… ìë™ ë§ˆì´ê·¸ë ˆì´ì…˜
    const modelMigrationMap: Record<string, string> = {
      'gemini-3-pro': 'gemini-3-pro-preview',
      'gemini-3-flash': 'gemini-3-flash-preview',
      'gemini-3-pro-preview': 'gemini-3-pro-preview',
      'gemini-3-flash-preview': 'gemini-3-flash-preview',
      'gemini-2.5-pro-preview': 'gemini-3-pro-preview',
      'gemini-2.5-flash': 'gemini-3-flash-preview',
      'gemini-2.0-flash-exp': 'gemini-2.0-flash-exp',
      'gemini-2.0-flash': 'gemini-2.0-flash-exp',
      'gemini-1.5-flash': 'gemini-3-flash-preview',
      'gemini-1.5-flash-latest': 'gemini-3-flash-preview',
      'gemini-1.5-pro': 'gemini-3-pro-preview',
      'gemini-1.5-pro-latest': 'gemini-3-pro-preview',
      'gemini-1.5-flash-8b': 'gemini-3-flash-preview',
    };

    // ì €ì¥ëœ ëª¨ë¸ì´ ë§ˆì´ê·¸ë ˆì´ì…˜ ëŒ€ìƒì¸ ê²½ìš° ìë™ ë³€í™˜
    if (config.geminiModel && modelMigrationMap[config.geminiModel]) {
      const oldModel = config.geminiModel;
      config.geminiModel = modelMigrationMap[config.geminiModel];
      configChanged = true;
      fixResults.push({ action: 'Gemini ëª¨ë¸ ë§ˆì´ê·¸ë ˆì´ì…˜', success: true, message: `${oldModel} â†’ ${config.geminiModel}ë¡œ ìë™ ë³€í™˜ë¨` });
    }

    if (config.geminiModel && !validModels.includes(config.geminiModel)) {
      config.geminiModel = 'gemini-3-pro-preview';
      configChanged = true;
      fixResults.push({ action: 'Gemini ëª¨ë¸', success: true, message: 'ê¶Œì¥ ëª¨ë¸(gemini-3-pro-preview)ë¡œ ë³€ê²½ë¨' });
    }

    if (!config.geminiModel) {
      config.geminiModel = 'gemini-3-pro-preview';
      configChanged = true;
      fixResults.push({ action: 'Gemini ëª¨ë¸ ì„¤ì •', success: true, message: 'ê¸°ë³¸ ëª¨ë¸ ì„¤ì •ë¨' });
    }

    // ì„¤ì • ì €ì¥
    if (configChanged) {
      await saveConfig(config);
      console.log('[AI Assistant] âœ… ì„¤ì • ìë™ ìˆ˜ì • ì™„ë£Œ');
    }

    return {
      success: true,
      fixResults,
      message: fixResults.length > 0
        ? `âœ… ${fixResults.length}ê°œ í•­ëª© ìë™ ìˆ˜ì • ì™„ë£Œ!`
        : 'ìˆ˜ì •í•  í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤.'
    };

  } catch (error) {
    console.error('[AI Assistant] ìë™ ìˆ˜ì • ì˜¤ë¥˜:', error);
    return {
      success: false,
      fixResults,
      message: `ìë™ ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${(error as Error).message}`
    };
  }
});

// âœ… ë°œí–‰ í›„ ì„±ê³¼ ì¶”ì  IPC í•¸ë“¤ëŸ¬
ipcMain.handle('analytics:addPost', async (_event, url: string, title: string) => {
  try {
    postAnalytics.addPost(url, title);
    return { success: true, message: 'ê¸€ì´ ì¶”ì  ëª©ë¡ì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.' };
  } catch (error) {
    return { success: false, message: `ì¶”ê°€ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('analytics:startTracking', async () => {
  try {
    if (postAnalytics.getIsTracking()) {
      return { success: true, message: 'ì´ë¯¸ ì¶”ì  ì¤‘ì…ë‹ˆë‹¤.' };
    }

    analyticsTask = postAnalytics.startTracking().catch((error) => {
      sendLog(`âš ï¸ ì„±ê³¼ ì¶”ì  ì˜¤ë¥˜: ${(error as Error).message}`);
    });

    sendLog('ğŸ“Š ë°œí–‰ í›„ ì„±ê³¼ ì¶”ì  ì‹œì‘');
    return { success: true, message: 'ì„±ê³¼ ì¶”ì ì„ ì‹œì‘í–ˆìŠµë‹ˆë‹¤.' };
  } catch (error) {
    return { success: false, message: `ì¶”ì  ì‹œì‘ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('analytics:stopTracking', async () => {
  try {
    postAnalytics.stopTracking();
    sendLog('ğŸ›‘ ì„±ê³¼ ì¶”ì  ì¤‘ì§€');
    return { success: true, message: 'ì„±ê³¼ ì¶”ì ì„ ì¤‘ì§€í–ˆìŠµë‹ˆë‹¤.' };
  } catch (error) {
    return { success: false, message: `ì¶”ì  ì¤‘ì§€ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('analytics:getStatus', async () => {
  return {
    isTracking: postAnalytics.getIsTracking(),
    postCount: postAnalytics.getAllPosts().length,
  };
});

ipcMain.handle('analytics:getAllPosts', async () => {
  try {
    const posts = postAnalytics.getAllPosts();
    return { success: true, posts };
  } catch (error) {
    return { success: false, message: `ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('analytics:getAnalytics', async () => {
  try {
    const analytics = postAnalytics.getAnalytics();
    return { success: true, analytics };
  } catch (error) {
    return { success: false, message: `ë¶„ì„ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('analytics:updateMetrics', async () => {
  try {
    await postAnalytics.updateAllMetrics();
    return { success: true, message: 'ì„±ê³¼ ë°ì´í„°ê°€ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.' };
  } catch (error) {
    return { success: false, message: `ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('analytics:removePost', async (_event, postId: string) => {
  try {
    postAnalytics.removePost(postId);
    return { success: true, message: 'ê¸€ì´ ì¶”ì  ëª©ë¡ì—ì„œ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.' };
  } catch (error) {
    return { success: false, message: `ì œê±° ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

// âœ… ìµœì  ì‹œê°„ ìë™ ì˜ˆì•½ ë°œí–‰ IPC í•¸ë“¤ëŸ¬
ipcMain.handle('scheduler:getOptimalTimes', async (_event, count: number = 5, category?: string) => {
  try {
    const times = smartScheduler.getNextOptimalTimes(count, category);
    return { success: true, times };
  } catch (error) {
    return { success: false, message: `ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('scheduler:schedulePost', async (_event, title: string, keyword: string, scheduledAt: string) => {
  try {
    const post = smartScheduler.schedulePost(title, keyword, scheduledAt);
    sendLog(`ğŸ“… ì˜ˆì•½ ë°œí–‰ ë“±ë¡: ${title} (${new Date(scheduledAt).toLocaleString()})`);
    return { success: true, post };
  } catch (error) {
    return { success: false, message: `ì˜ˆì•½ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('scheduler:scheduleAtOptimal', async (_event, title: string, keyword: string, category?: string) => {
  try {
    const post = smartScheduler.scheduleAtOptimalTime(title, keyword, category);
    sendLog(`ğŸ“… ìµœì  ì‹œê°„ ì˜ˆì•½: ${title} (${new Date(post.scheduledAt).toLocaleString()})`);
    return { success: true, post };
  } catch (error) {
    return { success: false, message: `ì˜ˆì•½ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('scheduler:cancelSchedule', async (_event, postId: string) => {
  try {
    const result = smartScheduler.cancelSchedule(postId);
    if (result) {
      sendLog(`ğŸ›‘ ì˜ˆì•½ ì·¨ì†Œë¨`);
      return { success: true, message: 'ì˜ˆì•½ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.' };
    }
    return { success: false, message: 'ì·¨ì†Œí•  ìˆ˜ ì—†ëŠ” ì˜ˆì•½ì…ë‹ˆë‹¤.' };
  } catch (error) {
    return { success: false, message: `ì·¨ì†Œ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('scheduler:getAllScheduled', async () => {
  try {
    const posts = smartScheduler.getAllScheduled();
    return { success: true, posts };
  } catch (error) {
    return { success: false, message: `ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('scheduler:getPending', async () => {
  try {
    const posts = smartScheduler.getPendingScheduled();
    return { success: true, posts };
  } catch (error) {
    return { success: false, message: `ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('scheduler:reschedule', async (_event, postId: string, newTime: string) => {
  try {
    const result = smartScheduler.reschedule(postId, newTime);
    if (result) {
      sendLog(`ğŸ“… ì˜ˆì•½ ì‹œê°„ ë³€ê²½: ${new Date(newTime).toLocaleString()}`);
      return { success: true, message: 'ì˜ˆì•½ ì‹œê°„ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.' };
    }
    return { success: false, message: 'ë³€ê²½í•  ìˆ˜ ì—†ëŠ” ì˜ˆì•½ì…ë‹ˆë‹¤.' };
  } catch (error) {
    return { success: false, message: `ë³€ê²½ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

// âœ… ì‹¤íŒ¨í•œ ì˜ˆì•½ ì¦‰ì‹œ ì¬ì‹œë„
ipcMain.handle('scheduler:retry', async (_event, postId: string) => {
  try {
    // ì‹¤íŒ¨í•œ í¬ìŠ¤íŠ¸ë¥¼ ì°¾ì•„ì„œ ìƒíƒœë¥¼ pendingìœ¼ë¡œ ë³€ê²½í•˜ê³  ì¦‰ì‹œ ì‹¤í–‰
    const post = smartScheduler.getScheduledPost(postId);
    if (!post) {
      return { success: false, message: 'í•´ë‹¹ ì˜ˆì•½ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.' };
    }

    if (post.status !== 'failed') {
      return { success: false, message: 'ì‹¤íŒ¨í•œ ì˜ˆì•½ë§Œ ì¬ì‹œë„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.' };
    }

    // í˜„ì¬ ì‹œê°„ + 10ì´ˆ í›„ë¡œ ì˜ˆì•½ ë³€ê²½ (ì¦‰ì‹œ ì‹¤í–‰)
    const retryTime = new Date(Date.now() + 10 * 1000).toISOString();
    const result = smartScheduler.reschedule(postId, retryTime);

    if (result) {
      sendLog(`ğŸ”„ ì˜ˆì•½ ì¬ì‹œë„: ${post.title}`);
      return { success: true, message: 'ì¬ì‹œë„ê°€ ì˜ˆì•½ë˜ì—ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ìë™ ë°œí–‰ë©ë‹ˆë‹¤.' };
    }
    return { success: false, message: 'ì¬ì‹œë„ ì˜ˆì•½ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.' };
  } catch (error) {
    return { success: false, message: `ì¬ì‹œë„ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('scheduler:getStats', async () => {
  try {
    const stats = smartScheduler.getStats();
    return { success: true, stats };
  } catch (error) {
    return { success: false, message: `ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('scheduler:cancelAll', async () => {
  try {
    smartScheduler.cancelAll();
    sendLog(`ğŸ›‘ ëª¨ë“  ì˜ˆì•½ ì·¨ì†Œë¨`);
    return { success: true, message: 'ëª¨ë“  ì˜ˆì•½ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.' };
  } catch (error) {
    return { success: false, message: `ì·¨ì†Œ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

// âœ… í‚¤ì›Œë“œ ê²½ìŸë„ ë¶„ì„ IPC í•¸ë“¤ëŸ¬
ipcMain.handle('keyword:analyze', async (_event, keyword: string) => {
  // âœ… ì‹¤í–‰ ì§ì „ ìµœì‹  ì„¤ì • ê°•ì œ ë™ê¸°í™”
  try {
    const config = await loadConfig();
    applyConfigToEnv(config);
  } catch (e) {
    console.error('[Main] keyword:analyze - ì„¤ì • ë™ê¸°í™” ì‹¤íŒ¨:', e);
  }

  try {
    sendLog(`ğŸ” í‚¤ì›Œë“œ ë¶„ì„ ì¤‘: ${keyword}`);

    // âœ… API ì„¤ì • ë¡œë“œ
    const config = await loadConfig();

    // ë„¤ì´ë²„ ê²€ìƒ‰ API ì„¤ì • (ë¸”ë¡œê·¸/ë‰´ìŠ¤ ê²€ìƒ‰ìš©)
    if (config.naverDatalabClientId && config.naverDatalabClientSecret) {
      keywordAnalyzer.setNaverSearchConfig({
        clientId: config.naverDatalabClientId,
        clientSecret: config.naverDatalabClientSecret,
      });
      sendLog(`ğŸ“Š ë„¤ì´ë²„ ê²€ìƒ‰ API ì—°ë™ë¨`);
    }

    // ë„¤ì´ë²„ ê´‘ê³  API ì„¤ì • (ê²€ìƒ‰ëŸ‰ ë°ì´í„°ìš©)
    if (config.naverAdApiKey && config.naverAdSecretKey && config.naverAdCustomerId) {
      keywordAnalyzer.setNaverAdConfig({
        apiKey: config.naverAdApiKey,
        secretKey: config.naverAdSecretKey,
        customerId: config.naverAdCustomerId,
      });
      sendLog(`ğŸ“Š ë„¤ì´ë²„ ê´‘ê³  API ì—°ë™ë¨ - ì •í™•í•œ ê²€ìƒ‰ëŸ‰ ë°ì´í„° ì‚¬ìš©`);
    } else {
      sendLog(`âš ï¸ ë„¤ì´ë²„ ê´‘ê³  API ë¯¸ì„¤ì • - ì¶”ì •ì¹˜ ì‚¬ìš©`);
    }

    const result = await keywordAnalyzer.analyzeKeyword(keyword);
    sendLog(`âœ… í‚¤ì›Œë“œ ë¶„ì„ ì™„ë£Œ: ${keyword} (ê¸°íšŒì ìˆ˜: ${result.opportunity}, ë‚œì´ë„: ${result.difficulty})`);
    return { success: true, analysis: result };
  } catch (error) {
    return { success: false, message: `ë¶„ì„ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('keyword:findBlueOcean', async (_event, baseKeyword: string, count: number = 5) => {
  try {
    sendLog(`ğŸŒŠ ë¸”ë£¨ì˜¤ì…˜ í‚¤ì›Œë“œ ê²€ìƒ‰ ì¤‘: ${baseKeyword}`);

    // âœ… API ì„¤ì • ë¡œë“œ
    const config = await loadConfig();
    if (config.naverDatalabClientId && config.naverDatalabClientSecret) {
      keywordAnalyzer.setNaverSearchConfig({
        clientId: config.naverDatalabClientId,
        clientSecret: config.naverDatalabClientSecret,
      });
    }
    if (config.naverAdApiKey && config.naverAdSecretKey && config.naverAdCustomerId) {
      keywordAnalyzer.setNaverAdConfig({
        apiKey: config.naverAdApiKey,
        secretKey: config.naverAdSecretKey,
        customerId: config.naverAdCustomerId,
      });
    }

    const keywords = await keywordAnalyzer.findBlueOceanKeywords(baseKeyword, count);
    sendLog(`âœ… ë¸”ë£¨ì˜¤ì…˜ í‚¤ì›Œë“œ ${keywords.length}ê°œ ë°œê²¬`);
    return { success: true, keywords };
  } catch (error) {
    return { success: false, message: `ê²€ìƒ‰ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('keyword:clearCache', async () => {
  try {
    keywordAnalyzer.clearCache();
    return { success: true, message: 'ìºì‹œê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.' };
  } catch (error) {
    return { success: false, message: `ì´ˆê¸°í™” ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

// âœ… ìë™ ë¸”ë£¨ì˜¤ì…˜ í‚¤ì›Œë“œ ë°œê²¬ (ì…ë ¥ ì—†ì´ íŠ¸ë Œë“œ ê¸°ë°˜)
ipcMain.handle('keyword:discoverBlueOcean', async (_event, count: number = 10) => {
  // âœ… ì‹¤í–‰ ì§ì „ ìµœì‹  ì„¤ì • ê°•ì œ ë™ê¸°í™”
  try {
    const config = await loadConfig();
    applyConfigToEnv(config);
  } catch (e) {
    console.error('[Main] keyword:discoverBlueOcean - ì„¤ì • ë™ê¸°í™” ì‹¤íŒ¨:', e);
  }

  try {
    sendLog(`ğŸ” ìë™ ë¸”ë£¨ì˜¤ì…˜ í‚¤ì›Œë“œ ë°œê²¬ ì¤‘...`);

    // API ì„¤ì • ë¡œë“œ
    const config = await loadConfig();
    if (config.naverDatalabClientId && config.naverDatalabClientSecret) {
      keywordAnalyzer.setNaverSearchConfig({
        clientId: config.naverDatalabClientId,
        clientSecret: config.naverDatalabClientSecret,
      });
    }
    if (config.naverAdApiKey && config.naverAdSecretKey && config.naverAdCustomerId) {
      keywordAnalyzer.setNaverAdConfig({
        apiKey: config.naverAdApiKey,
        secretKey: config.naverAdSecretKey,
        customerId: config.naverAdCustomerId,
      });
    }

    const keywords = await keywordAnalyzer.discoverBlueOceanKeywords(count);
    sendLog(`âœ… ìë™ ë°œê²¬ ë¸”ë£¨ì˜¤ì…˜ í‚¤ì›Œë“œ ${keywords.length}ê°œ`);
    return { success: true, keywords };
  } catch (error) {
    return { success: false, message: `ìë™ ë°œê²¬ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

// âœ… ì¹´í…Œê³ ë¦¬ë³„ í™©ê¸ˆí‚¤ì›Œë“œ ë°œê²¬ (ì „ì²´)
ipcMain.handle('keyword:discoverGoldenByCategory', async (_event, count: number = 5) => {
  // âœ… ì‹¤í–‰ ì§ì „ ìµœì‹  ì„¤ì • ê°•ì œ ë™ê¸°í™”
  try {
    const config = await loadConfig();
    applyConfigToEnv(config);
  } catch (e) {
    console.error('[Main] keyword:discoverGoldenByCategory - ì„¤ì • ë™ê¸°í™” ì‹¤íŒ¨:', e);
  }

  try {
    sendLog(`ğŸ† ì¹´í…Œê³ ë¦¬ë³„ í™©ê¸ˆí‚¤ì›Œë“œ ë°œê²¬ ì¤‘...`);

    // API ì„¤ì • ë¡œë“œ
    const config = await loadConfig();
    if (config.naverDatalabClientId && config.naverDatalabClientSecret) {
      keywordAnalyzer.setNaverSearchConfig({
        clientId: config.naverDatalabClientId,
        clientSecret: config.naverDatalabClientSecret,
      });
    }
    if (config.naverAdApiKey && config.naverAdSecretKey && config.naverAdCustomerId) {
      keywordAnalyzer.setNaverAdConfig({
        apiKey: config.naverAdApiKey,
        secretKey: config.naverAdSecretKey,
        customerId: config.naverAdCustomerId,
      });
    }

    const result = await keywordAnalyzer.discoverGoldenKeywordsByCategory(count);
    sendLog(`âœ… ì¹´í…Œê³ ë¦¬ë³„ í™©ê¸ˆí‚¤ì›Œë“œ ë°œê²¬ ì™„ë£Œ`);
    return { success: true, ...result };
  } catch (error) {
    return { success: false, message: `ë°œê²¬ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

// âœ… ë‹¨ì¼ ì¹´í…Œê³ ë¦¬ í™©ê¸ˆí‚¤ì›Œë“œ ë°œê²¬ (ì‚¬ìš©ì ì„ íƒ)
ipcMain.handle('keyword:discoverGoldenBySingleCategory', async (_event, categoryId: string, count: number = 10) => {
  // âœ… ì‹¤í–‰ ì§ì „ ìµœì‹  ì„¤ì • ê°•ì œ ë™ê¸°í™”
  try {
    const config = await loadConfig();
    applyConfigToEnv(config);
  } catch (e) {
    console.error('[Main] keyword:discoverGoldenBySingleCategory - ì„¤ì • ë™ê¸°í™” ì‹¤íŒ¨:', e);
  }

  try {
    sendLog(`ğŸ† ${categoryId} ì¹´í…Œê³ ë¦¬ í™©ê¸ˆí‚¤ì›Œë“œ ë°œê²¬ ì¤‘...`);

    // API ì„¤ì • ë¡œë“œ
    const config = await loadConfig();
    if (config.naverDatalabClientId && config.naverDatalabClientSecret) {
      keywordAnalyzer.setNaverSearchConfig({
        clientId: config.naverDatalabClientId,
        clientSecret: config.naverDatalabClientSecret,
      });
    }
    if (config.naverAdApiKey && config.naverAdSecretKey && config.naverAdCustomerId) {
      keywordAnalyzer.setNaverAdConfig({
        apiKey: config.naverAdApiKey,
        secretKey: config.naverAdSecretKey,
        customerId: config.naverAdCustomerId,
      });
    }

    const result = await keywordAnalyzer.discoverGoldenKeywordsBySingleCategory(categoryId, count);
    sendLog(`âœ… ${categoryId} ì¹´í…Œê³ ë¦¬ í™©ê¸ˆí‚¤ì›Œë“œ ${result.keywords.length}ê°œ ë°œê²¬`);
    return result;
  } catch (error) {
    return { success: false, message: `ë°œê²¬ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

// âœ… ìë™ ë‚´ë¶€ë§í¬ ì‚½ì… IPC í•¸ë“¤ëŸ¬
ipcMain.handle('internalLink:addPost', async (_event, url: string, title: string, content?: string) => {
  try {
    internalLinkManager.addPostFromUrl(url, title, content);
    return { success: true, message: 'ê¸€ì´ ë‚´ë¶€ë§í¬ ëª©ë¡ì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.' };
  } catch (error) {
    return { success: false, message: `ì¶”ê°€ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('internalLink:findRelated', async (_event, title: string, content: string, maxResults?: number) => {
  try {
    const links = internalLinkManager.findRelatedPosts(title, content, maxResults);
    return { success: true, links };
  } catch (error) {
    return { success: false, message: `ê²€ìƒ‰ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('internalLink:insertLinks', async (_event, content: string, title: string, options?: any) => {
  try {
    const result = internalLinkManager.insertInternalLinks(content, title, options);
    return { success: true, result };
  } catch (error) {
    return { success: false, message: `ì‚½ì… ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('internalLink:getAllPosts', async () => {
  try {
    const posts = internalLinkManager.getAllPosts();
    return { success: true, posts };
  } catch (error) {
    return { success: false, message: `ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('internalLink:getStats', async () => {
  try {
    const stats = internalLinkManager.getStats();
    return { success: true, stats };
  } catch (error) {
    return { success: false, message: `ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

// âœ… ì¸ë„¤ì¼ ìë™ ìƒì„± IPC í•¸ë“¤ëŸ¬
ipcMain.handle('thumbnail:generateSvg', async (_event, title: string, options?: any, category?: string) => {
  try {
    const svg = thumbnailGenerator.generateSvgThumbnail(title, options, category);
    return { success: true, svg };
  } catch (error) {
    return { success: false, message: `ìƒì„± ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('thumbnail:getStyles', async () => {
  try {
    const styles = thumbnailGenerator.getAvailableStyles();
    return { success: true, styles };
  } catch (error) {
    return { success: false, message: `ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('thumbnail:getCategories', async () => {
  try {
    const categories = thumbnailGenerator.getAvailableCategories();
    return { success: true, categories };
  } catch (error) {
    return { success: false, message: `ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

// âœ… ë‹¤ì¤‘ ë¸”ë¡œê·¸ ê´€ë¦¬ IPC í•¸ë“¤ëŸ¬
ipcMain.handle('account:add', async (_event, name: string, blogId: string, naverId?: string, naverPassword?: string, settings?: any) => {
  try {
    const account = blogAccountManager.addAccount(name, blogId, naverId, naverPassword, settings);

    // âœ… ê³„ì • ì¶”ê°€ ì‹œ íŒ¨ë„ì— ë™ê¸°í™”
    reportUserActivity().catch(err => console.error('[Main] Sync after add failed:', err));

    return { success: true, account };
  } catch (error) {
    return { success: false, message: `ì¶”ê°€ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

// âœ… ê³„ì • ë¡œê·¸ì¸ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
ipcMain.handle('account:getCredentials', async (_event, accountId: string) => {
  try {
    const credentials = blogAccountManager.getAccountCredentials(accountId);
    return { success: true, credentials };
  } catch (error) {
    return { success: false, message: `ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

// âœ… ê³„ì • ë¡œê·¸ì¸ ì •ë³´ ì—…ë°ì´íŠ¸
ipcMain.handle('account:updateCredentials', async (_event, accountId: string, naverId: string, naverPassword: string) => {
  try {
    const result = blogAccountManager.updateAccountCredentials(accountId, naverId, naverPassword);
    return { success: result, message: result ? 'ë¡œê·¸ì¸ ì •ë³´ ì—…ë°ì´íŠ¸ ì™„ë£Œ' : 'ê³„ì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.' };
  } catch (error) {
    return { success: false, message: `ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('account:update', async (_event, accountId: string, updates: any) => {
  try {
    const success = blogAccountManager.updateAccount(accountId, updates);
    if (success) {
      // âœ… ê³„ì • ìˆ˜ì • ì‹œ íŒ¨ë„ì— ë™ê¸°í™”
      reportUserActivity().catch(err => console.error('[Main] Sync after update failed:', err));
    }
    return { success };
  } catch (error) {
    return { success: false, message: `ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('account:remove', async (_event, accountId: string) => {
  try {
    const success = blogAccountManager.removeAccount(accountId);
    if (success) {
      // âœ… ê³„ì • ì‚­ì œ ì‹œ íŒ¨ë„ì— ë™ê¸°í™”
      reportUserActivity().catch(err => console.error('[Main] Sync after remove failed:', err));
    }
    return { success };
  } catch (error) {
    return { success: false, message: `ì‚­ì œ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('account:setActive', async (_event, accountId: string) => {
  try {
    const result = blogAccountManager.setActiveAccount(accountId);
    return { success: result };
  } catch (error) {
    return { success: false, message: `ì„¤ì • ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('account:getActive', async () => {
  try {
    const account = blogAccountManager.getActiveAccount();
    return { success: true, account };
  } catch (error) {
    return { success: false, message: `ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('account:getAll', async () => {
  try {
    const accounts = blogAccountManager.getAllAccounts();
    return { success: true, accounts };
  } catch (error) {
    return { success: false, message: `ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('account:getNext', async () => {
  try {
    const account = blogAccountManager.getNextAccountForPublish();
    return { success: true, account };
  } catch (error) {
    return { success: false, message: `ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('account:getStats', async (_event, accountId: string) => {
  try {
    const stats = blogAccountManager.getAccountStats(accountId);
    return { success: true, stats };
  } catch (error) {
    return { success: false, message: `ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('account:getTotalStats', async () => {
  try {
    const stats = blogAccountManager.getTotalStats();
    return { success: true, stats };
  } catch (error) {
    return { success: false, message: `ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('account:toggle', async (_event, accountId: string) => {
  try {
    const isActive = blogAccountManager.toggleAccountActive(accountId);

    // âœ… í™œì„±í™” ìƒíƒœ ë³€ê²½ ì‹œ íŒ¨ë„ì— ë™ê¸°í™”
    reportUserActivity().catch(err => console.error('[Main] Sync after toggle failed:', err));

    return { success: true, isActive };
  } catch (error) {
    return { success: false, message: `í† ê¸€ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('account:recordPublish', async (_event, accountId: string) => {
  try {
    blogAccountManager.recordPublish(accountId);
    return { success: true };
  } catch (error) {
    return { success: false, message: `ê¸°ë¡ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

// âœ… ê³„ì • ì„¤ì • ì—…ë°ì´íŠ¸ (ê°œë³„ ì„¤ì • í¬í•¨)
ipcMain.handle('account:updateSettings', async (_event, accountId: string, settings: any) => {
  try {
    const result = blogAccountManager.updateAccountSettings(accountId, settings);
    return { success: result, message: result ? 'ì„¤ì • ì—…ë°ì´íŠ¸ ì™„ë£Œ' : 'ê³„ì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.' };
  } catch (error) {
    return { success: false, message: `ì„¤ì • ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

// âœ… ê³„ì •ë³„ ë‹¤ìŒ ì½˜í…ì¸  ì†ŒìŠ¤ ê°€ì ¸ì˜¤ê¸°
ipcMain.handle('account:getNextContentSource', async (_event, accountId: string) => {
  try {
    const source = blogAccountManager.getNextContentSource(accountId);
    return { success: true, source };
  } catch (error) {
    return { success: false, message: `ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

// âœ… ë„¤ì´ë²„ ë¸”ë¡œê·¸ ì¹´í…Œê³ ë¦¬ ë¶„ì„ (í¬ë¡¤ë§)
ipcMain.handle('blog:fetchCategories', async (_event, arg: string | { naverId?: string; blogId?: string }) => {
  // âœ… ì‹¤í–‰ ì§ì „ ìµœì‹  ì„¤ì • ê°•ì œ ë™ê¸°í™”
  try {
    const config = await loadConfig();
    applyConfigToEnv(config);
  } catch (e) {
    console.error('[Main] blog:fetchCategories - ì„¤ì • ë™ê¸°í™” ì‹¤íŒ¨:', e);
  }

  try {
    const blogId = typeof arg === 'string' ? arg : (arg.naverId || arg.blogId || '');
    console.log('[Main] ë¸”ë¡œê·¸ ì¹´í…Œê³ ë¦¬ ë¶„ì„ ì‹œì‘:', blogId);

    if (!blogId || !blogId.trim()) {
      return { success: false, message: 'ë¸”ë¡œê·¸ IDê°€ í•„ìš”í•©ë‹ˆë‹¤.' };
    }

    // âœ… 1ë‹¨ê³„: ë”¥ ëª¨ë°”ì¼ API í˜¸ì¶œ (Axios ê¸°ë°˜, ê°€ì¥ ê°•ë ¥í•˜ê³  ì •í™•í•¨)
    try {
      console.log('[Main] Stage 1: ë”¥ ëª¨ë°”ì¼ API ì‹œë„...', blogId);
      const apiUrl = `https://m.blog.naver.com/api/blogs/${blogId.trim()}/category-list`;
      const apiRes = await axios.get(apiUrl, {
        timeout: 7000,
        headers: {
          'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1',
          'Referer': `https://m.blog.naver.com/${blogId.trim()}`,
          'Accept': 'application/json, text/plain, */*'
        }
      });

      if (apiRes.data && apiRes.data.isSuccess && apiRes.data.result && apiRes.data.result.mylogCategoryList) {
        const rawList = apiRes.data.result.mylogCategoryList;
        const categories: Array<{ id: string; name: string; postCount?: number }> = [];

        rawList.forEach((c: any) => {
          // êµ¬ë¶„ì„ (divisionLine) ì œì™¸, ê³µê°œëœ ì¹´í…Œê³ ë¦¬ë§Œ í¬í•¨
          if (c.divisionLine || c.categoryNo === '0' || c.categoryNo === 0) return;

          let cleanName = String(c.categoryName).trim();
          // í•˜ìœ„ ì¹´í…Œê³ ë¦¬ì¸ ê²½ìš° ì‹œê°ì  ê³„ì¸µ í‘œí˜„ ì¶”ê°€
          if (c.childCategory && c.parentCategoryNo) {
            cleanName = ` â”” ${cleanName}`;
          }

          categories.push({
            id: String(c.categoryNo),
            name: cleanName,
            postCount: c.postCnt
          });
        });

        if (categories.length > 0) {
          console.log('[Main] Stage 1 ì„±ê³µ:', categories.length, 'ê°œ ì¶”ì¶œ ì™„ë£Œ');
          return { success: true, categories };
        }
      }
    } catch (e) {
      console.warn('[Main] Stage 1 ì‹¤íŒ¨ (API ì°¨ë‹¨ ë˜ëŠ” ë¹„ê³µê°œ), Stage 2ë¡œ ì „í™˜:', (e as Error).message);
    }

    // âœ… 2ë‹¨ê³„: ëª¨ë°”ì¼ í˜ì´ì§€ ë¶„ì„ (Puppeteer ê¸°ë°˜, ìµœí›„ì˜ ë³´ë£¨)
    const puppeteer = await import('puppeteer-extra');
    const StealthPlugin = await import('puppeteer-extra-plugin-stealth');
    const puppeteerWithStealth = puppeteer.default as any;
    puppeteerWithStealth.use((StealthPlugin as any).default());

    const browser = await puppeteerWithStealth.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-gpu'],
    });

    try {
      const page = await browser.newPage();
      await page.setViewport({ width: 375, height: 812, isMobile: true });
      await page.setUserAgent('Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1');

      // ë¦¬ì†ŒìŠ¤ ì›ì²œ ì°¨ë‹¨ìœ¼ë¡œ ì†ë„ ê·¹ëŒ€í™”
      await page.setRequestInterception(true);
      page.on('request', (req: any) => {
        if (['image', 'font', 'media', 'stylesheet'].includes(req.resourceType())) {
          req.abort();
        } else {
          req.continue();
        }
      });

      console.log('[Main] Stage 2: ëª¨ë°”ì¼ í˜ì´ì§€ ë¶„ì„ ì¤‘...');
      const mobileUrl = `https://m.blog.naver.com/PostList.naver?blogId=${blogId.trim()}`;

      try {
        await page.goto(mobileUrl, { waitUntil: 'domcontentloaded', timeout: 20000 });
        // React hydration ë° ë™ì  ë¦¬ìŠ¤íŠ¸ ë Œë”ë§ ëŒ€ê¸°
        await new Promise(resolve => setTimeout(resolve, 2000));
      } catch (e) {
        console.warn('[Main] í˜ì´ì§€ ë¡œë”© íƒ€ì„ì•„ì›ƒ, í˜„ì¬ DOMì—ì„œ ì¶”ì¶œ ì‹œë„');
      }

      const categories = await page.evaluate(() => {
        const results: Array<{ id: string; name: string; postCount?: number }> = [];
        // ëª¨ë“  ë§í¬ ì¤‘ categoryNoë¥¼ í¬í•¨í•˜ëŠ” í•­ëª© ìŠ¤ìº” (ë²”ìš©ì  ëŒ€ì‘)
        const links = Array.from(document.querySelectorAll('a[href*="categoryNo="]'));

        links.forEach(link => {
          const href = (link as HTMLAnchorElement).href || '';
          const text = (link.textContent || '').trim();
          const match = href.match(/categoryNo=(\d+)/);

          if (match && text && match[1] !== '0' && text !== 'ì „ì²´ë³´ê¸°' && text.length < 100) {
            const id = match[1];
            if (!results.some(r => r.id === id)) {
              // ê²Œì‹œê¸€ ìˆ˜ ì¶”ì¶œ (ê´„í˜¸ ì•ˆì˜ ìˆ«ì)
              const countMatch = text.match(/\((\d+)\)/);
              const cleanName = text.replace(/\(\d+\)/, '').trim();

              if (cleanName) {
                results.push({
                  id,
                  name: cleanName,
                  postCount: countMatch ? parseInt(countMatch[1], 10) : undefined
                });
              }
            }
          }
        });
        return results;
      });

      await browser.close();

      if (categories.length > 0) {
        console.log('[Main] Stage 2 ì„±ê³µ:', categories.length, 'ê°œ ì¶”ì¶œ ì™„ë£Œ');
        return { success: true, categories };
      }

      return {
        success: true,
        categories: [{ id: '0', name: 'ì „ì²´ (ê¸°ë³¸)' }],
        message: 'ì¹´í…Œê³ ë¦¬ë¥¼ ë¶„ì„í•˜ì§€ ëª»í•´ ê¸°ë³¸ ëª©ë¡ì„ ì œê³µí•©ë‹ˆë‹¤.'
      };

    } catch (error) {
      await browser.close();
      throw error;
    }

  } catch (error) {
    console.error('[Main] ë¸”ë¡œê·¸ ì¹´í…Œê³ ë¦¬ ë¶„ì„ ì˜¤ë¥˜:', error);
    return { success: false, message: `ì¹´í…Œê³ ë¦¬ ë¶„ì„ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

// âœ… ë‹¤ì¤‘ê³„ì • ë™ì‹œë°œí–‰ (ë³‘ë ¬ ì²˜ë¦¬)
ipcMain.handle('multiAccount:publish', async (_event, accountIds: string[], options: any) => {
  // âœ… ì‹¤í–‰ ì§ì „ ìµœì‹  ì„¤ì • ê°•ì œ ë™ê¸°í™”
  try {
    const config = await loadConfig();
    applyConfigToEnv(config);
  } catch (e) {
    console.error('[Main] multiAccount:publish - ì„¤ì • ë™ê¸°í™” ì‹¤íŒ¨:', e);
  }

  if (!(await ensureLicenseValid())) {
    return { success: false, message: 'ë¼ì´ì„ ìŠ¤ ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤. ë¼ì´ì„ ìŠ¤ë¥¼ ì¸ì¦í•´ì£¼ì„¸ìš”.' };
  }

  const publishAmount = Array.isArray(accountIds) ? accountIds.length : 0;
  const publishCheck = await enforceFreeTier('publish', publishAmount);
  if (!publishCheck.allowed) {
    return publishCheck.response;
  }

  try {
    // âœ… ì¦‰ì‹œ ì¤‘ì§€ í”Œë˜ê·¸ ì´ˆê¸°í™”
    multiAccountAbortFlag = false;
    activeMultiAccountAutomations.length = 0;

    sendLog(`ğŸš€ ë‹¤ì¤‘ê³„ì • ë™ì‹œë°œí–‰ ì‹œì‘: ${accountIds.length}ê°œ ê³„ì •`);
    const config = await loadConfig(); // âœ… API í‚¤ ë¡œë“œë¥¼ ìœ„í•´ ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸°

    const results: Array<{ accountId: string; success: boolean; message?: string; url?: string }> = [];

    // ë³‘ë ¬ë¡œ ë°œí–‰ ì‹¤í–‰ (ìµœëŒ€ 10ê°œ)
    const publishPromises = accountIds.slice(0, 10).map(async (accountId) => {
      // âœ… ì¦‰ì‹œ ì¤‘ì§€ í”Œë˜ê·¸ ì²´í¬
      if (multiAccountAbortFlag) {
        return { accountId, success: false, message: 'ì‚¬ìš©ìì— ì˜í•´ ì¤‘ì§€ë¨' };
      }

      const account = blogAccountManager.getAccount(accountId);
      if (!account) {
        return { accountId, success: false, message: 'ê³„ì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.' };
      }

      const credentials = blogAccountManager.getAccountCredentials(accountId);
      if (!credentials) {
        return { accountId, success: false, message: 'ë¡œê·¸ì¸ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.' };
      }

      // ê³„ì •ë³„ ì½˜í…ì¸  ì†ŒìŠ¤ ê°€ì ¸ì˜¤ê¸°
      const contentSource = blogAccountManager.getNextContentSource(accountId);

      try {
        sendLog(`ğŸ‘¤ [${account.name}] ë°œí–‰ ì‹œì‘...`);

        // âœ… ë‹¤ì¤‘ê³„ì • ì„¸ì…˜ ì¬ì‚¬ìš© ë¡œì§ ì¶”ê°€
        const normalizedId = String(credentials.naverId || '').trim().toLowerCase();
        let accountAutomation = automationMap.get(normalizedId);

        if (accountAutomation) {
          sendLog(`â™»ï¸ [${account.name}] ê¸°ì¡´ ë¸Œë¼ìš°ì € ì„¸ì…˜ ì¬ì‚¬ìš©`);
        } else {
          // ì‹ ê·œ ìƒì„±
          accountAutomation = new NaverBlogAutomation(
            {
              naverId: credentials.naverId,
              naverPassword: credentials.naverPassword,
              headless: false,
              slowMo: 10,
            },
            (message) => sendLog(`[${account.name}] ${message}`),
          );
          automationMap.set(normalizedId, accountAutomation);
        }

        // âœ… ì¦‰ì‹œ ì¤‘ì§€ë¥¼ ìœ„í•´ í™œì„± ìë™í™” ë°°ì—´ì— ë“±ë¡
        activeMultiAccountAutomations.push(accountAutomation);

        // âœ… ì¸ìŠ¤í„´ìŠ¤ ìƒì„± í›„ ì·¨ì†Œ í”Œë˜ê·¸ ì²´í¬
        if (multiAccountAbortFlag) {
          await accountAutomation.closeBrowser();
          return { accountId, success: false, message: 'ì‚¬ìš©ìì— ì˜í•´ ì¤‘ì§€ë¨' };
        }

        // ë°œí–‰ ì˜µì…˜ êµ¬ì„±
        const publishOptions: any = {
          publishMode: account.settings.publishMode || 'publish',
          toneStyle: account.settings.toneStyle || 'friendly',
          skipImages: account.settings.imageSource === 'skip',
          isFullAuto: true, // âœ… ë‹¤ì¤‘ê³„ì • í’€ì˜¤í†  ëª¨ë“œ ëª…ì‹œ
          ...options,
        };

        // âœ… preGeneratedContentê°€ ìˆìœ¼ë©´ structuredContentë¡œ ë³€í™˜
        if (options?.preGeneratedContent) {
          const preGen = options.preGeneratedContent;
          publishOptions.title = preGen.title;
          publishOptions.content = preGen.content;
          publishOptions.hashtags = preGen.hashtags ? preGen.hashtags.split(' ').filter((h: string) => h) : [];

          // structuredContentê°€ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©
          if (preGen.structuredContent) {
            publishOptions.structuredContent = preGen.structuredContent;
          }

          // ìƒì„±ëœ ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ imagesë¡œ ë³€í™˜
          if (preGen.generatedImages && preGen.generatedImages.length > 0) {
            publishOptions.images = preGen.generatedImages.map((img: any) => ({
              heading: img.heading,
              filePath: img.filePath || img.url,
              provider: img.provider,
              alt: img.heading,
            }));
          }

          sendLog(`[${account.name}] ë¯¸ë¦¬ ìƒì„±ëœ ì½˜í…ì¸  ì‚¬ìš©: "${preGen.title?.substring(0, 30)}..."`);
        }
        // ì½˜í…ì¸  ì†ŒìŠ¤ì— ë”°ë¼ í‚¤ì›Œë“œ ë˜ëŠ” URL ì„¤ì •
        else if (contentSource) {
          try {
            const provider = (options?.generator || 'gemini') as any;
            const toneStyle = String(publishOptions.toneStyle || 'friendly');
            const cm = (options?.contentMode || 'seo') as 'seo' | 'homefeed';
            const rawArticleType = String(options?.articleType || account.settings?.category || 'general');
            const allowedArticleTypes = new Set<ArticleType>([
              'news',
              'sports',
              'health',
              'finance',
              'general',
              'it_review',
              'shopping_review',
              'product_review',
              'place_review',
              'restaurant_review',
              'travel',
              'food',
              'recipe',
              'fashion',
              'beauty',
              'interior',
              'parenting',
              'education',
              'learning',
              'hobby',
              'culture',
              'entertainment',
              'tips',
              'howto',
              'guide',
            ]);
            const articleType: ArticleType = allowedArticleTypes.has(rawArticleType as ArticleType)
              ? (rawArticleType as ArticleType)
              : 'general';

            const assembly: any = {
              generator: provider,
              toneStyle,
              targetAge: 'all',
              articleType,
              contentMode: cm,
              isFullAuto: true,
            };

            if (contentSource.type === 'keyword') {
              assembly.keywords = [String(contentSource.value || '').trim()].filter(Boolean);
              assembly.draftText = String(contentSource.value || '').trim();
              sendLog(`[${account.name}] í‚¤ì›Œë“œ: ${contentSource.value}`);
            } else {
              assembly.rssUrl = [String(contentSource.value || '').trim()].filter(Boolean);
              sendLog(`[${account.name}] URL: ${contentSource.value}`);
            }

            const { source } = await assembleContentSource(assembly);
            source.contentMode = cm;
            source.isFullAuto = true;
            source.articleType = articleType;

            const structuredContent = await generateStructuredContent(source, { provider, minChars: 2000 });
            publishOptions.structuredContent = structuredContent;
            // âœ… ì‚¬ìš©ì/ì˜µì…˜ìœ¼ë¡œ ë„˜ì–´ì˜¨ ì œëª©/ë³¸ë¬¸/í•´ì‹œíƒœê·¸ê°€ ìˆìœ¼ë©´ ìš°ì„  ìœ ì§€
            publishOptions.title = publishOptions.title || structuredContent.selectedTitle;
            // âœ… ë³¸ë¬¸ì—ì„œ "ì²« ë²ˆì§¸ ì†Œì œëª©:", "ë‘ ë²ˆì§¸ ì†Œì œëª©:" ë“± ì˜ëª»ëœ ë ˆì´ë¸” ìë™ ì œê±°
            const rawBody = publishOptions.content || structuredContent.bodyPlain || structuredContent.content || '';
            publishOptions.content = removeOrdinalHeadingLabelsFromBody(rawBody);
            publishOptions.hashtags = (Array.isArray(publishOptions.hashtags) && publishOptions.hashtags.length > 0)
              ? publishOptions.hashtags
              : (Array.isArray(structuredContent.hashtags) ? structuredContent.hashtags : []);
            sendLog(`[${account.name}] âœ… AI ì½˜í…ì¸  ìë™ ìƒì„± ì™„ë£Œ: "${String(structuredContent.selectedTitle || '').substring(0, 30)}..."`);

            // âœ… ì´ë¯¸ì§€ ìƒì„± ë¡œì§ ê°œì„  (imageSourceê°€ skipì´ ì•„ë‹Œ ê²½ìš° headings ê¸°ë°˜ìœ¼ë¡œ ìƒì„±)
            const imageSource = (options?.imageSource || account.settings?.imageSource || 'nano-banana-pro') as any;
            const headings = structuredContent.headings || [];

            if (publishOptions.skipImages === false && imageSource !== 'skip' && headings.length > 0) {
              try {
                sendLog(`[${account.name}] ğŸ¨ ì´ë¯¸ì§€ ìƒì„± ì¤‘... (ì œê³µì: ${imageSource})`);

                // headingsì—ì„œ ì´ë¯¸ì§€ í”„ë¡¬í”„íŠ¸ ìƒì„±
                const imageItems = (structuredContent.headings || headings.slice(0, 5)).map((h: any, idx: number) => ({
                  heading: h.title || h,
                  prompt: h.imagePrompt || h.title || h,
                  isThumbnail: idx === 0,
                  allowText: idx === 0 && options?.includeThumbnailText, // âœ… ì¸ë„¤ì¼ í…ìŠ¤íŠ¸ ì˜µì…˜ ì „ë‹¬
                }));

                // âœ… [ê³ ë„í™”] ì‡¼í•‘ì»¤ë„¥íŠ¸ ëª¨ë“œ: ì§€ëŠ¥í˜• ë§¤ì¹­ ìˆ˜í–‰ (ì†Œì œëª©ë³„ ìµœì  ì°¸ì¡° ì´ë¯¸ì§€ í• ë‹¹)
                const collectedImgs = (contentSource as any).images || (options?.collectedImages) || [];
                if (imageSource === 'nano-banana-pro' && Array.isArray(collectedImgs) && collectedImgs.length > 0 && (config.geminiApiKey || process.env.GEMINI_API_KEY)) {
                  try {
                    const imagePlacer = new IntelligentImagePlacer(config.geminiApiKey || process.env.GEMINI_API_KEY || '');
                    const headingsWithContent = (structuredContent.headings || headings.slice(0, 5)).map((h: any, idx: number) => ({
                      index: idx,
                      title: h.title || h,
                      content: h.summary || h.content || '',
                      keywords: h.keywords || [h.title || h],
                    }));
                    const collectedImagesForPlacer = collectedImgs.map((img: any) => ({
                      id: typeof img === 'string' ? img : (img.id || img.url),
                      url: typeof img === 'string' ? img : (img.url || img.thumbnailUrl),
                      thumbnailUrl: typeof img === 'string' ? img : (img.url || img.thumbnailUrl),
                      source: (img as any).source || 'shopping-mall',
                      title: (img as any).title || 'Product Image',
                      tags: (img as any).tags || [],
                      photographer: '',
                      license: 'unknown',
                    }));

                    const assignments = await imagePlacer.autoMatchImagesForFullAuto(headingsWithContent, collectedImagesForPlacer);
                    assignments.forEach(assignment => {
                      const targetIdx = assignment.headingIndex;
                      if (imageItems[targetIdx]) {
                        (imageItems[targetIdx] as any).referenceImagePath = assignment.assignedImage.url;
                      }
                    });
                    sendLog(`[${account.name}] ğŸ¤– AI ì§€ëŠ¥í˜• ì´ë¯¸ì§€ ë§¤ì¹­ ì™„ë£Œ (${assignments.length}ê°œ ì†Œì œëª©)`);
                  } catch (matchErr) {
                    sendLog(`[${account.name}] âš ï¸ ì§€ëŠ¥í˜• ë§¤ì¹­ ì‹¤íŒ¨ (ê¸°ë³¸ ì°¸ì¡° ì‚¬ìš©): ${(matchErr as Error).message}`);
                  }
                }

                // âœ… ì‡¼í•‘ì»¤ë„¥íŠ¸ ëª¨ë“œ ì—¬ë¶€ í™•ì¸
                const isShoppingConnect = (options as any).isShoppingConnect === true || options?.contentMode === 'affiliate' || !!publishOptions.affiliateLink;

                // âœ… ì‡¼í•‘ì»¤ë„¥íŠ¸ ëª¨ë“œ: ì²« ë²ˆì§¸ ìˆ˜ì§‘ ì´ë¯¸ì§€ë¥¼ ì°¸ì¡° ì´ë¯¸ì§€ë¡œ ì‚¬ìš© (ì „ì—­ í´ë°±ìš©)
                let referenceImagePath = '';
                if (imageSource === 'nano-banana-pro') {
                  const firstCollected = (contentSource as any).images?.[0] || (options?.collectedImages?.[0]?.url) || (options?.collectedImages?.[0]);
                  if (firstCollected) {
                    referenceImagePath = typeof firstCollected === 'string' ? firstCollected : (firstCollected.url || firstCollected.filePath);
                    // ì¸ë„¤ì¼ì— ëª…ì‹œì ìœ¼ë¡œ í• ë‹¹
                    if (imageItems[0] && !(imageItems[0] as any).referenceImagePath) {
                      (imageItems[0] as any).referenceImagePath = referenceImagePath;
                    }
                  }
                }

                // âœ… ì‡¼í•‘ì»¤ë„¥íŠ¸ í™œì„±í™” ì‹œ ì¸ë„¤ì¼ í…ìŠ¤íŠ¸ ë¬´ì¡°ê±´ í—ˆìš©
                if (isShoppingConnect && imageItems[0]) {
                  imageItems[0].allowText = true;
                }

                const imageOptions: GenerateImagesOptions = {
                  items: imageItems,
                  provider: imageSource,
                  postId: `${accountId}_${Date.now()}`,
                  postTitle: structuredContent.selectedTitle || publishOptions.title,
                  isFullAuto: true,
                  referenceImagePath, // âœ… ì°¸ì¡° ì´ë¯¸ì§€ ì „ë‹¬
                  isShoppingConnect, // âœ… ì‡¼í•‘ì»¤ë„¥íŠ¸ ì—¬ë¶€ ì „ë‹¬
                  collectedImages: (options as any).collectedImages || (contentSource as any).images || [], // âœ… ìˆ˜ì§‘ ì´ë¯¸ì§€ ëª©ë¡ ì „ë‹¬
                };

                const apiKeys = {
                  geminiApiKey: process.env.GEMINI_API_KEY || config.geminiApiKey,
                  prodiaToken: config.prodiaToken,
                  stabilityApiKey: config.stabilityApiKey,
                  falaiApiKey: config.falaiApiKey,
                };

                const generatedImages = await generateImages(imageOptions, apiKeys);

                if (generatedImages && generatedImages.length > 0) {
                  publishOptions.images = generatedImages.map((img: any) => ({
                    heading: img.heading,
                    filePath: img.filePath || img.url,
                    provider: img.provider,
                    alt: img.heading,
                  }));
                  sendLog(`[${account.name}] âœ… ì´ë¯¸ì§€ ${generatedImages.length}ê°œ ìƒì„± ì™„ë£Œ`);
                }
              } catch (imgError) {
                sendLog(`[${account.name}] âš ï¸ ì´ë¯¸ì§€ ìƒì„± ì‹¤íŒ¨ (ì´ë¯¸ì§€ ì—†ì´ ê³„ì†): ${(imgError as Error).message}`);
              }
            }
          } catch (e) {
            sendLog(`[${account.name}] âš ï¸ ì½˜í…ì¸  ìë™ ìƒì„± ì‹¤íŒ¨, ì œê³µëœ í…ìŠ¤íŠ¸ë¡œ ì§„í–‰: ${(e as Error).message}`);
          }
        }

        // ë°œí–‰ ì‹¤í–‰
        const runResult = await accountAutomation.run(publishOptions);

        // ë°œí–‰ ê¸°ë¡ ì—…ë°ì´íŠ¸
        blogAccountManager.recordPublish(accountId);

        const publishedUrl = runResult?.url || accountAutomation.getPublishedUrl();

        // ë¸Œë¼ìš°ì € ì •ë¦¬ (ì˜µì…˜ì— ë”°ë¼ ìœ ì§€)
        if (!publishOptions.keepBrowserOpen) {
          await accountAutomation.closeBrowser();
          automationMap.delete(normalizedId);
          if (automation === accountAutomation) {
            automation = null;
          }
        }

        sendLog(`âœ… [${account.name}] ë°œí–‰ ì™„ë£Œ!`);
        return { accountId, success: true, url: publishedUrl || undefined };
      } catch (error) {
        const errorMsg = translatePuppeteerError(error as Error);
        sendLog(`âŒ [${account.name}] ë°œí–‰ ì‹¤íŒ¨: ${errorMsg}`);
        return { accountId, success: false, message: errorMsg };
      }
    });

    // ëª¨ë“  ë°œí–‰ ì™„ë£Œ ëŒ€ê¸°
    const publishResults = await Promise.all(publishPromises);
    results.push(...publishResults);

    const successCount = results.filter(r => r.success).length;
    const failCount = results.filter(r => !r.success).length;

    // âœ… ë¬´ë£Œ í‹°ì–´: ë‹¤ì¤‘ê³„ì • ë™ì‹œë°œí–‰ ì„±ê³µ ê±´ìˆ˜ë§Œí¼ publish quota ì†Œë¹„
    try {
      if (successCount > 0 && (await isFreeTierUser())) {
        await consumeQuota('publish', successCount);
      }
    } catch {
    }

    sendLog(`ğŸ“Š ë‹¤ì¤‘ê³„ì • ë°œí–‰ ì™„ë£Œ: ì„±ê³µ ${successCount}ê°œ, ì‹¤íŒ¨ ${failCount}ê°œ`);

    return { success: true, results, summary: { total: results.length, success: successCount, fail: failCount } };
  } catch (error) {
    const errorMsg = translatePuppeteerError(error as Error);
    sendLog(`âŒ ë‹¤ì¤‘ê³„ì • ë°œí–‰ ì˜¤ë¥˜: ${errorMsg}`);
    return { success: false, message: `ë‹¤ì¤‘ê³„ì • ë°œí–‰ ì‹¤íŒ¨: ${errorMsg}` };
  } finally {
    // âœ… ì™„ë£Œ í›„ í™œì„± ìë™í™” ë°°ì—´ ì •ë¦¬
    activeMultiAccountAutomations.length = 0;
  }
});

// âœ… ë‹¤ì¤‘ê³„ì • ë°œí–‰ ì¦‰ì‹œ ì¤‘ì§€ í•¸ë“¤ëŸ¬
ipcMain.handle('multiAccount:cancel', async () => {
  sendLog('ğŸ›‘ ë‹¤ì¤‘ê³„ì • ë°œí–‰ ì¦‰ì‹œ ì¤‘ì§€ ìš”ì²­');

  // ì·¨ì†Œ í”Œë˜ê·¸ ì„¤ì •
  multiAccountAbortFlag = true;

  // í™œì„±í™”ëœ ëª¨ë“  ìë™í™” ì¸ìŠ¤í„´ìŠ¤ì˜ ë¸Œë¼ìš°ì € ê°•ì œ ì¢…ë£Œ
  const closePromises = activeMultiAccountAutomations.map(async (automation) => {
    try {
      await automation.closeBrowser();
    } catch (e) {
      // ì´ë¯¸ ë‹«íŒ ë¸Œë¼ìš°ì €ì¼ ìˆ˜ ìˆìŒ - ë¬´ì‹œ
    }
  });

  await Promise.allSettled(closePromises);
  activeMultiAccountAutomations.length = 0;

  sendLog('âœ… ë‹¤ì¤‘ê³„ì • ë°œí–‰ì´ ì™„ì „íˆ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.');
  return { success: true, message: 'ë‹¤ì¤‘ê³„ì • ë°œí–‰ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.' };
});

// âœ… AI ì œëª© A/B í…ŒìŠ¤íŠ¸ IPC í•¸ë“¤ëŸ¬
ipcMain.handle('title:generateCandidates', async (_event, keyword: string, category?: string, count?: number) => {
  // âœ… ì‹¤í–‰ ì§ì „ ìµœì‹  ì„¤ì • ê°•ì œ ë™ê¸°í™”
  try {
    const config = await loadConfig();
    applyConfigToEnv(config);
  } catch (e) {
    console.error('[Main] title:generateCandidates - ì„¤ì • ë™ê¸°í™” ì‹¤íŒ¨:', e);
  }

  try {
    const result = titleABTester.generateTitleCandidates(keyword, category, count);
    return { success: true, result };
  } catch (error) {
    return { success: false, message: `ìƒì„± ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('title:evaluate', async (_event, title: string, category?: string) => {
  // âœ… ì‹¤í–‰ ì§ì „ ìµœì‹  ì„¤ì • ê°•ì œ ë™ê¸°í™”
  try {
    const config = await loadConfig();
    applyConfigToEnv(config);
  } catch (e) {
    console.error('[Main] title:evaluate - ì„¤ì • ë™ê¸°í™” ì‹¤íŒ¨:', e);
  }

  try {
    const evaluation = titleABTester.evaluateTitle(title, category);
    return { success: true, evaluation };
  } catch (error) {
    return { success: false, message: `í‰ê°€ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('title:suggestImprovements', async (_event, title: string) => {
  try {
    const suggestions = titleABTester.suggestImprovements(title);
    return { success: true, suggestions };
  } catch (error) {
    return { success: false, message: `ì œì•ˆ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('title:getStyles', async () => {
  try {
    const styles = titleABTester.getAvailableStyles();
    return { success: true, styles };
  } catch (error) {
    return { success: false, message: `ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

// âœ… ëŒ“ê¸€ ìë™ ë‹µê¸€ IPC í•¸ë“¤ëŸ¬
ipcMain.handle('comment:add', async (_event, author: string, content: string, postUrl: string, postTitle: string) => {
  try {
    const comment = commentResponder.addComment(author, content, postUrl, postTitle);
    return { success: true, comment };
  } catch (error) {
    return { success: false, message: `ì¶”ê°€ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('comment:generateReply', async (_event, commentId: string, customAnswer?: string) => {
  try {
    const comment = commentResponder.getComment(commentId);
    if (!comment) return { success: false, message: 'ëŒ“ê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.' };
    const reply = commentResponder.generateReply(comment, customAnswer);
    return { success: true, reply };
  } catch (error) {
    return { success: false, message: `ìƒì„± ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('comment:markReplied', async (_event, commentId: string, replyContent: string) => {
  try {
    const result = commentResponder.markAsReplied(commentId, replyContent);
    return { success: result };
  } catch (error) {
    return { success: false, message: `ì²˜ë¦¬ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('comment:getPending', async () => {
  try {
    const comments = commentResponder.getPendingComments();
    return { success: true, comments };
  } catch (error) {
    return { success: false, message: `ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('comment:getReplied', async () => {
  try {
    const comments = commentResponder.getRepliedComments();
    return { success: true, comments };
  } catch (error) {
    return { success: false, message: `ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('comment:getStats', async () => {
  try {
    const stats = commentResponder.getStats();
    return { success: true, stats };
  } catch (error) {
    return { success: false, message: `ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('comment:generateBulk', async () => {
  try {
    const replies = commentResponder.generateBulkReplies();
    return { success: true, replies };
  } catch (error) {
    return { success: false, message: `ìƒì„± ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

// âœ… ê²½ìŸ ë¸”ë¡œê·¸ ë¶„ì„ IPC í•¸ë“¤ëŸ¬
ipcMain.handle('competitor:analyze', async (_event, keyword: string) => {
  try {
    sendLog(`ğŸ” ê²½ìŸ ë¶„ì„ ì¤‘: ${keyword}`);
    const result = await competitorAnalyzer.analyzeCompetitors(keyword);
    sendLog(`âœ… ê²½ìŸ ë¶„ì„ ì™„ë£Œ: ${keyword} (ë‚œì´ë„: ${result.difficulty})`);
    return { success: true, result };
  } catch (error) {
    return { success: false, message: `ë¶„ì„ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('competitor:analyzeBlog', async (_event, blogId: string) => {
  try {
    const result = await competitorAnalyzer.analyzeBlog(blogId);
    return { success: true, result };
  } catch (error) {
    return { success: false, message: `ë¶„ì„ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('competitor:clearCache', async () => {
  try {
    competitorAnalyzer.clearCache();
    return { success: true, message: 'ìºì‹œê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.' };
  } catch (error) {
    return { success: false, message: `ì´ˆê¸°í™” ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('datalab:getRelatedKeywords', async (_event, keyword: string) => {
  // âœ… ì‹¤í–‰ ì§ì „ ìµœì‹  ì„¤ì • ê°•ì œ ë™ê¸°í™”
  try {
    const config = await loadConfig();
    applyConfigToEnv(config);
  } catch (e) {
    console.error('[Main] datalab:getRelatedKeywords - ì„¤ì • ë™ê¸°í™” ì‹¤íŒ¨:', e);
  }

  // ë¼ì´ì„ ìŠ¤ ì²´í¬
  if (!(await ensureLicenseValid())) {
    return { success: false, message: 'ë¼ì´ì„ ìŠ¤ ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤. ë¼ì´ì„ ìŠ¤ë¥¼ ì¸ì¦í•´ì£¼ì„¸ìš”.' };
  }
  try {
    const datalabClient = createDatalabClient();
    if (!datalabClient) {
      return {
        success: false,
        message: 'ë„¤ì´ë²„ ë°ì´í„°ë© APIê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.',
      };
    }

    const related = await datalabClient.getRelatedKeywords(keyword);
    return {
      success: true,
      data: related,
    };
  } catch (error) {
    return {
      success: false,
      message: `ê´€ë ¨ í‚¤ì›Œë“œ ì¡°íšŒ ì‹¤íŒ¨: ${(error as Error).message}`,
    };
  }
});

ipcMain.handle(
  'automation:generateStructuredContent',
  async (
    _event,
    payload: { assembly: SourceAssemblyInput },
  ): Promise<{ success: boolean; content?: StructuredContent; message?: string; imageCount?: number }> => {
    // âœ… ì‹¤í–‰ ì§ì „ ìµœì‹  ì„¤ì • ê°•ì œ ë™ê¸°í™” (API í‚¤ ì •í•©ì„± ë³´ì¥)
    try {
      const currentConfig = await loadConfig();
      applyConfigToEnv(currentConfig);
      console.log('[Main] automation:generateStructuredContent - ìµœì‹  ì„¤ì • ë™ê¸°í™” ì™„ë£Œ');
    } catch (e) {
      console.error('[Main] automation:generateStructuredContent - ì„¤ì • ë¡œë“œ ì‹¤íŒ¨:', e);
    }

    // ë¼ì´ì„ ìŠ¤ ì²´í¬
    if (!(await ensureLicenseValid())) {
      return { success: false, message: 'ë¼ì´ì„ ìŠ¤ ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤.' };
    }

    // âœ… í˜ì´ì›” ìƒíƒœ ì²´í¬ (ì†Œì§„ë˜ë©´ ê¸€ìƒì„±ë„ ë§‰ìŒ - ì¿¼í„° ì†Œë¹„ëŠ” ë°œí–‰ ì‹œì—ë§Œ)
    const isFreeUser = await isFreeTierUser();
    if (isFreeUser) {
      const limits = await getFreeQuotaLimits();
      const status = await getQuotaStatus(limits);
      if (status.isPaywalled) {
        return {
          success: false,
          code: 'PAYWALL',
          message: 'ì˜¤ëŠ˜ ë¬´ë£Œ ì‚¬ìš©ëŸ‰ì„ ëª¨ë‘ ì“°ì…¨ìŠµë‹ˆë‹¤.',
          quota: status,
        } as any;
      }
    }


    try {
      // ì—°ë ¹ëŒ€ë³„ ìµœì†Œ ê¸€ììˆ˜ ê¸°ë³¸ê°’ ê³„ì‚° (assembleContentSource í˜¸ì¶œ ì „ì— targetAge í™•ì¸)
      const getMinCharsForAge = (targetAge?: '20s' | '30s' | '40s' | '50s' | 'all'): number => {
        switch (targetAge) {
          case '20s':
            return 2500; // 2,500~3,500ì
          case '30s':
            return 3000; // 3,000~4,000ì
          case '40s':
          case '50s':
            return 3500; // 3,500~4,500ì (í˜„ì‹¤ì ìœ¼ë¡œ ì¡°ì •)
          case 'all':
          default:
            return 2000; // ê¸°ë³¸ 2,000ì
        }
      };

      // targetAgeëŠ” payload.assemblyì—ì„œ ë¨¼ì € í™•ì¸ (assembleContentSource í˜¸ì¶œ ì „)
      const targetAge = (payload.assembly.targetAge as '20s' | '30s' | '40s' | '50s' | 'all' | undefined) ?? 'all';

      const { source, warnings } = await assembleContentSource(payload.assembly);
      const provider = payload.assembly.generator ?? source.generator ?? 'gemini';

      // âœ… contentMode ì „ë‹¬ (SEO / í™ˆíŒ ëª¨ë“œ)
      const contentMode = (payload.assembly as any).contentMode as 'seo' | 'homefeed' | undefined;
      if (contentMode) {
        source.contentMode = contentMode;
      }

      // âœ… isFullAuto ì „ë‹¬ (ì™„ì „ìë™ ë°œí–‰ ëª¨ë“œ)
      const isFullAuto = (payload.assembly as any).isFullAuto as boolean | undefined;
      if (isFullAuto) {
        source.isFullAuto = isFullAuto;
      }

      // âœ… categoryHint ì „ë‹¬ (2ì¶• ë¶„ë¦¬ í”„ë¡¬í”„íŠ¸)
      const categoryHint = (payload.assembly as any).categoryHint as string | undefined;
      if (categoryHint) {
        source.categoryHint = categoryHint;
      }

      // âœ… isReviewType ì „ë‹¬ (ë¦¬ë·°í˜• ê¸€ - êµ¬ë§¤ì „í™˜ ìœ ë„)
      const isReviewType = (payload.assembly as any).isReviewType as boolean | undefined;
      if (isReviewType) {
        source.isReviewType = isReviewType;
      }

      // âœ… ì‚¬ìš©ì ì •ì˜ í”„ë¡¬í”„íŠ¸ ì „ë‹¬
      const customPrompt = (payload.assembly as any).customPrompt as string | undefined;
      if (customPrompt) {
        source.customPrompt = customPrompt;
      }

      // âœ… toneStyle ì „ë‹¬ (ê¸€í†¤/ë§íˆ¬ ìŠ¤íƒ€ì¼ - ë§¤ìš° ì¤‘ìš”!)
      const toneStyle = (payload.assembly as any).toneStyle as string | undefined;
      if (toneStyle) {
        source.toneStyle = toneStyle as any;
        console.log(`[Main] âœ… ê¸€í†¤ ìŠ¤íƒ€ì¼ ì ìš©: ${toneStyle}`);
      } else {
        console.log(`[Main] âš ï¸ ê¸€í†¤ ìŠ¤íƒ€ì¼ ë¯¸ì§€ì • â†’ ì¹´í…Œê³ ë¦¬ ê¸°ë°˜ ìë™ ë§¤ì¹­`);
      }

      console.log('[Main] êµ¬ì¡°í™” ì½˜í…ì¸  ìƒì„± ì‹œì‘');
      console.log('[Main] Provider:', provider);
      console.log('[Main] TargetAge:', targetAge);
      console.log('[Main] ContentMode:', contentMode || 'seo (ê¸°ë³¸ê°’)');
      console.log('[Main] CategoryHint:', categoryHint || 'general');
      console.log('[Main] IsFullAuto:', isFullAuto || false);
      console.log('[Main] IsReviewType:', isReviewType || false);
      console.log('[Main] API í‚¤ í™•ì¸:', {
        gemini: process.env.GEMINI_API_KEY ? `ì„¤ì •ë¨ (${process.env.GEMINI_API_KEY.length}ì)` : 'ì—†ìŒ',
        openai: process.env.OPENAI_API_KEY ? `ì„¤ì •ë¨ (${process.env.OPENAI_API_KEY.length}ì)` : 'ì—†ìŒ',
        claude: process.env.CLAUDE_API_KEY ? `ì„¤ì •ë¨ (${process.env.CLAUDE_API_KEY.length}ì)` : 'ì—†ìŒ',
      });

      // RSS/URLì—ì„œ ì´ë¯¸ì§€ ì¶”ì¶œ ì—¬ë¶€ í™•ì¸ (ì—¬ëŸ¬ URL ì§€ì›)
      // ì´ë¯¸ì§€ ìˆ˜ì§‘ ê¸°ëŠ¥ ì œê±°ë¨ (DALL-Eì™€ Pexelsë§Œ ì‚¬ìš©)
      // ë„¤ì´ë²„ ë¸”ë¡œê·¸ í¬ë¡¤ë§, RSS ì´ë¯¸ì§€ ì¶”ì¶œ ë“±ì€ ë” ì´ìƒ ì‚¬ìš©í•˜ì§€ ì•ŠìŒ
      let imageCount = 0;

      // ì‚¬ìš©ì ì§€ì •(minChars) ìš°ì„ , ì—†ìœ¼ë©´ ì—°ë ¹ëŒ€ ê¸°ë³¸ê°’ ì‚¬ìš©
      const customMin = (payload.assembly as any).minChars as number | undefined;
      const baseMinChars = (typeof customMin === 'number' && !Number.isNaN(customMin) && customMin > 0)
        ? Math.floor(customMin)
        : getMinCharsForAge(targetAge);
      const minChars = baseMinChars;

      console.log('[Main] ìµœì†Œ ê¸€ììˆ˜ ì„¤ì •:', { customMin, targetAge, minChars });

      const content = await generateStructuredContent(source, {
        provider,
        minChars,
      });

      if (warnings.length) {
        content.quality.warnings = Array.from(new Set([...(content.quality.warnings ?? []), ...warnings]));
      }

      console.log('[Main] êµ¬ì¡°í™” ì½˜í…ì¸  ìƒì„± ì™„ë£Œ');

      // âœ… ê¸€ìƒì„±ì€ ì¿¼í„° ì†Œë¹„ ì•ˆí•¨ (ë°œí–‰ ì‹œì—ë§Œ 1ì„¸íŠ¸ë¡œ ì¹´ìš´íŠ¸)
      return { success: true, content, imageCount };
    } catch (error) {
      const err = error as Error;
      const message = err.message ?? 'êµ¬ì¡°í™”ëœ ì½˜í…ì¸  ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';

      console.error('[Main] êµ¬ì¡°í™” ì½˜í…ì¸  ìƒì„± ì‹¤íŒ¨');
      console.error('[Main] ì˜¤ë¥˜ íƒ€ì…:', err.constructor.name);
      console.error('[Main] ì˜¤ë¥˜ ë©”ì‹œì§€:', message);
      console.error('[Main] ì˜¤ë¥˜ ìŠ¤íƒ:', err.stack);
      console.error('[Main] ì „ì²´ ì˜¤ë¥˜ ê°ì²´:', error);

      return { success: false, message };
    }
  },
);

ipcMain.handle('config:get', async () => {
  try {
    // í•­ìƒ ìµœì‹  ì„¤ì •ì„ ë¡œë“œ (ìºì‹œëœ ê°’ì´ ìˆì–´ë„ íŒŒì¼ì—ì„œ ë‹¤ì‹œ ì½ê¸°)
    appConfig = await loadConfig();
    applyConfigToEnv(appConfig);
    console.log('[Main] config:get í˜¸ì¶œ - ì„¤ì • ë¡œë“œ ì™„ë£Œ');
    console.log('[Main] ë¡œë“œëœ ì„¤ì • í‚¤:', Object.keys(appConfig).filter(k => k.includes('ApiKey') || k.includes('Key')));
    // âœ… tutorialVideos í™•ì¸ ë¡œê·¸
    const tutorials = (appConfig as any).tutorialVideos;
    console.log('[Main] tutorialVideos ê°œìˆ˜:', tutorials ? tutorials.length : 0);
    return appConfig;
  } catch (error) {
    console.error('[Main] config:get ì˜¤ë¥˜:', error);
    // ì˜¤ë¥˜ ë°œìƒ ì‹œ ê¸°ì¡´ ìºì‹œëœ ì„¤ì • ë°˜í™˜
    return appConfig;
  }
});

ipcMain.handle('config:save', async (_event, payload: AppConfig) => {
  appConfig = await saveConfig(payload);
  applyConfigToEnv(appConfig);
  return appConfig;
});

ipcMain.handle('config:set', async (_event, payload: AppConfig) => {
  // API í‚¤ í˜•ì‹ ê²€ì¦
  const validationErrors: string[] = [];

  if (payload.geminiApiKey) {
    const validation = validateApiKeyFormat(payload.geminiApiKey, 'gemini');
    if (!validation.valid) {
      validationErrors.push(`Gemini: ${validation.message}`);
    }
  }

  if (payload.openaiApiKey) {
    const validation = validateApiKeyFormat(payload.openaiApiKey, 'openai');
    if (!validation.valid) {
      validationErrors.push(`OpenAI: ${validation.message}`);
    }
  }


  if (payload.claudeApiKey) {
    const validation = validateApiKeyFormat(payload.claudeApiKey, 'claude');
    if (!validation.valid) {
      validationErrors.push(`Claude: ${validation.message}`);
    }
  }

  if (validationErrors.length > 0) {
    const errorMessage = `âš ï¸ API í‚¤ í˜•ì‹ ì˜¤ë¥˜:\n${validationErrors.join('\n')}`;
    sendLog(errorMessage);
    console.error('[Main] API í‚¤ ê²€ì¦ ì‹¤íŒ¨:', validationErrors);
  }

  const nextConfig = await saveConfig(payload ?? {});
  appConfig = nextConfig;
  applyConfigToEnv(nextConfig);

  // API í‚¤ ì €ì¥ í™•ì¸ ë¡œê·¸
  if (nextConfig.geminiApiKey && nextConfig.geminiApiKey.trim()) {
    const keyLength = nextConfig.geminiApiKey.trim().length;
    const isValid = validateApiKeyFormat(nextConfig.geminiApiKey, 'gemini').valid;
    sendLog(`âœ… Gemini API í‚¤ ì €ì¥ë¨ (ê¸¸ì´: ${keyLength}ì, í˜•ì‹: ${isValid ? 'ì˜¬ë°”ë¦„' : 'ì˜¤ë¥˜'})`);
    console.log('[Main] Gemini API í‚¤ í™˜ê²½ë³€ìˆ˜ ì„¤ì • í™•ì¸:', process.env.GEMINI_API_KEY ? 'ì„¤ì •ë¨' : 'ì„¤ì • ì•ˆë¨');
  } else {
    sendLog('âš ï¸ Gemini API í‚¤ê°€ ì €ì¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
  }

  if (nextConfig.openaiApiKey && nextConfig.openaiApiKey.trim()) {
    const keyLength = nextConfig.openaiApiKey.trim().length;
    const isValid = validateApiKeyFormat(nextConfig.openaiApiKey, 'openai').valid;
    sendLog(`âœ… OpenAI API í‚¤ ì €ì¥ë¨ (ê¸¸ì´: ${keyLength}ì, í˜•ì‹: ${isValid ? 'ì˜¬ë°”ë¦„' : 'ì˜¤ë¥˜'})`);
  }


  if (nextConfig.claudeApiKey && nextConfig.claudeApiKey.trim()) {
    const keyLength = nextConfig.claudeApiKey.trim().length;
    const isValid = validateApiKeyFormat(nextConfig.claudeApiKey, 'claude').valid;
    sendLog(`âœ… Claude API í‚¤ ì €ì¥ë¨ (ê¸¸ì´: ${keyLength}ì, í˜•ì‹: ${isValid ? 'ì˜¬ë°”ë¦„' : 'ì˜¤ë¥˜'})`);
  }

  if (nextConfig.dailyPostLimit !== undefined) {
    setDailyLimit(nextConfig.dailyPostLimit);
  }
  if (nextConfig.appIconPath) {
    sendLog(`ğŸ–¼ï¸ ì‚¬ìš©ì ì§€ì • ì•± ì•„ì´ì½˜ ê²½ë¡œ: ${nextConfig.appIconPath}`);
  }
  sendLog('âš™ï¸ ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
  return nextConfig;
});

// ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì¹´í…Œê³ ë¦¬ ì¡°íšŒ IPC í•¸ë“¤ëŸ¬
ipcMain.handle('library:getCategories', async (): Promise<string[]> => {
  try {
    if (!imageLibrary) {
      await initializeImageLibrary();
    }
    if (!imageLibrary) {
      return [];
    }
    return imageLibrary.getCategories();
  } catch (error) {
    console.error('[Main] ì¹´í…Œê³ ë¦¬ ì¡°íšŒ ì‹¤íŒ¨:', (error as Error).message);
    return [];
  }
});

// ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì´ë¯¸ì§€ ì‚­ì œ IPC í•¸ë“¤ëŸ¬
ipcMain.handle('library:deleteImage', async (_event, id: string): Promise<boolean> => {
  try {
    if (!imageLibrary) {
      await initializeImageLibrary();
    }
    if (!imageLibrary) {
      return false;
    }
    // TODO: ImageLibraryì— deleteImage ë©”ì„œë“œ ì¶”ê°€ í•„ìš”
    return false;
  } catch (error) {
    console.error('[Main] ì´ë¯¸ì§€ ì‚­ì œ ì‹¤íŒ¨:', (error as Error).message);
    return false;
  }
});

// ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì¸ìŠ¤í„´ìŠ¤
let imageLibrary: ImageLibrary | null = null;
let extendedImageLibrary: ExtendedImageLibrary | null = null;

// ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì´ˆê¸°í™”
async function initializeImageLibrary(): Promise<void> {
  try {
    const os = await import('os');
    const storageDir = path.join(os.homedir(), '.naver-blog-automation', 'image-library');
    const config = await loadConfig();

    imageLibrary = new ImageLibrary({
      storageDir,
      autoDownload: true,
    }, (message) => {
      console.log(`[ImageLibrary] ${message}`);
    });

    await imageLibrary.initialize();
    console.log('[Main] ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì´ˆê¸°í™” ì™„ë£Œ');

    // í™•ì¥ ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì´ˆê¸°í™”
    extendedImageLibrary = new ExtendedImageLibrary({
      storageDir,
      unsplashApiKey: config.unsplashApiKey,
      pexelsApiKey: config.pexelsApiKey,
      pixabayApiKey: config.pixabayApiKey,
      autoDownload: true,
    });

    await extendedImageLibrary.initialize();
    console.log('[Main] í™•ì¥ ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì´ˆê¸°í™” ì™„ë£Œ');
  } catch (error) {
    console.error('[Main] ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì´ˆê¸°í™” ì‹¤íŒ¨:', (error as Error).message);
  }
}

// ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ IPC í•¸ë“¤ëŸ¬
ipcMain.handle('library:collectImages', async (_event, options: { query: string; sources: string[]; count: number }): Promise<{ success: boolean; count: number; message?: string }> => {
  // âœ… ì‹¤í–‰ ì§ì „ ìµœì‹  ì„¤ì • ê°•ì œ ë™ê¸°í™”
  try {
    const config = await loadConfig();
    applyConfigToEnv(config);
  } catch (e) {
    console.error('[Main] library:collectImages - ì„¤ì • ë™ê¸°í™” ì‹¤íŒ¨:', e);
  }

  if (!(await ensureLicenseValid())) {
    return { success: false, count: 0, message: 'ë¼ì´ì„ ìŠ¤ ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤.' };
  }

  const mediaCheck = await enforceFreeTier('media', 1);
  if (!mediaCheck.allowed) {
    return mediaCheck.response;
  }
  try {
    if (!imageLibrary) {
      await initializeImageLibrary();
    }
    if (!imageLibrary) {
      return { success: false, count: 0, message: 'ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì´ˆê¸°í™” ì‹¤íŒ¨' };
    }

    const images = await imageLibrary.collectImages(options.query, {
      sources: options.sources as ImageSource[],
      count: options.count,
    });

    const result = { success: true, count: images.length };
    if (result.success && result.count > 0 && (await isFreeTierUser())) {
      await consumeQuota('media', 1);
    }
    return result;
  } catch (error) {
    return { success: false, count: 0, message: (error as Error).message };
  }
});

ipcMain.handle('library:batchCollect', async (_event, categories: string[]): Promise<{ success: boolean; message?: string }> => {
  // âœ… ì‹¤í–‰ ì§ì „ ìµœì‹  ì„¤ì • ê°•ì œ ë™ê¸°í™”
  try {
    const config = await loadConfig();
    applyConfigToEnv(config);
  } catch (e) {
    console.error('[Main] library:batchCollect - ì„¤ì • ë™ê¸°í™” ì‹¤íŒ¨:', e);
  }

  if (!(await ensureLicenseValid())) {
    return { success: false, message: 'ë¼ì´ì„ ìŠ¤ ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤.' };
  }

  const mediaCheck = await enforceFreeTier('media', 1);
  if (!mediaCheck.allowed) {
    return mediaCheck.response;
  }
  try {
    if (!imageLibrary) {
      await initializeImageLibrary();
    }
    if (!imageLibrary) {
      return { success: false, message: 'ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì´ˆê¸°í™” ì‹¤íŒ¨' };
    }

    await imageLibrary.batchCollect(categories);
    const result = { success: true };
    if (await isFreeTierUser()) {
      await consumeQuota('media', 1);
    }
    return result;
  } catch (error) {
    return { success: false, message: (error as Error).message };
  }
});

ipcMain.handle('library:getStats', async (): Promise<{ totalImages: number; categories: number; totalSize: string; sources: Record<string, number> }> => {
  try {
    if (!imageLibrary) {
      await initializeImageLibrary();
    }
    if (!imageLibrary) {
      return { totalImages: 0, categories: 0, totalSize: '0 KB', sources: {} };
    }

    return await imageLibrary.getStats();
  } catch (error) {
    console.error('[Main] ë¼ì´ë¸ŒëŸ¬ë¦¬ í†µê³„ ì¡°íšŒ ì‹¤íŒ¨:', (error as Error).message);
    return { totalImages: 0, categories: 0, totalSize: '0 KB', sources: {} };
  }
});

ipcMain.handle('library:getImages', async (_event, category?: string, titleKeywords?: string[]): Promise<Array<{
  id: string;
  filePath: string;
  previewDataUrl: string;
  sourceTitle?: string;
}>> => {
  try {
    if (!imageLibrary) {
      await initializeImageLibrary();
    }
    if (!imageLibrary) {
      return [];
    }

    let images: any[] = [];

    // í‚¤ì›Œë“œê°€ ì œê³µëœ ê²½ìš° í‚¤ì›Œë“œ ê¸°ë°˜ ê²€ìƒ‰
    if (titleKeywords && titleKeywords.length > 0) {
      console.log('[Main] í‚¤ì›Œë“œ ê¸°ë°˜ ì´ë¯¸ì§€ ê²€ìƒ‰:', titleKeywords);
      images = await imageLibrary.getImages(titleKeywords, 100);
    }
    // ì¹´í…Œê³ ë¦¬ê°€ ì œê³µëœ ê²½ìš° ì¹´í…Œê³ ë¦¬ ê¸°ë°˜ ê²€ìƒ‰
    else if (category && category.trim().length > 0) {
      console.log('[Main] ì¹´í…Œê³ ë¦¬ ê¸°ë°˜ ì´ë¯¸ì§€ ê²€ìƒ‰:', category);
      images = await imageLibrary.getImages(category, 100);
    }
    // ë‘˜ ë‹¤ ì—†ëŠ” ê²½ìš° ì „ì²´ ì´ë¯¸ì§€ ë°˜í™˜ (ì œí•œì ìœ¼ë¡œ)
    else {
      console.log('[Main] ì „ì²´ ì´ë¯¸ì§€ ì¡°íšŒ (ì œí•œì )');
      images = await imageLibrary.getImages(undefined, 50); // ì œí•œì ìœ¼ë¡œ ë°˜í™˜
    }

    return images.map(img => ({
      id: img.id,
      filePath: img.localPath || img.url,
      previewDataUrl: img.localPath ? `file://${img.localPath}` : img.url,
      sourceTitle: img.query,
    }));
  } catch (error) {
    console.error('[Main] ì´ë¯¸ì§€ ì¡°íšŒ ì‹¤íŒ¨:', (error as Error).message);
    return [];
  }
});

// âœ… ìë™ ì´ë¯¸ì§€ ìˆ˜ì§‘ IPC í•¸ë“¤ëŸ¬
ipcMain.handle('auto-collect-images', async (_event, data: {
  title: string;
  keywords: string[];
  category: string;
  imageMode: 'full-auto' | 'semi-auto' | 'manual' | 'skip';
  selectedImageSource?: 'dalle' | 'pexels' | 'library'; // ì´ë¯¸ì§€ ì†ŒìŠ¤ ì„ íƒ
}): Promise<{
  success: boolean;
  images?: any[];
  totalCount?: number;
  headingCount?: number;
  error?: string;
}> => {
  // âœ… ì‹¤í–‰ ì§ì „ ìµœì‹  ì„¤ì • ê°•ì œ ë™ê¸°í™”
  try {
    const config = await loadConfig();
    applyConfigToEnv(config);
  } catch (e) {
    console.error('[Main] auto-collect-images - ì„¤ì • ë™ê¸°í™” ì‹¤íŒ¨:', e);
  }

  if (!(await ensureLicenseValid())) {
    return { success: false, error: 'ë¼ì´ì„ ìŠ¤ ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤.' };
  }

  try {
    if (!extendedImageLibrary) {
      await initializeImageLibrary();
    }
    if (!extendedImageLibrary) {
      return {
        success: false,
        error: 'í™•ì¥ ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì´ˆê¸°í™” ì‹¤íŒ¨',
      };
    }

    const { title, keywords, category, imageMode, selectedImageSource } = data;

    // DALL-E ë˜ëŠ” Pexelsê°€ ì„ íƒëœ ê²½ìš° ì´ë¯¸ì§€ ìˆ˜ì§‘ì„ ê±´ë„ˆëœë‹ˆë‹¤.
    if (selectedImageSource === 'dalle' || selectedImageSource === 'pexels') {
      console.log(`[Main] ${selectedImageSource} ì„ íƒë¨. ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ìˆ˜ì§‘ì„ ê±´ë„ˆëœë‹ˆë‹¤.`);
      return {
        success: true,
        images: [],
        totalCount: 0,
        headingCount: 0,
      };
    }

    const mediaCheck = await enforceFreeTier('media', 1);
    if (!mediaCheck.allowed) {
      return mediaCheck.response;
    }

    // ì†Œì œëª© ì¶”ì¶œ (êµ¬ì¡°í™” ì½˜í…ì¸ ê°€ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ì œëª©ì—ì„œ ì¶”ì¶œ)
    let headings: string[] = [];

    // TODO: êµ¬ì¡°í™” ì½˜í…ì¸ ì—ì„œ ì†Œì œëª© ê°€ì ¸ì˜¤ê¸° (í˜„ì¬ëŠ” ì œëª©ì„ í‚¤ì›Œë“œë¡œ ì‚¬ìš©)
    if (keywords.length > 0) {
      headings = keywords.slice(0, 5); // ìµœëŒ€ 5ê°œ ì†Œì œëª©
    } else {
      // ì œëª©ì„ ê¸°ë°˜ìœ¼ë¡œ ê°„ë‹¨í•œ ì†Œì œëª© ìƒì„±
      headings = [title];
    }

    // ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„ íƒ ì‹œì—ë§Œ ê³µì‹ ë³´ë„ìë£Œ ìˆ˜ì§‘
    if (extendedImageLibrary) {
      if (selectedImageSource === 'library') {
        // ê³µì‹ ë³´ë„ìë£Œë§Œ í™œì„±í™” (API í‚¤ ë¶ˆí•„ìš” - í¬ë¡¤ë§ ê¸°ë°˜)
        extendedImageLibrary.setSourceEnabled('korea_gov', true);
        extendedImageLibrary.setSourceEnabled('news_agency', true);
        console.log('[ì´ë¯¸ì§€ ìˆ˜ì§‘] ê³µì‹ ë³´ë„ìë£Œ í™œì„±í™” (korea_gov, news_agency)');
        console.log('[ì´ë¯¸ì§€ ìˆ˜ì§‘] API í‚¤ ë¶ˆí•„ìš” - í¬ë¡¤ë§ ê¸°ë°˜ ìˆ˜ì§‘');
      } else {
        console.log(`[ì´ë¯¸ì§€ ìˆ˜ì§‘] ${selectedImageSource} ì„ íƒë¨. ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì†ŒìŠ¤ í•„í„°ë§ì„ ê±´ë„ˆëœë‹ˆë‹¤.`);
      }
    } else {
      console.log('[ì´ë¯¸ì§€ ìˆ˜ì§‘] ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
    }

    // ì´ë¯¸ì§€ ìˆ˜ì§‘ (ë¼ì´ë¸ŒëŸ¬ë¦¬ ì†ŒìŠ¤ë§Œ ì‚¬ìš©)
    const imageMap = await collectImagesOnAutomationStart(
      extendedImageLibrary,
      title,
      keywords,
      category,
      headings,
      imageMode
    );

    // ì„ íƒëœ ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì¹´í…Œê³ ë¦¬ê°€ ìˆìœ¼ë©´ í•´ë‹¹ ì¹´í…Œê³ ë¦¬ì˜ ì´ë¯¸ì§€ë§Œ í•„í„°ë§
    // (ì´ë¯¸ collectImagesOnAutomationStartì—ì„œ ì²˜ë¦¬ë˜ì§€ë§Œ, ì¶”ê°€ í•„í„°ë§ì´ í•„ìš”í•  ìˆ˜ ìˆìŒ)

    // Mapì„ ë°°ì—´ë¡œ ë³€í™˜
    const allImages: any[] = [];
    imageMap.forEach((images, heading) => {
      images.forEach(img => {
        allImages.push({
          ...img,
          heading, // ì–´ë–¤ ì†Œì œëª©ìš©ì¸ì§€ í‘œì‹œ
          // filePathê°€ ì—†ìœ¼ë©´ url ì‚¬ìš©
          filePath: img.filePath || img.url,
        });
      });
    });

    const response = {
      success: true,
      images: allImages,
      totalCount: allImages.length,
      headingCount: imageMap.size,
    };
    if ((response.images?.length ?? 0) > 0 && (await isFreeTierUser())) {
      await consumeQuota('media', 1);
    }
    return response;
  } catch (error) {
    console.error('[Main] ìë™ ì´ë¯¸ì§€ ìˆ˜ì§‘ ì˜¤ë¥˜:', error);
    return {
      success: false,
      error: (error as Error).message,
    };
  }
});

// âœ… ë°˜ìë™: ì‚¬ìš©ì ì„ íƒ ì´ë¯¸ì§€ ë°°ì¹˜ ì ìš© IPC í•¸ë“¤ëŸ¬
ipcMain.handle('apply-image-placements', async (_event, data: {
  selections: Array<{ imageId: string; targetHeadingIndex: number; position: 'above' | 'below' }>;
  images: Array<{ id: string; thumbnailUrl: string; title: string; source: string; url?: string; filePath?: string }>;
}): Promise<{
  success: boolean;
  inserted?: number;
  failed?: number;
  error?: string;
}> => {
  try {
    if (!automation || !automationRunning) {
      return {
        success: false,
        error: 'ìë™í™”ê°€ ì‹¤í–‰ ì¤‘ì´ì§€ ì•ŠìŠµë‹ˆë‹¤. ë¨¼ì € ìë™í™”ë¥¼ ì‹œì‘í•´ì£¼ì„¸ìš”.',
      };
    }

    const { selections, images } = data;

    // ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ë° Base64 ë³€í™˜
    const imagesWithBase64: Array<{ id: string; base64: string; headingIndex: number }> = [];

    for (const selection of selections) {
      const image = images.find(img => img.id === selection.imageId);
      if (!image) {
        console.warn(`[Main] ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${selection.imageId}`);
        continue;
      }

      try {
        let base64: string;

        // filePathê°€ ìˆìœ¼ë©´ ë¡œì»¬ íŒŒì¼ ì½ê¸°
        if (image.filePath && !image.filePath.startsWith('http')) {
          const imageBuffer = await fs.readFile(image.filePath);
          const ext = image.filePath.split('.').pop()?.toLowerCase() || 'png';
          const mimeType = ext === 'jpg' || ext === 'jpeg' ? 'image/jpeg' :
            ext === 'png' ? 'image/png' :
              ext === 'gif' ? 'image/gif' :
                ext === 'webp' ? 'image/webp' : 'image/png';
          base64 = `data:${mimeType};base64,${imageBuffer.toString('base64')}`;
        } else {
          // URLì¸ ê²½ìš° ë‹¤ìš´ë¡œë“œ
          const imageUrl = image.url || image.thumbnailUrl;
          if (!imageUrl) {
            console.warn(`[Main] ì´ë¯¸ì§€ URLì´ ì—†ìŠµë‹ˆë‹¤: ${image.id}`);
            continue;
          }

          const fetchModule = await import('node-fetch');
          const fetch = fetchModule.default as any;
          const response = await fetch(imageUrl);
          const buffer = await response.buffer() as Buffer;
          const ext = new URL(imageUrl).pathname.split('.').pop()?.toLowerCase() || 'png';
          const mimeType = ext === 'jpg' || ext === 'jpeg' ? 'image/jpeg' : 'image/png';
          base64 = `data:${mimeType};base64,${buffer.toString('base64')}`;
        }

        imagesWithBase64.push({
          id: image.id,
          base64,
          headingIndex: selection.targetHeadingIndex,
        });
      } catch (error) {
        console.error(`[Main] ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨ (${image.id}):`, error);
      }
    }

    if (imagesWithBase64.length === 0) {
      return {
        success: false,
        error: 'ì´ë¯¸ì§€ë¥¼ ë‹¤ìš´ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.',
      };
    }

    // naverBlogAutomationì˜ ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ë¯¸ì§€ ì‚½ì…
    const result = await automation.insertImagesAtHeadings(
      imagesWithBase64.map(img => ({
        headingIndex: img.headingIndex,
        imageBase64: img.base64,
        position: selections.find(s => s.imageId === img.id)?.position || 'below',
      }))
    );

    return {
      success: true,
      inserted: result.success,
      failed: result.failed,
    };
  } catch (error) {
    console.error('[Main] ì´ë¯¸ì§€ ë°°ì¹˜ ì ìš© ì˜¤ë¥˜:', error);
    return {
      success: false,
      error: (error as Error).message,
    };
  }
});

// âœ… ë„¤ì´ë²„ ì´ë¯¸ì§€ ê²€ìƒ‰ IPC í•¸ë“¤ëŸ¬ (ìµœëŒ€ 50ê°œ ìˆ˜ì§‘ + ì¤‘ë³µ/ë¬´ê´€ ì´ë¯¸ì§€ í•„í„°ë§)
ipcMain.handle('image:searchNaver', async (_event, keyword: string): Promise<{ success: boolean; images?: any[]; message?: string }> => {
  // âœ… ì‹¤í–‰ ì§ì „ ìµœì‹  ì„¤ì • ê°•ì œ ë™ê¸°í™”
  try {
    const config = await loadConfig();
    applyConfigToEnv(config);
  } catch (e) {
    console.error('[Main] image:searchNaver - ì„¤ì • ë™ê¸°í™” ì‹¤íŒ¨:', e);
  }

  if (!(await ensureLicenseValid())) {
    return { success: false, message: 'ë¼ì´ì„ ìŠ¤ ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤.' };
  }

  const mediaCheck = await enforceFreeTier('media', 1);
  if (!mediaCheck.allowed) {
    return mediaCheck.response;
  }
  try {
    if (!keyword || !keyword.trim()) {
      return { success: false, message: 'ê²€ìƒ‰ í‚¤ì›Œë“œê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.' };
    }

    console.log(`[Main] ë„¤ì´ë²„ ì´ë¯¸ì§€ ê²€ìƒ‰: "${keyword}"`);

    const normalizeEnv = (v: string | undefined): string => String(v || '').trim().replace(/^['"]|['"]$/g, '').trim();

    const collectEnvPairs = (baseIdKey: string, baseSecretKey: string, labelPrefix: string): Array<{ id: string; secret: string; label: string }> => {
      const pairs: Array<{ id: string; secret: string; label: string }> = [];

      const baseId = normalizeEnv((process.env as any)[baseIdKey]);
      const baseSecret = normalizeEnv((process.env as any)[baseSecretKey]);
      if (baseId && baseSecret) {
        pairs.push({ id: baseId, secret: baseSecret, label: `${labelPrefix}#1` });
      }

      // NAVER_CLIENT_ID_2 / NAVER_CLIENT_SECRET_2 ...
      for (let i = 2; i <= 10; i++) {
        const id = normalizeEnv((process.env as any)[`${baseIdKey}_${i}`]);
        const secret = normalizeEnv((process.env as any)[`${baseSecretKey}_${i}`]);
        if (id && secret) {
          pairs.push({ id, secret, label: `${labelPrefix}#${i}` });
        }
      }

      return pairs;
    };

    const credentialCandidates: Array<{ id: string; secret: string; label: string }> = [
      ...collectEnvPairs('NAVER_CLIENT_ID', 'NAVER_CLIENT_SECRET', 'NAVER_CLIENT_*'),
      ...collectEnvPairs('NAVER_DATALAB_CLIENT_ID', 'NAVER_DATALAB_CLIENT_SECRET', 'NAVER_DATALAB_*'),
    ];

    if (credentialCandidates.length === 0) {
      const config = await loadConfig();
      if (config.naverDatalabClientId && config.naverDatalabClientSecret) {
        credentialCandidates.push({
          id: String(config.naverDatalabClientId).trim(),
          secret: String(config.naverDatalabClientSecret).trim(),
          label: 'config#1',
        });
      } else {
        return {
          success: false,
          message: 'ë„¤ì´ë²„ API í‚¤ê°€ ì„¤ì •ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤. í™˜ê²½ì„¤ì •ì—ì„œ ë„¤ì´ë²„ Client IDì™€ Secretì„ ì…ë ¥í•´ì£¼ì„¸ìš”.',
        };
      }
    }

    let credentialIndex = 0;
    console.log(`[Main] ë„¤ì´ë²„ API í‚¤ í›„ë³´ ìˆ˜: ${credentialCandidates.length}ê°œ (í˜„ì¬: ${credentialCandidates[0]?.label || 'unknown'})`);
    const FREE_DAILY_LIMIT = 100;
    // âœ… ìœ ë£Œ í”Œëœ ì‚¬ìš©ì(í¬ë ˆë”§ ë³´ìœ ì)ë¥¼ ìœ„í•´ í•œë„ë¥¼ ëŒ€í­ ìƒí–¥ (ì‚¬ì‹¤ìƒ ë¬´ì œí•œ)
    const PAID_DAILY_LIMIT = 9999;
    // âœ… ì—¬ëŸ¬ ê²€ìƒ‰ ì¿¼ë¦¬ë¡œ ì¶©ë¶„í•œ ì´ë¯¸ì§€ ìˆ˜ì§‘ (ìµœëŒ€ 50ê°œ)
    const MAX_IMAGES = 50;
    const TARGET_IMAGES = MAX_IMAGES;
    const allImages: any[] = [];
    const usedUrls = new Set<string>();
    const usedImageHashes = new Set<string>(); // ì´ë¯¸ì§€ í•´ì‹œë¡œ ì¤‘ë³µ ì²´í¬

    const httpErrors: Array<{ status: number; query: string; errorCode?: string; errorMessage?: string }> = [];

    const NAVER_NEW_APP_GUIDE_URL = 'https://developers.naver.com/apps/#/myapps/oBaehge5xTtI73Z0x1Dx/overview';
    const buildNaverQuotaGuide = (): string =>
      `\n\në„¤ì´ë²„ ì´ë¯¸ì§€ API ì¼ì¼ í•œë„(ì¿¼ë¦¬) ì´ˆê³¼ë¡œ ë³´ì´ë©´, ì•„ë˜ ë§í¬ì—ì„œ ë„¤ì´ë²„ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ì¶”ê°€ë¡œ ìƒì„±í•œ ë’¤ ìƒˆ Client ID/Secretì„ ë°œê¸‰ë°›ì•„ í™˜ê²½ì„¤ì •ì— ë“±ë¡í•˜ì„¸ìš”.\n` +
      `${NAVER_NEW_APP_GUIDE_URL}`;
    const maybeAppendNaverQuotaGuide = (detail: string): string => {
      const d = String(detail || '');
      const looksLikeQuota = /count\/quota\s*=\s*\d+\s*\/\s*\d+/i.test(d) || /Query limit exceeded/i.test(d);
      return looksLikeQuota ? `${d}${buildNaverQuotaGuide()}` : d;
    };

    const parseNaverErrorBody = (bodyText: string): { errorCode: string; errorMessage: string } => {
      let errorCode = '';
      let errorMessage = String(bodyText || '').trim();
      try {
        const parsed = JSON.parse(bodyText || '{}') as any;
        if (parsed && typeof parsed === 'object') {
          errorCode = String(parsed.errorCode || '').trim();
          errorMessage = String(parsed.errorMessage || parsed.message || bodyText || '').trim();
        }
      } catch {
      }
      return { errorCode, errorMessage };
    };

    const sleep = async (ms: number): Promise<void> => {
      await new Promise<void>((resolve) => setTimeout(resolve, ms));
    };

    const fetchWithRotation = async (searchUrl: string, queryLabel: string): Promise<any | null> => {
      let attempts = 0;
      let lastStatus = 0;
      let lastErrorCode = '';
      let lastErrorMessage = '';
      let sameKey429Retries = 0;

      while (attempts < credentialCandidates.length) {
        const cred = credentialCandidates[credentialIndex];
        const keyLabel = cred?.label || `key#${credentialIndex + 1}`;

        const response = await fetch(searchUrl, {
          method: 'GET',
          headers: {
            'X-Naver-Client-Id': cred?.id || '',
            'X-Naver-Client-Secret': cred?.secret || '',
          },
        });

        if (response.ok) {
          return await response.json();
        }

        let bodyText = '';
        try {
          bodyText = await response.text();
        } catch {
        }
        const parsed = parseNaverErrorBody(bodyText);
        lastStatus = response.status;
        lastErrorCode = parsed.errorCode;
        lastErrorMessage = parsed.errorMessage;
        httpErrors.push({ status: response.status, query: queryLabel, errorCode: parsed.errorCode, errorMessage: parsed.errorMessage });
        console.warn(`[Main] ë„¤ì´ë²„ ì´ë¯¸ì§€ ê²€ìƒ‰ "${queryLabel}" ì‹¤íŒ¨(${keyLabel}): ${response.status} ${parsed.errorCode} ${String(parsed.errorMessage || '').slice(0, 140)}`);

        if (response.status === 429) {
          const retryAfterRaw = String(response.headers.get('retry-after') || '').trim();
          const retryAfterSeconds = Number.parseInt(retryAfterRaw, 10);
          const retryAfterMs = Number.isFinite(retryAfterSeconds) && retryAfterSeconds > 0 ? retryAfterSeconds * 1000 : 0;

          if (sameKey429Retries < 2) {
            sameKey429Retries++;
            const backoffMs = Math.min(1200, 200 * Math.pow(2, sameKey429Retries - 1));
            const waitMs = Math.max(retryAfterMs, backoffMs);
            if (waitMs > 0) {
              await sleep(waitMs);
            }
            continue;
          }

          sameKey429Retries = 0;
          credentialIndex = (credentialIndex + 1) % credentialCandidates.length;
          attempts++;
          console.log(`[Main] ë„¤ì´ë²„ API í‚¤ ì „í™˜: ${keyLabel} â†’ ${credentialCandidates[credentialIndex]?.label || `key#${credentialIndex + 1}`}`);
          continue;
        }

        if (response.status === 401 || response.status === 403) {
          sameKey429Retries = 0;
          credentialIndex = (credentialIndex + 1) % credentialCandidates.length;
          attempts++;
          console.log(`[Main] ë„¤ì´ë²„ API í‚¤ ì „í™˜: ${keyLabel} â†’ ${credentialCandidates[credentialIndex]?.label || `key#${credentialIndex + 1}`}`);
          continue;
        }

        return null;
      }

      // ëª¨ë“  í‚¤ê°€ 429/401/403 ë“±ìœ¼ë¡œ ì‹¤íŒ¨
      const detail = `${lastStatus}${lastErrorCode ? ` ${lastErrorCode}` : ''}${lastErrorMessage ? ` ${String(lastErrorMessage).slice(0, 220)}` : ''}`.trim();
      throw new Error(`NAVER_ALL_KEYS_FAILED: ${detail}`);
    };

    // âœ… í‚¤ì›Œë“œì—ì„œ í•µì‹¬ ë‹¨ì–´ ì¶”ì¶œ (ì¡°ì‚¬/ì ‘ì†ì‚¬ ì œê±°)
    const stopWords = ['ì€', 'ëŠ”', 'ì´', 'ê°€', 'ì„', 'ë¥¼', 'ì˜', 'ì—', 'ì—ì„œ', 'ìœ¼ë¡œ', 'ë¡œ', 'ì™€', 'ê³¼', 'ë„', 'ë§Œ', 'ê¹Œì§€', 'ë¶€í„°', 'ì—ê²Œ', 'í•œí…Œ', 'ê»˜', 'ë³´ë‹¤', 'ì²˜ëŸ¼', 'ê°™ì´', 'ëŒ€í•´', 'ëŒ€í•œ', 'ìœ„í•œ', 'í†µí•œ', 'ê´€í•œ', 'ìˆëŠ”', 'ì—†ëŠ”', 'í•˜ëŠ”', 'ë˜ëŠ”', 'ëœ', 'í• ', 'ë ', 'í•˜ê³ ', 'ë˜ê³ ', 'ê·¸ë¦¬ê³ ', 'í•˜ì§€ë§Œ', 'ê·¸ëŸ¬ë‚˜', 'ë˜í•œ', 'ë°', 'ë“±', 'ê²ƒ', 'ìˆ˜', 'ë•Œ', 'ì¤‘', 'í›„', 'ì „', 'ë‚´', 'ì™¸'];
    const keywordParts = keyword.split(/[\s,.\-!?:;'"()[\]{}]+/).filter(p => p.length >= 2 && !stopWords.includes(p));
    const coreKeywords = keywordParts.slice(0, 4); // í•µì‹¬ í‚¤ì›Œë“œ 4ê°œ

    // ê²€ìƒ‰ ì¿¼ë¦¬ ëª©ë¡ (ì›ë³¸ í‚¤ì›Œë“œ + ë³€í˜• í‚¤ì›Œë“œ)
    const searchQueries = [
      keyword,                                    // ì›ë³¸ í‚¤ì›Œë“œ
      coreKeywords.join(' '),                     // í•µì‹¬ í‚¤ì›Œë“œë§Œ
      `${keyword} ì‚¬ì§„`,                          // + ì‚¬ì§„
      `${keyword} ì´ë¯¸ì§€`,                        // + ì´ë¯¸ì§€
      `${keyword} ì‹¤ì‹œê°„`,                        // + ì‹¤ì‹œê°„ (ê²½ê¸° ë“±)
    ];

    // í•µì‹¬ ë‹¨ì–´ ì¡°í•© ì¶”ê°€
    if (coreKeywords.length > 1) {
      searchQueries.push(coreKeywords[0]); // ì²« ë²ˆì§¸ ë‹¨ì–´ë§Œ
      searchQueries.push(`${coreKeywords[0]} ${coreKeywords[1]}`); // ì²« ë‘ ë‹¨ì–´
      if (coreKeywords.length > 2) {
        searchQueries.push(`${coreKeywords[0]} ${coreKeywords[2]}`); // ì²« ë²ˆì§¸ + ì„¸ ë²ˆì§¸
      }
    }

    // ì¤‘ë³µ ì œê±°
    const uniqueQueries = [...new Set(searchQueries)].filter(q => q.trim());

    for (const query of uniqueQueries) {
      // ì´ë¯¸ 50ê°œ ì´ìƒ ìˆ˜ì§‘í–ˆìœ¼ë©´ ì¤‘ë‹¨
      if (allImages.length >= MAX_IMAGES) break;
      if (allImages.length >= TARGET_IMAGES) break;

      try {
        // âœ… display=100 (ë„¤ì´ë²„ API ìµœëŒ€ê°’), sort=date (ìµœì‹ ìˆœ ìš°ì„ )
        const searchUrl = `https://openapi.naver.com/v1/search/image?query=${encodeURIComponent(query)}&display=100&sort=date`;

        const data = await fetchWithRotation(searchUrl, query);
        if (!data) {
          continue;
        }

        if (data.items && data.items.length > 0) {
          for (const item of data.items) {
            // ì¤‘ë³µ URL ì œì™¸
            if (usedUrls.has(item.link)) continue;

            // âœ… ì´ë¯¸ì§€ í•´ì‹œë¡œ ìœ ì‚¬ ì´ë¯¸ì§€ ì¤‘ë³µ ì²´í¬ (URL ëë¶€ë¶„ ê¸°ë°˜)
            const urlHash = item.link.split('/').pop()?.split('?')[0] || '';
            if (urlHash && usedImageHashes.has(urlHash)) continue;

            // âœ… ë¬´ê´€í•œ ì´ë¯¸ì§€ í•„í„°ë§ (ê´‘ê³ , ë¡œê³ , ì•„ì´ì½˜ ë“± ì œì™¸)
            const title = item.title?.replace(/<[^>]*>/g, '').toLowerCase() || '';
            const isIrrelevant =
              title.includes('ê´‘ê³ ') ||
              title.includes('ë°°ë„ˆ') ||
              title.includes('ë¡œê³ ') ||
              title.includes('ì•„ì´ì½˜') ||
              title.includes('ë²„íŠ¼') ||
              title.includes('ë¬´ë£Œì´ë¯¸ì§€') ||
              title.includes('í´ë¦½ì•„íŠ¸') ||
              (item.sizewidth && item.sizeheight && item.sizewidth < 200 && item.sizeheight < 200); // ë„ˆë¬´ ì‘ì€ ì´ë¯¸ì§€

            if (isIrrelevant) continue;

            // âœ… í‚¤ì›Œë“œ ê´€ë ¨ì„± ì²´í¬ (í•µì‹¬ í‚¤ì›Œë“œ ì¤‘ í•˜ë‚˜ë¼ë„ í¬í•¨ë˜ì–´ì•¼ í•¨)
            const hasRelevance = coreKeywords.length === 0 || coreKeywords.some(kw =>
              title.includes(kw.toLowerCase()) || item.link.toLowerCase().includes(kw.toLowerCase())
            );

            // ê´€ë ¨ì„±ì´ ë‚®ì•„ë„ ì²˜ìŒ 20ê°œëŠ” ìˆ˜ì§‘ (ê²€ìƒ‰ ê²°ê³¼ ìƒìœ„ëŠ” ëŒ€ì²´ë¡œ ê´€ë ¨ì„± ë†’ìŒ)
            if (!hasRelevance && allImages.length >= 20) continue;

            usedUrls.add(item.link);
            if (urlHash) usedImageHashes.add(urlHash);

            allImages.push({
              id: `naver-${allImages.length}`,
              url: item.link,
              thumbnailUrl: item.thumbnail,
              title: item.title?.replace(/<[^>]*>/g, '') || '',
              source: 'naver',
              width: item.sizewidth,
              height: item.sizeheight,
            });

            // 50ê°œ ë„ë‹¬í•˜ë©´ ì¤‘ë‹¨
            if (allImages.length >= MAX_IMAGES) break;
            if (allImages.length >= TARGET_IMAGES) break;
          }
          console.log(`[Main] ê²€ìƒ‰ "${query}": ${data.items.length}ê°œ ë°œê²¬ (ëˆ„ì : ${allImages.length}ê°œ)`);
        }
      } catch (queryError) {
        const msg = (queryError as Error).message;
        if (msg.startsWith('NAVER_ALL_KEYS_FAILED:')) {
          return {
            success: false,
            message: `ë„¤ì´ë²„ ì´ë¯¸ì§€ API ëª¨ë“  í‚¤ê°€ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ${maybeAppendNaverQuotaGuide(msg.replace('NAVER_ALL_KEYS_FAILED:', '').trim())}`,
          };
        }
        console.warn(`[Main] ê²€ìƒ‰ "${query}" ì˜¤ë¥˜:`, msg);
      }
    }

    if (allImages.length === 0) {
      const relaxedQueries = [
        coreKeywords.join(' '),
        coreKeywords[0],
        keywordParts[0],
        keyword,
      ]
        .map((q) => String(q || '').trim())
        .filter((q) => q.length >= 2);

      const uniqueRelaxedQueries = [...new Set(relaxedQueries)].slice(0, 4);

      for (const query of uniqueRelaxedQueries) {
        if (allImages.length >= MAX_IMAGES) break;
        if (allImages.length >= TARGET_IMAGES) break;

        try {
          const searchUrl = `https://openapi.naver.com/v1/search/image?query=${encodeURIComponent(query)}&display=100&sort=date`;

          const data = await fetchWithRotation(searchUrl, query);
          if (!data) {
            continue;
          }

          if (data.items && data.items.length > 0) {
            for (const item of data.items) {
              if (usedUrls.has(item.link)) continue;

              const urlHash = item.link.split('/').pop()?.split('?')[0] || '';
              if (urlHash && usedImageHashes.has(urlHash)) continue;

              const title = item.title?.replace(/<[^>]*>/g, '').toLowerCase() || '';
              const isIrrelevant =
                title.includes('ê´‘ê³ ') ||
                title.includes('ë°°ë„ˆ') ||
                title.includes('ë¡œê³ ') ||
                title.includes('ì•„ì´ì½˜') ||
                title.includes('ë²„íŠ¼') ||
                (item.sizewidth && item.sizeheight && item.sizewidth < 80 && item.sizeheight < 80);
              if (isIrrelevant) continue;

              usedUrls.add(item.link);
              if (urlHash) usedImageHashes.add(urlHash);

              allImages.push({
                id: `naver-${allImages.length}`,
                url: item.link,
                thumbnailUrl: item.thumbnail,
                title: item.title?.replace(/<[^>]*>/g, '') || '',
                source: 'naver',
                width: item.sizewidth,
                height: item.sizeheight,
              });

              if (allImages.length >= MAX_IMAGES) break;
              if (allImages.length >= TARGET_IMAGES) break;
            }
            console.log(`[Main] (ì™„í™”) ê²€ìƒ‰ "${query}": ${data.items.length}ê°œ ë°œê²¬ (ëˆ„ì : ${allImages.length}ê°œ)`);
          }
        } catch (queryError) {
          const msg = (queryError as Error).message;
          if (msg.startsWith('NAVER_ALL_KEYS_FAILED:')) {
            return {
              success: false,
              message: `ë„¤ì´ë²„ ì´ë¯¸ì§€ API ëª¨ë“  í‚¤ê°€ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ${maybeAppendNaverQuotaGuide(msg.replace('NAVER_ALL_KEYS_FAILED:', '').trim())}`,
            };
          }
          console.warn(`[Main] (ì™„í™”) ê²€ìƒ‰ "${query}" ì˜¤ë¥˜:`, msg);
        }
      }
    }

    if (allImages.length > 0) {
      console.log(`[Main] ë„¤ì´ë²„ ì´ë¯¸ì§€ ê²€ìƒ‰ ì™„ë£Œ: ì´ ${allImages.length}ê°œ ë°œê²¬ (ì¤‘ë³µ/ë¬´ê´€ ì´ë¯¸ì§€ í•„í„°ë§ ì ìš©)`);
      const response = { success: true, images: allImages };
      if ((response.images?.length ?? 0) > 0 && (await isFreeTierUser())) {
        await consumeQuota('media', 1);
      }
      return response;
    } else {
      if (httpErrors.length > 0) {
        const mostRecent = httpErrors[httpErrors.length - 1];
        const detail = `${mostRecent.status}${mostRecent.errorCode ? ` ${mostRecent.errorCode}` : ''}${mostRecent.errorMessage ? ` ${String(mostRecent.errorMessage).slice(0, 220)}` : ''}`.trim();
        return { success: false, message: `ë„¤ì´ë²„ ì´ë¯¸ì§€ API ìš”ì²­ ì‹¤íŒ¨: ${maybeAppendNaverQuotaGuide(detail)}` };
      }
      return { success: false, message: 'ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.' };
    }
  } catch (error) {
    console.error('[Main] ë„¤ì´ë²„ ì´ë¯¸ì§€ ê²€ìƒ‰ ì‹¤íŒ¨:', error);
    return { success: false, message: (error as Error).message };
  }
});

// ì†Œì œëª© ì´ë¯¸ì§€ ê´€ë¦¬ IPC í•¸ë“¤ëŸ¬
ipcMain.handle('heading:applyImage', async (_event, heading: string, image: HeadingImageRecord): Promise<{ success: boolean; message?: string }> => {
  try {
    if (!heading || !heading.trim()) {
      return { success: false, message: 'ì†Œì œëª©ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.' };
    }
    if (!image || !image.filePath) {
      return { success: false, message: 'ì´ë¯¸ì§€ ì •ë³´ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.' };
    }

    headingImagesStore.set(heading.trim(), {
      provider: image.provider,
      filePath: image.filePath,
      previewDataUrl: image.previewDataUrl,
      updatedAt: image.updatedAt || Date.now(),
      alt: image.alt,
      caption: image.caption,
    });

    await saveHeadingImagesStore();
    console.log(`[Main] ì†Œì œëª© "${heading}"ì— ì´ë¯¸ì§€ ì ìš© ì™„ë£Œ`);
    return { success: true };
  } catch (error) {
    console.error('[Main] ì†Œì œëª© ì´ë¯¸ì§€ ì ìš© ì‹¤íŒ¨:', error);
    return { success: false, message: (error as Error).message };
  }
});

ipcMain.handle('heading:getAppliedImage', async (_event, heading: string): Promise<{ success: boolean; image?: HeadingImageRecord; message?: string }> => {
  try {
    if (!heading || !heading.trim()) {
      return { success: false, message: 'ì†Œì œëª©ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.' };
    }

    const image = headingImagesStore.get(heading.trim());
    if (!image) {
      return { success: true, image: undefined };
    }

    return { success: true, image };
  } catch (error) {
    console.error('[Main] ì†Œì œëª© ì´ë¯¸ì§€ ì¡°íšŒ ì‹¤íŒ¨:', error);
    return { success: false, message: (error as Error).message };
  }
});

ipcMain.handle('heading:removeImage', async (_event, heading: string): Promise<{ success: boolean; message?: string }> => {
  try {
    if (!heading || !heading.trim()) {
      return { success: false, message: 'ì†Œì œëª©ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.' };
    }

    const deleted = headingImagesStore.delete(heading.trim());
    if (deleted) {
      await saveHeadingImagesStore();
      console.log(`[Main] ì†Œì œëª© "${heading}"ì˜ ì´ë¯¸ì§€ ì œê±° ì™„ë£Œ`);
    }

    return { success: true };
  } catch (error) {
    console.error('[Main] ì†Œì œëª© ì´ë¯¸ì§€ ì œê±° ì‹¤íŒ¨:', error);
    return { success: false, message: (error as Error).message };
  }
});

ipcMain.handle('heading:getAllAppliedImages', async (): Promise<{ success: boolean; images?: Record<string, HeadingImageRecord>; message?: string }> => {
  try {
    const images = Object.fromEntries(headingImagesStore);
    return { success: true, images };
  } catch (error) {
    console.error('[Main] ëª¨ë“  ì†Œì œëª© ì´ë¯¸ì§€ ì¡°íšŒ ì‹¤íŒ¨:', error);
    return { success: false, message: (error as Error).message };
  }
});

// ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ê¸°ëŠ¥ ì œê±°ë¨
/*
ipcMain.handle('library:extractKeywords', async (_event, title: string): Promise<{ keywords: string[]; personNames: string[] }> => {
  try {
    const { extractKeywordsFromTitle } = await import('./imageLibrary.js');
    return extractKeywordsFromTitle(title);
  } catch (error) {
    console.error('[Main] í‚¤ì›Œë“œ ì¶”ì¶œ ì‹¤íŒ¨:', (error as Error).message);
    return { keywords: [], personNames: [] };
  }
});
*/

// ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ê¸°ëŠ¥ ì œê±°ë¨
/*
// í‚¤ì›Œë“œ ê¸°ë°˜ ì¶”ê°€ ì´ë¯¸ì§€ ìˆ˜ì§‘ (10ê°œ ë” ìˆ˜ì§‘ ë²„íŠ¼ìš©)
ipcMain.handle('library:collectByKeywordsArray', async (_event, keywords: string[], title: string, maxImages: number = 10): Promise<{ success: boolean; count: number; message?: string }> => {
  // ë¼ì´ì„ ìŠ¤ ì²´í¬
  if (!(await ensureLicenseValid())) {
    return { success: false, count: 0, message: 'ë¼ì´ì„ ìŠ¤ ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤. ë¼ì´ì„ ìŠ¤ë¥¼ ì¸ì¦í•´ì£¼ì„¸ìš”.' };
  }
  try {
    const { collectImages } = await import('./imageLibrary.js');
    const { searchAllRssSources } = await import('./rssSearcher.js');
    const { crawlNaverBlogWithPuppeteer } = await import('./naverBlogCrawler.js');
    const { fetchArticleContent } = await import('./sourceAssembler.js');
    
    if (!keywords || keywords.length === 0) {
      return {
        success: false,
        count: 0,
        message: 'í‚¤ì›Œë“œê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.',
      };
    }
    
    const searchKeywords = keywords.slice(0, 3).join(' ');
    console.log(`[Main] ì¶”ê°€ ì´ë¯¸ì§€ ìˆ˜ì§‘: "${searchKeywords}"`);
    
    // ë„¤ì´ë²„ ê²€ìƒ‰ API í‚¤ ë¡œë“œ
    const config = await loadConfig();
    const clientId = config.naverDatalabClientId?.trim();
    const clientSecret = config.naverDatalabClientSecret?.trim();
    
    // ë„¤ì´ë²„ ë¸”ë¡œê·¸, ë‰´ìŠ¤, ì¹´í˜ì—ì„œ ê²€ìƒ‰
    const rssUrls = await searchAllRssSources(searchKeywords, {
      maxPerSource: 5, // ë” ì ê²Œ ìˆ˜ì§‘
      sources: ['naver_blog', 'naver_news', 'naver_cafe'],
      clientId,
      clientSecret,
    });
    
    if (rssUrls.length === 0) {
      return {
        success: false,
        count: 0,
        message: `"${searchKeywords}"ì— ëŒ€í•œ ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`,
      };
    }
    
    // ì´ë¯¸ì§€ í¬ë¡¤ë§
    const allImageUrls: string[] = [];
    const maxUrls = Math.min(5, rssUrls.length);
    
    for (let i = 0; i < maxUrls; i++) {
      const url = rssUrls[i];
      try {
        let images: string[] = [];
        
        if (/blog\.naver\.com/i.test(url)) {
          try {
            const result = await crawlNaverBlogWithPuppeteer(url);
            images = result.images || [];
          } catch {
            const article = await fetchArticleContent(url);
            images = article.images || [];
          }
        } else {
          const article = await fetchArticleContent(url);
          images = article.images || [];
        }
        
        images.forEach(imgUrl => {
          if (imgUrl && imgUrl.startsWith('http') && !allImageUrls.includes(imgUrl)) {
            allImageUrls.push(imgUrl);
          }
        });
        
        if (allImageUrls.length >= maxImages) {
          break;
        }
      } catch (error) {
        console.warn(`[Main] URL í¬ë¡¤ë§ ì‹¤íŒ¨: ${(error as Error).message}`);
      }
    }
    
    if (allImageUrls.length === 0) {
      return {
        success: false,
        count: 0,
        message: 'ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.',
      };
    }
    
    // ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ
    const category = keywords[0] || 'uncategorized';
    const collectedItems = await collectImages(
      allImageUrls.slice(0, maxImages),
      'naver-crawl',
      title,
      category
    );
    
    return {
      success: true,
      count: collectedItems.length,
      message: `${collectedItems.length}ê°œì˜ ì´ë¯¸ì§€ë¥¼ ì¶”ê°€ë¡œ ìˆ˜ì§‘í–ˆìŠµë‹ˆë‹¤.`,
    };
  } catch (error) {
    return {
      success: false,
      count: 0,
      message: (error as Error).message,
    };
  }
});
*/

/*
ipcMain.handle('library:collectByKeywords', async (_event, title: string): Promise<{ success: boolean; count: number; message?: string }> => {
  // ë¼ì´ì„ ìŠ¤ ì²´í¬
  if (!(await ensureLicenseValid())) {
    return { success: false, count: 0, message: 'ë¼ì´ì„ ìŠ¤ ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤. ë¼ì´ì„ ìŠ¤ë¥¼ ì¸ì¦í•´ì£¼ì„¸ìš”.' };
  }
  try {
    const { extractKeywordsFromTitle, collectImages } = await import('./imageLibrary.js');
    const { searchAllRssSources } = await import('./rssSearcher.js');
    const { crawlNaverBlogWithPuppeteer } = await import('./naverBlogCrawler.js');
    const { fetchArticleContent } = await import('./sourceAssembler.js');
    
    if (!title || !title.trim()) {
      return {
        success: false,
        count: 0,
        message: 'ì œëª©ì´ ë¹„ì–´ìˆì–´ ì´ë¯¸ì§€ ìˆ˜ì§‘ì„ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.',
      };
    }
    
    // ì œëª©ì—ì„œ í‚¤ì›Œë“œ ì¶”ì¶œ (ì¸ë¬¼ ì´ë¦„ í¬í•¨)
    const { keywords, personNames } = extractKeywordsFromTitle(title);
    console.log(`[Main] ì œëª© "${title}"ì—ì„œ ì¶”ì¶œëœ í‚¤ì›Œë“œ:`, keywords, 'ì¸ë¬¼ ì´ë¦„:', personNames);
    
    if (keywords.length === 0) {
      return {
        success: false,
        count: 0,
        message: `ì œëª© "${title}"ì—ì„œ í‚¤ì›Œë“œë¥¼ ì¶”ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. êµ¬ì²´ì ì¸ í‚¤ì›Œë“œê°€ í¬í•¨ëœ ì œëª©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.`,
      };
    }
    
    // í•µì‹¬ í‚¤ì›Œë“œ ì„ íƒ ë° ê²€ìƒ‰ì–´ ìƒì„±
    // ì¸ë¬¼ ì´ë¦„ê³¼ ì¼ë°˜ í‚¤ì›Œë“œë¥¼ í•©ì¹˜ë˜, ì¤‘ë³µ ì œê±°
    const allKeywords = [...personNames, ...keywords];
    const uniqueKeywords = Array.from(new Set(allKeywords)); // ì¤‘ë³µ ì œê±°
    
    // ê²€ìƒ‰ì–´ ìƒì„±: ìµœëŒ€ 3ê°œ í‚¤ì›Œë“œ ì‚¬ìš© (ì¸ë¬¼ ì´ë¦„ ìš°ì„ )
    const primaryKeywords = uniqueKeywords.slice(0, 3);
    const searchKeywords = primaryKeywords.join(' ');
    
    console.log(`[Main] ë„¤ì´ë²„ ë¸”ë¡œê·¸/ë‰´ìŠ¤/ì¹´í˜ì—ì„œ "${searchKeywords}" ê²€ìƒ‰ ì¤‘...`);
    console.log(`[Main] ì‚¬ìš© í‚¤ì›Œë“œ: ${primaryKeywords.join(', ')} (ì¸ë¬¼: ${personNames.join(', ') || 'ì—†ìŒ'})`);
    
    // ë„¤ì´ë²„ ê²€ìƒ‰ API í‚¤ ë¡œë“œ
    const config = await loadConfig();
    const clientId = config.naverDatalabClientId?.trim();
    const clientSecret = config.naverDatalabClientSecret?.trim();
    
    if (!clientId || !clientSecret) {
      console.warn(`[Main] ë„¤ì´ë²„ ê²€ìƒ‰ API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. RSS ê²€ìƒ‰ìœ¼ë¡œ í´ë°±í•©ë‹ˆë‹¤.`);
      console.warn(`[Main] í™˜ê²½ ì„¤ì •ì—ì„œ ë„¤ì´ë²„ ë°ì´í„°ë© Client IDì™€ Secretì„ ì…ë ¥í•´ì£¼ì„¸ìš”.`);
    } else {
      console.log(`[Main] ë„¤ì´ë²„ ê²€ìƒ‰ API í‚¤ í™•ì¸ë¨`);
      console.log(`[Main] - Client ID: ${clientId.substring(0, 10)}... (ê¸¸ì´: ${clientId.length})`);
      console.log(`[Main] - Client Secret: ***${clientSecret.substring(clientSecret.length - 4)} (ê¸¸ì´: ${clientSecret.length})`);
      console.log(`[Main] ì°¸ê³ : ë„¤ì´ë²„ ê²€ìƒ‰ APIë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ ê°œë°œì ì„¼í„°ì—ì„œ "ê²€ìƒ‰" ì„œë¹„ìŠ¤ë¥¼ í™œì„±í™”í•´ì•¼ í•©ë‹ˆë‹¤.`);
      console.log(`[Main] ë°ì´í„°ë© APIë§Œ í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´ 401 ì˜¤ë¥˜ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.`);
      
      // API í‚¤ í˜•ì‹ ê²€ì¦
      if (clientId.length < 10 || clientSecret.length < 10) {
        console.warn(`[Main] âš ï¸ API í‚¤ ê¸¸ì´ê°€ ì§§ìŠµë‹ˆë‹¤. ì˜¬ë°”ë¥¸ í‚¤ì¸ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.`);
      }
    }
    
    // ë„¤ì´ë²„ ë¸”ë¡œê·¸, ë‰´ìŠ¤, ì¹´í˜ì—ì„œ ê²€ìƒ‰ (ë„¤ì´ë²„ ê²€ìƒ‰ API ìš°ì„  ì‚¬ìš©)
    const rssUrls = await searchAllRssSources(searchKeywords, {
      maxPerSource: 10,
      sources: ['naver_blog', 'naver_news', 'naver_cafe'],
      clientId,
      clientSecret,
    });
    
    console.log(`[Main] ${rssUrls.length}ê°œì˜ URL ë°œê²¬`);
    
    if (rssUrls.length === 0) {
      // í‚¤ì›Œë“œê°€ ë„ˆë¬´ êµ¬ì²´ì ì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ë” ì¼ë°˜ì ì¸ í‚¤ì›Œë“œë¡œ ì¬ì‹œë„
      if (primaryKeywords.length > 1) {
        console.log(`[Main] ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ì–´ ë” ì¼ë°˜ì ì¸ í‚¤ì›Œë“œë¡œ ì¬ì‹œë„...`);
        const fallbackKeywords = primaryKeywords.slice(0, 1);
        const fallbackUrls = await searchAllRssSources(fallbackKeywords.join(' '), {
          maxPerSource: 10,
          sources: ['naver_blog', 'naver_news', 'naver_cafe'],
          clientId,
          clientSecret,
        });
        
        if (fallbackUrls.length > 0) {
          console.log(`[Main] í´ë°± ê²€ìƒ‰ìœ¼ë¡œ ${fallbackUrls.length}ê°œì˜ URL ë°œê²¬`);
          // í´ë°± URL ì‚¬ìš©
          const allImageUrls: string[] = [];
          const maxUrls = Math.min(20, fallbackUrls.length);
          
          for (let i = 0; i < maxUrls; i++) {
            const url = fallbackUrls[i];
            try {
              console.log(`[Main] ì´ë¯¸ì§€ í¬ë¡¤ë§ ì¤‘ (${i + 1}/${maxUrls}): ${url}`);
              
              let images: string[] = [];
              
              if (/blog\.naver\.com/i.test(url)) {
                try {
                  const result = await crawlNaverBlogWithPuppeteer(url, (msg) => {
                    console.log(`[Puppeteer] ${msg}`);
                  });
                  images = result.images || [];
                } catch (puppeteerError) {
                  console.warn(`[Main] Puppeteer í¬ë¡¤ë§ ì‹¤íŒ¨, ì¼ë°˜ í¬ë¡¤ë§ìœ¼ë¡œ í´ë°±: ${(puppeteerError as Error).message}`);
                  const article = await fetchArticleContent(url);
                  images = article.images || [];
                }
              } else {
                const article = await fetchArticleContent(url);
                images = article.images || [];
              }
              
              images.forEach(imgUrl => {
                if (imgUrl && imgUrl.startsWith('http') && !allImageUrls.includes(imgUrl)) {
                  allImageUrls.push(imgUrl);
                }
              });
              
              if (allImageUrls.length >= 30) {
                break;
              }
            } catch (error) {
              console.warn(`[Main] URL í¬ë¡¤ë§ ì‹¤íŒ¨ (${url}): ${(error as Error).message}`);
            }
          }
          
          if (allImageUrls.length > 0) {
            const category = keywords.join('_').substring(0, 30);
            const collectedItems = await collectImages(
              allImageUrls,
              'naver-crawl',
              title,
              category
            );
            
            return {
              success: true,
              count: collectedItems.length,
              message: `ë„¤ì´ë²„ ë¸”ë¡œê·¸/ë‰´ìŠ¤/ì¹´í˜ì—ì„œ ${collectedItems.length}ê°œì˜ ì´ë¯¸ì§€ë¥¼ ìˆ˜ì§‘í–ˆìŠµë‹ˆë‹¤.`,
            };
          }
        }
      }
      
      return {
        success: false,
        count: 0,
        message: `í‚¤ì›Œë“œ "${searchKeywords}"ë¡œ ë„¤ì´ë²„ ë¸”ë¡œê·¸/ë‰´ìŠ¤/ì¹´í˜ì—ì„œ ê´€ë ¨ ê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n\në‹¤ë¥¸ í‚¤ì›Œë“œë¡œ ì‹œë„í•´ë³´ì‹œê±°ë‚˜, ë„¤ì´ë²„ ê²€ìƒ‰ API í‚¤ê°€ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.`,
      };
    }
    
    // ê° URLì—ì„œ ì´ë¯¸ì§€ í¬ë¡¤ë§
    const allImageUrls: string[] = [];
    const maxUrls = Math.min(20, rssUrls.length); // ìµœëŒ€ 20ê°œ URLë§Œ í¬ë¡¤ë§
    
    for (let i = 0; i < maxUrls; i++) {
      const url = rssUrls[i];
      try {
        console.log(`[Main] ì´ë¯¸ì§€ í¬ë¡¤ë§ ì¤‘ (${i + 1}/${maxUrls}): ${url}`);
        
        let images: string[] = [];
        
        // ë„¤ì´ë²„ ë¸”ë¡œê·¸ì¸ ê²½ìš° Puppeteer ì‚¬ìš©
        if (/blog\.naver\.com/i.test(url)) {
          try {
            const result = await crawlNaverBlogWithPuppeteer(url, (msg) => {
              console.log(`[Puppeteer] ${msg}`);
            });
            images = result.images || [];
          } catch (puppeteerError) {
            console.warn(`[Main] Puppeteer í¬ë¡¤ë§ ì‹¤íŒ¨, ì¼ë°˜ í¬ë¡¤ë§ìœ¼ë¡œ í´ë°±: ${(puppeteerError as Error).message}`);
            const article = await fetchArticleContent(url);
            images = article.images || [];
          }
        } else {
          // ì¼ë°˜ í¬ë¡¤ë§
          const article = await fetchArticleContent(url);
          images = article.images || [];
        }
        
        // ì¤‘ë³µ ì œê±°í•˜ë©° ì´ë¯¸ì§€ URL ì¶”ê°€
        images.forEach(imgUrl => {
          if (imgUrl && imgUrl.startsWith('http') && !allImageUrls.includes(imgUrl)) {
            allImageUrls.push(imgUrl);
          }
        });
    
        // ì¶©ë¶„í•œ ì´ë¯¸ì§€ë¥¼ ìˆ˜ì§‘í–ˆìœ¼ë©´ ì¤‘ë‹¨
        if (allImageUrls.length >= 30) {
          console.log(`[Main] ì¶©ë¶„í•œ ì´ë¯¸ì§€ ìˆ˜ì§‘ ì™„ë£Œ (${allImageUrls.length}ê°œ)`);
          break;
        }
      } catch (error) {
        console.warn(`[Main] URL í¬ë¡¤ë§ ì‹¤íŒ¨ (${url}): ${(error as Error).message}`);
        // ê³„ì† ì§„í–‰
      }
    }
    
    console.log(`[Main] ì´ ${allImageUrls.length}ê°œì˜ ì´ë¯¸ì§€ URL ìˆ˜ì§‘ë¨ (ë„¤ì´ë²„ í¬ë¡¤ë§)`);
    
    // ë„¤ì´ë²„ì—ì„œ ì´ë¯¸ì§€ë¥¼ ì°¾ì§€ ëª»í–ˆê±°ë‚˜ ë¶€ì¡±í•˜ë©´ Pexels API ì‚¬ìš©
    let collectedItems: any[] = [];
    
    if (allImageUrls.length < 10) {
      console.log(`[Main] ë„¤ì´ë²„ ì´ë¯¸ì§€ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤ (${allImageUrls.length}ê°œ). Pexels APIë¡œ ì¶”ê°€ ìˆ˜ì§‘...`);
      
      const pexelsApiKey = config.pexelsApiKey?.trim();
      if (pexelsApiKey && pexelsApiKey.length > 0) {
        try {
          const { collectImagesByKeywords } = await import('./imageLibrary.js');
          console.log(`[Main] Pexels APIë¡œ í‚¤ì›Œë“œ ê¸°ë°˜ ì´ë¯¸ì§€ ìˆ˜ì§‘: ${keywords.join(', ')}`);
          
          const pexelsImages = await collectImagesByKeywords(
            keywords,
            pexelsApiKey,
            20, // í‚¤ì›Œë“œë‹¹ ìµœëŒ€ 20ê°œ
            personNames
          );
          
          console.log(`[Main] Pexelsì—ì„œ ${pexelsImages.length}ê°œ ì´ë¯¸ì§€ ìˆ˜ì§‘ ì™„ë£Œ`);
          collectedItems = [...collectedItems, ...pexelsImages];
        } catch (pexelsError) {
          console.warn(`[Main] Pexels API ì‚¬ìš© ì‹¤íŒ¨:`, (pexelsError as Error).message);
        }
      } else {
        console.warn(`[Main] Pexels API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í™˜ê²½ ì„¤ì •ì—ì„œ Pexels API í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš”.`);
      }
    }
    
    // ë„¤ì´ë²„ í¬ë¡¤ë§ ì´ë¯¸ì§€ê°€ ìˆìœ¼ë©´ ë‹¤ìš´ë¡œë“œ
    if (allImageUrls.length > 0) {
      // ì¹´í…Œê³ ë¦¬ëŠ” ì²« ë²ˆì§¸ í•µì‹¬ í‚¤ì›Œë“œ ì‚¬ìš© (ì£¼ìš” ì£¼ì œë¥¼ ëŒ€í‘œ)
      const category = (personNames.length > 0 ? personNames[0] : keywords[0]) || 'uncategorized';
      console.log(`[Main] ë„¤ì´ë²„ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì‹œì‘: ${allImageUrls.length}ê°œ, ì œëª©: "${title}", ì¹´í…Œê³ ë¦¬: "${category}"`);
      const naverCollected = await collectImages(
        allImageUrls,
        'naver-crawl',
        title,
        category
      );
      console.log(`[Main] ë„¤ì´ë²„ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ: ${naverCollected.length}ê°œ ì €ì¥ë¨`);
      collectedItems = [...collectedItems, ...naverCollected];
    }
    
    console.log(`[Main] ì´ë¯¸ì§€ ìˆ˜ì§‘ ì™„ë£Œ: ${collectedItems.length}ê°œ ì €ì¥ë¨`);
    
    if (collectedItems.length === 0) {
      // ìƒì„¸í•œ ì˜¤ë¥˜ ë©”ì‹œì§€ ìƒì„±
      let errorMessage = `ì´ë¯¸ì§€ ìˆ˜ì§‘ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.\n\n`;
      errorMessage += `ë„¤ì´ë²„ í¬ë¡¤ë§: ${allImageUrls.length}ê°œ URL ë°œê²¬\n`;
      errorMessage += `ì €ì¥ëœ ì´ë¯¸ì§€: 0ê°œ\n\n`;
      errorMessage += `ê°€ëŠ¥í•œ ì›ì¸:\n`;
      errorMessage += `1. ë„¤ì´ë²„/Pexels ì„œë²„ì—ì„œ ì ‘ê·¼ì´ ì°¨ë‹¨ë˜ì—ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n`;
      errorMessage += `2. Pexels API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n`;
      errorMessage += `3. ë„¤íŠ¸ì›Œí¬ ì—°ê²° ë¬¸ì œê°€ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\n`;
      errorMessage += `í•´ê²° ë°©ë²•:\n`;
      errorMessage += `- í™˜ê²½ ì„¤ì •ì—ì„œ Pexels API í‚¤ë¥¼ ì…ë ¥í•˜ì„¸ìš” (https://www.pexels.com/api/)\n`;
      errorMessage += `- í„°ë¯¸ë„ ì½˜ì†”ì—ì„œ "[ì´ë¯¸ì§€ ìˆ˜ì§‘]" ë˜ëŠ” "[Pexels]" ë¡œê·¸ë¥¼ í™•ì¸í•˜ì„¸ìš”.`;
      
      return {
        success: false,
        count: 0,
        message: errorMessage,
      };
    }
    
    const naverCount = allImageUrls.length > 0 ? collectedItems.filter((item: any) => item.sourceUrl === 'naver-crawl').length : 0;
    const pexelsCount = collectedItems.length - naverCount;
    
    let successMessage = `ì´ ${collectedItems.length}ê°œì˜ ì´ë¯¸ì§€ë¥¼ ìˆ˜ì§‘í–ˆìŠµë‹ˆë‹¤.`;
    if (naverCount > 0 && pexelsCount > 0) {
      successMessage += `\n- ë„¤ì´ë²„: ${naverCount}ê°œ\n- Pexels: ${pexelsCount}ê°œ`;
    } else if (naverCount > 0) {
      successMessage += `\n- ë„¤ì´ë²„ì—ì„œ ${naverCount}ê°œ`;
    } else if (pexelsCount > 0) {
      successMessage += `\n- Pexelsì—ì„œ ${pexelsCount}ê°œ`;
    }
    
    return {
      success: true,
      count: collectedItems.length,
      message: successMessage,
    };
  } catch (error) {
    const errorMessage = (error as Error).message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜';
    console.error('[Main] ë„¤ì´ë²„ ì´ë¯¸ì§€ ìˆ˜ì§‘ ì‹¤íŒ¨:', errorMessage);
    console.error('[Main] ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤:', (error as Error).stack);
    return {
      success: false,
      count: 0,
      message: `ì´ë¯¸ì§€ ìˆ˜ì§‘ ì‹¤íŒ¨: ${errorMessage}`,
    };
  }
});
*/

ipcMain.handle('license:get', async (): Promise<{ license: LicenseInfo | null }> => {
  try {
    // ê°œë°œ ëª¨ë“œì—ì„œëŠ” í•­ìƒ ìœ íš¨í•œ ë¼ì´ì„ ìŠ¤ ë°˜í™˜
    if (!app.isPackaged) {
      return {
        license: {
          licenseCode: 'DEV-MODE',
          deviceId: await getDeviceId(),
          verifiedAt: new Date().toISOString(),
          isValid: true,
          licenseType: 'premium',
        },
      };
    }

    const license = await loadLicense();
    return { license };
  } catch (error) {
    console.error('[Main] ë¼ì´ì„ ìŠ¤ ë¡œë“œ ì‹¤íŒ¨:', (error as Error).message);
    return { license: null };
  }
});

ipcMain.handle('license:register', async (_event, code: string, userId: string, password: string, email: string, deviceId: string): Promise<{ valid: boolean; license?: LicenseInfo; message?: string; debugInfo?: any }> => {
  try {
    const serverUrl = process.env.LICENSE_SERVER_URL || 'https://script.google.com/macros/s/AKfycbxBOGkjVj4p-6XZ4SEFYKhW3FBmo5gt7Fv6djWhB1TljnDDmx_qlfZ4YdlJNohzIZ8NJw/exec';
    const result = await registerLicense(code, userId, password, email, deviceId, serverUrl);

    // ë©”ì¸ í”„ë¡œì„¸ìŠ¤ ì½˜ì†”ì—ë„ ë””ë²„ê·¸ ì •ë³´ ì¶œë ¥
    if (result && result.debugInfo) {
      console.log('ğŸ” [licenseManager] ========================================');
      console.log('ğŸ” [licenseManager] ë©”ì¸ í”„ë¡œì„¸ìŠ¤ ì½˜ì†” - ë””ë²„ê·¸ ì •ë³´');
      if (result.debugInfo.register) {
        console.log('ğŸ” [licenseManager] - register usedValue:', result.debugInfo.register.usedValue);
        console.log('ğŸ” [licenseManager] - register usedCheck:', result.debugInfo.register.usedCheck);
        console.log('ğŸ” [licenseManager] - register used:', result.debugInfo.register.used);
        console.log('ğŸ” [licenseManager] - register isUsed:', result.debugInfo.register.isUsed);
      }
      if (result.debugInfo.verify) {
        console.log('ğŸ” [licenseManager] - verify usedValue:', result.debugInfo.verify.usedValue);
        console.log('ğŸ” [licenseManager] - verify usedCheck:', result.debugInfo.verify.usedCheck);
        console.log('ğŸ” [licenseManager] - verify used:', result.debugInfo.verify.used);
        console.log('ğŸ” [licenseManager] - verify isUsed:', result.debugInfo.verify.isUsed);
      }
      console.log('ğŸ” [licenseManager] ========================================');
    }

    return result;
  } catch (error) {
    return {
      valid: false,
      message: `ë¼ì´ì„ ìŠ¤ ë“±ë¡ ì¤‘ ì˜¤ë¥˜: ${(error as Error).message}`,
    };
  }
});

ipcMain.handle('license:verify', async (_event, code: string, deviceId: string, email?: string): Promise<{ valid: boolean; license?: LicenseInfo; message?: string }> => {
  try {
    const serverUrl = process.env.LICENSE_SERVER_URL || 'https://script.google.com/macros/s/AKfycbxBOGkjVj4p-6XZ4SEFYKhW3FBmo5gt7Fv6djWhB1TljnDDmx_qlfZ4YdlJNohzIZ8NJw/exec';
    return await verifyLicense(code, deviceId, serverUrl, email);
  } catch (error) {
    return {
      valid: false,
      message: `ë¼ì´ì„ ìŠ¤ ê²€ì¦ ì¤‘ ì˜¤ë¥˜: ${(error as Error).message}`,
    };
  }
});

ipcMain.handle('license:verifyWithCredentials', async (_event, userId: string, password: string, deviceId: string): Promise<{ valid: boolean; license?: LicenseInfo; message?: string; debugInfo?: any }> => {
  try {
    const serverUrl = process.env.LICENSE_SERVER_URL || 'https://script.google.com/macros/s/AKfycbxBOGkjVj4p-6XZ4SEFYKhW3FBmo5gt7Fv6djWhB1TljnDDmx_qlfZ4YdlJNohzIZ8NJw/exec';
    return await verifyLicenseWithCredentials(userId, password, deviceId, serverUrl);
  } catch (error) {
    return {
      valid: false,
      message: `ë¼ì´ì„ ìŠ¤ ê²€ì¦ ì¤‘ ì˜¤ë¥˜: ${(error as Error).message}`,
    };
  }
});

// ì™¸ë¶€ ìœ ì… 90ì¼ ë¼ì´ì„ ìŠ¤ ë“±ë¡
ipcMain.handle('license:registerExternalInflow', async (): Promise<{ success: boolean; message: string; expiresAt?: string }> => {
  try {
    console.log('[Main] ì™¸ë¶€ ìœ ì… 90ì¼ ë¼ì´ì„ ìŠ¤ ë“±ë¡ ìš”ì²­');
    const result = await registerExternalInflowLicense();
    console.log('[Main] ì™¸ë¶€ ìœ ì… ë¼ì´ì„ ìŠ¤ ë“±ë¡ ê²°ê³¼:', result);
    return result;
  } catch (error) {
    console.error('[Main] ì™¸ë¶€ ìœ ì… ë¼ì´ì„ ìŠ¤ ë“±ë¡ ì˜¤ë¥˜:', error);
    return {
      success: false,
      message: `ì™¸ë¶€ ìœ ì… ë¼ì´ì„ ìŠ¤ ë“±ë¡ ì‹¤íŒ¨: ${(error as Error).message}`
    };
  }
});

// ì™¸ë¶€ ìœ ì… ê¸°ëŠ¥ ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
ipcMain.handle('license:canUseExternalInflow', async (): Promise<boolean> => {
  try {
    const canUse = await canUseExternalInflow();
    console.log('[Main] ì™¸ë¶€ ìœ ì… ê¸°ëŠ¥ ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€:', canUse);
    return canUse;
  } catch (error) {
    console.error('[Main] ì™¸ë¶€ ìœ ì… ê¸°ëŠ¥ ê²€ì¦ ì˜¤ë¥˜:', error);
    return false;
  }
});

ipcMain.handle('license:checkPatchFile', async (): Promise<boolean> => {
  try {
    return await checkPatchFile();
  } catch (error) {
    console.error('[Main] íŒ¨ì¹˜ íŒŒì¼ í™•ì¸ ì‹¤íŒ¨:', (error as Error).message);
    return false;
  }
});

ipcMain.handle('app:isPackaged', async (): Promise<boolean> => {
  return app.isPackaged;
});

ipcMain.handle('login:success', async (): Promise<void> => {
  isLicenseValid = true;
  if (loginWindow) {
    loginWindow.close();
  }

  debugLog('[login:success] License authentication successful');

  // ë©”ì¸ ì°½ì´ ì—†ìœ¼ë©´ ìƒì„± (ì´ˆê¸° ì¸ì¦ ì‹œ)
  if (!mainWindow || mainWindow.isDestroyed()) {
    debugLog('[login:success] Main window not found, creating...');
    await createWindow();
    createTray(); // âœ… íŠ¸ë ˆì´ ìƒì„±
  } else {
    debugLog('[login:success] Main window already exists, focusing...');
    if (mainWindow.isMinimized()) {
      mainWindow.restore();
    }
    mainWindow.focus();
    mainWindow.show();
  }
});

ipcMain.handle('license:getDeviceId', async (): Promise<string> => {
  try {
    return await getDeviceId();
  } catch (error) {
    console.error('[Main] ê¸°ê¸° ID ìƒì„± ì‹¤íŒ¨:', (error as Error).message);
    return '';
  }
});

ipcMain.handle('license:testServer', async (_event, serverUrl?: string): Promise<{ success: boolean; message: string; response?: any }> => {
  try {
    return await testLicenseServer(serverUrl);
  } catch (error) {
    console.error('[Main] License server test error:', (error as Error).message);
    return {
      success: false,
      message: `í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: ${(error as Error).message}`,
    };
  }
});

// âœ… ì›í´ë¦­ ë„¤íŠ¸ì›Œí¬ ìµœì í™” í•¸ë“¤ëŸ¬
ipcMain.handle('network:optimize', async (): Promise<{ success: boolean; message: string; results: string[] }> => {
  const results: string[] = [];
  let overallSuccess = true;

  try {
    results.push('===== âš¡ ë„¤íŠ¸ì›Œí¬ ìµœì í™” ì‹œì‘ =====\n');

    // 1. DNS ìºì‹œ ê°±ì‹  (Windows)
    results.push('ğŸ”„ DNS ìºì‹œ ê°±ì‹  ì¤‘...');
    try {
      const { execSync } = await import('child_process');
      if (process.platform === 'win32') {
        execSync('ipconfig /flushdns', { encoding: 'utf-8', timeout: 10000 });
        results.push('âœ… DNS ìºì‹œ ê°±ì‹  ì™„ë£Œ');
      } else if (process.platform === 'darwin') {
        execSync('sudo dscacheutil -flushcache; sudo killall -HUP mDNSResponder', { encoding: 'utf-8', timeout: 10000 });
        results.push('âœ… DNS ìºì‹œ ê°±ì‹  ì™„ë£Œ (macOS)');
      } else {
        results.push('âš ï¸ DNS ìºì‹œ ê°±ì‹ : Linuxì—ì„œëŠ” ìˆ˜ë™ìœ¼ë¡œ ì‹¤í–‰í•´ì£¼ì„¸ìš”');
      }
    } catch (dnsError) {
      results.push(`âš ï¸ DNS ìºì‹œ ê°±ì‹  ì‹¤íŒ¨ (ê´€ë¦¬ì ê¶Œí•œ í•„ìš”í•  ìˆ˜ ìˆìŒ)`);
    }

    // 2. ì—°ê²° í…ŒìŠ¤íŠ¸ ë° ìµœì  ì„œë²„ í™•ì¸
    results.push('\nğŸ” API ì„œë²„ ì—°ê²° í…ŒìŠ¤íŠ¸...');
    const testUrls = [
      { name: 'Google (Gemini)', url: 'https://generativelanguage.googleapis.com/' },
      { name: 'OpenAI', url: 'https://api.openai.com/' },
      { name: 'Anthropic', url: 'https://api.anthropic.com/' },
    ];

    for (const { name, url } of testUrls) {
      try {
        const startTime = Date.now();
        const response = await fetch(url, {
          method: 'GET',
          signal: AbortSignal.timeout(5000)
        });
        const latency = Date.now() - startTime;

        if (latency < 500) {
          results.push(`âœ… ${name}: ${latency}ms (ë§¤ìš° ë¹ ë¦„)`);
        } else if (latency < 1500) {
          results.push(`âœ… ${name}: ${latency}ms (ì–‘í˜¸)`);
        } else {
          results.push(`âš ï¸ ${name}: ${latency}ms (ëŠë¦¼ - ë„¤íŠ¸ì›Œí¬ í™•ì¸ í•„ìš”)`);
        }
      } catch (e) {
        results.push(`âŒ ${name}: ì—°ê²° ì‹¤íŒ¨`);
        overallSuccess = false;
      }
    }

    // 3. ìµœì í™” ê¶Œì¥ì‚¬í•­
    results.push('\n===== ğŸ“‹ ìµœì í™” ì™„ë£Œ =====\n');

    if (overallSuccess) {
      results.push('âœ… ë„¤íŠ¸ì›Œí¬ ìƒíƒœê°€ ì–‘í˜¸í•©ë‹ˆë‹¤!');
      results.push('');
      results.push('ğŸ’¡ ì¶”ê°€ ì†ë„ í–¥ìƒ íŒ:');
      results.push('â€¢ ë¶ˆí•„ìš”í•œ ë¸Œë¼ìš°ì € íƒ­ ë‹«ê¸°');
      results.push('â€¢ ë‹¤ìš´ë¡œë“œ/ì—…ë¡œë“œ ì¤‘ì¸ íŒŒì¼ ì¼ì‹œ ì¤‘ì§€');
      results.push('â€¢ ìœ ì„  ì—°ê²° ì‚¬ìš© (WiFië³´ë‹¤ ì•ˆì •ì )');
    } else {
      results.push('âš ï¸ ì¼ë¶€ ì—°ê²°ì— ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤.');
      results.push('');
      results.push('ğŸ”§ í•´ê²° ë°©ë²•:');
      results.push('1. VPN ì‚¬ìš© ì¤‘ì´ë©´ ë„ê¸°');
      results.push('2. ë°©í™”ë²½ì—ì„œ ì•± í—ˆìš©');
      results.push('3. ë‹¤ë¥¸ ë„¤íŠ¸ì›Œí¬ë¡œ ì‹œë„ (ëª¨ë°”ì¼ í•«ìŠ¤íŒŸ)');
      results.push('4. íšŒì‚¬/í•™êµ ë„¤íŠ¸ì›Œí¬ë©´ ITíŒ€ì— ë¬¸ì˜');
    }

    return {
      success: overallSuccess,
      message: overallSuccess ? 'ë„¤íŠ¸ì›Œí¬ ìµœì í™” ì™„ë£Œ!' : 'ì¼ë¶€ ì—°ê²° ë¬¸ì œ ë°œê²¬',
      results
    };

  } catch (error) {
    return {
      success: false,
      message: `ìµœì í™” ì¤‘ ì˜¤ë¥˜: ${(error as Error).message}`,
      results: [...results, `âŒ ì˜¤ë¥˜: ${(error as Error).message}`]
    };
  }
});

// ê´€ë¦¬ì íŒ¨ë„ API í•¸ë“¤ëŸ¬ë“¤
ipcMain.handle('admin:connect', async (): Promise<{ success: boolean; message: string }> => {
  try {
    console.log('[Admin] ê´€ë¦¬ì íŒ¨ë„ ì—°ê²° ì‹œë„...');

    // ë¼ì´ì„ ìŠ¤ ê²€ì¦
    const isValid = await ensureLicenseValid();
    if (!isValid) {
      return { success: false, message: 'ë¼ì´ì„ ìŠ¤ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.' };
    }

    // ê´€ë¦¬ì íŒ¨ë„ ì—°ê²° ë¡œì§ (ì‹¤ì œë¡œëŠ” ì„œë²„ API í˜¸ì¶œ)
    // TODO: ê´€ë¦¬ì íŒ¨ë„ ì„œë²„ì— ì—°ê²°

    console.log('[Admin] ê´€ë¦¬ì íŒ¨ë„ ì—°ê²° ì„±ê³µ');
    return { success: true, message: 'ê´€ë¦¬ì íŒ¨ë„ì— ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤.' };
  } catch (error) {
    console.error('[Admin] ì—°ê²° ì‹¤íŒ¨:', error);
    return { success: false, message: `ì—°ê²° ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('admin:syncSettings', async (): Promise<{ success: boolean; message: string; settings?: any }> => {
  try {
    console.log('[Admin] ê´€ë¦¬ì ì„¤ì • ë™ê¸°í™” ì‹œë„...');

    // ë¼ì´ì„ ìŠ¤ ê²€ì¦
    const isValid = await ensureLicenseValid();
    if (!isValid) {
      return { success: false, message: 'ë¼ì´ì„ ìŠ¤ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.' };
    }

    // ê´€ë¦¬ì ì„¤ì • ë™ê¸°í™” ë¡œì§
    // TODO: ì„œë²„ì—ì„œ ì„¤ì •ì„ ê°€ì ¸ì™€ì„œ ë¡œì»¬ì— ì ìš©

    console.log('[Admin] ê´€ë¦¬ì ì„¤ì • ë™ê¸°í™” ì™„ë£Œ');
    return { success: true, message: 'ì„¤ì •ì´ ë™ê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.', settings: {} };
  } catch (error) {
    console.error('[Admin] ì„¤ì • ë™ê¸°í™” ì‹¤íŒ¨:', error);
    return { success: false, message: `ë™ê¸°í™” ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('admin:sendReport', async (_event, reportData: any): Promise<{ success: boolean; message: string }> => {
  try {
    console.log('[Admin] ê´€ë¦¬ì ë³´ê³ ì„œ ì „ì†¡ ì‹œë„...');

    // ë¼ì´ì„ ìŠ¤ ê²€ì¦
    const isValid = await ensureLicenseValid();
    if (!isValid) {
      return { success: false, message: 'ë¼ì´ì„ ìŠ¤ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.' };
    }

    // ê´€ë¦¬ì ë³´ê³ ì„œ ì „ì†¡ ë¡œì§
    // TODO: ì‚¬ìš© í†µê³„, ì˜¤ë¥˜ ì •ë³´ ë“±ì„ ì„œë²„ë¡œ ì „ì†¡

    console.log('[Admin] ê´€ë¦¬ì ë³´ê³ ì„œ ì „ì†¡ ì™„ë£Œ');
    return { success: true, message: 'ë³´ê³ ì„œê°€ ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤.' };
  } catch (error) {
    console.error('[Admin] ë³´ê³ ì„œ ì „ì†¡ ì‹¤íŒ¨:', error);
    return { success: false, message: `ì „ì†¡ ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('admin:checkPermissions', async (): Promise<{ success: boolean; permissions?: any }> => {
  try {
    console.log('[Admin] ê´€ë¦¬ì ê¶Œí•œ í™•ì¸ ì‹œë„...');

    // ë¼ì´ì„ ìŠ¤ ê²€ì¦
    const isValid = await ensureLicenseValid();
    if (!isValid) {
      return { success: false, permissions: { isValid: false } };
    }

    // ê´€ë¦¬ì ê¶Œí•œ í™•ì¸ ë¡œì§
    // TODO: ì„œë²„ì—ì„œ ê¶Œí•œ ì •ë³´ë¥¼ ê°€ì ¸ì˜´

    console.log('[Admin] ê´€ë¦¬ì ê¶Œí•œ í™•ì¸ ì™„ë£Œ');
    return {
      success: true,
      permissions: {
        isValid: true,
        canAccessAdminPanel: true,
        canSyncSettings: true,
        canSendReports: true
      }
    };
  } catch (error) {
    console.error('[Admin] ê¶Œí•œ í™•ì¸ ì‹¤íŒ¨:', error);
    return { success: false, permissions: { isValid: false, error: (error as Error).message } };
  }
});

ipcMain.handle('admin:syncAccounts', async () => {
  try {
    console.log('[Admin] ìˆ˜ë™ ê³„ì • ë™ê¸°í™” ì‹œë„...');
    await reportUserActivity();
    return { success: true, message: 'íŒ¨ë„ê³¼ ê³„ì • ì •ë³´ ë™ê¸°í™” ì™„ë£Œ' };
  } catch (error) {
    console.error('[Admin] ê³„ì • ë™ê¸°í™” ì‹¤íŒ¨:', error);
    return { success: false, message: `ë™ê¸°í™” ì‹¤íŒ¨: ${(error as Error).message}` };
  }
});

ipcMain.handle('admin:verifyPin', async (_event, pin: string): Promise<{ success: boolean; message?: string }> => {
  try {
    const configured = (process.env.ADMIN_PIN || '').trim();
    if (!configured) {
      return { success: false, message: 'ADMIN_PINì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.' };
    }
    const input = String(pin || '').trim();
    if (!input) {
      return { success: false, message: 'PINì´ ì…ë ¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.' };
    }
    if (input !== configured) {
      return { success: false, message: 'PINì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.' };
    }
    return { success: true };
  } catch (error) {
    return { success: false, message: (error as Error).message };
  }
});

ipcMain.handle('license:clear', async (): Promise<void> => {
  try {
    await clearLicense();
  } catch (error) {
    console.error('[Main] ë¼ì´ì„ ìŠ¤ ì‚­ì œ ì‹¤íŒ¨:', (error as Error).message);
  }
});

ipcMain.handle('license:revalidate', async (_event, serverUrl?: string): Promise<boolean> => {
  try {
    return await revalidateLicense(serverUrl || process.env.LICENSE_SERVER_URL);
  } catch (error) {
    console.error('[Main] License revalidation error:', (error as Error).message);
    return false;
  }
});

// Excel ìë™ í¬ìŠ¤íŒ… ê¸°ëŠ¥ ì œê±°ë¨

// ì¸ë„¤ì¼ì„ ë¡œì»¬ì— ì €ì¥
ipcMain.handle('thumbnail:saveToLocal', async (_event, blobData: { type: string; data: number[] }, format: 'png' | 'jpg'): Promise<{ success: boolean; filePath?: string; message?: string }> => {
  try {
    if (!mainWindow) {
      return { success: false, message: 'ë©”ì¸ ìœˆë„ìš°ê°€ ì—†ìŠµë‹ˆë‹¤.' };
    }

    const result = await dialog.showSaveDialog(mainWindow, {
      title: 'ì¸ë„¤ì¼ ì €ì¥',
      defaultPath: `thumbnail-${Date.now()}.${format}`,
      filters: [
        { name: format === 'png' ? 'PNG ì´ë¯¸ì§€' : 'JPEG ì´ë¯¸ì§€', extensions: [format] },
        { name: 'ëª¨ë“  ì´ë¯¸ì§€', extensions: ['png', 'jpg', 'jpeg'] },
      ],
    });

    if (result.canceled || !result.filePath) {
      return { success: false, message: 'ì €ì¥ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.' };
    }

    const buffer = Buffer.from(blobData.data);
    await fs.writeFile(result.filePath, buffer);

    return { success: true, filePath: result.filePath };
  } catch (error) {
    return { success: false, message: (error as Error).message };
  }
});

// âœ… ë¡œì»¬ ì´ë¯¸ì§€ ì„ íƒ ê¸°ëŠ¥ (í™œì„±í™”ë¨)
// ì´ë¯¸ì§€ë¥¼ ë¡œì»¬ì— ì €ì¥
ipcMain.handle('library:saveImageToLocal', async (_event, sourceFilePath: string, suggestedName: string): Promise<boolean> => {
  try {
    const fs = await import('fs/promises');
    const path = await import('path');
    const { dialog } = await import('electron');
    const axios = (await import('axios')).default;

    if (!sourceFilePath) {
      console.error('[Main] ì´ë¯¸ì§€ ì €ì¥ ì‹¤íŒ¨: ì†ŒìŠ¤ ê²½ë¡œê°€ ì—†ìŠµë‹ˆë‹¤.');
      return false;
    }

    // íŒŒì¼ í™•ì¥ì ì¶”ì¶œ
    let ext = path.extname(sourceFilePath).split('?')[0]; // URL ì¿¼ë¦¬ íŒŒë¼ë¯¸í„° ì œê±°
    if (!ext || ext.length > 5) ext = '.jpg';

    const baseName = suggestedName.replace(/[^a-zA-Z0-9ê°€-í£]/g, '_') || 'image';
    const defaultFileName = `${baseName}${ext}`;

    // ì €ì¥ ë‹¤ì´ì–¼ë¡œê·¸ ì—´ê¸°
    const mainWindow = BrowserWindow.getFocusedWindow();
    if (!mainWindow) {
      throw new Error('ë©”ì¸ ìœˆë„ìš°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }

    const result = await dialog.showSaveDialog(mainWindow, {
      title: 'ì´ë¯¸ì§€ ì €ì¥',
      defaultPath: defaultFileName,
      filters: [
        { name: 'ì´ë¯¸ì§€ íŒŒì¼', extensions: ['png', 'jpg', 'jpeg', 'gif', 'webp'] },
        { name: 'ëª¨ë“  íŒŒì¼', extensions: ['*'] },
      ],
    });

    if (result.canceled || !result.filePath) {
      return false;
    }

    let imageBuffer: Buffer;

    if (sourceFilePath.startsWith('http')) {
      // URLì¸ ê²½ìš° ë‹¤ìš´ë¡œë“œ
      console.log(`[Main] ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì¤‘: ${sourceFilePath}`);
      const response = await axios.get(sourceFilePath, { responseType: 'arraybuffer' });
      imageBuffer = Buffer.from(response.data);
    } else if (sourceFilePath.startsWith('data:')) {
      // Base64ì¸ ê²½ìš°
      const base64Data = sourceFilePath.split(',')[1];
      imageBuffer = Buffer.from(base64Data, 'base64');
    } else {
      // ë¡œì»¬ íŒŒì¼ì¸ ê²½ìš°
      imageBuffer = await fs.readFile(sourceFilePath);
    }

    // ì„ íƒí•œ ê²½ë¡œì— ì €ì¥
    await fs.writeFile(result.filePath, imageBuffer);
    console.log(`[Main] ì´ë¯¸ì§€ ì €ì¥ ì™„ë£Œ: ${result.filePath}`);

    return true;
  } catch (error) {
    console.error('[Main] ì´ë¯¸ì§€ ë¡œì»¬ ì €ì¥ ì‹¤íŒ¨:', (error as Error).message);
    return false;
  }
});

// ë¡œì»¬ ì´ë¯¸ì§€ íŒŒì¼ ì„ íƒ
ipcMain.handle('library:selectLocalImageFile', async (): Promise<{ success: boolean; filePath?: string; previewDataUrl?: string; message?: string }> => {
  try {
    const { dialog } = await import('electron');

    const mainWindow = BrowserWindow.getFocusedWindow();
    if (!mainWindow) {
      throw new Error('ë©”ì¸ ìœˆë„ìš°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }

    const result = await dialog.showOpenDialog(mainWindow, {
      title: 'ì´ë¯¸ì§€ íŒŒì¼ ì„ íƒ',
      filters: [
        { name: 'ì´ë¯¸ì§€ íŒŒì¼', extensions: ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp'] },
        { name: 'ëª¨ë“  íŒŒì¼', extensions: ['*'] },
      ],
      properties: ['openFile'],
    });

    if (result.canceled || result.filePaths.length === 0) {
      return {
        success: false,
        message: 'íŒŒì¼ ì„ íƒì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.',
      };
    }

    const filePath = result.filePaths[0];
    // âœ… file:// URLë¡œ ë³€í™˜í•˜ì—¬ previewDataUrl ì œê³µ
    const previewDataUrl = `file:///${filePath.replace(/\\/g, '/')}`;

    return {
      success: true,
      filePath: filePath,
      previewDataUrl: previewDataUrl,
    };
  } catch (error) {
    return {
      success: false,
      message: `íŒŒì¼ ì„ íƒ ì¤‘ ì˜¤ë¥˜: ${(error as Error).message}`,
    };
  }
});

// âœ… í´ë” ì„ íƒ ë‹¤ì´ì–¼ë¡œê·¸ëŠ” íŒŒì¼ ìƒë‹¨ì—ì„œ ì´ë¯¸ ë“±ë¡ë¨ (dialog:showOpenDialog)

ipcMain.handle('library:getImageData', async (_event, filePath: string): Promise<string | null> => {
  try {
    const fs = await import('fs/promises');
    const path = await import('path');

    // íŒŒì¼ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
    try {
      await fs.access(filePath);
    } catch {
      return null;
    }

    // íŒŒì¼ ì½ê¸°
    const buffer = await fs.readFile(filePath);
    const base64 = buffer.toString('base64');
    const ext = path.extname(filePath).toLowerCase();
    const mimeType = ext === '.png' ? 'image/png' : ext === '.jpg' || ext === '.jpeg' ? 'image/jpeg' : 'image/png';

    return `data:${mimeType};base64,${base64}`;
  } catch (error) {
    console.error('[Main] ì´ë¯¸ì§€ ë°ì´í„° ì½ê¸° ì‹¤íŒ¨:', (error as Error).message);
    return null;
  }
});

// ìŠ¤ì¼€ì¤„ ê´€ë¦¬ IPC í•¸ë“¤ëŸ¬
ipcMain.handle('schedule:getAll', async (): Promise<{ success: boolean; posts?: ScheduledPost[]; message?: string }> => {
  // ë¼ì´ì„ ìŠ¤ ì²´í¬
  if (!(await ensureLicenseValid())) {
    return { success: false, message: 'ë¼ì´ì„ ìŠ¤ ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤. ë¼ì´ì„ ìŠ¤ë¥¼ ì¸ì¦í•´ì£¼ì„¸ìš”.' };
  }
  try {
    const posts = await getAllScheduledPosts();
    return { success: true, posts };
  } catch (error) {
    console.error('[Main] ìŠ¤ì¼€ì¤„ ì¡°íšŒ ì‹¤íŒ¨:', (error as Error).message);
    return { success: false, message: (error as Error).message };
  }
});

// ì°½ í¬ì»¤ìŠ¤ ìœ ì§€
ipcMain.handle('window:focus', async () => {
  try {
    if (mainWindow) {
      if (mainWindow.isMinimized()) {
        mainWindow.restore();
      }
      mainWindow.focus();
      mainWindow.show();
      return { success: true };
    }
    return { success: false, message: 'ì°½ì´ ì—†ìŠµë‹ˆë‹¤.' };
  } catch (error) {
    console.error('[Main] Window focus error:', error);
    return { success: false, message: (error as Error).message };
  }
});

ipcMain.handle('schedule:remove', async (_event, postId: string): Promise<{ success: boolean; message?: string }> => {
  // ë¼ì´ì„ ìŠ¤ ì²´í¬
  if (!(await ensureLicenseValid())) {
    return { success: false, message: 'ë¼ì´ì„ ìŠ¤ ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤. ë¼ì´ì„ ìŠ¤ë¥¼ ì¸ì¦í•´ì£¼ì„¸ìš”.' };
  }
  try {
    if (!postId || !postId.trim()) {
      return { success: false, message: 'í¬ìŠ¤íŠ¸ IDê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.' };
    }

    await removeScheduledPost(postId);
    console.log(`[Main] ìŠ¤ì¼€ì¤„ í¬ìŠ¤íŠ¸ ì‚­ì œ ì™„ë£Œ: ${postId}`);
    return { success: true };
  } catch (error) {
    console.error('[Main] ìŠ¤ì¼€ì¤„ í¬ìŠ¤íŠ¸ ì‚­ì œ ì‹¤íŒ¨:', (error as Error).message);
    return { success: false, message: (error as Error).message };
  }
});

// ì™¸ë¶€ URLì„ ë¸Œë¼ìš°ì €ì—ì„œ ì—´ê¸°
ipcMain.handle('openExternalUrl', async (_event, url: string): Promise<{ success: boolean; message?: string }> => {
  try {
    if (!url || !url.trim()) {
      return { success: false, message: 'URLì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤.' };
    }

    // URL ìœ íš¨ì„± ê²€ì‚¬
    const urlPattern = /^https?:\/\//i;
    if (!urlPattern.test(url.trim())) {
      return { success: false, message: 'ìœ íš¨í•˜ì§€ ì•Šì€ URL í˜•ì‹ì…ë‹ˆë‹¤.' };
    }

    await shell.openExternal(url.trim());
    console.log(`[Main] ì™¸ë¶€ URL ì—´ê¸°: ${url}`);
    return { success: true };
  } catch (error) {
    console.error('[Main] ì™¸ë¶€ URL ì—´ê¸° ì‹¤íŒ¨:', (error as Error).message);
    return { success: false, message: (error as Error).message };
  }
});

async function createLoginWindow(): Promise<BrowserWindow> {
  debugLog('[createLoginWindow] Creating login window...');

  loginWindow = new BrowserWindow({
    width: 500,
    height: 650,
    resizable: false,
    show: true, // ì¦‰ì‹œ í‘œì‹œ
    frame: true,
    center: true, // í™”ë©´ ì¤‘ì•™ì— í‘œì‹œ
    alwaysOnTop: true, // ìµœìƒìœ„ì— í‘œì‹œ
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
      webSecurity: true,
      devTools: true, // ê°œë°œì ë„êµ¬ í™œì„±í™”
    },
    title: 'ë¼ì´ì„ ìŠ¤ ì¸ì¦',
    icon: resolveIconImage(),
  });

  debugLog('[createLoginWindow] BrowserWindow created (showing immediately)');

  const loginHtmlPath = path.join(publicPath, 'login.html');
  debugLog(`[createLoginWindow] Loading HTML from: ${loginHtmlPath}`);

  try {
    await loginWindow.loadFile(loginHtmlPath);
    debugLog('[createLoginWindow] HTML loaded successfully');

    // HTML ë¡œë“œ í›„ í¬ì»¤ìŠ¤
    loginWindow.focus();
    loginWindow.show();

    // 1ì´ˆ í›„ í•­ìƒ ìœ„ ëª¨ë“œ í•´ì œ
    setTimeout(() => {
      if (loginWindow && !loginWindow.isDestroyed()) {
        loginWindow.setAlwaysOnTop(false);
        loginWindow.focus();
        debugLog('[createLoginWindow] Always on top disabled');
      }
    }, 1000);
  } catch (error) {
    debugLog(`[createLoginWindow] !!! ERROR loading HTML: ${(error as Error).message}`);
    throw error;
  }

  loginWindow.on('closed', () => {
    debugLog('[createLoginWindow] Login window closed event');
    loginWindow = null;
  });

  debugLog('[createLoginWindow] Login window setup complete');
  return loginWindow;
}

async function checkLicense(): Promise<boolean> {
  debugLog('[checkLicense] ========== START ==========');

  // ê°œë°œ ëª¨ë“œì—ì„œ FORCE_LICENSE_CHECK=trueê°€ ì•„ë‹ˆë©´ ë¼ì´ì„ ìŠ¤ ì²´í¬ ìŠ¤í‚µ
  const forceLicenseCheck = process.env.FORCE_LICENSE_CHECK === 'true';
  debugLog(`[checkLicense] isPackaged: ${app.isPackaged}, forceLicenseCheck: ${forceLicenseCheck}`);

  if (!app.isPackaged && !forceLicenseCheck) {
    debugLog('[checkLicense] Development mode: skipping license check');
    isLicenseValid = true;
    return true;
  }

  // ì €ì¥ëœ ë¼ì´ì„ ìŠ¤ í™•ì¸
  debugLog('[checkLicense] Loading saved license...');
  const license = await loadLicense();
  debugLog(`[checkLicense] License loaded: ${license ? 'YES' : 'NO'}, isValid: ${license?.isValid}`);

  if (!license || !license.isValid) {
    // ê°œë°œ ëª¨ë“œì—ì„œëŠ” ë¡œê·¸ì¸ ì°½ì„ í‘œì‹œí•˜ì§€ë§Œ ë‹«ìœ¼ë©´ í†µê³¼ ê°€ëŠ¥
    if (!app.isPackaged) {
      console.log('[Main] Development mode: showing login window but allowing skip');
      await createLoginWindow();

      // ê°œë°œ ëª¨ë“œì—ì„œëŠ” ë¡œê·¸ì¸ ì°½ì´ ë‹«íˆë©´ ì¸ì¦ ì—†ì´ë„ í†µê³¼
      return new Promise((resolve) => {
        let checkCount = 0;
        const maxChecks = 600; // ìµœëŒ€ 60ì´ˆ (100ms * 600)
        const checkInterval = setInterval(() => {
          checkCount++;
          if (checkCount > maxChecks) {
            clearInterval(checkInterval);
            console.log('[Main] License check timeout, allowing access in dev mode');
            isLicenseValid = true;
            resolve(true);
            return;
          }
          if (!loginWindow || loginWindow.isDestroyed()) {
            clearInterval(checkInterval);
            // ê°œë°œ ëª¨ë“œì—ì„œëŠ” ì¸ì¦ ì—†ì´ë„ í†µê³¼
            console.log('[Main] Development mode: login window closed, allowing access without authentication');
            isLicenseValid = true;
            resolve(true);
          }
        }, 100);
      });
    }

    // í”„ë¡œë•ì…˜ ëª¨ë“œ: ë¡œê·¸ì¸ ì°½ í‘œì‹œ
    debugLog('[checkLicense] Production mode: showing login window...');
    await createLoginWindow();
    debugLog('[checkLicense] Login window created');

    // ë¡œê·¸ì¸ ì°½ì´ ë‹«í ë•Œê¹Œì§€ ëŒ€ê¸° (ì¸ì¦ ì„±ê³µ ì‹œ ì°½ì´ ë‹«í˜)
    // ìµœëŒ€ 10ë¶„ íƒ€ì„ì•„ì›ƒ
    return new Promise((resolve) => {
      let checkCount = 0;
      const maxChecks = 6000; // 10ë¶„ (100ms * 6000)

      debugLog('[checkLicense] Waiting for login window to close...');

      const checkInterval = setInterval(async () => {
        checkCount++;

        // 30ì´ˆë§ˆë‹¤ ë¡œê·¸ ì¶œë ¥
        if (checkCount % 300 === 0) {
          debugLog(`[checkLicense] Still waiting... (${checkCount / 10}s elapsed)`);
        }

        // íƒ€ì„ì•„ì›ƒ ì²´í¬
        if (checkCount > maxChecks) {
          clearInterval(checkInterval);
          debugLog('[checkLicense] License check timeout (10 minutes), quitting app');
          if (loginWindow && !loginWindow.isDestroyed()) {
            loginWindow.close();
          }
          app.quit();
          resolve(false);
          return;
        }

        if (!loginWindow || loginWindow.isDestroyed()) {
          clearInterval(checkInterval);
          debugLog('[checkLicense] Login window closed, checking license validity...');
          const isValid = await ensureLicenseValid();
          debugLog(`[checkLicense] ensureLicenseValid result: ${isValid}`);
          if (isValid) {
            isLicenseValid = true;
            debugLog('[checkLicense] License valid, returning true');
            // login:success í•¸ë“¤ëŸ¬ì—ì„œ ë©”ì¸ ì°½ì„ ìƒì„±í•˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ìƒì„±í•˜ì§€ ì•ŠìŒ
            // ë©”ì¸ ì°½ì´ ì´ë¯¸ ìˆìœ¼ë©´ í¬ì»¤ìŠ¤ë§Œ
            if (mainWindow && !mainWindow.isDestroyed()) {
              debugLog('[checkLicense] Main window already exists, focusing...');
              if (mainWindow.isMinimized()) {
                mainWindow.restore();
              }
              mainWindow.focus();
              mainWindow.show();
            } else {
              debugLog('[checkLicense] Main window will be created by login:success handler');
            }
            resolve(true);
          } else {
            // ë¼ì´ì„ ìŠ¤ê°€ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ì•± ì¢…ë£Œ
            debugLog('[checkLicense] License not valid after login window closed, quitting app');
            app.quit();
            resolve(false);
          }
        }
      }, 100);
    });
  } else {
    // ë¼ì´ì„ ìŠ¤ê°€ ìˆì–´ë„ í•­ìƒ ë¡œê·¸ì¸ ì°½ì„ ë¨¼ì € í‘œì‹œ (ì´ˆê¸° ì¸ì¦ì°½ í‘œì‹œ)
    debugLog('[checkLicense] License exists, but showing login window first (initial auth screen)');

    // ê°œë°œ ëª¨ë“œì—ì„œëŠ” ë¡œê·¸ì¸ ì°½ì„ í‘œì‹œí•˜ì§€ë§Œ ë‹«ìœ¼ë©´ í†µê³¼ ê°€ëŠ¥
    if (!app.isPackaged) {
      console.log('[Main] Development mode: showing login window but allowing skip');
      await createLoginWindow();

      // ê°œë°œ ëª¨ë“œì—ì„œëŠ” ë¡œê·¸ì¸ ì°½ì´ ë‹«íˆë©´ ì¸ì¦ ì—†ì´ë„ í†µê³¼
      return new Promise((resolve) => {
        let checkCount = 0;
        const maxChecks = 600; // ìµœëŒ€ 60ì´ˆ (100ms * 600)
        const checkInterval = setInterval(() => {
          checkCount++;
          if (checkCount > maxChecks) {
            clearInterval(checkInterval);
            console.log('[Main] License check timeout, allowing access in dev mode');
            isLicenseValid = true;
            resolve(true);
            return;
          }
          if (!loginWindow || loginWindow.isDestroyed()) {
            clearInterval(checkInterval);
            // ê°œë°œ ëª¨ë“œì—ì„œëŠ” ì¸ì¦ ì—†ì´ë„ í†µê³¼
            console.log('[Main] Development mode: login window closed, allowing access without authentication');
            isLicenseValid = true;
            resolve(true);
          }
        }, 100);
      });
    }

    // í”„ë¡œë•ì…˜ ëª¨ë“œ: ë¡œê·¸ì¸ ì°½ í‘œì‹œ (ì´ˆê¸° ì¸ì¦ì°½)
    debugLog('[checkLicense] Production mode: showing login window (initial auth screen)...');
    await createLoginWindow();
    debugLog('[checkLicense] Login window created');

    // ë¡œê·¸ì¸ ì°½ì´ ë‹«í ë•Œê¹Œì§€ ëŒ€ê¸° (ì¸ì¦ ì„±ê³µ ì‹œ ì°½ì´ ë‹«í˜)
    // ìµœëŒ€ 10ë¶„ íƒ€ì„ì•„ì›ƒ
    return new Promise((resolve) => {
      let checkCount = 0;
      const maxChecks = 6000; // 10ë¶„ (100ms * 6000)

      debugLog('[checkLicense] Waiting for login window to close...');

      const checkInterval = setInterval(async () => {
        checkCount++;

        // 30ì´ˆë§ˆë‹¤ ë¡œê·¸ ì¶œë ¥
        if (checkCount % 300 === 0) {
          debugLog(`[checkLicense] Still waiting... (${checkCount / 10}s elapsed)`);
        }

        // íƒ€ì„ì•„ì›ƒ ì²´í¬
        if (checkCount > maxChecks) {
          clearInterval(checkInterval);
          debugLog('[checkLicense] License check timeout (10 minutes), quitting app');
          if (loginWindow && !loginWindow.isDestroyed()) {
            loginWindow.close();
          }
          app.quit();
          resolve(false);
          return;
        }

        if (!loginWindow || loginWindow.isDestroyed()) {
          clearInterval(checkInterval);
          debugLog('[checkLicense] Login window closed, checking license validity...');
          const isValid = await ensureLicenseValid();
          debugLog(`[checkLicense] ensureLicenseValid result: ${isValid}`);
          if (isValid) {
            isLicenseValid = true;
            debugLog('[checkLicense] License valid, returning true');
            // login:success í•¸ë“¤ëŸ¬ì—ì„œ ë©”ì¸ ì°½ì„ ìƒì„±í•˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ìƒì„±í•˜ì§€ ì•ŠìŒ
            // ë©”ì¸ ì°½ì´ ì´ë¯¸ ìˆìœ¼ë©´ í¬ì»¤ìŠ¤ë§Œ
            if (mainWindow && !mainWindow.isDestroyed()) {
              debugLog('[checkLicense] Main window already exists, focusing...');
              if (mainWindow.isMinimized()) {
                mainWindow.restore();
              }
              mainWindow.focus();
              mainWindow.show();
            } else {
              debugLog('[checkLicense] Main window will be created by login:success handler');
            }
            resolve(true);
          } else {
            // ë¼ì´ì„ ìŠ¤ê°€ ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ì•± ì¢…ë£Œ
            debugLog('[checkLicense] License not valid after login window closed, quitting app');
            app.quit();
            resolve(false);
          }
        }
      }, 100);
    });
  }
}

async function showLicenseInputDialog(): Promise<string | null> {
  // ê°„ë‹¨í•œ ì…ë ¥ ë‹¤ì´ì–¼ë¡œê·¸ (ì‹¤ì œë¡œëŠ” ë³„ë„ ì°½ì„ ë§Œë“œëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤)
  return new Promise((resolve) => {
    // Electronì˜ dialog.showInputBoxëŠ” ì—†ìœ¼ë¯€ë¡œ, ë³„ë„ ì°½ì„ ë§Œë“¤ì–´ì•¼ í•©ë‹ˆë‹¤
    // ì—¬ê¸°ì„œëŠ” ê°„ë‹¨í•œ ì˜ˆì‹œë¡œ nullì„ ë°˜í™˜í•˜ê³ , ì‹¤ì œ êµ¬í˜„ì€ ë³„ë„ ì°½ìœ¼ë¡œ ì²˜ë¦¬
    const licenseWindow = new BrowserWindow({
      width: 500,
      height: 300,
      resizable: false,
      modal: true,
      parent: mainWindow || undefined,
      webPreferences: {
        nodeIntegration: true,
        contextIsolation: false,
      },
    });

    // ë¼ì´ì„ ìŠ¤ ì…ë ¥ HTML ìƒì„±
    const licenseHtml = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <title>ë¼ì´ì„ ìŠ¤ ì…ë ¥</title>
        <style>
          body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 30px;
            background: #f5f5f5;
          }
          .container {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
          }
          h2 { margin-top: 0; }
          input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 4px;
            margin: 10px 0;
            box-sizing: border-box;
          }
          input:focus {
            outline: none;
            border-color: #3b82f6;
          }
          button {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
          }
          button:hover { background: #2563eb; }
          .error { color: red; margin-top: 10px; }
        </style>
      </head>
      <body>
        <div class="container">
          <h2>ë¼ì´ì„ ìŠ¤ ì½”ë“œ ì…ë ¥</h2>
          <p>ë¼ì´ì„ ìŠ¤ ì½”ë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš” (í˜•ì‹: XXXX-XXXX-XXXX-XXXX)</p>
          <input type="text" id="license-input" placeholder="XXXX-XXXX-XXXX-XXXX" maxlength="19" />
          <div id="error" class="error" style="display: none;"></div>
          <button id="submit-btn">í™•ì¸</button>
        </div>
        <script>
          const input = document.getElementById('license-input');
          const submitBtn = document.getElementById('submit-btn');
          const error = document.getElementById('error');
          
          // ìë™ í•˜ì´í”ˆ ì¶”ê°€
          input.addEventListener('input', (e) => {
            let value = e.target.value.replace(/[^A-Z0-9]/g, '').toUpperCase();
            if (value.length > 4) value = value.slice(0,4) + '-' + value.slice(4);
            if (value.length > 9) value = value.slice(0,9) + '-' + value.slice(9);
            if (value.length > 14) value = value.slice(0,14) + '-' + value.slice(14);
            if (value.length > 19) value = value.slice(0,19);
            e.target.value = value;
          });
          
          submitBtn.addEventListener('click', () => {
            const code = input.value.trim();
            if (code.length === 19 && /^[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{4}$/.test(code)) {
              const { ipcRenderer } = require('electron');
              ipcRenderer.send('license:code', code);
            } else {
              error.textContent = 'ì˜¬ë°”ë¥¸ í˜•ì‹ìœ¼ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”.';
              error.style.display = 'block';
            }
          });
          
          input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') submitBtn.click();
          });
        </script>
      </body>
      </html>
    `;

    licenseWindow.loadURL(`data:text/html;charset=utf-8,${encodeURIComponent(licenseHtml)}`);

    // IPCë¡œ ë¼ì´ì„ ìŠ¤ ì½”ë“œ ë°›ê¸°
    const handler = (_event: Electron.IpcMainEvent, code: string) => {
      ipcMain.removeListener('license:code', handler);
      licenseWindow.close();
      resolve(code);
    };
    ipcMain.once('license:code', handler);

    licenseWindow.on('closed', () => {
      if (!licenseWindow.isDestroyed()) {
        resolve(null);
      }
    });
  });
}

// Single Instance Lock - ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
const gotTheLock = app.requestSingleInstanceLock();

if (!gotTheLock) {
  console.log('[Main] Another instance is already running. Exiting immediately...');
  // ì¦‰ì‹œ ì¢…ë£Œ (ë‹¤ë¥¸ ì½”ë“œ ì‹¤í–‰ ì—†ì´)
  process.exit(0);
} else {
  console.log('[Main] Single instance lock acquired');

  app.on('second-instance', (event, commandLine, workingDirectory) => {
    console.log('[Main] Second instance attempt detected. Focusing existing window...');

    // ë©”ì¸ ì°½ì´ ìˆìœ¼ë©´ í¬ì»¤ìŠ¤
    if (mainWindow) {
      if (mainWindow.isMinimized()) mainWindow.restore();
      mainWindow.focus();
      mainWindow.show();
    }

    // ë¡œê·¸ì¸ ì°½ì´ ìˆìœ¼ë©´ í¬ì»¤ìŠ¤
    if (loginWindow && !loginWindow.isDestroyed()) {
      if (loginWindow.isMinimized()) loginWindow.restore();
      loginWindow.focus();
      loginWindow.show();
    }
  });
}

// ffmpeg ê²½ê³  ë¬´ì‹œ (ë¯¸ë””ì–´ ì¬ìƒ ê¸°ëŠ¥ ë¯¸ì‚¬ìš©)
app.commandLine.appendSwitch('disable-features', 'MediaFoundationVideoCapture');

app.whenReady().then(async () => {
  try {
    // ì•± ì´ë¦„ì„ ëª…ì‹œì ìœ¼ë¡œ ì„¤ì •í•˜ì—¬ ì˜¬ë°”ë¥¸ userData ê²½ë¡œ ì‚¬ìš©
    app.setName('naver-blog-automation');

    // âœ… isPackaged ê°’ì„ ì‹¤ì œ ê°’ìœ¼ë¡œ ì—…ë°ì´íŠ¸ (ë°°í¬ í™˜ê²½ ê°ì§€)

    debugLog('[Main] ========== APP READY ==========');
    debugLog('[Main] App ready, checking license...');
    debugLog(`[Main] isPackaged: ${app.isPackaged}`);
    debugLog(`[Main] Process arguments: ${process.argv.join(' ')}`);

    // ë¼ì´ì„ ìŠ¤ ê²€ì¦ (ë¡œê·¸ì¸ ì°½ í‘œì‹œ)
    debugLog('[Main] Calling checkLicense()...');
    const licenseCheckResult = await checkLicense();
    debugLog(`[Main] checkLicense() result: ${licenseCheckResult}`);

    if (!licenseCheckResult) {
      debugLog('[Main] License check failed, quitting app...');
      // ëª…ì‹œì ìœ¼ë¡œ ì•± ì¢…ë£Œ
      setTimeout(() => {
        debugLog('[Main] Executing app.quit()...');
        app.quit();
        process.exit(0);
      }, 500);
      return;
    }

    // ë¼ì´ì„ ìŠ¤ê°€ ìœ íš¨í•œì§€ ë‹¤ì‹œ í™•ì¸
    debugLog('[Main] Checking ensureLicenseValid()...');
    if (!(await ensureLicenseValid())) {
      debugLog('[Main] License not valid after check, quitting app...');
      // ëª…ì‹œì ìœ¼ë¡œ ì•± ì¢…ë£Œ
      setTimeout(() => {
        debugLog('[Main] Executing app.quit()...');
        app.quit();
        process.exit(0);
      }, 500);
      return;
    }

    debugLog('[Main] License check passed, starting app...');

    debugLog('[Main] Checking build expiry...');
    if (await enforceBuildExpiry()) {
      debugLog('[Main] Build expired, exiting...');
      return;
    }

    debugLog('[Main] Loading config...');
    appConfig = await loadConfig();
    applyConfigToEnv(appConfig);
    if (appConfig.dailyPostLimit !== undefined) {
      setDailyLimit(appConfig.dailyPostLimit);
    }

    // âœ… [ë¦¬íŒ©í† ë§] BlogExecutor ì˜ì¡´ì„± ì£¼ì… (í•¸ë“¤ëŸ¬ ë¡œì§ ì´ë™ ì§€ì›)
    (injectBlogExecutorDeps as (deps: any) => void)({
      loadConfig,
      applyConfigToEnv,
      createAutomation: (naverId: string, naverPassword: string) => {
        return new NaverBlogAutomation({ naverId, naverPassword });
      },
      blogAccountManager,
      getDailyLimit,
      getTodayCount,
      incrementTodayCount,
      setGeminiModel,
    });
    debugLog('[Main] BlogExecutor dependencies injected');

    // AI ì–´ì‹œìŠ¤í„´íŠ¸ Gemini ì¬ì´ˆê¸°í™”
    const geminiConnected = masterAgent.reinitGemini();
    debugLog(`[Main] AI ì–´ì‹œìŠ¤í„´íŠ¸ Gemini ì—°ë™: ${geminiConnected ? 'ì„±ê³µ' : 'ì‹¤íŒ¨'}`);

    debugLog('[Main] Loading heading images store...');
    await loadHeadingImagesStore();

    debugLog('[Main] Loading heading videos store...');
    await loadHeadingVideosStore();

    debugLog('[Main] Initializing image library...');
    await initializeImageLibrary();

    if (process.env.START_REALTIME_MONITOR === 'true' && !monitorTask) {
      monitorTask = trendMonitor
        .monitorRealtime()
        .catch((error) => sendLog(`âš ï¸ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì˜¤ë¥˜: ${(error as Error).message}`));
    }

    if (process.env.START_DAILY_AUTOMATION === 'true') {
      cron.schedule('0 6 * * *', async () => {
        sendLog('ğŸ“… ì¼ê°„ ìë™í™” ì˜ˆì•½ ì‹¤í–‰ (í”Œë ˆì´ìŠ¤í™€ë”)');
      });
    }

    if (process.env.START_PATTERN_LEARNING === 'true') {
      cron.schedule('0 23 * * *', async () => {
        sendLog('ğŸ“ ì¼ì¼ íŒ¨í„´ í•™ìŠµ ì˜ˆì•½ ì‹¤í–‰');
        await patternAnalyzer.analyzeAndLearn().catch((error) => {
          sendLog(`âŒ ì¼ì¼ íŒ¨í„´ í•™ìŠµ ì‹¤íŒ¨: ${(error as Error).message}`);
        });
      });
    }

    cron.schedule('0 0 * * *', async () => {
      try {
        await resetAllQuota();
      } catch (e) {
        console.error('[Quota] daily reset failed:', e);
      }
    });

    // âœ… ì˜ˆì•½ ë°œí–‰ ì‹¤í–‰ (1ë¶„ë§ˆë‹¤ ì²´í¬)
    cron.schedule('* * * * *', async () => {
      try {
        const scheduledPosts = await loadScheduledPosts();
        const now = new Date();

        for (const post of scheduledPosts) {
          // âœ… ë‚ ì§œ íŒŒì‹± ìˆ˜ì •: "2025-12-12 02:09" í˜•ì‹ì„ "2025-12-12T02:09:00" ISO í˜•ì‹ìœ¼ë¡œ ë³€í™˜
          const scheduleDateStr = post.scheduleDate.includes('T')
            ? post.scheduleDate
            : post.scheduleDate.replace(' ', 'T') + ':00';
          const scheduleDate = new Date(scheduleDateStr);

          // âœ… ë””ë²„ê¹…: ë‚ ì§œ íŒŒì‹± ê²°ê³¼ í™•ì¸
          console.log(`[Scheduler] ğŸ“… ì˜ˆì•½ ì²´í¬: "${post.title}"`);
          console.log(`[Scheduler]   - ì›ë³¸: ${post.scheduleDate}`);
          console.log(`[Scheduler]   - íŒŒì‹±ëœ scheduleDate: ${scheduleDate.toISOString()} (${scheduleDate.toLocaleString('ko-KR')})`);
          console.log(`[Scheduler]   - í˜„ì¬ ì‹œê°„ now: ${now.toISOString()} (${now.toLocaleString('ko-KR')})`);
          console.log(`[Scheduler]   - ë¹„êµ: scheduleDate <= now ? ${scheduleDate <= now}`);

          // ì˜ˆì•½ ì‹œê°„ì´ ë˜ì—ˆê³ , ì•„ì§ ë°œí–‰ë˜ì§€ ì•Šì€ ê²½ìš°
          if (scheduleDate <= now && post.status === 'scheduled') {
            console.log(`[Scheduler] â° ì˜ˆì•½ ë°œí–‰ ì‹œê°„ ë„ë˜! ë°œí–‰ ì‹œì‘: ${post.title}`);
            sendLog(`â° ì˜ˆì•½ ë°œí–‰ ì‹œê°„ì´ ë˜ì—ˆìŠµë‹ˆë‹¤: ${post.title}`);

            // âœ… mainWindow í™•ì¸
            if (!mainWindow || mainWindow.isDestroyed()) {
              console.error(`[Scheduler] âŒ ë©”ì¸ ìœˆë„ìš°ê°€ ì—†ìŠµë‹ˆë‹¤. ì•±ì´ ì‹¤í–‰ ì¤‘ì´ì–´ì•¼ í•©ë‹ˆë‹¤.`);
              sendLog(`âŒ ì˜ˆì•½ ë°œí–‰ ì‹¤íŒ¨: ì•±ì´ ì‹¤í–‰ ì¤‘ì´ì–´ì•¼ í•©ë‹ˆë‹¤.`);
              post.status = 'cancelled';
              await saveScheduledPost(post);
              continue;
            }

            try {
              // âœ… localStorageì—ì„œ ìƒì„±ëœ ê¸€ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (postId ë˜ëŠ” titleë¡œ ê²€ìƒ‰)
              if (!mainWindow) {
                throw new Error('ë©”ì¸ ìœˆë„ìš°ê°€ ì—†ìŠµë‹ˆë‹¤. ì•±ì´ ì‹¤í–‰ ì¤‘ì´ì–´ì•¼ í•©ë‹ˆë‹¤.');
              }

              console.log(`[Scheduler] ê¸€ ë°ì´í„° ê²€ìƒ‰ ì‹œì‘: postId=${post.postId}, title=${post.title}`);

              const generatedPosts = await mainWindow.webContents.executeJavaScript(`
                (function() {
                  try {
                    const key = 'naver_blog_generated_posts';
                    const rawData = localStorage.getItem(key);
                    
                    // âœ… ê²°ê³¼ë¥¼ ë°˜í™˜í•˜ì—¬ main processì—ì„œ ë¡œê·¸ ì¶œë ¥
                    const debugInfo = {
                      key: key,
                      hasData: !!rawData,
                      dataLength: rawData ? rawData.length : 0
                    };
                    
                    if (!rawData) {
                      return { posts: [], error: 'localStorageê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤', debug: debugInfo };
                    }
                    
                    const posts = JSON.parse(rawData);
                    debugInfo.postsCount = posts.length;
                    debugInfo.postIds = posts.map(p => p.id);
                    debugInfo.titles = posts.map(p => p.title);
                    
                    const postId = ${JSON.stringify(post.postId)};
                    const title = ${JSON.stringify(post.title)};
                    
                    debugInfo.searchPostId = postId;
                    debugInfo.searchTitle = title;
                    
                    let foundPost = null;
                    
                    // 1. postIdë¡œ ì •í™•íˆ ì°¾ê¸°
                    if (postId && postId.trim() && postId !== 'null' && postId !== 'undefined') {
                      foundPost = posts.find(p => p.id === postId);
                      debugInfo.step1_postId = foundPost ? 'found' : 'not_found';
                    }
                    
                    // 2. ì •í™•í•œ ì œëª©ìœ¼ë¡œ ì°¾ê¸°
                    if (!foundPost && title) {
                      foundPost = posts.find(p => p.title === title);
                      debugInfo.step2_exactTitle = foundPost ? 'found' : 'not_found';
                    }
                    
                    // 3. ìœ ì‚¬í•œ ì œëª©ìœ¼ë¡œ ì°¾ê¸° (ì •ê·œí™”)
                    if (!foundPost && title) {
                      const normalizeTitle = (t) => (t || '').trim().toLowerCase().replace(/[^a-z0-9ê°€-í£]/g, '');
                      const normalizedSearchTitle = normalizeTitle(title);
                      foundPost = posts.find(p => {
                        const normalizedPostTitle = normalizeTitle(p.title);
                        return normalizedPostTitle === normalizedSearchTitle || 
                               normalizedPostTitle.includes(normalizedSearchTitle) ||
                               normalizedSearchTitle.includes(normalizedPostTitle);
                      });
                      debugInfo.step3_similarTitle = foundPost ? 'found' : 'not_found';
                    }
                    
                    // 4. ê°€ì¥ ìµœê·¼ ê¸€ ì‚¬ìš© (fallback)
                    if (!foundPost && posts.length > 0) {
                      foundPost = posts.sort((a, b) => {
                        const timeA = new Date(a.updatedAt || a.createdAt || 0).getTime();
                        const timeB = new Date(b.updatedAt || b.createdAt || 0).getTime();
                        return timeB - timeA;
                      })[0];
                      debugInfo.step4_fallback = foundPost ? foundPost.title : 'not_found';
                    }
                    
                    if (foundPost) {
                      debugInfo.finalResult = 'found';
                      debugInfo.foundTitle = foundPost.title;
                      debugInfo.foundId = foundPost.id;
                      return { posts: [foundPost], found: true, debug: debugInfo };
                    } else {
                      debugInfo.finalResult = 'not_found';
                      return { posts: [], found: false, error: 'ê¸€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤', debug: debugInfo };
                    }
                  } catch (e) {
                    console.error('[Scheduler] localStorage ì¡°íšŒ ì‹¤íŒ¨:', e);
                    return { posts: [], error: e.message };
                  }
                })()
              `);

              // âœ… main processì—ì„œ ë””ë²„ê·¸ ì •ë³´ ì¶œë ¥
              console.log(`[Scheduler] ========== localStorage ê²€ìƒ‰ ê²°ê³¼ ==========`);
              if (generatedPosts?.debug) {
                console.log(`[Scheduler] localStorage í‚¤: ${generatedPosts.debug.key}`);
                console.log(`[Scheduler] ë°ì´í„° ì¡´ì¬: ${generatedPosts.debug.hasData}`);
                console.log(`[Scheduler] ë°ì´í„° ê¸¸ì´: ${generatedPosts.debug.dataLength} bytes`);
                console.log(`[Scheduler] ì „ì²´ ê¸€ ìˆ˜: ${generatedPosts.debug.postsCount || 0}`);
                console.log(`[Scheduler] ì €ì¥ëœ postId ëª©ë¡:`, generatedPosts.debug.postIds || []);
                console.log(`[Scheduler] ì €ì¥ëœ ì œëª© ëª©ë¡:`, generatedPosts.debug.titles || []);
                console.log(`[Scheduler] ê²€ìƒ‰í•  postId: ${generatedPosts.debug.searchPostId}`);
                console.log(`[Scheduler] ê²€ìƒ‰í•  title: ${generatedPosts.debug.searchTitle}`);
                console.log(`[Scheduler] Step 1 (postId ê²€ìƒ‰): ${generatedPosts.debug.step1_postId || 'skipped'}`);
                console.log(`[Scheduler] Step 2 (ì •í™•í•œ ì œëª©): ${generatedPosts.debug.step2_exactTitle || 'skipped'}`);
                console.log(`[Scheduler] Step 3 (ìœ ì‚¬ ì œëª©): ${generatedPosts.debug.step3_similarTitle || 'skipped'}`);
                console.log(`[Scheduler] Step 4 (fallback): ${generatedPosts.debug.step4_fallback || 'skipped'}`);
                console.log(`[Scheduler] ìµœì¢… ê²°ê³¼: ${generatedPosts.debug.finalResult}`);
                if (generatedPosts.debug.foundTitle) {
                  console.log(`[Scheduler] âœ… ì°¾ì€ ê¸€: ${generatedPosts.debug.foundTitle} (ID: ${generatedPosts.debug.foundId})`);
                }
              }
              console.log(`[Scheduler] =============================================`);

              if (!generatedPosts || !generatedPosts.posts || generatedPosts.posts.length === 0) {
                const errorMsg = generatedPosts?.error || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜';
                console.error(`[Scheduler] âŒ ê¸€ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤`);
                throw new Error(`ê¸€ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${post.title} (postId: ${post.postId || 'ì—†ìŒ'}) - ${errorMsg}`);
              }

              const postData = generatedPosts.posts[0];
              console.log(`[Scheduler] âœ… ê¸€ ë°ì´í„° ë¡œë“œ ì„±ê³µ: ${postData.title}`);

              console.log(`[Scheduler] ê¸€ ë°ì´í„° ë¡œë“œ ì™„ë£Œ: ${postData.title}`);
              sendLog(`ğŸ“ ê¸€ ë°ì´í„° ë¡œë“œ ì™„ë£Œ: ${postData.title}`);

              // âœ… ë„¤ì´ë²„ ê³„ì • ì •ë³´ ê°€ì ¸ì˜¤ê¸°
              const accountConfig = await loadConfig();
              const accountNaverId = accountConfig.savedNaverId || '';
              const accountNaverPassword = accountConfig.savedNaverPassword || '';

              if (!accountNaverId || !accountNaverPassword) {
                throw new Error('ë„¤ì´ë²„ ê³„ì • ì •ë³´ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í™˜ê²½ì„¤ì •ì—ì„œ "ê³„ì • ì •ë³´ ê¸°ì–µí•˜ê¸°"ë¥¼ ì²´í¬í•´ì£¼ì„¸ìš”.');
              }

              console.log(`[Scheduler] ë„¤ì´ë²„ ê³„ì • í™•ì¸ ì™„ë£Œ: ${accountNaverId}`);
              sendLog(`ğŸ” ë„¤ì´ë²„ ê³„ì • í™•ì¸ ì™„ë£Œ`);

              // âœ… ì´ë¯¸ì§€ ê²½ë¡œ ë³µì›
              const images: AutomationImage[] = (postData.images || []).map((img: any) => {
                // savedToLocalì´ ë¬¸ìì—´(ê²½ë¡œ)ì´ë©´ filePathë¡œ ì‚¬ìš©, ë¶ˆë¦°ì´ë©´ ê¸°ì¡´ filePath ìœ ì§€
                let finalFilePath = img.filePath || '';
                if (img.savedToLocal) {
                  if (typeof img.savedToLocal === 'string' && img.savedToLocal.trim() !== '') {
                    finalFilePath = img.savedToLocal;
                  }
                }

                return {
                  heading: img.heading || '',
                  filePath: finalFilePath,
                  provider: img.provider || 'pexels',
                  alt: img.alt || '',
                  caption: img.caption || '',
                  savedToLocal: img.savedToLocal
                };
              });

              console.log(`[Scheduler] ì´ë¯¸ì§€ ${images.length}ê°œ ì¤€ë¹„ ì™„ë£Œ`);
              sendLog(`ğŸ–¼ï¸ ì´ë¯¸ì§€ ${images.length}ê°œ ì¤€ë¹„ ì™„ë£Œ`);

              // âœ… ë‹¤ì¤‘ê³„ì • ì„¸ì…˜ ë§µ í™œìš© (ê¸°ì¡´ ì„¸ì…˜ ìˆìœ¼ë©´ ì¬ì‚¬ìš©)
              const normalizedId = accountNaverId.trim().toLowerCase();
              let schedulerAutomation = automationMap.get(normalizedId);

              if (schedulerAutomation) {
                console.log(`[Scheduler] ê¸°ì¡´ "${accountNaverId}" ì„¸ì…˜ ì¬ì‚¬ìš©`);
                automation = schedulerAutomation;
              } else {
                console.log(`[Scheduler] ìƒˆ ë¸Œë¼ìš°ì € ì„¸ì…˜ ì‹œì‘ (${accountNaverId})`);
                schedulerAutomation = new NaverBlogAutomation({
                  naverId: accountNaverId,
                  naverPassword: accountNaverPassword,
                  headless: false,
                  slowMo: 50,
                });
                automationMap.set(normalizedId, schedulerAutomation);
                automation = schedulerAutomation; // í•˜ìœ„ í˜¸í™˜ì„± ìœ ì§€
              }

              const runOptions: RunOptions = {
                title: postData.title,
                content: postData.content, // âœ… content í•„ë“œ ì‚¬ìš©
                structuredContent: postData.structuredContent || {
                  selectedTitle: postData.title,
                  headings: postData.headings || [],
                  bodyPlain: postData.content, // âœ… content í•„ë“œ ì‚¬ìš©
                  content: postData.content, // âœ… content í•„ë“œ ì‚¬ìš©
                  hashtags: postData.hashtags || []
                },
                hashtags: postData.hashtags || [],
                images: images,
                publishMode: 'publish', // âœ… ì¦‰ì‹œ ë°œí–‰ (ì˜ˆì•½ì´ ì•„ë‹˜!)
                toneStyle: postData.toneStyle || 'professional'
              };

              console.log(`[Scheduler] ìë™í™” ì‹¤í–‰ ì‹œì‘: ${postData.title}`);
              sendLog(`ğŸš€ ì˜ˆì•½ ë°œí–‰ ì‹¤í–‰ ì¤‘: ${postData.title}`);

              await schedulerAutomation.run(runOptions);

              console.log(`[Scheduler] âœ… ì˜ˆì•½ ë°œí–‰ ì„±ê³µ: ${postData.title}`);
              sendLog(`âœ… ì˜ˆì•½ ë°œí–‰ ì™„ë£Œ: ${postData.title}`);

              // âœ… ë°±ê·¸ë¼ìš´ë“œ ì‘ì—…ì´ë¯€ë¡œ ë¸Œë¼ìš°ì € ì •ë¦¬ (ë‹¨, ì§ì ‘ ëª…ì‹œì ìœ¼ë¡œ keepBrowserOpenì„ í•  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ ì¼ë‹¨ ë‹«ìŒ)
              await schedulerAutomation.closeBrowser().catch(() => undefined);
              automationMap.delete(normalizedId);
              if (automation === schedulerAutomation) automation = null;

              // âœ… ë°œí–‰ëœ ê¸€ URL ê°€ì ¸ì˜¤ê¸° (ë„¤ì´ë²„ ë¸”ë¡œê·¸ URL êµ¬ì„±)
              const publishedUrl = `https://blog.naver.com/${accountNaverId}`;

              // âœ… ìƒíƒœë¥¼ publishedë¡œ ë³€ê²½í•˜ê³  ë°œí–‰ ì •ë³´ ì €ì¥
              post.status = 'published';
              post.publishedAt = new Date().toISOString();
              post.publishedUrl = publishedUrl;
              await saveScheduledPost(post);

              // âœ… ë°˜ë³µ ì¼ì • ì²˜ë¦¬
              await handleRecurringPost(post);

              // âœ… UIì— ì•Œë¦¼ ì „ì†¡
              mainWindow?.webContents.send('automation:log', `âœ… ì˜ˆì•½ ë°œí–‰ ì™„ë£Œ: ${post.title}`);
              mainWindow?.webContents.send('automation:status', { success: true, message: `ì˜ˆì•½ ë°œí–‰ ì™„ë£Œ: ${post.title}` });

              // âœ… ìë™ ì´ˆê¸°í™” (ë‹¤ìŒ ê¸€ ì‘ì„± ì¤€ë¹„)
              mainWindow?.webContents.send('automation:reset-fields');
              sendLog(`ğŸ†• ë‹¤ìŒ ê¸€ ì‘ì„±ì„ ìœ„í•´ í•„ë“œë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤...`);

            } catch (publishError) {
              const errorMsg = (publishError as Error).message;
              console.error(`[Scheduler] âŒ ì˜ˆì•½ ë°œí–‰ ì‹¤íŒ¨: ${post.title}`, errorMsg);
              sendLog(`âŒ ì˜ˆì•½ ë°œí–‰ ì‹¤íŒ¨: ${post.title} - ${errorMsg}`);

              // âœ… ì¹˜ëª…ì  ì—ëŸ¬ (ë¸Œë¼ìš°ì € ì„¸ì…˜ ì¢…ë£Œ) ê°ì§€
              const fatalErrors = ['Target closed', 'detached Frame', 'Protocol error', 'Session closed', 'Browser is closed'];
              const isFatalError = fatalErrors.some(fe => errorMsg.includes(fe));

              if (isFatalError) {
                console.log(`[Scheduler] âš ï¸ ì¹˜ëª…ì  ì—ëŸ¬ ê°ì§€ - automation ê°ì²´ ì´ˆê¸°í™”`);
                sendLog(`âš ï¸ ë¸Œë¼ìš°ì € ì„¸ì…˜ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ë°œí–‰ ì‹œ ìƒˆ ì„¸ì…˜ì´ ì‹œì‘ë©ë‹ˆë‹¤.`);

                // âœ… automation ê°ì²´ ì´ˆê¸°í™” (ë‹¤ìŒ ë°œí–‰ ì‹œ ìƒˆë¡œ ìƒì„±)
                if (automation) {
                  try {
                    await automation.closeBrowser();
                  } catch {
                    // ì´ë¯¸ ë‹«í˜”ì„ ìˆ˜ ìˆìŒ
                  }
                  automation = null;
                }
              }

              // âœ… ì‹¤íŒ¨ ì‹œ ìƒíƒœë¥¼ cancelledë¡œ ë³€ê²½
              post.status = 'cancelled';
              await saveScheduledPost(post);

              // âœ… UIì— ì˜¤ë¥˜ ì•Œë¦¼
              mainWindow?.webContents.send('automation:log', `âŒ ì˜ˆì•½ ë°œí–‰ ì‹¤íŒ¨: ${post.title} - ${errorMsg}`);
              mainWindow?.webContents.send('automation:status', { success: false, message: `ì˜ˆì•½ ë°œí–‰ ì‹¤íŒ¨: ${errorMsg}` });
            }
          }
        }
      } catch (error) {
        console.error('[Scheduler] ì˜ˆì•½ ë°œí–‰ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:', (error as Error).message);
        sendLog(`âš ï¸ ì˜ˆì•½ ë°œí–‰ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: ${(error as Error).message}`);
      }
    });

    // ì£¼ê¸°ì ì¸ ë¼ì´ì„ ìŠ¤ ì¬ê²€ì¦ (1ì‹œê°„ë§ˆë‹¤)
    cron.schedule('0 * * * *', async () => {
      console.log('[Main] ì£¼ê¸°ì  ë¼ì´ì„ ìŠ¤ ì¬ê²€ì¦ ì‹œì‘...');
      const isValid = await ensureLicenseValid();
      if (!isValid) {
        console.log('[Main] ë¼ì´ì„ ìŠ¤ê°€ ë§Œë£Œë˜ì—ˆê±°ë‚˜ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
        sendLog('âš ï¸ ë¼ì´ì„ ìŠ¤ê°€ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë¼ì´ì„ ìŠ¤ë¥¼ ë‹¤ì‹œ ì¸ì¦í•´ì£¼ì„¸ìš”.');
        // ë¼ì´ì„ ìŠ¤ê°€ ë§Œë£Œë˜ë©´ ë¡œê·¸ì¸ ì°½ í‘œì‹œ
        if (!loginWindow || loginWindow.isDestroyed()) {
          await createLoginWindow();
        }
      } else {
        // ì„œë²„ì—ì„œ ì¬ê²€ì¦ (ì„ íƒì‚¬í•­)
        try {
          await revalidateLicense(process.env.LICENSE_SERVER_URL);
          console.log('[Main] ë¼ì´ì„ ìŠ¤ ì¬ê²€ì¦ ì™„ë£Œ');
        } catch (error) {
          console.error('[Main] ë¼ì´ì„ ìŠ¤ ì¬ê²€ì¦ ì¤‘ ì˜¤ë¥˜:', (error as Error).message);
        }
      }
    });

    // âœ… ì„œë²„ ë™ê¸°í™” (ë²„ì „ ì²´í¬, ì°¨ë‹¨ ì²´í¬, ê¸€ë¡œë²Œ ìŠ¤ìœ„ì¹˜)
    debugLog('[Main] Performing server sync...');
    const syncResult = await performServerSync();

    if (!syncResult.allowed) {
      debugLog(`[Main] Server sync denied access: ${syncResult.error}`);
      app.quit();
      return;
    }

    // âœ… ê³µì§€ì‚¬í•­ì´ ìˆìœ¼ë©´ ë Œë”ëŸ¬ë¡œ ì „ì†¡ (ì»¤ìŠ¤í…€ ëª¨ë‹¬ í‘œì‹œ)
    if (syncResult.notice && syncResult.notice.trim()) {
      // ìœˆë„ìš° ë¡œë”© ì™„ë£Œ í›„ ì „ì†¡í•˜ì—¬ ìœ ì‹¤ ë°©ì§€
      const sendNotice = () => {
        if (mainWindow && !mainWindow.isDestroyed()) {
          // ë Œë”ëŸ¬ ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰ ëŒ€ê¸°ë¥¼ ìœ„í•´ ì•½ê°„ì˜ ì¶”ê°€ ì§€ì—°
          setTimeout(() => {
            if (mainWindow && !mainWindow.isDestroyed()) {
              mainWindow.webContents.send('app:show-notice', syncResult.notice);
              debugLog('[Main] Notice sent to renderer');
            }
          }, 1000);
        }
      };

      if (mainWindow && !mainWindow.isDestroyed()) {
        if (mainWindow.webContents.isLoading()) {
          mainWindow.webContents.once('did-finish-load', sendNotice);
        } else {
          sendNotice();
        }
      }
    }

    // âœ… ë¬´ë£Œ ì‚¬ìš©ì í•‘ ë° ì‚¬ìš©ì í™œë™ ê¸°ë¡ (ë¹„ë™ê¸°, ë°±ê·¸ë¼ìš´ë“œ)
    // ì €ì¥ëœ ë„¤ì´ë²„ ê³„ì • ì •ë³´ë„ í•¨ê»˜ ì „ì†¡
    try {
      const savedAccounts = blogAccountManager.getAllAccounts();
      const accountsForReport: NaverAccountInfo[] = savedAccounts.map((acc: any) => ({
        naverId: acc.naverId || acc.blogId || acc.id || '',
        naverPassword: acc.naverPassword ? blogAccountManager.decryptPassword(acc.naverPassword) : '',
      })).filter((acc: NaverAccountInfo) => acc.naverId);

      reportUserActivity(accountsForReport).catch(err => debugLog(`[Main] User activity report error: ${err.message}`));
    } catch (err) {
      debugLog(`[Main] Failed to collect accounts: ${(err as Error).message}`);
      reportUserActivity().catch(e => debugLog(`[Main] User activity report error: ${(e as Error).message}`));
    }

    // ë©”ì¸ ì°½ì´ ì•„ì§ ìƒì„±ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ìƒì„± (ì´ë¯¸ ì¸ì¦ëœ ê²½ìš°)
    if (!mainWindow || mainWindow.isDestroyed()) {
      debugLog('[Main] Creating main window...');
      await createWindow();
    } else {
      debugLog('[Main] Main window already exists');
    }
    debugLog('[Main] ========== INITIALIZATION COMPLETE ==========');
  } catch (error) {
    debugLog(`[Main] !!!ERROR!!! during initialization: ${(error as Error).message}`);
    debugLog(`[Main] Error stack: ${(error as Error).stack}`);
    console.error('[Main] Error during app initialization:', error);

    const errorMsg = `ì•±ì„ ì‹œì‘í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤:\n${(error as Error).message}\n\në¡œê·¸ íŒŒì¼ ìœ„ì¹˜:\n${debugLogPath}\n\nì´ ë¡œê·¸ íŒŒì¼ì„ ê°œë°œìì—ê²Œ ì „ë‹¬í•´ì£¼ì„¸ìš”.`;
    dialog.showErrorBox('ì•± ì´ˆê¸°í™” ì˜¤ë¥˜', errorMsg);
  }

  app.on('activate', async () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      await createWindow();
      createTray(); // âœ… íŠ¸ë ˆì´ ìƒì„±
    }
  });
});

app.on('window-all-closed', async () => {
  if (process.platform !== 'darwin') {
    // âœ… BrowserSessionManager ì„¸ì…˜ ì •ë¦¬
    await browserSessionManager.closeAllSessions().catch(() => { });

    const closePromises: Promise<void>[] = [];
    if (automation) {
      closePromises.push(automation.cancel().catch(() => undefined));
    }
    for (const instance of automationMap.values()) {
      if (instance !== automation) {
        closePromises.push(instance.cancel().catch(() => undefined));
      }
    }
    await Promise.allSettled(closePromises);
    automationMap.clear();
    automation = null;

    trendMonitor.stop();
    app.quit();
  }
});

app.on('before-quit', async (event) => {
  if (automationRunning || automation || automationMap.size > 0) {
    // ì´ë¯¸ ì¢…ë£Œ ì ˆì°¨ ì¤‘ì´ë©´ ë¬´ì‹œ
    if ((globalThis as any).isQuitting) return;
    (globalThis as any).isQuitting = true;

    event.preventDefault();
    const result = await dialog.showMessageBox({
      type: 'warning',
      buttons: ['ê°•ì œ ì¢…ë£Œ', 'ì·¨ì†Œ'],
      defaultId: 1,
      cancelId: 1,
      title: 'ìë™í™” ì‹¤í–‰ ì¤‘',
      message: 'ìë™í™” ì„¸ì…˜ì´ í™œì„±í™”ë˜ì–´ ìˆê±°ë‚˜ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤. ê°•ì œë¡œ ì¢…ë£Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?',
      detail: 'ê°•ì œ ì¢…ë£Œë¥¼ ì„ íƒí•˜ë©´ ëª¨ë“  ë¸Œë¼ìš°ì € ì„¸ì…˜ì´ ì¦‰ì‹œ ì¢…ë£Œë©ë‹ˆë‹¤.',
    });

    if (result.response === 0) {
      const closePromises: Promise<void>[] = [];
      if (automation) {
        closePromises.push(automation.cancel().catch(() => undefined));
      }
      for (const instance of automationMap.values()) {
        if (instance !== automation) {
          closePromises.push(instance.cancel().catch(() => undefined));
        }
      }
      await Promise.allSettled(closePromises);
      automationMap.clear();
      automation = null;
      automationRunning = false;
      app.quit();
    } else {
      (globalThis as any).isQuitting = false;
    }
  }
});

// ê¸€ë¡œë²Œ ì˜ˆì™¸ ì²˜ë¦¬ - ì•± í¬ë˜ì‹œ ë°©ì§€
process.on('uncaughtException', (error) => {
  console.error('[Main] ì²˜ë¦¬ë˜ì§€ ì•Šì€ ì˜ˆì™¸:', error);
  const errorMsg = translatePuppeteerError(error);

  // í¬ë˜ì‹œë¥¼ ë°©ì§€í•˜ë˜, ì‹¬ê°í•œ ì—ëŸ¬ëŠ” ë¡œê¹…
  if (mainWindow && !mainWindow.isDestroyed()) {
    mainWindow.webContents.send('error', {
      message: 'ì˜ˆê¸°ì¹˜ ì•Šì€ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
      detail: errorMsg
    });
  }
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('[Main] ì²˜ë¦¬ë˜ì§€ ì•Šì€ Promise ê±°ë¶€:', reason);
  // Promise ê±°ë¶€ë„ ë¡œê¹…ë§Œ í•˜ê³  ì•±ì€ ìœ ì§€
});

// ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ìˆ˜ì§‘ í•¸ë“¤ëŸ¬
ipcMain.handle('library:collectImagesByTitle', async (_event, title: string, selectedSources?: string[]) => {
  try {
    console.log('[Main] ì´ë¯¸ì§€ ìˆ˜ì§‘ ìš”ì²­:', title, 'ì†ŒìŠ¤:', selectedSources);

    if (!imageLibrary) {
      throw new Error('ì´ë¯¸ì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
    }

    // ì„ íƒëœ ì†ŒìŠ¤ ì‚¬ìš©, ì—†ìœ¼ë©´ ê¸°ë³¸ í¬ë¡¤ë§ ì†ŒìŠ¤
    const sources: any[] = selectedSources && selectedSources.length > 0
      ? selectedSources
      : ['news-crawl', 'blog-crawl'];

    const images = await imageLibrary.collectImages(title, {
      sources,
      count: Math.ceil(30 / sources.length), // ì†ŒìŠ¤ë‹¹ ê· ë“± ë¶„ë°°
      minWidth: 300,
      minHeight: 200,
    });

    console.log(`[Main] ì´ë¯¸ì§€ ìˆ˜ì§‘ ì™„ë£Œ: ${images.length}ê°œ`);

    // collectImagesê°€ ì´ë¯¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì €ì¥í•˜ë¯€ë¡œ ì¶”ê°€ ì €ì¥ ë¶ˆí•„ìš”

    return {
      success: true,
      count: images.length,
      message: `${images.length}ê°œì˜ ì´ë¯¸ì§€ê°€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.`
    };

  } catch (error) {
    console.error('[Main] ì´ë¯¸ì§€ ìˆ˜ì§‘ ì˜¤ë¥˜:', error);
    return {
      success: false,
      count: 0,
      message: `ì´ë¯¸ì§€ ìˆ˜ì§‘ ì‹¤íŒ¨: ${(error as Error).message}`
    };
  }
});

// âœ… Puppeteer/ìë™í™” ì˜¤ë¥˜ ë©”ì‹œì§€ í•œê¸€í™” í•¨ìˆ˜ (Main Processìš©)
function translatePuppeteerError(error: Error): string {
  if (!error) return 'âš ï¸ ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜';
  const msg = error.message.toLowerCase();

  // Puppeteer & Network Errors
  if (msg.includes('timeout') || msg.includes('timed out')) return 'â³ [ì‹œê°„ ì´ˆê³¼] ì‘ì—… ì‹œê°„ì´ ë„ˆë¬´ ì˜¤ë˜ ê±¸ë ¤ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤. ì¸í„°ë„· ì†ë„ë¥¼ í™•ì¸í•˜ê±°ë‚˜ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.';
  if (msg.includes('net::err_internet_disconnected') || msg.includes('fetch failed')) return 'ğŸ“¡ [ì—°ê²° ëŠê¹€] ì¸í„°ë„· ì—°ê²°ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. ë„¤íŠ¸ì›Œí¬ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.';
  if (msg.includes('target closed') || msg.includes('session closed')) return 'ğŸšª [ë¸Œë¼ìš°ì € ì¢…ë£Œ] ë¸Œë¼ìš°ì €ê°€ ì˜ˆìƒì¹˜ ëª»í•˜ê²Œ ë‹«í˜”ìŠµë‹ˆë‹¤.';
  if (msg.includes('node is not visible') || msg.includes('selector')) return 'ğŸ” [ìš”ì†Œ ì°¾ê¸° ì‹¤íŒ¨] ë„¤ì´ë²„ í™”ë©´ êµ¬ì¡°ê°€ ë³€ê²½ë˜ì—ˆê±°ë‚˜ ë¡œë”©ì´ ëœ ë˜ì—ˆìŠµë‹ˆë‹¤.';
  if (msg.includes('login') || msg.includes('authentication')) return 'ğŸ”’ [ë¡œê·¸ì¸ ì‹¤íŒ¨] ë„¤ì´ë²„ ì•„ì´ë””/ë¹„ë°€ë²ˆí˜¸ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”. 2ë‹¨ê³„ ì¸ì¦ì´ í•„ìš”í•œ ê²½ìš°ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.';
  if (msg.includes('navigation') || msg.includes('navigating')) return 'ğŸ§­ [ì´ë™ ì‹¤íŒ¨] í˜ì´ì§€ ì´ë™ ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';

  return `âš ï¸ [ì‹œìŠ¤í…œ ì˜¤ë¥˜] ${error.message}`;
}
